""" Cisco_IOS_XR_l2vpn_cfg 

This module contains a collection of YANG definitions
for Cisco IOS\-XR l2vpn package configuration.

This module contains definitions
for the following management objects\:
  l2vpn\: L2VPN configuration
  generic\-interface\-lists\: generic interface lists
  evpn\: evpn

This YANG module augments the
  Cisco\-IOS\-XR\-ifmgr\-cfg,
  Cisco\-IOS\-XR\-snmp\-agent\-cfg
modules with configuration data.

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class BackupDisable(Enum):
    """
    BackupDisable

    Backup disable

    .. data:: never = 0

    	Never

    .. data:: delay = 1

    	Delay seconds

    """

    never = Enum.YLeaf(0, "never")

    delay = Enum.YLeaf(1, "delay")


class BdmacLearn(Enum):
    """
    BdmacLearn

    Bdmac learn

    .. data:: disable_learning = 2

    	Disable Learning

    """

    disable_learning = Enum.YLeaf(2, "disable-learning")


class BgpRouteDistinguisher(Enum):
    """
    BgpRouteDistinguisher

    Bgp route distinguisher

    .. data:: auto = 1

    	RD automatically assigned

    .. data:: two_byte_as = 2

    	RD in 2 byte AS:nn format

    .. data:: four_byte_as = 3

    	RD in 4 byte AS:nn format

    .. data:: ipv4_address = 4

    	RD in IpV4address

    """

    auto = Enum.YLeaf(1, "auto")

    two_byte_as = Enum.YLeaf(2, "two-byte-as")

    four_byte_as = Enum.YLeaf(3, "four-byte-as")

    ipv4_address = Enum.YLeaf(4, "ipv4-address")


class BgpRouteTarget(Enum):
    """
    BgpRouteTarget

    Bgp route target

    .. data:: no_stitching = 0

    	RT is default type

    .. data:: stitching = 1

    	RT is for stitching (Golf-L2)

    """

    no_stitching = Enum.YLeaf(0, "no-stitching")

    stitching = Enum.YLeaf(1, "stitching")


class BgpRouteTargetFormat(Enum):
    """
    BgpRouteTargetFormat

    Bgp route target format

    .. data:: none = 0

    	No route target

    .. data:: two_byte_as = 1

    	2 Byte AS:nn format

    .. data:: four_byte_as = 2

    	4 byte AS:nn format

    .. data:: ipv4_address = 3

    	IP:nn format

    .. data:: es_import = 1538

    	a.a.i format

    """

    none = Enum.YLeaf(0, "none")

    two_byte_as = Enum.YLeaf(1, "two-byte-as")

    four_byte_as = Enum.YLeaf(2, "four-byte-as")

    ipv4_address = Enum.YLeaf(3, "ipv4-address")

    es_import = Enum.YLeaf(1538, "es-import")


class BgpRouteTargetRole(Enum):
    """
    BgpRouteTargetRole

    Bgp route target role

    .. data:: both = 0

    	Both Import and export roles

    .. data:: import_ = 1

    	Import role

    .. data:: export = 2

    	Export role

    """

    both = Enum.YLeaf(0, "both")

    import_ = Enum.YLeaf(1, "import")

    export = Enum.YLeaf(2, "export")


class BridgeDomainTransportMode(Enum):
    """
    BridgeDomainTransportMode

    Bridge domain transport mode

    .. data:: vlan_passthrough = 3

    	Vlan tagged passthrough mode

    """

    vlan_passthrough = Enum.YLeaf(3, "vlan-passthrough")


class ControlWord(Enum):
    """
    ControlWord

    Control word

    .. data:: enable = 1

    	Enable control word

    .. data:: disable = 2

    	Disable control word

    """

    enable = Enum.YLeaf(1, "enable")

    disable = Enum.YLeaf(2, "disable")


class ErpPort(Enum):
    """
    ErpPort

    Erp port

    .. data:: none = 1

    	ERP port type none

    .. data:: virtual = 2

    	ERP port type virtual

    .. data:: interface = 3

    	ERP port type interface

    """

    none = Enum.YLeaf(1, "none")

    virtual = Enum.YLeaf(2, "virtual")

    interface = Enum.YLeaf(3, "interface")


class ErpPort1(Enum):
    """
    ErpPort1

    Erp port1

    .. data:: port0 = 0

    	ERP main port 0

    .. data:: port1 = 1

    	ERP main port 1

    """

    port0 = Enum.YLeaf(0, "port0")

    port1 = Enum.YLeaf(1, "port1")


class Erpaps(Enum):
    """
    Erpaps

    Erpaps

    .. data:: interface = 1

    	ERP APS type interface

    .. data:: bridge_domain = 2

    	ERP APS type bridge domain

    .. data:: xconnect = 3

    	ERP APS type xconnect

    .. data:: none = 4

    	ERP APS type none

    """

    interface = Enum.YLeaf(1, "interface")

    bridge_domain = Enum.YLeaf(2, "bridge-domain")

    xconnect = Enum.YLeaf(3, "xconnect")

    none = Enum.YLeaf(4, "none")


class EthernetSegmentIdentifier(Enum):
    """
    EthernetSegmentIdentifier

    Ethernet segment identifier

    .. data:: type0 = 0

    	ESI type 0

    .. data:: legacy = 128

    	Legacy ESI type

    .. data:: override = 129

    	Override ESI type

    """

    type0 = Enum.YLeaf(0, "type0")

    legacy = Enum.YLeaf(128, "legacy")

    override = Enum.YLeaf(129, "override")


class EvpnEncapsulation(Enum):
    """
    EvpnEncapsulation

    Evpn encapsulation

    .. data:: evpn_encapsulation_mpls = 10

    	MPLS Encapsulation

    """

    evpn_encapsulation_mpls = Enum.YLeaf(10, "evpn-encapsulation-mpls")


class EvpnSide(Enum):
    """
    EvpnSide

    Evpn side

    .. data:: evpn_side_stitching = 2

    	EVPN Instance side defined as stitching

    """

    evpn_side_stitching = Enum.YLeaf(2, "evpn-side-stitching")


class FlowLabelLoadBalance(Enum):
    """
    FlowLabelLoadBalance

    Flow label load balance

    .. data:: off = 0

    	Flow Label load balance is off

    .. data:: receive = 1

    	Delete Flow Label on receive side

    .. data:: transmit = 2

    	Insert Flow Label on transmit side

    .. data:: both = 3

    	Insert/Delete  Flow Label on transmit/receive

    	side

    """

    off = Enum.YLeaf(0, "off")

    receive = Enum.YLeaf(1, "receive")

    transmit = Enum.YLeaf(2, "transmit")

    both = Enum.YLeaf(3, "both")


class FlowLabelTlvCode(Enum):
    """
    FlowLabelTlvCode

    Flow label tlv code

    .. data:: Y_17 = 4

    	Set Flow Label Legacy TLV code (DEPRECATED)

    .. data:: disable = 8

    	Disable Sending Flow Label Legacy TLV

    """

    Y_17 = Enum.YLeaf(4, "17")

    disable = Enum.YLeaf(8, "disable")


class InterfaceProfile(Enum):
    """
    InterfaceProfile

    Interface profile

    .. data:: snoop = 1

    	Set the snooping

    .. data:: dhcp_protocol = 2

    	disable DHCP protocol

    """

    snoop = Enum.YLeaf(1, "snoop")

    dhcp_protocol = Enum.YLeaf(2, "dhcp-protocol")


class InterfaceTrafficFlood(Enum):
    """
    InterfaceTrafficFlood

    Interface traffic flood

    .. data:: traffic_flooding = 0

    	Traffic flooding

    .. data:: enable_flooding = 1

    	Enable Flooding

    .. data:: disable_flooding = 2

    	Disable flooding

    """

    traffic_flooding = Enum.YLeaf(0, "traffic-flooding")

    enable_flooding = Enum.YLeaf(1, "enable-flooding")

    disable_flooding = Enum.YLeaf(2, "disable-flooding")


class Interworking(Enum):
    """
    Interworking

    Interworking

    .. data:: ethernet = 1

    	Ethernet interworking

    .. data:: ipv4 = 3

    	IPv4 interworking

    """

    ethernet = Enum.YLeaf(1, "ethernet")

    ipv4 = Enum.YLeaf(3, "ipv4")


class L2Encapsulation(Enum):
    """
    L2Encapsulation

    L2 encapsulation

    .. data:: vlan = 4

    	Vlan tagged mode

    .. data:: ethernet = 5

    	Ethernet port mode

    """

    vlan = Enum.YLeaf(4, "vlan")

    ethernet = Enum.YLeaf(5, "ethernet")


class L2TpCookieSize(Enum):
    """
    L2TpCookieSize

    L2tp cookie size

    .. data:: zero = 0

    	Cookie size is zero bytes

    .. data:: four = 4

    	Cookie size is four bytes

    .. data:: eight = 8

    	Cookie size is eight bytes

    """

    zero = Enum.YLeaf(0, "zero")

    four = Enum.YLeaf(4, "four")

    eight = Enum.YLeaf(8, "eight")


class L2TpSignalingProtocol(Enum):
    """
    L2TpSignalingProtocol

    L2tp signaling protocol

    .. data:: none = 1

    	No signaling

    .. data:: l2tpv3 = 2

    	L2TPv3

    """

    none = Enum.YLeaf(1, "none")

    l2tpv3 = Enum.YLeaf(2, "l2tpv3")


class L2Tpv3Sequencing(Enum):
    """
    L2Tpv3Sequencing

    L2tpv3 sequencing

    .. data:: off = 0

    	Sequencing is off

    .. data:: both = 4

    	Sequencing on both transmit and receive side

    """

    off = Enum.YLeaf(0, "off")

    both = Enum.YLeaf(4, "both")


class L2VpnCapabilityMode(Enum):
    """
    L2VpnCapabilityMode

    L2vpn capability mode

    .. data:: high_mode = 1

    	Compute global capability as the highest node

    	capability

    .. data:: single_mode = 2

    	Disable global capability re-computation

    """

    high_mode = Enum.YLeaf(1, "high-mode")

    single_mode = Enum.YLeaf(2, "single-mode")


class L2VpnLogging(Enum):
    """
    L2VpnLogging

    L2vpn logging

    .. data:: enable = 1

    	enable logging

    .. data:: disable = 2

    	disable logging

    """

    enable = Enum.YLeaf(1, "enable")

    disable = Enum.YLeaf(2, "disable")


class L2VpnVerification(Enum):
    """
    L2VpnVerification

    L2vpn verification

    .. data:: enable = 1

    	enable verification

    .. data:: disable = 2

    	disable verification

    """

    enable = Enum.YLeaf(1, "enable")

    disable = Enum.YLeaf(2, "disable")


class LdpVplsId(Enum):
    """
    LdpVplsId

    Ldp vpls id

    .. data:: two_byte_as = 10

    	VPLS-ID in 2 byte AS:nn format

    .. data:: ipv4_address = 266

    	VPLS-ID in IPv4 IP:nn format

    """

    two_byte_as = Enum.YLeaf(10, "two-byte-as")

    ipv4_address = Enum.YLeaf(266, "ipv4-address")


class LoadBalance(Enum):
    """
    LoadBalance

    Load balance

    .. data:: source_dest_mac = 1

    	Source and Destination MAC hashing

    .. data:: source_dest_ip = 2

    	Source and Destination IP hashing

    .. data:: pseudowire_label = 4

    	PW Label hashing

    """

    source_dest_mac = Enum.YLeaf(1, "source-dest-mac")

    source_dest_ip = Enum.YLeaf(2, "source-dest-ip")

    pseudowire_label = Enum.YLeaf(4, "pseudowire-label")


class MacAging(Enum):
    """
    MacAging

    Mac aging

    .. data:: absolute = 1

    	Absolute aging type

    .. data:: inactivity = 2

    	Inactivity aging type

    """

    absolute = Enum.YLeaf(1, "absolute")

    inactivity = Enum.YLeaf(2, "inactivity")


class MacLearn(Enum):
    """
    MacLearn

    Mac learn

    .. data:: default_learning = 0

    	Mac Learning

    .. data:: enable_learning = 1

    	Enable Learning

    .. data:: disable_learning = 2

    	Disable Learning

    """

    default_learning = Enum.YLeaf(0, "default-learning")

    enable_learning = Enum.YLeaf(1, "enable-learning")

    disable_learning = Enum.YLeaf(2, "disable-learning")


class MacLimitAction(Enum):
    """
    MacLimitAction

    Mac limit action

    .. data:: none = 0

    	No action

    .. data:: flood = 1

    	Flood Mac Limit Action

    .. data:: no_flood = 2

    	NoFlood Mac Limit Action

    .. data:: shutdown = 3

    	Shutdown Mac Limit Action

    """

    none = Enum.YLeaf(0, "none")

    flood = Enum.YLeaf(1, "flood")

    no_flood = Enum.YLeaf(2, "no-flood")

    shutdown = Enum.YLeaf(3, "shutdown")


class MacNotification(Enum):
    """
    MacNotification

    Mac notification

    .. data:: no_notif = 0

    	No_Notification Trap

    .. data:: syslog = 1

    	syslog message

    .. data:: trap = 2

    	Snmp Trap

    .. data:: syslog_snmp = 3

    	Syslog_snmp Trap

    """

    no_notif = Enum.YLeaf(0, "no-notif")

    syslog = Enum.YLeaf(1, "syslog")

    trap = Enum.YLeaf(2, "trap")

    syslog_snmp = Enum.YLeaf(3, "syslog-snmp")


class MacSecureAction(Enum):
    """
    MacSecureAction

    Mac secure action

    .. data:: restrict = 1

    	MAC Secure Action Restrict

    .. data:: none = 2

    	No Action

    .. data:: shutdown = 3

    	MAC Secure Action Shutdown

    """

    restrict = Enum.YLeaf(1, "restrict")

    none = Enum.YLeaf(2, "none")

    shutdown = Enum.YLeaf(3, "shutdown")


class MacWithdrawBehavior(Enum):
    """
    MacWithdrawBehavior

    Mac withdraw behavior

    .. data:: legacy = 1

    	MAC Withdrawal sent on state-down (legacy)

    .. data:: optimized = 2

    	Optimized MAC Withdrawal

    """

    legacy = Enum.YLeaf(1, "legacy")

    optimized = Enum.YLeaf(2, "optimized")


class MplsSequencing(Enum):
    """
    MplsSequencing

    Mpls sequencing

    .. data:: off = 0

    	Sequencing is off

    .. data:: transmit = 1

    	Sequencing on transmit side

    .. data:: receive = 2

    	Sequencing on receive side

    .. data:: both = 4

    	Sequencing on both transmit and receive side

    """

    off = Enum.YLeaf(0, "off")

    transmit = Enum.YLeaf(1, "transmit")

    receive = Enum.YLeaf(2, "receive")

    both = Enum.YLeaf(4, "both")


class MplsSignalingProtocol(Enum):
    """
    MplsSignalingProtocol

    Mpls signaling protocol

    .. data:: none = 1

    	No signaling

    .. data:: ldp = 4

    	LDP

    """

    none = Enum.YLeaf(1, "none")

    ldp = Enum.YLeaf(4, "ldp")


class PortDownFlush(Enum):
    """
    PortDownFlush

    Port down flush

    .. data:: port_down_flush = 0

    	MAC Port Down Flush

    .. data:: enable_port_down_flush = 1

    	Enable Port Down Flush

    .. data:: disable_port_down_flush = 2

    	Disable Port Down Flush

    """

    port_down_flush = Enum.YLeaf(0, "port-down-flush")

    enable_port_down_flush = Enum.YLeaf(1, "enable-port-down-flush")

    disable_port_down_flush = Enum.YLeaf(2, "disable-port-down-flush")


class PreferredPath(Enum):
    """
    PreferredPath

    Preferred path

    .. data:: te_tunnel = 2

    	TE Tunnel

    .. data:: ip_tunnel = 3

    	IP Tunnel

    .. data:: tp_tunnel = 4

    	TP Tunnel

    """

    te_tunnel = Enum.YLeaf(2, "te-tunnel")

    ip_tunnel = Enum.YLeaf(3, "ip-tunnel")

    tp_tunnel = Enum.YLeaf(4, "tp-tunnel")


class PwSwitchingPointTlv(Enum):
    """
    PwSwitchingPointTlv

    Pw switching point tlv

    .. data:: hide = 2

    	Hide TLV

    """

    hide = Enum.YLeaf(2, "hide")


class RplRole(Enum):
    """
    RplRole

    Rpl role

    .. data:: owner = 1

    	ERP RPL owner

    .. data:: neighbor = 2

    	ERP RPL neighbor

    .. data:: next_neighbor = 3

    	ERP RPL next neighbor

    """

    owner = Enum.YLeaf(1, "owner")

    neighbor = Enum.YLeaf(2, "neighbor")

    next_neighbor = Enum.YLeaf(3, "next-neighbor")


class StormControl(Enum):
    """
    StormControl

    Storm control

    .. data:: unicast = 1

    	Unknown-unicast Storm Control

    .. data:: multicast = 2

    	Multicast Storm Control

    .. data:: broadcast = 4

    	Broadcast Storm Control

    """

    unicast = Enum.YLeaf(1, "unicast")

    multicast = Enum.YLeaf(2, "multicast")

    broadcast = Enum.YLeaf(4, "broadcast")


class TransportMode(Enum):
    """
    TransportMode

    Transport mode

    .. data:: ethernet = 1

    	Ethernet port mode

    .. data:: vlan = 2

    	Vlan tagged mode

    .. data:: vlan_passthrough = 3

    	Vlan tagged passthrough mode

    """

    ethernet = Enum.YLeaf(1, "ethernet")

    vlan = Enum.YLeaf(2, "vlan")

    vlan_passthrough = Enum.YLeaf(3, "vlan-passthrough")


class TypeOfServiceMode(Enum):
    """
    TypeOfServiceMode

    Type of service mode

    .. data:: none = 0

    	Do not reflect the type of service

    .. data:: reflect = 1

    	Reflect the type of service

    """

    none = Enum.YLeaf(0, "none")

    reflect = Enum.YLeaf(1, "reflect")


class VccvVerification(Enum):
    """
    VccvVerification

    Vccv verification

    .. data:: none = 0

    	No connectivity verification over VCCV

    .. data:: lsp_ping = 2

    	LSP Ping over VCCV

    """

    none = Enum.YLeaf(0, "none")

    lsp_ping = Enum.YLeaf(2, "lsp-ping")



class L2Vpn(Entity):
    """
    L2VPN configuration
    
    .. attribute:: auto_discovery
    
    	Global auto\-discovery attributes
    	**type**\:   :py:class:`AutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.AutoDiscovery>`
    
    .. attribute:: capability
    
    	L2VPN Capability Mode
    	**type**\:   :py:class:`L2VpnCapabilityMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnCapabilityMode>`
    
    .. attribute:: database
    
    	L2VPN databases
    	**type**\:   :py:class:`Database <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database>`
    
    .. attribute:: enable
    
    	Enable L2VPN feature
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: l2vpn_router_id
    
    	Global L2VPN Router ID
    	**type**\:  str
    
    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
    
    .. attribute:: load_balance
    
    	Enable flow load balancing on l2vpn bridges
    	**type**\:   :py:class:`LoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.LoadBalance>`
    
    .. attribute:: mspw_description
    
    	MS\-PW global description
    	**type**\:  str
    
    	**length:** 1..64
    
    .. attribute:: mtu_mismatch_ignore
    
    	Ignore MTU Mismatch for XCs
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: neighbor
    
    	L2VPN neighbor submode
    	**type**\:   :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Neighbor>`
    
    .. attribute:: nsr
    
    	Enable Non\-Stop Routing
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: pbb
    
    	L2VPN PBB Global
    	**type**\:   :py:class:`Pbb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Pbb>`
    
    .. attribute:: pw_grouping
    
    	Enable PW grouping
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: pw_routing
    
    	Pseudowire\-routing attributes
    	**type**\:   :py:class:`PwRouting <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.PwRouting>`
    
    .. attribute:: pw_status_disable
    
    	Disable PW status
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: pwoam_refresh
    
    	Configure PW OAM refresh interval
    	**type**\:  int
    
    	**range:** 1..4095
    
    	**units**\: second
    
    .. attribute:: snmp
    
    	SNMP related configuration
    	**type**\:   :py:class:`Snmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Snmp>`
    
    .. attribute:: tcn_propagation
    
    	Topology change notification propagation
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: utility
    
    	L2VPN utilities
    	**type**\:   :py:class:`Utility <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Utility>`
    
    

    """

    _prefix = 'l2vpn-cfg'
    _revision = '2015-11-09'

    def __init__(self):
        super(L2Vpn, self).__init__()
        self._top_entity = None

        self.yang_name = "l2vpn"
        self.yang_parent_name = "Cisco-IOS-XR-l2vpn-cfg"

        self.capability = YLeaf(YType.enumeration, "capability")

        self.enable = YLeaf(YType.empty, "enable")

        self.l2vpn_router_id = YLeaf(YType.str, "l2vpn-router-id")

        self.load_balance = YLeaf(YType.enumeration, "load-balance")

        self.mspw_description = YLeaf(YType.str, "mspw-description")

        self.mtu_mismatch_ignore = YLeaf(YType.empty, "mtu-mismatch-ignore")

        self.nsr = YLeaf(YType.empty, "nsr")

        self.pw_grouping = YLeaf(YType.empty, "pw-grouping")

        self.pw_status_disable = YLeaf(YType.empty, "pw-status-disable")

        self.pwoam_refresh = YLeaf(YType.uint32, "pwoam-refresh")

        self.tcn_propagation = YLeaf(YType.empty, "tcn-propagation")

        self.auto_discovery = L2Vpn.AutoDiscovery()
        self.auto_discovery.parent = self
        self._children_name_map["auto_discovery"] = "auto-discovery"
        self._children_yang_names.add("auto-discovery")

        self.database = L2Vpn.Database()
        self.database.parent = self
        self._children_name_map["database"] = "database"
        self._children_yang_names.add("database")

        self.neighbor = L2Vpn.Neighbor()
        self.neighbor.parent = self
        self._children_name_map["neighbor"] = "neighbor"
        self._children_yang_names.add("neighbor")

        self.pbb = L2Vpn.Pbb()
        self.pbb.parent = self
        self._children_name_map["pbb"] = "pbb"
        self._children_yang_names.add("pbb")

        self.pw_routing = L2Vpn.PwRouting()
        self.pw_routing.parent = self
        self._children_name_map["pw_routing"] = "pw-routing"
        self._children_yang_names.add("pw-routing")

        self.snmp = L2Vpn.Snmp()
        self.snmp.parent = self
        self._children_name_map["snmp"] = "snmp"
        self._children_yang_names.add("snmp")

        self.utility = L2Vpn.Utility()
        self.utility.parent = self
        self._children_name_map["utility"] = "utility"
        self._children_yang_names.add("utility")

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in ("capability",
                        "enable",
                        "l2vpn_router_id",
                        "load_balance",
                        "mspw_description",
                        "mtu_mismatch_ignore",
                        "nsr",
                        "pw_grouping",
                        "pw_status_disable",
                        "pwoam_refresh",
                        "tcn_propagation") and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(L2Vpn, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(L2Vpn, self).__setattr__(name, value)


    class PwRouting(Entity):
        """
        Pseudowire\-routing attributes
        
        .. attribute:: pw_routing_bgp
        
        	Enable Autodiscovery BGP Pseudowire\-routing BGP
        	**type**\:   :py:class:`PwRoutingBgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.PwRouting.PwRoutingBgp>`
        
        .. attribute:: pw_routing_global_id
        
        	Pseudowire\-routing Global ID
        	**type**\:  int
        
        	**range:** 1..4294967295
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Vpn.PwRouting, self).__init__()

            self.yang_name = "pw-routing"
            self.yang_parent_name = "l2vpn"

            self.pw_routing_global_id = YLeaf(YType.uint32, "pw-routing-global-id")

            self.pw_routing_bgp = L2Vpn.PwRouting.PwRoutingBgp()
            self.pw_routing_bgp.parent = self
            self._children_name_map["pw_routing_bgp"] = "pw-routing-bgp"
            self._children_yang_names.add("pw-routing-bgp")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("pw_routing_global_id") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Vpn.PwRouting, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Vpn.PwRouting, self).__setattr__(name, value)


        class PwRoutingBgp(Entity):
            """
            Enable Autodiscovery BGP Pseudowire\-routing BGP
            
            .. attribute:: enable
            
            	Enable Autodiscovery BGP
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: evpn_route_distinguisher
            
            	Route Distinguisher
            	**type**\:   :py:class:`EvpnRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.PwRouting.PwRoutingBgp.EvpnRouteDistinguisher>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.PwRouting.PwRoutingBgp, self).__init__()

                self.yang_name = "pw-routing-bgp"
                self.yang_parent_name = "pw-routing"

                self.enable = YLeaf(YType.empty, "enable")

                self.evpn_route_distinguisher = L2Vpn.PwRouting.PwRoutingBgp.EvpnRouteDistinguisher()
                self.evpn_route_distinguisher.parent = self
                self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                self._children_yang_names.add("evpn-route-distinguisher")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.PwRouting.PwRoutingBgp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.PwRouting.PwRoutingBgp, self).__setattr__(name, value)


            class EvpnRouteDistinguisher(Entity):
                """
                Route Distinguisher
                
                .. attribute:: addr_index
                
                	Addr index
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: address
                
                	IPV4 address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: as_
                
                	Two byte or 4 byte AS number
                	**type**\:  int
                
                	**range:** 1..4294967295
                
                .. attribute:: as_index
                
                	AS\:nn (hex or decimal format)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: type
                
                	Router Distinguisher Type
                	**type**\:   :py:class:`BgpRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteDistinguisher>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.PwRouting.PwRoutingBgp.EvpnRouteDistinguisher, self).__init__()

                    self.yang_name = "evpn-route-distinguisher"
                    self.yang_parent_name = "pw-routing-bgp"

                    self.addr_index = YLeaf(YType.uint32, "addr-index")

                    self.address = YLeaf(YType.str, "address")

                    self.as_ = YLeaf(YType.uint32, "as")

                    self.as_index = YLeaf(YType.uint32, "as-index")

                    self.type = YLeaf(YType.enumeration, "type")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("addr_index",
                                    "address",
                                    "as_",
                                    "as_index",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.PwRouting.PwRoutingBgp.EvpnRouteDistinguisher, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.PwRouting.PwRoutingBgp.EvpnRouteDistinguisher, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.addr_index.is_set or
                        self.address.is_set or
                        self.as_.is_set or
                        self.as_index.is_set or
                        self.type.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.addr_index.yfilter != YFilter.not_set or
                        self.address.yfilter != YFilter.not_set or
                        self.as_.yfilter != YFilter.not_set or
                        self.as_index.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpn-route-distinguisher" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/pw-routing/pw-routing-bgp/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.addr_index.get_name_leafdata())
                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address.get_name_leafdata())
                    if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.as_.get_name_leafdata())
                    if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.as_index.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "addr-index"):
                        self.addr_index = value
                        self.addr_index.value_namespace = name_space
                        self.addr_index.value_namespace_prefix = name_space_prefix
                    if(value_path == "address"):
                        self.address = value
                        self.address.value_namespace = name_space
                        self.address.value_namespace_prefix = name_space_prefix
                    if(value_path == "as"):
                        self.as_ = value
                        self.as_.value_namespace = name_space
                        self.as_.value_namespace_prefix = name_space_prefix
                    if(value_path == "as-index"):
                        self.as_index = value
                        self.as_index.value_namespace = name_space
                        self.as_index.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.enable.is_set or
                    (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "pw-routing-bgp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/pw-routing/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpn-route-distinguisher"):
                    if (self.evpn_route_distinguisher is None):
                        self.evpn_route_distinguisher = L2Vpn.PwRouting.PwRoutingBgp.EvpnRouteDistinguisher()
                        self.evpn_route_distinguisher.parent = self
                        self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                    return self.evpn_route_distinguisher

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpn-route-distinguisher" or name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                self.pw_routing_global_id.is_set or
                (self.pw_routing_bgp is not None and self.pw_routing_bgp.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.pw_routing_global_id.yfilter != YFilter.not_set or
                (self.pw_routing_bgp is not None and self.pw_routing_bgp.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "pw-routing" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.pw_routing_global_id.is_set or self.pw_routing_global_id.yfilter != YFilter.not_set):
                leaf_name_data.append(self.pw_routing_global_id.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "pw-routing-bgp"):
                if (self.pw_routing_bgp is None):
                    self.pw_routing_bgp = L2Vpn.PwRouting.PwRoutingBgp()
                    self.pw_routing_bgp.parent = self
                    self._children_name_map["pw_routing_bgp"] = "pw-routing-bgp"
                return self.pw_routing_bgp

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "pw-routing-bgp" or name == "pw-routing-global-id"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "pw-routing-global-id"):
                self.pw_routing_global_id = value
                self.pw_routing_global_id.value_namespace = name_space
                self.pw_routing_global_id.value_namespace_prefix = name_space_prefix


    class Neighbor(Entity):
        """
        L2VPN neighbor submode
        
        .. attribute:: ldp_flap
        
        	Enable targetted LDP session flap action
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Vpn.Neighbor, self).__init__()

            self.yang_name = "neighbor"
            self.yang_parent_name = "l2vpn"

            self.ldp_flap = YLeaf(YType.empty, "ldp-flap")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("ldp_flap") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Vpn.Neighbor, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Vpn.Neighbor, self).__setattr__(name, value)

        def has_data(self):
            return self.ldp_flap.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.ldp_flap.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "neighbor" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.ldp_flap.is_set or self.ldp_flap.yfilter != YFilter.not_set):
                leaf_name_data.append(self.ldp_flap.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ldp-flap"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "ldp-flap"):
                self.ldp_flap = value
                self.ldp_flap.value_namespace = name_space
                self.ldp_flap.value_namespace_prefix = name_space_prefix


    class Database(Entity):
        """
        L2VPN databases
        
        .. attribute:: bridge_domain_groups
        
        	List of bridge  groups
        	**type**\:   :py:class:`BridgeDomainGroups <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups>`
        
        .. attribute:: flexible_xconnect_service_table
        
        	List of Flexible XConnect Services
        	**type**\:   :py:class:`FlexibleXconnectServiceTable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable>`
        
        .. attribute:: g8032_rings
        
        	List of G8032 Ring
        	**type**\:   :py:class:`G8032Rings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings>`
        
        .. attribute:: pseudowire_classes
        
        	List of pseudowire classes
        	**type**\:   :py:class:`PseudowireClasses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses>`
        
        .. attribute:: redundancy
        
        	Redundancy groups
        	**type**\:   :py:class:`Redundancy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.Redundancy>`
        
        .. attribute:: xconnect_groups
        
        	List of xconnect groups
        	**type**\:   :py:class:`XconnectGroups <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups>`
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Vpn.Database, self).__init__()

            self.yang_name = "database"
            self.yang_parent_name = "l2vpn"

            self.bridge_domain_groups = L2Vpn.Database.BridgeDomainGroups()
            self.bridge_domain_groups.parent = self
            self._children_name_map["bridge_domain_groups"] = "bridge-domain-groups"
            self._children_yang_names.add("bridge-domain-groups")

            self.flexible_xconnect_service_table = L2Vpn.Database.FlexibleXconnectServiceTable()
            self.flexible_xconnect_service_table.parent = self
            self._children_name_map["flexible_xconnect_service_table"] = "flexible-xconnect-service-table"
            self._children_yang_names.add("flexible-xconnect-service-table")

            self.g8032_rings = L2Vpn.Database.G8032Rings()
            self.g8032_rings.parent = self
            self._children_name_map["g8032_rings"] = "g8032-rings"
            self._children_yang_names.add("g8032-rings")

            self.pseudowire_classes = L2Vpn.Database.PseudowireClasses()
            self.pseudowire_classes.parent = self
            self._children_name_map["pseudowire_classes"] = "pseudowire-classes"
            self._children_yang_names.add("pseudowire-classes")

            self.redundancy = L2Vpn.Database.Redundancy()
            self.redundancy.parent = self
            self._children_name_map["redundancy"] = "redundancy"
            self._children_yang_names.add("redundancy")

            self.xconnect_groups = L2Vpn.Database.XconnectGroups()
            self.xconnect_groups.parent = self
            self._children_name_map["xconnect_groups"] = "xconnect-groups"
            self._children_yang_names.add("xconnect-groups")


        class G8032Rings(Entity):
            """
            List of G8032 Ring
            
            .. attribute:: g8032_ring
            
            	G8032 Ring
            	**type**\: list of    :py:class:`G8032Ring <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Database.G8032Rings, self).__init__()

                self.yang_name = "g8032-rings"
                self.yang_parent_name = "database"

                self.g8032_ring = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.Database.G8032Rings, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.Database.G8032Rings, self).__setattr__(name, value)


            class G8032Ring(Entity):
                """
                G8032 Ring
                
                .. attribute:: g8032_ring_name  <key>
                
                	Name of the G8032 ring
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: erp_instances
                
                	List of ethernet ring protection instance
                	**type**\:   :py:class:`ErpInstances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances>`
                
                .. attribute:: erp_port0s
                
                	Ethernet ring protection port0
                	**type**\:   :py:class:`ErpPort0S <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S>`
                
                .. attribute:: erp_port1s
                
                	Ethernet ring protection port0
                	**type**\:   :py:class:`ErpPort1S <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S>`
                
                .. attribute:: erp_provider_bridge
                
                	Ethernet ring protection provider bridge
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: exclusion_list
                
                	Vlan IDs in the format of a\-b,c,d,e\-f,g ,untagged
                	**type**\:  str
                
                .. attribute:: open_ring
                
                	Specify the G.8032 instance as open ring
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Database.G8032Rings.G8032Ring, self).__init__()

                    self.yang_name = "g8032-ring"
                    self.yang_parent_name = "g8032-rings"

                    self.g8032_ring_name = YLeaf(YType.str, "g8032-ring-name")

                    self.erp_provider_bridge = YLeaf(YType.empty, "erp-provider-bridge")

                    self.exclusion_list = YLeaf(YType.str, "exclusion-list")

                    self.open_ring = YLeaf(YType.empty, "open-ring")

                    self.erp_instances = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances()
                    self.erp_instances.parent = self
                    self._children_name_map["erp_instances"] = "erp-instances"
                    self._children_yang_names.add("erp-instances")

                    self.erp_port0s = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S()
                    self.erp_port0s.parent = self
                    self._children_name_map["erp_port0s"] = "erp-port0s"
                    self._children_yang_names.add("erp-port0s")

                    self.erp_port1s = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S()
                    self.erp_port1s.parent = self
                    self._children_name_map["erp_port1s"] = "erp-port1s"
                    self._children_yang_names.add("erp-port1s")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("g8032_ring_name",
                                    "erp_provider_bridge",
                                    "exclusion_list",
                                    "open_ring") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Database.G8032Rings.G8032Ring, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Database.G8032Rings.G8032Ring, self).__setattr__(name, value)


                class ErpPort0S(Entity):
                    """
                    Ethernet ring protection port0
                    
                    .. attribute:: erp_port0
                    
                    	Configure ERP main port0
                    	**type**\: list of    :py:class:`ErpPort0 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S.ErpPort0>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S, self).__init__()

                        self.yang_name = "erp-port0s"
                        self.yang_parent_name = "g8032-ring"

                        self.erp_port0 = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S, self).__setattr__(name, value)


                    class ErpPort0(Entity):
                        """
                        Configure ERP main port0
                        
                        .. attribute:: interface_name  <key>
                        
                        	Port0 interface
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: monitor
                        
                        	Ethernet ring protection port0 monitor
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S.ErpPort0, self).__init__()

                            self.yang_name = "erp-port0"
                            self.yang_parent_name = "erp-port0s"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.monitor = YLeaf(YType.str, "monitor")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name",
                                            "monitor") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S.ErpPort0, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S.ErpPort0, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.interface_name.is_set or
                                self.monitor.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                self.monitor.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "erp-port0" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                            if (self.monitor.is_set or self.monitor.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.monitor.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "interface-name" or name == "monitor"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "monitor"):
                                self.monitor = value
                                self.monitor.value_namespace = name_space
                                self.monitor.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.erp_port0:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.erp_port0:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "erp-port0s" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "erp-port0"):
                            for c in self.erp_port0:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S.ErpPort0()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.erp_port0.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "erp-port0"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class ErpInstances(Entity):
                    """
                    List of ethernet ring protection instance
                    
                    .. attribute:: erp_instance
                    
                    	Ethernet ring protection instance
                    	**type**\: list of    :py:class:`ErpInstance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances, self).__init__()

                        self.yang_name = "erp-instances"
                        self.yang_parent_name = "g8032-ring"

                        self.erp_instance = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances, self).__setattr__(name, value)


                    class ErpInstance(Entity):
                        """
                        Ethernet ring protection instance
                        
                        .. attribute:: erp_instance_id  <key>
                        
                        	ERP instance number
                        	**type**\:  int
                        
                        	**range:** 1..2
                        
                        .. attribute:: aps
                        
                        	Automatic protection switching
                        	**type**\:   :py:class:`Aps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps>`
                        
                        .. attribute:: description
                        
                        	Ethernet ring protection instance description
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: inclusion_list
                        
                        	Associates a set of VLAN IDs with the G .8032 instance
                        	**type**\:  str
                        
                        .. attribute:: profile
                        
                        	Ethernet ring protection instance profile
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: rpl
                        
                        	Ring protection link
                        	**type**\:   :py:class:`Rpl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Rpl>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance, self).__init__()

                            self.yang_name = "erp-instance"
                            self.yang_parent_name = "erp-instances"

                            self.erp_instance_id = YLeaf(YType.uint32, "erp-instance-id")

                            self.description = YLeaf(YType.str, "description")

                            self.inclusion_list = YLeaf(YType.str, "inclusion-list")

                            self.profile = YLeaf(YType.str, "profile")

                            self.aps = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps()
                            self.aps.parent = self
                            self._children_name_map["aps"] = "aps"
                            self._children_yang_names.add("aps")

                            self.rpl = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Rpl()
                            self.rpl.parent = self
                            self._children_name_map["rpl"] = "rpl"
                            self._children_yang_names.add("rpl")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("erp_instance_id",
                                            "description",
                                            "inclusion_list",
                                            "profile") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance, self).__setattr__(name, value)


                        class Rpl(Entity):
                            """
                            Ring protection link
                            
                            .. attribute:: port
                            
                            	ERP main port number
                            	**type**\:   :py:class:`ErpPort1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.ErpPort1>`
                            
                            .. attribute:: role
                            
                            	RPL role
                            	**type**\:   :py:class:`RplRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.RplRole>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Rpl, self).__init__()

                                self.yang_name = "rpl"
                                self.yang_parent_name = "erp-instance"

                                self.port = YLeaf(YType.enumeration, "port")

                                self.role = YLeaf(YType.enumeration, "role")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("port",
                                                "role") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Rpl, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Rpl, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.port.is_set or
                                    self.role.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.port.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "rpl" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.port.is_set or self.port.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "port" or name == "role"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "port"):
                                    self.port = value
                                    self.port.value_namespace = name_space
                                    self.port.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix


                        class Aps(Entity):
                            """
                            Automatic protection switching
                            
                            .. attribute:: enable
                            
                            	Enable automatic protection switching
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: level
                            
                            	Automatic protection switching level
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            .. attribute:: port0
                            
                            	Port0 APS channel in the format of InterfaceName
                            	**type**\:  str
                            
                            .. attribute:: port1
                            
                            	APS channel for ERP port1
                            	**type**\:   :py:class:`Port1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps.Port1>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps, self).__init__()

                                self.yang_name = "aps"
                                self.yang_parent_name = "erp-instance"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.level = YLeaf(YType.uint32, "level")

                                self.port0 = YLeaf(YType.str, "port0")

                                self.port1 = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps.Port1()
                                self.port1.parent = self
                                self._children_name_map["port1"] = "port1"
                                self._children_yang_names.add("port1")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "level",
                                                "port0") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps, self).__setattr__(name, value)


                            class Port1(Entity):
                                """
                                APS channel for ERP port1
                                
                                .. attribute:: aps_channel
                                
                                	Port1 APS channel in the format of InterfaceName, BDName or XconnectName
                                	**type**\:  str
                                
                                .. attribute:: aps_type
                                
                                	Port1 APS type
                                	**type**\:   :py:class:`Erpaps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Erpaps>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps.Port1, self).__init__()

                                    self.yang_name = "port1"
                                    self.yang_parent_name = "aps"

                                    self.aps_channel = YLeaf(YType.str, "aps-channel")

                                    self.aps_type = YLeaf(YType.enumeration, "aps-type")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("aps_channel",
                                                    "aps_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps.Port1, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps.Port1, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.aps_channel.is_set or
                                        self.aps_type.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.aps_channel.yfilter != YFilter.not_set or
                                        self.aps_type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "port1" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.aps_channel.is_set or self.aps_channel.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.aps_channel.get_name_leafdata())
                                    if (self.aps_type.is_set or self.aps_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.aps_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "aps-channel" or name == "aps-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "aps-channel"):
                                        self.aps_channel = value
                                        self.aps_channel.value_namespace = name_space
                                        self.aps_channel.value_namespace_prefix = name_space_prefix
                                    if(value_path == "aps-type"):
                                        self.aps_type = value
                                        self.aps_type.value_namespace = name_space
                                        self.aps_type.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.level.is_set or
                                    self.port0.is_set or
                                    (self.port1 is not None and self.port1.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.port0.yfilter != YFilter.not_set or
                                    (self.port1 is not None and self.port1.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "aps" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.port0.is_set or self.port0.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port0.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "port1"):
                                    if (self.port1 is None):
                                        self.port1 = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps.Port1()
                                        self.port1.parent = self
                                        self._children_name_map["port1"] = "port1"
                                    return self.port1

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "port1" or name == "enable" or name == "level" or name == "port0"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "port0"):
                                    self.port0 = value
                                    self.port0.value_namespace = name_space
                                    self.port0.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.erp_instance_id.is_set or
                                self.description.is_set or
                                self.inclusion_list.is_set or
                                self.profile.is_set or
                                (self.aps is not None and self.aps.has_data()) or
                                (self.rpl is not None and self.rpl.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.erp_instance_id.yfilter != YFilter.not_set or
                                self.description.yfilter != YFilter.not_set or
                                self.inclusion_list.yfilter != YFilter.not_set or
                                self.profile.yfilter != YFilter.not_set or
                                (self.aps is not None and self.aps.has_operation()) or
                                (self.rpl is not None and self.rpl.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "erp-instance" + "[erp-instance-id='" + self.erp_instance_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.erp_instance_id.is_set or self.erp_instance_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.erp_instance_id.get_name_leafdata())
                            if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.description.get_name_leafdata())
                            if (self.inclusion_list.is_set or self.inclusion_list.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.inclusion_list.get_name_leafdata())
                            if (self.profile.is_set or self.profile.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.profile.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "aps"):
                                if (self.aps is None):
                                    self.aps = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Aps()
                                    self.aps.parent = self
                                    self._children_name_map["aps"] = "aps"
                                return self.aps

                            if (child_yang_name == "rpl"):
                                if (self.rpl is None):
                                    self.rpl = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance.Rpl()
                                    self.rpl.parent = self
                                    self._children_name_map["rpl"] = "rpl"
                                return self.rpl

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "aps" or name == "rpl" or name == "erp-instance-id" or name == "description" or name == "inclusion-list" or name == "profile"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "erp-instance-id"):
                                self.erp_instance_id = value
                                self.erp_instance_id.value_namespace = name_space
                                self.erp_instance_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "description"):
                                self.description = value
                                self.description.value_namespace = name_space
                                self.description.value_namespace_prefix = name_space_prefix
                            if(value_path == "inclusion-list"):
                                self.inclusion_list = value
                                self.inclusion_list.value_namespace = name_space
                                self.inclusion_list.value_namespace_prefix = name_space_prefix
                            if(value_path == "profile"):
                                self.profile = value
                                self.profile.value_namespace = name_space
                                self.profile.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.erp_instance:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.erp_instance:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "erp-instances" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "erp-instance"):
                            for c in self.erp_instance:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances.ErpInstance()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.erp_instance.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "erp-instance"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class ErpPort1S(Entity):
                    """
                    Ethernet ring protection port0
                    
                    .. attribute:: erp_port1
                    
                    	Ethernet ring protection port1
                    	**type**\: list of    :py:class:`ErpPort1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S, self).__init__()

                        self.yang_name = "erp-port1s"
                        self.yang_parent_name = "g8032-ring"

                        self.erp_port1 = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S, self).__setattr__(name, value)


                    class ErpPort1(Entity):
                        """
                        Ethernet ring protection port1
                        
                        .. attribute:: erp_port_type  <key>
                        
                        	Port1 type
                        	**type**\:   :py:class:`ErpPort <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.ErpPort>`
                        
                        .. attribute:: interface
                        
                        	interface
                        	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.Interface>`
                        
                        .. attribute:: none_or_virtual
                        
                        	none or virtual
                        	**type**\:   :py:class:`NoneOrVirtual <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.NoneOrVirtual>`
                        
                        	**presence node**\: True
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1, self).__init__()

                            self.yang_name = "erp-port1"
                            self.yang_parent_name = "erp-port1s"

                            self.erp_port_type = YLeaf(YType.enumeration, "erp-port-type")

                            self.none_or_virtual = None
                            self._children_name_map["none_or_virtual"] = "none-or-virtual"
                            self._children_yang_names.add("none-or-virtual")

                            self.interface = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("erp_port_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1, self).__setattr__(name, value)


                        class NoneOrVirtual(Entity):
                            """
                            none or virtual
                            
                            .. attribute:: monitor
                            
                            	Ethernet ring protection port1 monitor
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.NoneOrVirtual, self).__init__()

                                self.yang_name = "none-or-virtual"
                                self.yang_parent_name = "erp-port1"
                                self.is_presence_container = True

                                self.monitor = YLeaf(YType.str, "monitor")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("monitor") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.NoneOrVirtual, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.NoneOrVirtual, self).__setattr__(name, value)

                            def has_data(self):
                                return self.monitor.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.monitor.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "none-or-virtual" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.monitor.is_set or self.monitor.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.monitor.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "monitor"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "monitor"):
                                    self.monitor = value
                                    self.monitor.value_namespace = name_space
                                    self.monitor.value_namespace_prefix = name_space_prefix


                        class Interface(Entity):
                            """
                            interface
                            
                            .. attribute:: interface_name  <key>
                            
                            	Port1 interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: monitor
                            
                            	Ethernet ring protection port1 monitor
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.Interface, self).__init__()

                                self.yang_name = "interface"
                                self.yang_parent_name = "erp-port1"

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.monitor = YLeaf(YType.str, "monitor")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interface_name",
                                                "monitor") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.Interface, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.Interface, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.interface_name.is_set or
                                    self.monitor.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.monitor.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.monitor.is_set or self.monitor.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.monitor.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface-name" or name == "monitor"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "monitor"):
                                    self.monitor = value
                                    self.monitor.value_namespace = name_space
                                    self.monitor.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.interface:
                                if (c.has_data()):
                                    return True
                            return (
                                self.erp_port_type.is_set or
                                (self.none_or_virtual is not None))

                        def has_operation(self):
                            for c in self.interface:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.erp_port_type.yfilter != YFilter.not_set or
                                (self.none_or_virtual is not None and self.none_or_virtual.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "erp-port1" + "[erp-port-type='" + self.erp_port_type.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.erp_port_type.is_set or self.erp_port_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.erp_port_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "interface"):
                                for c in self.interface:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.Interface()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.interface.append(c)
                                return c

                            if (child_yang_name == "none-or-virtual"):
                                if (self.none_or_virtual is None):
                                    self.none_or_virtual = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1.NoneOrVirtual()
                                    self.none_or_virtual.parent = self
                                    self._children_name_map["none_or_virtual"] = "none-or-virtual"
                                return self.none_or_virtual

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "interface" or name == "none-or-virtual" or name == "erp-port-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "erp-port-type"):
                                self.erp_port_type = value
                                self.erp_port_type.value_namespace = name_space
                                self.erp_port_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.erp_port1:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.erp_port1:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "erp-port1s" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "erp-port1"):
                            for c in self.erp_port1:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S.ErpPort1()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.erp_port1.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "erp-port1"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.g8032_ring_name.is_set or
                        self.erp_provider_bridge.is_set or
                        self.exclusion_list.is_set or
                        self.open_ring.is_set or
                        (self.erp_instances is not None and self.erp_instances.has_data()) or
                        (self.erp_port0s is not None and self.erp_port0s.has_data()) or
                        (self.erp_port1s is not None and self.erp_port1s.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.g8032_ring_name.yfilter != YFilter.not_set or
                        self.erp_provider_bridge.yfilter != YFilter.not_set or
                        self.exclusion_list.yfilter != YFilter.not_set or
                        self.open_ring.yfilter != YFilter.not_set or
                        (self.erp_instances is not None and self.erp_instances.has_operation()) or
                        (self.erp_port0s is not None and self.erp_port0s.has_operation()) or
                        (self.erp_port1s is not None and self.erp_port1s.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "g8032-ring" + "[g8032-ring-name='" + self.g8032_ring_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/g8032-rings/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.g8032_ring_name.is_set or self.g8032_ring_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.g8032_ring_name.get_name_leafdata())
                    if (self.erp_provider_bridge.is_set or self.erp_provider_bridge.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.erp_provider_bridge.get_name_leafdata())
                    if (self.exclusion_list.is_set or self.exclusion_list.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.exclusion_list.get_name_leafdata())
                    if (self.open_ring.is_set or self.open_ring.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.open_ring.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "erp-instances"):
                        if (self.erp_instances is None):
                            self.erp_instances = L2Vpn.Database.G8032Rings.G8032Ring.ErpInstances()
                            self.erp_instances.parent = self
                            self._children_name_map["erp_instances"] = "erp-instances"
                        return self.erp_instances

                    if (child_yang_name == "erp-port0s"):
                        if (self.erp_port0s is None):
                            self.erp_port0s = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort0S()
                            self.erp_port0s.parent = self
                            self._children_name_map["erp_port0s"] = "erp-port0s"
                        return self.erp_port0s

                    if (child_yang_name == "erp-port1s"):
                        if (self.erp_port1s is None):
                            self.erp_port1s = L2Vpn.Database.G8032Rings.G8032Ring.ErpPort1S()
                            self.erp_port1s.parent = self
                            self._children_name_map["erp_port1s"] = "erp-port1s"
                        return self.erp_port1s

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "erp-instances" or name == "erp-port0s" or name == "erp-port1s" or name == "g8032-ring-name" or name == "erp-provider-bridge" or name == "exclusion-list" or name == "open-ring"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "g8032-ring-name"):
                        self.g8032_ring_name = value
                        self.g8032_ring_name.value_namespace = name_space
                        self.g8032_ring_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "erp-provider-bridge"):
                        self.erp_provider_bridge = value
                        self.erp_provider_bridge.value_namespace = name_space
                        self.erp_provider_bridge.value_namespace_prefix = name_space_prefix
                    if(value_path == "exclusion-list"):
                        self.exclusion_list = value
                        self.exclusion_list.value_namespace = name_space
                        self.exclusion_list.value_namespace_prefix = name_space_prefix
                    if(value_path == "open-ring"):
                        self.open_ring = value
                        self.open_ring.value_namespace = name_space
                        self.open_ring.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.g8032_ring:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.g8032_ring:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "g8032-rings" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "g8032-ring"):
                    for c in self.g8032_ring:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = L2Vpn.Database.G8032Rings.G8032Ring()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.g8032_ring.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "g8032-ring"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class XconnectGroups(Entity):
            """
            List of xconnect groups
            
            .. attribute:: xconnect_group
            
            	Xconnect group
            	**type**\: list of    :py:class:`XconnectGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Database.XconnectGroups, self).__init__()

                self.yang_name = "xconnect-groups"
                self.yang_parent_name = "database"

                self.xconnect_group = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.Database.XconnectGroups, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.Database.XconnectGroups, self).__setattr__(name, value)


            class XconnectGroup(Entity):
                """
                Xconnect group
                
                .. attribute:: name  <key>
                
                	Name of the xconnect group
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: mp2mp_xconnects
                
                	List of multi point to multi point xconnects
                	**type**\:   :py:class:`Mp2MpXconnects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects>`
                
                .. attribute:: p2p_xconnects
                
                	List of point to point xconnects
                	**type**\:   :py:class:`P2PXconnects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Database.XconnectGroups.XconnectGroup, self).__init__()

                    self.yang_name = "xconnect-group"
                    self.yang_parent_name = "xconnect-groups"

                    self.name = YLeaf(YType.str, "name")

                    self.mp2mp_xconnects = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects()
                    self.mp2mp_xconnects.parent = self
                    self._children_name_map["mp2mp_xconnects"] = "mp2mp-xconnects"
                    self._children_yang_names.add("mp2mp-xconnects")

                    self.p2p_xconnects = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects()
                    self.p2p_xconnects.parent = self
                    self._children_name_map["p2p_xconnects"] = "p2p-xconnects"
                    self._children_yang_names.add("p2p-xconnects")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Database.XconnectGroups.XconnectGroup, self).__setattr__(name, value)


                class P2PXconnects(Entity):
                    """
                    List of point to point xconnects
                    
                    .. attribute:: p2p_xconnect
                    
                    	Point to point xconnect
                    	**type**\: list of    :py:class:`P2PXconnect <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects, self).__init__()

                        self.yang_name = "p2p-xconnects"
                        self.yang_parent_name = "xconnect-group"

                        self.p2p_xconnect = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects, self).__setattr__(name, value)


                    class P2PXconnect(Entity):
                        """
                        Point to point xconnect
                        
                        .. attribute:: name  <key>
                        
                        	Name of the point to point xconnect
                        	**type**\:  str
                        
                        	**length:** 1..38
                        
                        .. attribute:: attachment_circuits
                        
                        	List of attachment circuits
                        	**type**\:   :py:class:`AttachmentCircuits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits>`
                        
                        .. attribute:: backup_attachment_circuits
                        
                        	List of backup attachment circuits
                        	**type**\:   :py:class:`BackupAttachmentCircuits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits>`
                        
                        .. attribute:: interworking
                        
                        	Interworking
                        	**type**\:   :py:class:`Interworking <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Interworking>`
                        
                        .. attribute:: monitor_sessions
                        
                        	List of Monitor session segments
                        	**type**\:   :py:class:`MonitorSessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions>`
                        
                        .. attribute:: p2p_description
                        
                        	cross connect description Name
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: pseudowire_evpns
                        
                        	List of EVPN Services
                        	**type**\:   :py:class:`PseudowireEvpns <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns>`
                        
                        .. attribute:: pseudowire_routeds
                        
                        	List of pseudowire\-routed
                        	**type**\:   :py:class:`PseudowireRouteds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds>`
                        
                        .. attribute:: pseudowires
                        
                        	List of pseudowires
                        	**type**\:   :py:class:`Pseudowires <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect, self).__init__()

                            self.yang_name = "p2p-xconnect"
                            self.yang_parent_name = "p2p-xconnects"

                            self.name = YLeaf(YType.str, "name")

                            self.interworking = YLeaf(YType.enumeration, "interworking")

                            self.p2p_description = YLeaf(YType.str, "p2p-description")

                            self.attachment_circuits = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits()
                            self.attachment_circuits.parent = self
                            self._children_name_map["attachment_circuits"] = "attachment-circuits"
                            self._children_yang_names.add("attachment-circuits")

                            self.backup_attachment_circuits = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits()
                            self.backup_attachment_circuits.parent = self
                            self._children_name_map["backup_attachment_circuits"] = "backup-attachment-circuits"
                            self._children_yang_names.add("backup-attachment-circuits")

                            self.monitor_sessions = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions()
                            self.monitor_sessions.parent = self
                            self._children_name_map["monitor_sessions"] = "monitor-sessions"
                            self._children_yang_names.add("monitor-sessions")

                            self.pseudowire_evpns = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns()
                            self.pseudowire_evpns.parent = self
                            self._children_name_map["pseudowire_evpns"] = "pseudowire-evpns"
                            self._children_yang_names.add("pseudowire-evpns")

                            self.pseudowire_routeds = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds()
                            self.pseudowire_routeds.parent = self
                            self._children_name_map["pseudowire_routeds"] = "pseudowire-routeds"
                            self._children_yang_names.add("pseudowire-routeds")

                            self.pseudowires = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires()
                            self.pseudowires.parent = self
                            self._children_name_map["pseudowires"] = "pseudowires"
                            self._children_yang_names.add("pseudowires")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("name",
                                            "interworking",
                                            "p2p_description") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect, self).__setattr__(name, value)


                        class BackupAttachmentCircuits(Entity):
                            """
                            List of backup attachment circuits
                            
                            .. attribute:: backup_attachment_circuit
                            
                            	Backup attachment circuit
                            	**type**\: list of    :py:class:`BackupAttachmentCircuit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits.BackupAttachmentCircuit>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits, self).__init__()

                                self.yang_name = "backup-attachment-circuits"
                                self.yang_parent_name = "p2p-xconnect"

                                self.backup_attachment_circuit = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits, self).__setattr__(name, value)


                            class BackupAttachmentCircuit(Entity):
                                """
                                Backup attachment circuit
                                
                                .. attribute:: interface_name  <key>
                                
                                	Name of the attachment circuit interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits.BackupAttachmentCircuit, self).__init__()

                                    self.yang_name = "backup-attachment-circuit"
                                    self.yang_parent_name = "backup-attachment-circuits"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits.BackupAttachmentCircuit, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits.BackupAttachmentCircuit, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.interface_name.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "backup-attachment-circuit" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.backup_attachment_circuit:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.backup_attachment_circuit:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "backup-attachment-circuits" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "backup-attachment-circuit"):
                                    for c in self.backup_attachment_circuit:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits.BackupAttachmentCircuit()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.backup_attachment_circuit.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "backup-attachment-circuit"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class PseudowireEvpns(Entity):
                            """
                            List of EVPN Services
                            
                            .. attribute:: pseudowire_evpn
                            
                            	EVPN P2P Service Configuration
                            	**type**\: list of    :py:class:`PseudowireEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns.PseudowireEvpn>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns, self).__init__()

                                self.yang_name = "pseudowire-evpns"
                                self.yang_parent_name = "p2p-xconnect"

                                self.pseudowire_evpn = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns, self).__setattr__(name, value)


                            class PseudowireEvpn(Entity):
                                """
                                EVPN P2P Service Configuration
                                
                                .. attribute:: eviid  <key>
                                
                                	Ethernet VPN ID
                                	**type**\:  int
                                
                                	**range:** 1..65534
                                
                                .. attribute:: remote_acid  <key>
                                
                                	Remote AC ID
                                	**type**\:  int
                                
                                	**range:** 1..16777215
                                
                                .. attribute:: source_acid  <key>
                                
                                	Source AC ID
                                	**type**\:  int
                                
                                	**range:** 1..16777215
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns.PseudowireEvpn, self).__init__()

                                    self.yang_name = "pseudowire-evpn"
                                    self.yang_parent_name = "pseudowire-evpns"

                                    self.eviid = YLeaf(YType.uint32, "eviid")

                                    self.remote_acid = YLeaf(YType.uint32, "remote-acid")

                                    self.source_acid = YLeaf(YType.uint32, "source-acid")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("eviid",
                                                    "remote_acid",
                                                    "source_acid") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns.PseudowireEvpn, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns.PseudowireEvpn, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.eviid.is_set or
                                        self.remote_acid.is_set or
                                        self.source_acid.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.eviid.yfilter != YFilter.not_set or
                                        self.remote_acid.yfilter != YFilter.not_set or
                                        self.source_acid.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "pseudowire-evpn" + "[eviid='" + self.eviid.get() + "']" + "[remote-acid='" + self.remote_acid.get() + "']" + "[source-acid='" + self.source_acid.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.eviid.get_name_leafdata())
                                    if (self.remote_acid.is_set or self.remote_acid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_acid.get_name_leafdata())
                                    if (self.source_acid.is_set or self.source_acid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source_acid.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "eviid" or name == "remote-acid" or name == "source-acid"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "eviid"):
                                        self.eviid = value
                                        self.eviid.value_namespace = name_space
                                        self.eviid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-acid"):
                                        self.remote_acid = value
                                        self.remote_acid.value_namespace = name_space
                                        self.remote_acid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "source-acid"):
                                        self.source_acid = value
                                        self.source_acid.value_namespace = name_space
                                        self.source_acid.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.pseudowire_evpn:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.pseudowire_evpn:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "pseudowire-evpns" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "pseudowire-evpn"):
                                    for c in self.pseudowire_evpn:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns.PseudowireEvpn()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.pseudowire_evpn.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "pseudowire-evpn"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Pseudowires(Entity):
                            """
                            List of pseudowires
                            
                            .. attribute:: pseudowire
                            
                            	Pseudowire configuration
                            	**type**\: list of    :py:class:`Pseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires, self).__init__()

                                self.yang_name = "pseudowires"
                                self.yang_parent_name = "p2p-xconnect"

                                self.pseudowire = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires, self).__setattr__(name, value)


                            class Pseudowire(Entity):
                                """
                                Pseudowire configuration
                                
                                .. attribute:: pseudowire_id  <key>
                                
                                	Pseudowire ID
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                .. attribute:: neighbor
                                
                                	keys\: neighbor
                                	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor>`
                                
                                .. attribute:: pseudowire_address
                                
                                	keys\: pseudowire\-address
                                	**type**\: list of    :py:class:`PseudowireAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire, self).__init__()

                                    self.yang_name = "pseudowire"
                                    self.yang_parent_name = "pseudowires"

                                    self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                                    self.neighbor = YList(self)
                                    self.pseudowire_address = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("pseudowire_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire, self).__setattr__(name, value)


                                class Neighbor(Entity):
                                    """
                                    keys\: neighbor
                                    
                                    .. attribute:: neighbor  <key>
                                    
                                    	Pseudowire IPv4 address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: backup_pseudowires
                                    
                                    	List of pseudowires
                                    	**type**\:   :py:class:`BackupPseudowires <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires>`
                                    
                                    .. attribute:: bandwidth
                                    
                                    	Pseudowire Bandwidth
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: class_
                                    
                                    	Name of the pseudowire class
                                    	**type**\:  str
                                    
                                    	**length:** 1..32
                                    
                                    .. attribute:: l2tp_static
                                    
                                    	Pseudowire L2TPv3 static configuration
                                    	**type**\:   :py:class:`L2TpStatic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStatic>`
                                    
                                    .. attribute:: l2tp_static_attributes
                                    
                                    	L2TP Static Attributes
                                    	**type**\:   :py:class:`L2TpStaticAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes>`
                                    
                                    .. attribute:: mpls_static_labels
                                    
                                    	MPLS static labels
                                    	**type**\:   :py:class:`MplsStaticLabels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.MplsStaticLabels>`
                                    
                                    .. attribute:: source_address
                                    
                                    	Value of the Pseudowire source address. Must be IPv6 only
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: tag_impose
                                    
                                    	Tag Impose vlan tagged mode
                                    	**type**\:  int
                                    
                                    	**range:** 1..4094
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor, self).__init__()

                                        self.yang_name = "neighbor"
                                        self.yang_parent_name = "pseudowire"

                                        self.neighbor = YLeaf(YType.str, "neighbor")

                                        self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                                        self.class_ = YLeaf(YType.str, "class")

                                        self.source_address = YLeaf(YType.str, "source-address")

                                        self.tag_impose = YLeaf(YType.uint32, "tag-impose")

                                        self.backup_pseudowires = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires()
                                        self.backup_pseudowires.parent = self
                                        self._children_name_map["backup_pseudowires"] = "backup-pseudowires"
                                        self._children_yang_names.add("backup-pseudowires")

                                        self.l2tp_static = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStatic()
                                        self.l2tp_static.parent = self
                                        self._children_name_map["l2tp_static"] = "l2tp-static"
                                        self._children_yang_names.add("l2tp-static")

                                        self.l2tp_static_attributes = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes()
                                        self.l2tp_static_attributes.parent = self
                                        self._children_name_map["l2tp_static_attributes"] = "l2tp-static-attributes"
                                        self._children_yang_names.add("l2tp-static-attributes")

                                        self.mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.MplsStaticLabels()
                                        self.mpls_static_labels.parent = self
                                        self._children_name_map["mpls_static_labels"] = "mpls-static-labels"
                                        self._children_yang_names.add("mpls-static-labels")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("neighbor",
                                                        "bandwidth",
                                                        "class_",
                                                        "source_address",
                                                        "tag_impose") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor, self).__setattr__(name, value)


                                    class MplsStaticLabels(Entity):
                                        """
                                        MPLS static labels
                                        
                                        .. attribute:: local_static_label
                                        
                                        	Pseudowire local static label
                                        	**type**\:  int
                                        
                                        	**range:** 16..1048575
                                        
                                        .. attribute:: remote_static_label
                                        
                                        	Pseudowire remote static label
                                        	**type**\:  int
                                        
                                        	**range:** 16..1048575
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.MplsStaticLabels, self).__init__()

                                            self.yang_name = "mpls-static-labels"
                                            self.yang_parent_name = "neighbor"

                                            self.local_static_label = YLeaf(YType.uint32, "local-static-label")

                                            self.remote_static_label = YLeaf(YType.uint32, "remote-static-label")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("local_static_label",
                                                            "remote_static_label") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.MplsStaticLabels, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.MplsStaticLabels, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.local_static_label.is_set or
                                                self.remote_static_label.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.local_static_label.yfilter != YFilter.not_set or
                                                self.remote_static_label.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "mpls-static-labels" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.local_static_label.is_set or self.local_static_label.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.local_static_label.get_name_leafdata())
                                            if (self.remote_static_label.is_set or self.remote_static_label.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.remote_static_label.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "local-static-label" or name == "remote-static-label"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "local-static-label"):
                                                self.local_static_label = value
                                                self.local_static_label.value_namespace = name_space
                                                self.local_static_label.value_namespace_prefix = name_space_prefix
                                            if(value_path == "remote-static-label"):
                                                self.remote_static_label = value
                                                self.remote_static_label.value_namespace = name_space
                                                self.remote_static_label.value_namespace_prefix = name_space_prefix


                                    class BackupPseudowires(Entity):
                                        """
                                        List of pseudowires
                                        
                                        .. attribute:: backup_pseudowire
                                        
                                        	Backup pseudowire for the cross connect
                                        	**type**\: list of    :py:class:`BackupPseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires, self).__init__()

                                            self.yang_name = "backup-pseudowires"
                                            self.yang_parent_name = "neighbor"

                                            self.backup_pseudowire = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires, self).__setattr__(name, value)


                                        class BackupPseudowire(Entity):
                                            """
                                            Backup pseudowire for the cross connect
                                            
                                            .. attribute:: neighbor  <key>
                                            
                                            	Neighbor IP address
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: pseudowire_id  <key>
                                            
                                            	Pseudowire ID
                                            	**type**\:  int
                                            
                                            	**range:** 1..4294967295
                                            
                                            .. attribute:: backup_mpls_static_labels
                                            
                                            	MPLS static labels
                                            	**type**\:   :py:class:`BackupMplsStaticLabels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels>`
                                            
                                            .. attribute:: backup_pw_class
                                            
                                            	PW class template name to use for the backup PW
                                            	**type**\:  str
                                            
                                            	**length:** 1..32
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire, self).__init__()

                                                self.yang_name = "backup-pseudowire"
                                                self.yang_parent_name = "backup-pseudowires"

                                                self.neighbor = YLeaf(YType.str, "neighbor")

                                                self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                                                self.backup_pw_class = YLeaf(YType.str, "backup-pw-class")

                                                self.backup_mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels()
                                                self.backup_mpls_static_labels.parent = self
                                                self._children_name_map["backup_mpls_static_labels"] = "backup-mpls-static-labels"
                                                self._children_yang_names.add("backup-mpls-static-labels")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("neighbor",
                                                                "pseudowire_id",
                                                                "backup_pw_class") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire, self).__setattr__(name, value)


                                            class BackupMplsStaticLabels(Entity):
                                                """
                                                MPLS static labels
                                                
                                                .. attribute:: local_static_label
                                                
                                                	Pseudowire local static label
                                                	**type**\:  int
                                                
                                                	**range:** 16..1048575
                                                
                                                .. attribute:: remote_static_label
                                                
                                                	Pseudowire remote static label
                                                	**type**\:  int
                                                
                                                	**range:** 16..1048575
                                                
                                                

                                                """

                                                _prefix = 'l2vpn-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels, self).__init__()

                                                    self.yang_name = "backup-mpls-static-labels"
                                                    self.yang_parent_name = "backup-pseudowire"

                                                    self.local_static_label = YLeaf(YType.uint32, "local-static-label")

                                                    self.remote_static_label = YLeaf(YType.uint32, "remote-static-label")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("local_static_label",
                                                                    "remote_static_label") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.local_static_label.is_set or
                                                        self.remote_static_label.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.local_static_label.yfilter != YFilter.not_set or
                                                        self.remote_static_label.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "backup-mpls-static-labels" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.local_static_label.is_set or self.local_static_label.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.local_static_label.get_name_leafdata())
                                                    if (self.remote_static_label.is_set or self.remote_static_label.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.remote_static_label.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "local-static-label" or name == "remote-static-label"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "local-static-label"):
                                                        self.local_static_label = value
                                                        self.local_static_label.value_namespace = name_space
                                                        self.local_static_label.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "remote-static-label"):
                                                        self.remote_static_label = value
                                                        self.remote_static_label.value_namespace = name_space
                                                        self.remote_static_label.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                return (
                                                    self.neighbor.is_set or
                                                    self.pseudowire_id.is_set or
                                                    self.backup_pw_class.is_set or
                                                    (self.backup_mpls_static_labels is not None and self.backup_mpls_static_labels.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.neighbor.yfilter != YFilter.not_set or
                                                    self.pseudowire_id.yfilter != YFilter.not_set or
                                                    self.backup_pw_class.yfilter != YFilter.not_set or
                                                    (self.backup_mpls_static_labels is not None and self.backup_mpls_static_labels.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "backup-pseudowire" + "[neighbor='" + self.neighbor.get() + "']" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.neighbor.get_name_leafdata())
                                                if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pseudowire_id.get_name_leafdata())
                                                if (self.backup_pw_class.is_set or self.backup_pw_class.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.backup_pw_class.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "backup-mpls-static-labels"):
                                                    if (self.backup_mpls_static_labels is None):
                                                        self.backup_mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels()
                                                        self.backup_mpls_static_labels.parent = self
                                                        self._children_name_map["backup_mpls_static_labels"] = "backup-mpls-static-labels"
                                                    return self.backup_mpls_static_labels

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "backup-mpls-static-labels" or name == "neighbor" or name == "pseudowire-id" or name == "backup-pw-class"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "neighbor"):
                                                    self.neighbor = value
                                                    self.neighbor.value_namespace = name_space
                                                    self.neighbor.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pseudowire-id"):
                                                    self.pseudowire_id = value
                                                    self.pseudowire_id.value_namespace = name_space
                                                    self.pseudowire_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "backup-pw-class"):
                                                    self.backup_pw_class = value
                                                    self.backup_pw_class.value_namespace = name_space
                                                    self.backup_pw_class.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.backup_pseudowire:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.backup_pseudowire:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "backup-pseudowires" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "backup-pseudowire"):
                                                for c in self.backup_pseudowire:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires.BackupPseudowire()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.backup_pseudowire.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "backup-pseudowire"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class L2TpStaticAttributes(Entity):
                                        """
                                        L2TP Static Attributes
                                        
                                        .. attribute:: l2tp_local_cookie
                                        
                                        	L2TP local cookie
                                        	**type**\:   :py:class:`L2TpLocalCookie <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpLocalCookie>`
                                        
                                        .. attribute:: l2tp_local_session_id
                                        
                                        	L2TP local session ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: l2tp_remote_cookie
                                        
                                        	L2TP remote cookie
                                        	**type**\:   :py:class:`L2TpRemoteCookie <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpRemoteCookie>`
                                        
                                        .. attribute:: l2tp_remote_session_id
                                        
                                        	L2TP remote session ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: l2tp_secondary_local_cookie
                                        
                                        	L2TP secondary local cookie
                                        	**type**\:   :py:class:`L2TpSecondaryLocalCookie <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpSecondaryLocalCookie>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes, self).__init__()

                                            self.yang_name = "l2tp-static-attributes"
                                            self.yang_parent_name = "neighbor"

                                            self.l2tp_local_session_id = YLeaf(YType.uint32, "l2tp-local-session-id")

                                            self.l2tp_remote_session_id = YLeaf(YType.uint32, "l2tp-remote-session-id")

                                            self.l2tp_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpLocalCookie()
                                            self.l2tp_local_cookie.parent = self
                                            self._children_name_map["l2tp_local_cookie"] = "l2tp-local-cookie"
                                            self._children_yang_names.add("l2tp-local-cookie")

                                            self.l2tp_remote_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpRemoteCookie()
                                            self.l2tp_remote_cookie.parent = self
                                            self._children_name_map["l2tp_remote_cookie"] = "l2tp-remote-cookie"
                                            self._children_yang_names.add("l2tp-remote-cookie")

                                            self.l2tp_secondary_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpSecondaryLocalCookie()
                                            self.l2tp_secondary_local_cookie.parent = self
                                            self._children_name_map["l2tp_secondary_local_cookie"] = "l2tp-secondary-local-cookie"
                                            self._children_yang_names.add("l2tp-secondary-local-cookie")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("l2tp_local_session_id",
                                                            "l2tp_remote_session_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes, self).__setattr__(name, value)


                                        class L2TpRemoteCookie(Entity):
                                            """
                                            L2TP remote cookie
                                            
                                            .. attribute:: higher_value
                                            
                                            	Higher remote cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: lower_value
                                            
                                            	Lower remote cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: size
                                            
                                            	Remote cookie size
                                            	**type**\:   :py:class:`L2TpCookieSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpCookieSize>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpRemoteCookie, self).__init__()

                                                self.yang_name = "l2tp-remote-cookie"
                                                self.yang_parent_name = "l2tp-static-attributes"

                                                self.higher_value = YLeaf(YType.uint32, "higher-value")

                                                self.lower_value = YLeaf(YType.uint32, "lower-value")

                                                self.size = YLeaf(YType.enumeration, "size")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("higher_value",
                                                                "lower_value",
                                                                "size") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpRemoteCookie, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpRemoteCookie, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.higher_value.is_set or
                                                    self.lower_value.is_set or
                                                    self.size.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.higher_value.yfilter != YFilter.not_set or
                                                    self.lower_value.yfilter != YFilter.not_set or
                                                    self.size.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "l2tp-remote-cookie" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.higher_value.is_set or self.higher_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.higher_value.get_name_leafdata())
                                                if (self.lower_value.is_set or self.lower_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lower_value.get_name_leafdata())
                                                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.size.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "higher-value" or name == "lower-value" or name == "size"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "higher-value"):
                                                    self.higher_value = value
                                                    self.higher_value.value_namespace = name_space
                                                    self.higher_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lower-value"):
                                                    self.lower_value = value
                                                    self.lower_value.value_namespace = name_space
                                                    self.lower_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "size"):
                                                    self.size = value
                                                    self.size.value_namespace = name_space
                                                    self.size.value_namespace_prefix = name_space_prefix


                                        class L2TpSecondaryLocalCookie(Entity):
                                            """
                                            L2TP secondary local cookie
                                            
                                            .. attribute:: higher_value
                                            
                                            	Higher local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: lower_value
                                            
                                            	Lower local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: size
                                            
                                            	Local cookie size
                                            	**type**\:   :py:class:`L2TpCookieSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpCookieSize>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpSecondaryLocalCookie, self).__init__()

                                                self.yang_name = "l2tp-secondary-local-cookie"
                                                self.yang_parent_name = "l2tp-static-attributes"

                                                self.higher_value = YLeaf(YType.uint32, "higher-value")

                                                self.lower_value = YLeaf(YType.uint32, "lower-value")

                                                self.size = YLeaf(YType.enumeration, "size")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("higher_value",
                                                                "lower_value",
                                                                "size") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpSecondaryLocalCookie, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpSecondaryLocalCookie, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.higher_value.is_set or
                                                    self.lower_value.is_set or
                                                    self.size.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.higher_value.yfilter != YFilter.not_set or
                                                    self.lower_value.yfilter != YFilter.not_set or
                                                    self.size.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "l2tp-secondary-local-cookie" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.higher_value.is_set or self.higher_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.higher_value.get_name_leafdata())
                                                if (self.lower_value.is_set or self.lower_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lower_value.get_name_leafdata())
                                                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.size.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "higher-value" or name == "lower-value" or name == "size"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "higher-value"):
                                                    self.higher_value = value
                                                    self.higher_value.value_namespace = name_space
                                                    self.higher_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lower-value"):
                                                    self.lower_value = value
                                                    self.lower_value.value_namespace = name_space
                                                    self.lower_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "size"):
                                                    self.size = value
                                                    self.size.value_namespace = name_space
                                                    self.size.value_namespace_prefix = name_space_prefix


                                        class L2TpLocalCookie(Entity):
                                            """
                                            L2TP local cookie
                                            
                                            .. attribute:: higher_value
                                            
                                            	Higher local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: lower_value
                                            
                                            	Lower local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: size
                                            
                                            	Local cookie size
                                            	**type**\:   :py:class:`L2TpCookieSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpCookieSize>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpLocalCookie, self).__init__()

                                                self.yang_name = "l2tp-local-cookie"
                                                self.yang_parent_name = "l2tp-static-attributes"

                                                self.higher_value = YLeaf(YType.uint32, "higher-value")

                                                self.lower_value = YLeaf(YType.uint32, "lower-value")

                                                self.size = YLeaf(YType.enumeration, "size")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("higher_value",
                                                                "lower_value",
                                                                "size") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpLocalCookie, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpLocalCookie, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.higher_value.is_set or
                                                    self.lower_value.is_set or
                                                    self.size.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.higher_value.yfilter != YFilter.not_set or
                                                    self.lower_value.yfilter != YFilter.not_set or
                                                    self.size.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "l2tp-local-cookie" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.higher_value.is_set or self.higher_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.higher_value.get_name_leafdata())
                                                if (self.lower_value.is_set or self.lower_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lower_value.get_name_leafdata())
                                                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.size.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "higher-value" or name == "lower-value" or name == "size"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "higher-value"):
                                                    self.higher_value = value
                                                    self.higher_value.value_namespace = name_space
                                                    self.higher_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lower-value"):
                                                    self.lower_value = value
                                                    self.lower_value.value_namespace = name_space
                                                    self.lower_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "size"):
                                                    self.size = value
                                                    self.size.value_namespace = name_space
                                                    self.size.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.l2tp_local_session_id.is_set or
                                                self.l2tp_remote_session_id.is_set or
                                                (self.l2tp_local_cookie is not None and self.l2tp_local_cookie.has_data()) or
                                                (self.l2tp_remote_cookie is not None and self.l2tp_remote_cookie.has_data()) or
                                                (self.l2tp_secondary_local_cookie is not None and self.l2tp_secondary_local_cookie.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.l2tp_local_session_id.yfilter != YFilter.not_set or
                                                self.l2tp_remote_session_id.yfilter != YFilter.not_set or
                                                (self.l2tp_local_cookie is not None and self.l2tp_local_cookie.has_operation()) or
                                                (self.l2tp_remote_cookie is not None and self.l2tp_remote_cookie.has_operation()) or
                                                (self.l2tp_secondary_local_cookie is not None and self.l2tp_secondary_local_cookie.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "l2tp-static-attributes" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.l2tp_local_session_id.is_set or self.l2tp_local_session_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.l2tp_local_session_id.get_name_leafdata())
                                            if (self.l2tp_remote_session_id.is_set or self.l2tp_remote_session_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.l2tp_remote_session_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "l2tp-local-cookie"):
                                                if (self.l2tp_local_cookie is None):
                                                    self.l2tp_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpLocalCookie()
                                                    self.l2tp_local_cookie.parent = self
                                                    self._children_name_map["l2tp_local_cookie"] = "l2tp-local-cookie"
                                                return self.l2tp_local_cookie

                                            if (child_yang_name == "l2tp-remote-cookie"):
                                                if (self.l2tp_remote_cookie is None):
                                                    self.l2tp_remote_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpRemoteCookie()
                                                    self.l2tp_remote_cookie.parent = self
                                                    self._children_name_map["l2tp_remote_cookie"] = "l2tp-remote-cookie"
                                                return self.l2tp_remote_cookie

                                            if (child_yang_name == "l2tp-secondary-local-cookie"):
                                                if (self.l2tp_secondary_local_cookie is None):
                                                    self.l2tp_secondary_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes.L2TpSecondaryLocalCookie()
                                                    self.l2tp_secondary_local_cookie.parent = self
                                                    self._children_name_map["l2tp_secondary_local_cookie"] = "l2tp-secondary-local-cookie"
                                                return self.l2tp_secondary_local_cookie

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "l2tp-local-cookie" or name == "l2tp-remote-cookie" or name == "l2tp-secondary-local-cookie" or name == "l2tp-local-session-id" or name == "l2tp-remote-session-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "l2tp-local-session-id"):
                                                self.l2tp_local_session_id = value
                                                self.l2tp_local_session_id.value_namespace = name_space
                                                self.l2tp_local_session_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "l2tp-remote-session-id"):
                                                self.l2tp_remote_session_id = value
                                                self.l2tp_remote_session_id.value_namespace = name_space
                                                self.l2tp_remote_session_id.value_namespace_prefix = name_space_prefix


                                    class L2TpStatic(Entity):
                                        """
                                        Pseudowire L2TPv3 static configuration
                                        
                                        .. attribute:: enable
                                        
                                        	Enable pseudowire L2TPv3 static configuration
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStatic, self).__init__()

                                            self.yang_name = "l2tp-static"
                                            self.yang_parent_name = "neighbor"

                                            self.enable = YLeaf(YType.empty, "enable")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("enable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStatic, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStatic, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.enable.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "l2tp-static" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "enable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.neighbor.is_set or
                                            self.bandwidth.is_set or
                                            self.class_.is_set or
                                            self.source_address.is_set or
                                            self.tag_impose.is_set or
                                            (self.backup_pseudowires is not None and self.backup_pseudowires.has_data()) or
                                            (self.l2tp_static is not None and self.l2tp_static.has_data()) or
                                            (self.l2tp_static_attributes is not None and self.l2tp_static_attributes.has_data()) or
                                            (self.mpls_static_labels is not None and self.mpls_static_labels.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.neighbor.yfilter != YFilter.not_set or
                                            self.bandwidth.yfilter != YFilter.not_set or
                                            self.class_.yfilter != YFilter.not_set or
                                            self.source_address.yfilter != YFilter.not_set or
                                            self.tag_impose.yfilter != YFilter.not_set or
                                            (self.backup_pseudowires is not None and self.backup_pseudowires.has_operation()) or
                                            (self.l2tp_static is not None and self.l2tp_static.has_operation()) or
                                            (self.l2tp_static_attributes is not None and self.l2tp_static_attributes.has_operation()) or
                                            (self.mpls_static_labels is not None and self.mpls_static_labels.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "neighbor" + "[neighbor='" + self.neighbor.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.neighbor.get_name_leafdata())
                                        if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.bandwidth.get_name_leafdata())
                                        if (self.class_.is_set or self.class_.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.class_.get_name_leafdata())
                                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.source_address.get_name_leafdata())
                                        if (self.tag_impose.is_set or self.tag_impose.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tag_impose.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "backup-pseudowires"):
                                            if (self.backup_pseudowires is None):
                                                self.backup_pseudowires = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.BackupPseudowires()
                                                self.backup_pseudowires.parent = self
                                                self._children_name_map["backup_pseudowires"] = "backup-pseudowires"
                                            return self.backup_pseudowires

                                        if (child_yang_name == "l2tp-static"):
                                            if (self.l2tp_static is None):
                                                self.l2tp_static = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStatic()
                                                self.l2tp_static.parent = self
                                                self._children_name_map["l2tp_static"] = "l2tp-static"
                                            return self.l2tp_static

                                        if (child_yang_name == "l2tp-static-attributes"):
                                            if (self.l2tp_static_attributes is None):
                                                self.l2tp_static_attributes = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.L2TpStaticAttributes()
                                                self.l2tp_static_attributes.parent = self
                                                self._children_name_map["l2tp_static_attributes"] = "l2tp-static-attributes"
                                            return self.l2tp_static_attributes

                                        if (child_yang_name == "mpls-static-labels"):
                                            if (self.mpls_static_labels is None):
                                                self.mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor.MplsStaticLabels()
                                                self.mpls_static_labels.parent = self
                                                self._children_name_map["mpls_static_labels"] = "mpls-static-labels"
                                            return self.mpls_static_labels

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "backup-pseudowires" or name == "l2tp-static" or name == "l2tp-static-attributes" or name == "mpls-static-labels" or name == "neighbor" or name == "bandwidth" or name == "class" or name == "source-address" or name == "tag-impose"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "neighbor"):
                                            self.neighbor = value
                                            self.neighbor.value_namespace = name_space
                                            self.neighbor.value_namespace_prefix = name_space_prefix
                                        if(value_path == "bandwidth"):
                                            self.bandwidth = value
                                            self.bandwidth.value_namespace = name_space
                                            self.bandwidth.value_namespace_prefix = name_space_prefix
                                        if(value_path == "class"):
                                            self.class_ = value
                                            self.class_.value_namespace = name_space
                                            self.class_.value_namespace_prefix = name_space_prefix
                                        if(value_path == "source-address"):
                                            self.source_address = value
                                            self.source_address.value_namespace = name_space
                                            self.source_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tag-impose"):
                                            self.tag_impose = value
                                            self.tag_impose.value_namespace = name_space
                                            self.tag_impose.value_namespace_prefix = name_space_prefix


                                class PseudowireAddress(Entity):
                                    """
                                    keys\: pseudowire\-address
                                    
                                    .. attribute:: pseudowire_address  <key>
                                    
                                    	Pseudowire IPv6 address. A pseudowire can have only one address\: IPv4 or IPv6
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: backup_pseudowires
                                    
                                    	List of pseudowires
                                    	**type**\:   :py:class:`BackupPseudowires <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires>`
                                    
                                    .. attribute:: bandwidth
                                    
                                    	Pseudowire Bandwidth
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: class_
                                    
                                    	Name of the pseudowire class
                                    	**type**\:  str
                                    
                                    	**length:** 1..32
                                    
                                    .. attribute:: l2tp_static
                                    
                                    	Pseudowire L2TPv3 static configuration
                                    	**type**\:   :py:class:`L2TpStatic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStatic>`
                                    
                                    .. attribute:: l2tp_static_attributes
                                    
                                    	L2TP Static Attributes
                                    	**type**\:   :py:class:`L2TpStaticAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes>`
                                    
                                    .. attribute:: mpls_static_labels
                                    
                                    	MPLS static labels
                                    	**type**\:   :py:class:`MplsStaticLabels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.MplsStaticLabels>`
                                    
                                    .. attribute:: source_address
                                    
                                    	Value of the Pseudowire source address. Must be IPv6 only
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: tag_impose
                                    
                                    	Tag Impose vlan tagged mode
                                    	**type**\:  int
                                    
                                    	**range:** 1..4094
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress, self).__init__()

                                        self.yang_name = "pseudowire-address"
                                        self.yang_parent_name = "pseudowire"

                                        self.pseudowire_address = YLeaf(YType.str, "pseudowire-address")

                                        self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                                        self.class_ = YLeaf(YType.str, "class")

                                        self.source_address = YLeaf(YType.str, "source-address")

                                        self.tag_impose = YLeaf(YType.uint32, "tag-impose")

                                        self.backup_pseudowires = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires()
                                        self.backup_pseudowires.parent = self
                                        self._children_name_map["backup_pseudowires"] = "backup-pseudowires"
                                        self._children_yang_names.add("backup-pseudowires")

                                        self.l2tp_static = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStatic()
                                        self.l2tp_static.parent = self
                                        self._children_name_map["l2tp_static"] = "l2tp-static"
                                        self._children_yang_names.add("l2tp-static")

                                        self.l2tp_static_attributes = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes()
                                        self.l2tp_static_attributes.parent = self
                                        self._children_name_map["l2tp_static_attributes"] = "l2tp-static-attributes"
                                        self._children_yang_names.add("l2tp-static-attributes")

                                        self.mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.MplsStaticLabels()
                                        self.mpls_static_labels.parent = self
                                        self._children_name_map["mpls_static_labels"] = "mpls-static-labels"
                                        self._children_yang_names.add("mpls-static-labels")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("pseudowire_address",
                                                        "bandwidth",
                                                        "class_",
                                                        "source_address",
                                                        "tag_impose") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress, self).__setattr__(name, value)


                                    class MplsStaticLabels(Entity):
                                        """
                                        MPLS static labels
                                        
                                        .. attribute:: local_static_label
                                        
                                        	Pseudowire local static label
                                        	**type**\:  int
                                        
                                        	**range:** 16..1048575
                                        
                                        .. attribute:: remote_static_label
                                        
                                        	Pseudowire remote static label
                                        	**type**\:  int
                                        
                                        	**range:** 16..1048575
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.MplsStaticLabels, self).__init__()

                                            self.yang_name = "mpls-static-labels"
                                            self.yang_parent_name = "pseudowire-address"

                                            self.local_static_label = YLeaf(YType.uint32, "local-static-label")

                                            self.remote_static_label = YLeaf(YType.uint32, "remote-static-label")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("local_static_label",
                                                            "remote_static_label") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.MplsStaticLabels, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.MplsStaticLabels, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.local_static_label.is_set or
                                                self.remote_static_label.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.local_static_label.yfilter != YFilter.not_set or
                                                self.remote_static_label.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "mpls-static-labels" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.local_static_label.is_set or self.local_static_label.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.local_static_label.get_name_leafdata())
                                            if (self.remote_static_label.is_set or self.remote_static_label.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.remote_static_label.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "local-static-label" or name == "remote-static-label"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "local-static-label"):
                                                self.local_static_label = value
                                                self.local_static_label.value_namespace = name_space
                                                self.local_static_label.value_namespace_prefix = name_space_prefix
                                            if(value_path == "remote-static-label"):
                                                self.remote_static_label = value
                                                self.remote_static_label.value_namespace = name_space
                                                self.remote_static_label.value_namespace_prefix = name_space_prefix


                                    class BackupPseudowires(Entity):
                                        """
                                        List of pseudowires
                                        
                                        .. attribute:: backup_pseudowire
                                        
                                        	Backup pseudowire for the cross connect
                                        	**type**\: list of    :py:class:`BackupPseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires, self).__init__()

                                            self.yang_name = "backup-pseudowires"
                                            self.yang_parent_name = "pseudowire-address"

                                            self.backup_pseudowire = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires, self).__setattr__(name, value)


                                        class BackupPseudowire(Entity):
                                            """
                                            Backup pseudowire for the cross connect
                                            
                                            .. attribute:: neighbor  <key>
                                            
                                            	Neighbor IP address
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: pseudowire_id  <key>
                                            
                                            	Pseudowire ID
                                            	**type**\:  int
                                            
                                            	**range:** 1..4294967295
                                            
                                            .. attribute:: backup_mpls_static_labels
                                            
                                            	MPLS static labels
                                            	**type**\:   :py:class:`BackupMplsStaticLabels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels>`
                                            
                                            .. attribute:: backup_pw_class
                                            
                                            	PW class template name to use for the backup PW
                                            	**type**\:  str
                                            
                                            	**length:** 1..32
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire, self).__init__()

                                                self.yang_name = "backup-pseudowire"
                                                self.yang_parent_name = "backup-pseudowires"

                                                self.neighbor = YLeaf(YType.str, "neighbor")

                                                self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                                                self.backup_pw_class = YLeaf(YType.str, "backup-pw-class")

                                                self.backup_mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels()
                                                self.backup_mpls_static_labels.parent = self
                                                self._children_name_map["backup_mpls_static_labels"] = "backup-mpls-static-labels"
                                                self._children_yang_names.add("backup-mpls-static-labels")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("neighbor",
                                                                "pseudowire_id",
                                                                "backup_pw_class") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire, self).__setattr__(name, value)


                                            class BackupMplsStaticLabels(Entity):
                                                """
                                                MPLS static labels
                                                
                                                .. attribute:: local_static_label
                                                
                                                	Pseudowire local static label
                                                	**type**\:  int
                                                
                                                	**range:** 16..1048575
                                                
                                                .. attribute:: remote_static_label
                                                
                                                	Pseudowire remote static label
                                                	**type**\:  int
                                                
                                                	**range:** 16..1048575
                                                
                                                

                                                """

                                                _prefix = 'l2vpn-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels, self).__init__()

                                                    self.yang_name = "backup-mpls-static-labels"
                                                    self.yang_parent_name = "backup-pseudowire"

                                                    self.local_static_label = YLeaf(YType.uint32, "local-static-label")

                                                    self.remote_static_label = YLeaf(YType.uint32, "remote-static-label")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("local_static_label",
                                                                    "remote_static_label") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.local_static_label.is_set or
                                                        self.remote_static_label.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.local_static_label.yfilter != YFilter.not_set or
                                                        self.remote_static_label.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "backup-mpls-static-labels" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.local_static_label.is_set or self.local_static_label.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.local_static_label.get_name_leafdata())
                                                    if (self.remote_static_label.is_set or self.remote_static_label.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.remote_static_label.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "local-static-label" or name == "remote-static-label"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "local-static-label"):
                                                        self.local_static_label = value
                                                        self.local_static_label.value_namespace = name_space
                                                        self.local_static_label.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "remote-static-label"):
                                                        self.remote_static_label = value
                                                        self.remote_static_label.value_namespace = name_space
                                                        self.remote_static_label.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                return (
                                                    self.neighbor.is_set or
                                                    self.pseudowire_id.is_set or
                                                    self.backup_pw_class.is_set or
                                                    (self.backup_mpls_static_labels is not None and self.backup_mpls_static_labels.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.neighbor.yfilter != YFilter.not_set or
                                                    self.pseudowire_id.yfilter != YFilter.not_set or
                                                    self.backup_pw_class.yfilter != YFilter.not_set or
                                                    (self.backup_mpls_static_labels is not None and self.backup_mpls_static_labels.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "backup-pseudowire" + "[neighbor='" + self.neighbor.get() + "']" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.neighbor.get_name_leafdata())
                                                if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pseudowire_id.get_name_leafdata())
                                                if (self.backup_pw_class.is_set or self.backup_pw_class.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.backup_pw_class.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "backup-mpls-static-labels"):
                                                    if (self.backup_mpls_static_labels is None):
                                                        self.backup_mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire.BackupMplsStaticLabels()
                                                        self.backup_mpls_static_labels.parent = self
                                                        self._children_name_map["backup_mpls_static_labels"] = "backup-mpls-static-labels"
                                                    return self.backup_mpls_static_labels

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "backup-mpls-static-labels" or name == "neighbor" or name == "pseudowire-id" or name == "backup-pw-class"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "neighbor"):
                                                    self.neighbor = value
                                                    self.neighbor.value_namespace = name_space
                                                    self.neighbor.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pseudowire-id"):
                                                    self.pseudowire_id = value
                                                    self.pseudowire_id.value_namespace = name_space
                                                    self.pseudowire_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "backup-pw-class"):
                                                    self.backup_pw_class = value
                                                    self.backup_pw_class.value_namespace = name_space
                                                    self.backup_pw_class.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.backup_pseudowire:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.backup_pseudowire:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "backup-pseudowires" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "backup-pseudowire"):
                                                for c in self.backup_pseudowire:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires.BackupPseudowire()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.backup_pseudowire.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "backup-pseudowire"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class L2TpStaticAttributes(Entity):
                                        """
                                        L2TP Static Attributes
                                        
                                        .. attribute:: l2tp_local_cookie
                                        
                                        	L2TP local cookie
                                        	**type**\:   :py:class:`L2TpLocalCookie <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpLocalCookie>`
                                        
                                        .. attribute:: l2tp_local_session_id
                                        
                                        	L2TP local session ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: l2tp_remote_cookie
                                        
                                        	L2TP remote cookie
                                        	**type**\:   :py:class:`L2TpRemoteCookie <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpRemoteCookie>`
                                        
                                        .. attribute:: l2tp_remote_session_id
                                        
                                        	L2TP remote session ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: l2tp_secondary_local_cookie
                                        
                                        	L2TP secondary local cookie
                                        	**type**\:   :py:class:`L2TpSecondaryLocalCookie <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpSecondaryLocalCookie>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes, self).__init__()

                                            self.yang_name = "l2tp-static-attributes"
                                            self.yang_parent_name = "pseudowire-address"

                                            self.l2tp_local_session_id = YLeaf(YType.uint32, "l2tp-local-session-id")

                                            self.l2tp_remote_session_id = YLeaf(YType.uint32, "l2tp-remote-session-id")

                                            self.l2tp_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpLocalCookie()
                                            self.l2tp_local_cookie.parent = self
                                            self._children_name_map["l2tp_local_cookie"] = "l2tp-local-cookie"
                                            self._children_yang_names.add("l2tp-local-cookie")

                                            self.l2tp_remote_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpRemoteCookie()
                                            self.l2tp_remote_cookie.parent = self
                                            self._children_name_map["l2tp_remote_cookie"] = "l2tp-remote-cookie"
                                            self._children_yang_names.add("l2tp-remote-cookie")

                                            self.l2tp_secondary_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpSecondaryLocalCookie()
                                            self.l2tp_secondary_local_cookie.parent = self
                                            self._children_name_map["l2tp_secondary_local_cookie"] = "l2tp-secondary-local-cookie"
                                            self._children_yang_names.add("l2tp-secondary-local-cookie")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("l2tp_local_session_id",
                                                            "l2tp_remote_session_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes, self).__setattr__(name, value)


                                        class L2TpRemoteCookie(Entity):
                                            """
                                            L2TP remote cookie
                                            
                                            .. attribute:: higher_value
                                            
                                            	Higher remote cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: lower_value
                                            
                                            	Lower remote cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: size
                                            
                                            	Remote cookie size
                                            	**type**\:   :py:class:`L2TpCookieSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpCookieSize>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpRemoteCookie, self).__init__()

                                                self.yang_name = "l2tp-remote-cookie"
                                                self.yang_parent_name = "l2tp-static-attributes"

                                                self.higher_value = YLeaf(YType.uint32, "higher-value")

                                                self.lower_value = YLeaf(YType.uint32, "lower-value")

                                                self.size = YLeaf(YType.enumeration, "size")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("higher_value",
                                                                "lower_value",
                                                                "size") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpRemoteCookie, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpRemoteCookie, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.higher_value.is_set or
                                                    self.lower_value.is_set or
                                                    self.size.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.higher_value.yfilter != YFilter.not_set or
                                                    self.lower_value.yfilter != YFilter.not_set or
                                                    self.size.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "l2tp-remote-cookie" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.higher_value.is_set or self.higher_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.higher_value.get_name_leafdata())
                                                if (self.lower_value.is_set or self.lower_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lower_value.get_name_leafdata())
                                                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.size.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "higher-value" or name == "lower-value" or name == "size"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "higher-value"):
                                                    self.higher_value = value
                                                    self.higher_value.value_namespace = name_space
                                                    self.higher_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lower-value"):
                                                    self.lower_value = value
                                                    self.lower_value.value_namespace = name_space
                                                    self.lower_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "size"):
                                                    self.size = value
                                                    self.size.value_namespace = name_space
                                                    self.size.value_namespace_prefix = name_space_prefix


                                        class L2TpSecondaryLocalCookie(Entity):
                                            """
                                            L2TP secondary local cookie
                                            
                                            .. attribute:: higher_value
                                            
                                            	Higher local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: lower_value
                                            
                                            	Lower local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: size
                                            
                                            	Local cookie size
                                            	**type**\:   :py:class:`L2TpCookieSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpCookieSize>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpSecondaryLocalCookie, self).__init__()

                                                self.yang_name = "l2tp-secondary-local-cookie"
                                                self.yang_parent_name = "l2tp-static-attributes"

                                                self.higher_value = YLeaf(YType.uint32, "higher-value")

                                                self.lower_value = YLeaf(YType.uint32, "lower-value")

                                                self.size = YLeaf(YType.enumeration, "size")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("higher_value",
                                                                "lower_value",
                                                                "size") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpSecondaryLocalCookie, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpSecondaryLocalCookie, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.higher_value.is_set or
                                                    self.lower_value.is_set or
                                                    self.size.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.higher_value.yfilter != YFilter.not_set or
                                                    self.lower_value.yfilter != YFilter.not_set or
                                                    self.size.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "l2tp-secondary-local-cookie" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.higher_value.is_set or self.higher_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.higher_value.get_name_leafdata())
                                                if (self.lower_value.is_set or self.lower_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lower_value.get_name_leafdata())
                                                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.size.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "higher-value" or name == "lower-value" or name == "size"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "higher-value"):
                                                    self.higher_value = value
                                                    self.higher_value.value_namespace = name_space
                                                    self.higher_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lower-value"):
                                                    self.lower_value = value
                                                    self.lower_value.value_namespace = name_space
                                                    self.lower_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "size"):
                                                    self.size = value
                                                    self.size.value_namespace = name_space
                                                    self.size.value_namespace_prefix = name_space_prefix


                                        class L2TpLocalCookie(Entity):
                                            """
                                            L2TP local cookie
                                            
                                            .. attribute:: higher_value
                                            
                                            	Higher local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: lower_value
                                            
                                            	Lower local cookie value
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: size
                                            
                                            	Local cookie size
                                            	**type**\:   :py:class:`L2TpCookieSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpCookieSize>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpLocalCookie, self).__init__()

                                                self.yang_name = "l2tp-local-cookie"
                                                self.yang_parent_name = "l2tp-static-attributes"

                                                self.higher_value = YLeaf(YType.uint32, "higher-value")

                                                self.lower_value = YLeaf(YType.uint32, "lower-value")

                                                self.size = YLeaf(YType.enumeration, "size")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("higher_value",
                                                                "lower_value",
                                                                "size") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpLocalCookie, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpLocalCookie, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.higher_value.is_set or
                                                    self.lower_value.is_set or
                                                    self.size.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.higher_value.yfilter != YFilter.not_set or
                                                    self.lower_value.yfilter != YFilter.not_set or
                                                    self.size.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "l2tp-local-cookie" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.higher_value.is_set or self.higher_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.higher_value.get_name_leafdata())
                                                if (self.lower_value.is_set or self.lower_value.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lower_value.get_name_leafdata())
                                                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.size.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "higher-value" or name == "lower-value" or name == "size"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "higher-value"):
                                                    self.higher_value = value
                                                    self.higher_value.value_namespace = name_space
                                                    self.higher_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lower-value"):
                                                    self.lower_value = value
                                                    self.lower_value.value_namespace = name_space
                                                    self.lower_value.value_namespace_prefix = name_space_prefix
                                                if(value_path == "size"):
                                                    self.size = value
                                                    self.size.value_namespace = name_space
                                                    self.size.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.l2tp_local_session_id.is_set or
                                                self.l2tp_remote_session_id.is_set or
                                                (self.l2tp_local_cookie is not None and self.l2tp_local_cookie.has_data()) or
                                                (self.l2tp_remote_cookie is not None and self.l2tp_remote_cookie.has_data()) or
                                                (self.l2tp_secondary_local_cookie is not None and self.l2tp_secondary_local_cookie.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.l2tp_local_session_id.yfilter != YFilter.not_set or
                                                self.l2tp_remote_session_id.yfilter != YFilter.not_set or
                                                (self.l2tp_local_cookie is not None and self.l2tp_local_cookie.has_operation()) or
                                                (self.l2tp_remote_cookie is not None and self.l2tp_remote_cookie.has_operation()) or
                                                (self.l2tp_secondary_local_cookie is not None and self.l2tp_secondary_local_cookie.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "l2tp-static-attributes" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.l2tp_local_session_id.is_set or self.l2tp_local_session_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.l2tp_local_session_id.get_name_leafdata())
                                            if (self.l2tp_remote_session_id.is_set or self.l2tp_remote_session_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.l2tp_remote_session_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "l2tp-local-cookie"):
                                                if (self.l2tp_local_cookie is None):
                                                    self.l2tp_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpLocalCookie()
                                                    self.l2tp_local_cookie.parent = self
                                                    self._children_name_map["l2tp_local_cookie"] = "l2tp-local-cookie"
                                                return self.l2tp_local_cookie

                                            if (child_yang_name == "l2tp-remote-cookie"):
                                                if (self.l2tp_remote_cookie is None):
                                                    self.l2tp_remote_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpRemoteCookie()
                                                    self.l2tp_remote_cookie.parent = self
                                                    self._children_name_map["l2tp_remote_cookie"] = "l2tp-remote-cookie"
                                                return self.l2tp_remote_cookie

                                            if (child_yang_name == "l2tp-secondary-local-cookie"):
                                                if (self.l2tp_secondary_local_cookie is None):
                                                    self.l2tp_secondary_local_cookie = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes.L2TpSecondaryLocalCookie()
                                                    self.l2tp_secondary_local_cookie.parent = self
                                                    self._children_name_map["l2tp_secondary_local_cookie"] = "l2tp-secondary-local-cookie"
                                                return self.l2tp_secondary_local_cookie

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "l2tp-local-cookie" or name == "l2tp-remote-cookie" or name == "l2tp-secondary-local-cookie" or name == "l2tp-local-session-id" or name == "l2tp-remote-session-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "l2tp-local-session-id"):
                                                self.l2tp_local_session_id = value
                                                self.l2tp_local_session_id.value_namespace = name_space
                                                self.l2tp_local_session_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "l2tp-remote-session-id"):
                                                self.l2tp_remote_session_id = value
                                                self.l2tp_remote_session_id.value_namespace = name_space
                                                self.l2tp_remote_session_id.value_namespace_prefix = name_space_prefix


                                    class L2TpStatic(Entity):
                                        """
                                        Pseudowire L2TPv3 static configuration
                                        
                                        .. attribute:: enable
                                        
                                        	Enable pseudowire L2TPv3 static configuration
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStatic, self).__init__()

                                            self.yang_name = "l2tp-static"
                                            self.yang_parent_name = "pseudowire-address"

                                            self.enable = YLeaf(YType.empty, "enable")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("enable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStatic, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStatic, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.enable.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "l2tp-static" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "enable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.pseudowire_address.is_set or
                                            self.bandwidth.is_set or
                                            self.class_.is_set or
                                            self.source_address.is_set or
                                            self.tag_impose.is_set or
                                            (self.backup_pseudowires is not None and self.backup_pseudowires.has_data()) or
                                            (self.l2tp_static is not None and self.l2tp_static.has_data()) or
                                            (self.l2tp_static_attributes is not None and self.l2tp_static_attributes.has_data()) or
                                            (self.mpls_static_labels is not None and self.mpls_static_labels.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.pseudowire_address.yfilter != YFilter.not_set or
                                            self.bandwidth.yfilter != YFilter.not_set or
                                            self.class_.yfilter != YFilter.not_set or
                                            self.source_address.yfilter != YFilter.not_set or
                                            self.tag_impose.yfilter != YFilter.not_set or
                                            (self.backup_pseudowires is not None and self.backup_pseudowires.has_operation()) or
                                            (self.l2tp_static is not None and self.l2tp_static.has_operation()) or
                                            (self.l2tp_static_attributes is not None and self.l2tp_static_attributes.has_operation()) or
                                            (self.mpls_static_labels is not None and self.mpls_static_labels.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pseudowire-address" + "[pseudowire-address='" + self.pseudowire_address.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.pseudowire_address.is_set or self.pseudowire_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.pseudowire_address.get_name_leafdata())
                                        if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.bandwidth.get_name_leafdata())
                                        if (self.class_.is_set or self.class_.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.class_.get_name_leafdata())
                                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.source_address.get_name_leafdata())
                                        if (self.tag_impose.is_set or self.tag_impose.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tag_impose.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "backup-pseudowires"):
                                            if (self.backup_pseudowires is None):
                                                self.backup_pseudowires = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.BackupPseudowires()
                                                self.backup_pseudowires.parent = self
                                                self._children_name_map["backup_pseudowires"] = "backup-pseudowires"
                                            return self.backup_pseudowires

                                        if (child_yang_name == "l2tp-static"):
                                            if (self.l2tp_static is None):
                                                self.l2tp_static = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStatic()
                                                self.l2tp_static.parent = self
                                                self._children_name_map["l2tp_static"] = "l2tp-static"
                                            return self.l2tp_static

                                        if (child_yang_name == "l2tp-static-attributes"):
                                            if (self.l2tp_static_attributes is None):
                                                self.l2tp_static_attributes = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.L2TpStaticAttributes()
                                                self.l2tp_static_attributes.parent = self
                                                self._children_name_map["l2tp_static_attributes"] = "l2tp-static-attributes"
                                            return self.l2tp_static_attributes

                                        if (child_yang_name == "mpls-static-labels"):
                                            if (self.mpls_static_labels is None):
                                                self.mpls_static_labels = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress.MplsStaticLabels()
                                                self.mpls_static_labels.parent = self
                                                self._children_name_map["mpls_static_labels"] = "mpls-static-labels"
                                            return self.mpls_static_labels

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "backup-pseudowires" or name == "l2tp-static" or name == "l2tp-static-attributes" or name == "mpls-static-labels" or name == "pseudowire-address" or name == "bandwidth" or name == "class" or name == "source-address" or name == "tag-impose"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "pseudowire-address"):
                                            self.pseudowire_address = value
                                            self.pseudowire_address.value_namespace = name_space
                                            self.pseudowire_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "bandwidth"):
                                            self.bandwidth = value
                                            self.bandwidth.value_namespace = name_space
                                            self.bandwidth.value_namespace_prefix = name_space_prefix
                                        if(value_path == "class"):
                                            self.class_ = value
                                            self.class_.value_namespace = name_space
                                            self.class_.value_namespace_prefix = name_space_prefix
                                        if(value_path == "source-address"):
                                            self.source_address = value
                                            self.source_address.value_namespace = name_space
                                            self.source_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tag-impose"):
                                            self.tag_impose = value
                                            self.tag_impose.value_namespace = name_space
                                            self.tag_impose.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.neighbor:
                                        if (c.has_data()):
                                            return True
                                    for c in self.pseudowire_address:
                                        if (c.has_data()):
                                            return True
                                    return self.pseudowire_id.is_set

                                def has_operation(self):
                                    for c in self.neighbor:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.pseudowire_address:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.pseudowire_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "pseudowire" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pseudowire_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "neighbor"):
                                        for c in self.neighbor:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.Neighbor()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.neighbor.append(c)
                                        return c

                                    if (child_yang_name == "pseudowire-address"):
                                        for c in self.pseudowire_address:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire.PseudowireAddress()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.pseudowire_address.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "neighbor" or name == "pseudowire-address" or name == "pseudowire-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "pseudowire-id"):
                                        self.pseudowire_id = value
                                        self.pseudowire_id.value_namespace = name_space
                                        self.pseudowire_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.pseudowire:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.pseudowire:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "pseudowires" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "pseudowire"):
                                    for c in self.pseudowire:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires.Pseudowire()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.pseudowire.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "pseudowire"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MonitorSessions(Entity):
                            """
                            List of Monitor session segments
                            
                            .. attribute:: monitor_session
                            
                            	Monitor session segment
                            	**type**\: list of    :py:class:`MonitorSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions.MonitorSession>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions, self).__init__()

                                self.yang_name = "monitor-sessions"
                                self.yang_parent_name = "p2p-xconnect"

                                self.monitor_session = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions, self).__setattr__(name, value)


                            class MonitorSession(Entity):
                                """
                                Monitor session segment
                                
                                .. attribute:: name  <key>
                                
                                	Name of the monitor session
                                	**type**\:  str
                                
                                	**length:** 1..64
                                
                                .. attribute:: enable
                                
                                	Enable monitor session segment 
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions.MonitorSession, self).__init__()

                                    self.yang_name = "monitor-session"
                                    self.yang_parent_name = "monitor-sessions"

                                    self.name = YLeaf(YType.str, "name")

                                    self.enable = YLeaf(YType.empty, "enable")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("name",
                                                    "enable") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions.MonitorSession, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions.MonitorSession, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.name.is_set or
                                        self.enable.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.name.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "monitor-session" + "[name='" + self.name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.name.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "name" or name == "enable"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "name"):
                                        self.name = value
                                        self.name.value_namespace = name_space
                                        self.name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.monitor_session:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.monitor_session:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "monitor-sessions" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "monitor-session"):
                                    for c in self.monitor_session:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions.MonitorSession()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.monitor_session.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "monitor-session"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class PseudowireRouteds(Entity):
                            """
                            List of pseudowire\-routed
                            
                            .. attribute:: pseudowire_routed
                            
                            	Pseudowire configuration
                            	**type**\: list of    :py:class:`PseudowireRouted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds.PseudowireRouted>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds, self).__init__()

                                self.yang_name = "pseudowire-routeds"
                                self.yang_parent_name = "p2p-xconnect"

                                self.pseudowire_routed = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds, self).__setattr__(name, value)


                            class PseudowireRouted(Entity):
                                """
                                Pseudowire configuration
                                
                                .. attribute:: global_id  <key>
                                
                                	Target Global ID
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                .. attribute:: prefix  <key>
                                
                                	Target Prefix
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: acid  <key>
                                
                                	Target AC ID
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                .. attribute:: sacid  <key>
                                
                                	Source AC ID
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                .. attribute:: class_
                                
                                	Name of the pseudowire class
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: tag_impose
                                
                                	Tag Impose vlan tagged mode
                                	**type**\:  int
                                
                                	**range:** 1..4094
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds.PseudowireRouted, self).__init__()

                                    self.yang_name = "pseudowire-routed"
                                    self.yang_parent_name = "pseudowire-routeds"

                                    self.global_id = YLeaf(YType.uint32, "global-id")

                                    self.prefix = YLeaf(YType.str, "prefix")

                                    self.acid = YLeaf(YType.uint32, "acid")

                                    self.sacid = YLeaf(YType.uint32, "sacid")

                                    self.class_ = YLeaf(YType.str, "class")

                                    self.tag_impose = YLeaf(YType.uint32, "tag-impose")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("global_id",
                                                    "prefix",
                                                    "acid",
                                                    "sacid",
                                                    "class_",
                                                    "tag_impose") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds.PseudowireRouted, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds.PseudowireRouted, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.global_id.is_set or
                                        self.prefix.is_set or
                                        self.acid.is_set or
                                        self.sacid.is_set or
                                        self.class_.is_set or
                                        self.tag_impose.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.global_id.yfilter != YFilter.not_set or
                                        self.prefix.yfilter != YFilter.not_set or
                                        self.acid.yfilter != YFilter.not_set or
                                        self.sacid.yfilter != YFilter.not_set or
                                        self.class_.yfilter != YFilter.not_set or
                                        self.tag_impose.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "pseudowire-routed" + "[global-id='" + self.global_id.get() + "']" + "[prefix='" + self.prefix.get() + "']" + "[acid='" + self.acid.get() + "']" + "[sacid='" + self.sacid.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.global_id.is_set or self.global_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.global_id.get_name_leafdata())
                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                    if (self.acid.is_set or self.acid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.acid.get_name_leafdata())
                                    if (self.sacid.is_set or self.sacid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sacid.get_name_leafdata())
                                    if (self.class_.is_set or self.class_.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.class_.get_name_leafdata())
                                    if (self.tag_impose.is_set or self.tag_impose.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag_impose.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "global-id" or name == "prefix" or name == "acid" or name == "sacid" or name == "class" or name == "tag-impose"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "global-id"):
                                        self.global_id = value
                                        self.global_id.value_namespace = name_space
                                        self.global_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix"):
                                        self.prefix = value
                                        self.prefix.value_namespace = name_space
                                        self.prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "acid"):
                                        self.acid = value
                                        self.acid.value_namespace = name_space
                                        self.acid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "sacid"):
                                        self.sacid = value
                                        self.sacid.value_namespace = name_space
                                        self.sacid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "class"):
                                        self.class_ = value
                                        self.class_.value_namespace = name_space
                                        self.class_.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag-impose"):
                                        self.tag_impose = value
                                        self.tag_impose.value_namespace = name_space
                                        self.tag_impose.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.pseudowire_routed:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.pseudowire_routed:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "pseudowire-routeds" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "pseudowire-routed"):
                                    for c in self.pseudowire_routed:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds.PseudowireRouted()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.pseudowire_routed.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "pseudowire-routed"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class AttachmentCircuits(Entity):
                            """
                            List of attachment circuits
                            
                            .. attribute:: attachment_circuit
                            
                            	Attachment circuit interface
                            	**type**\: list of    :py:class:`AttachmentCircuit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits.AttachmentCircuit>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits, self).__init__()

                                self.yang_name = "attachment-circuits"
                                self.yang_parent_name = "p2p-xconnect"

                                self.attachment_circuit = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits, self).__setattr__(name, value)


                            class AttachmentCircuit(Entity):
                                """
                                Attachment circuit interface
                                
                                .. attribute:: name  <key>
                                
                                	Name of the attachment circuit interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: enable
                                
                                	Enable attachment circuit interface
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits.AttachmentCircuit, self).__init__()

                                    self.yang_name = "attachment-circuit"
                                    self.yang_parent_name = "attachment-circuits"

                                    self.name = YLeaf(YType.str, "name")

                                    self.enable = YLeaf(YType.empty, "enable")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("name",
                                                    "enable") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits.AttachmentCircuit, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits.AttachmentCircuit, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.name.is_set or
                                        self.enable.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.name.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "attachment-circuit" + "[name='" + self.name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.name.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "name" or name == "enable"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "name"):
                                        self.name = value
                                        self.name.value_namespace = name_space
                                        self.name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.attachment_circuit:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.attachment_circuit:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "attachment-circuits" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "attachment-circuit"):
                                    for c in self.attachment_circuit:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits.AttachmentCircuit()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.attachment_circuit.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "attachment-circuit"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.name.is_set or
                                self.interworking.is_set or
                                self.p2p_description.is_set or
                                (self.attachment_circuits is not None and self.attachment_circuits.has_data()) or
                                (self.backup_attachment_circuits is not None and self.backup_attachment_circuits.has_data()) or
                                (self.monitor_sessions is not None and self.monitor_sessions.has_data()) or
                                (self.pseudowire_evpns is not None and self.pseudowire_evpns.has_data()) or
                                (self.pseudowire_routeds is not None and self.pseudowire_routeds.has_data()) or
                                (self.pseudowires is not None and self.pseudowires.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.name.yfilter != YFilter.not_set or
                                self.interworking.yfilter != YFilter.not_set or
                                self.p2p_description.yfilter != YFilter.not_set or
                                (self.attachment_circuits is not None and self.attachment_circuits.has_operation()) or
                                (self.backup_attachment_circuits is not None and self.backup_attachment_circuits.has_operation()) or
                                (self.monitor_sessions is not None and self.monitor_sessions.has_operation()) or
                                (self.pseudowire_evpns is not None and self.pseudowire_evpns.has_operation()) or
                                (self.pseudowire_routeds is not None and self.pseudowire_routeds.has_operation()) or
                                (self.pseudowires is not None and self.pseudowires.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "p2p-xconnect" + "[name='" + self.name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.name.get_name_leafdata())
                            if (self.interworking.is_set or self.interworking.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interworking.get_name_leafdata())
                            if (self.p2p_description.is_set or self.p2p_description.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.p2p_description.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "attachment-circuits"):
                                if (self.attachment_circuits is None):
                                    self.attachment_circuits = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.AttachmentCircuits()
                                    self.attachment_circuits.parent = self
                                    self._children_name_map["attachment_circuits"] = "attachment-circuits"
                                return self.attachment_circuits

                            if (child_yang_name == "backup-attachment-circuits"):
                                if (self.backup_attachment_circuits is None):
                                    self.backup_attachment_circuits = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.BackupAttachmentCircuits()
                                    self.backup_attachment_circuits.parent = self
                                    self._children_name_map["backup_attachment_circuits"] = "backup-attachment-circuits"
                                return self.backup_attachment_circuits

                            if (child_yang_name == "monitor-sessions"):
                                if (self.monitor_sessions is None):
                                    self.monitor_sessions = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.MonitorSessions()
                                    self.monitor_sessions.parent = self
                                    self._children_name_map["monitor_sessions"] = "monitor-sessions"
                                return self.monitor_sessions

                            if (child_yang_name == "pseudowire-evpns"):
                                if (self.pseudowire_evpns is None):
                                    self.pseudowire_evpns = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireEvpns()
                                    self.pseudowire_evpns.parent = self
                                    self._children_name_map["pseudowire_evpns"] = "pseudowire-evpns"
                                return self.pseudowire_evpns

                            if (child_yang_name == "pseudowire-routeds"):
                                if (self.pseudowire_routeds is None):
                                    self.pseudowire_routeds = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.PseudowireRouteds()
                                    self.pseudowire_routeds.parent = self
                                    self._children_name_map["pseudowire_routeds"] = "pseudowire-routeds"
                                return self.pseudowire_routeds

                            if (child_yang_name == "pseudowires"):
                                if (self.pseudowires is None):
                                    self.pseudowires = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect.Pseudowires()
                                    self.pseudowires.parent = self
                                    self._children_name_map["pseudowires"] = "pseudowires"
                                return self.pseudowires

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "attachment-circuits" or name == "backup-attachment-circuits" or name == "monitor-sessions" or name == "pseudowire-evpns" or name == "pseudowire-routeds" or name == "pseudowires" or name == "name" or name == "interworking" or name == "p2p-description"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "name"):
                                self.name = value
                                self.name.value_namespace = name_space
                                self.name.value_namespace_prefix = name_space_prefix
                            if(value_path == "interworking"):
                                self.interworking = value
                                self.interworking.value_namespace = name_space
                                self.interworking.value_namespace_prefix = name_space_prefix
                            if(value_path == "p2p-description"):
                                self.p2p_description = value
                                self.p2p_description.value_namespace = name_space
                                self.p2p_description.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.p2p_xconnect:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.p2p_xconnect:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "p2p-xconnects" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "p2p-xconnect"):
                            for c in self.p2p_xconnect:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects.P2PXconnect()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.p2p_xconnect.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "p2p-xconnect"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Mp2MpXconnects(Entity):
                    """
                    List of multi point to multi point xconnects
                    
                    .. attribute:: mp2mp_xconnect
                    
                    	Multi point to multi point xconnect
                    	**type**\: list of    :py:class:`Mp2MpXconnect <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects, self).__init__()

                        self.yang_name = "mp2mp-xconnects"
                        self.yang_parent_name = "xconnect-group"

                        self.mp2mp_xconnect = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects, self).__setattr__(name, value)


                    class Mp2MpXconnect(Entity):
                        """
                        Multi point to multi point xconnect
                        
                        .. attribute:: name  <key>
                        
                        	Name of the multi point to multi point xconnect
                        	**type**\:  str
                        
                        	**length:** 1..26
                        
                        .. attribute:: mp2mp_auto_discovery
                        
                        	auto\-discovery in this MP2MP
                        	**type**\:   :py:class:`Mp2MpAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery>`
                        
                        .. attribute:: mp2mp_control_word
                        
                        	Disable control word
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: mp2mp_interworking
                        
                        	Interworking
                        	**type**\:   :py:class:`Interworking <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Interworking>`
                        
                        .. attribute:: mp2mp_shutdown
                        
                        	shutdown this MP2MP VPWS instance
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: mp2mpl2_encapsulation
                        
                        	Configure Layer 2 Encapsulation
                        	**type**\:   :py:class:`L2Encapsulation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Encapsulation>`
                        
                        .. attribute:: mp2mpmtu
                        
                        	Maximum transmission unit for this MP2MP VPWS instance
                        	**type**\:  int
                        
                        	**range:** 64..65535
                        
                        	**units**\: byte
                        
                        .. attribute:: mp2mpvpn_id
                        
                        	VPN Identifier
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect, self).__init__()

                            self.yang_name = "mp2mp-xconnect"
                            self.yang_parent_name = "mp2mp-xconnects"

                            self.name = YLeaf(YType.str, "name")

                            self.mp2mp_control_word = YLeaf(YType.empty, "mp2mp-control-word")

                            self.mp2mp_interworking = YLeaf(YType.enumeration, "mp2mp-interworking")

                            self.mp2mp_shutdown = YLeaf(YType.empty, "mp2mp-shutdown")

                            self.mp2mpl2_encapsulation = YLeaf(YType.enumeration, "mp2mpl2-encapsulation")

                            self.mp2mpmtu = YLeaf(YType.uint32, "mp2mpmtu")

                            self.mp2mpvpn_id = YLeaf(YType.uint32, "mp2mpvpn-id")

                            self.mp2mp_auto_discovery = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery()
                            self.mp2mp_auto_discovery.parent = self
                            self._children_name_map["mp2mp_auto_discovery"] = "mp2mp-auto-discovery"
                            self._children_yang_names.add("mp2mp-auto-discovery")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("name",
                                            "mp2mp_control_word",
                                            "mp2mp_interworking",
                                            "mp2mp_shutdown",
                                            "mp2mpl2_encapsulation",
                                            "mp2mpmtu",
                                            "mp2mpvpn_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect, self).__setattr__(name, value)


                        class Mp2MpAutoDiscovery(Entity):
                            """
                            auto\-discovery in this MP2MP
                            
                            .. attribute:: enable
                            
                            	Enable auto\-discovery
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: mp2mp_route_policy
                            
                            	Route policy
                            	**type**\:   :py:class:`Mp2MpRoutePolicy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRoutePolicy>`
                            
                            .. attribute:: mp2mp_route_targets
                            
                            	Route Target
                            	**type**\:   :py:class:`Mp2MpRouteTargets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets>`
                            
                            .. attribute:: mp2mp_signaling_protocol
                            
                            	signaling protocol in this MP2MP
                            	**type**\:   :py:class:`Mp2MpSignalingProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol>`
                            
                            .. attribute:: route_distinguisher
                            
                            	Route Distinguisher
                            	**type**\:   :py:class:`RouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.RouteDistinguisher>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery, self).__init__()

                                self.yang_name = "mp2mp-auto-discovery"
                                self.yang_parent_name = "mp2mp-xconnect"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.mp2mp_route_policy = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRoutePolicy()
                                self.mp2mp_route_policy.parent = self
                                self._children_name_map["mp2mp_route_policy"] = "mp2mp-route-policy"
                                self._children_yang_names.add("mp2mp-route-policy")

                                self.mp2mp_route_targets = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets()
                                self.mp2mp_route_targets.parent = self
                                self._children_name_map["mp2mp_route_targets"] = "mp2mp-route-targets"
                                self._children_yang_names.add("mp2mp-route-targets")

                                self.mp2mp_signaling_protocol = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol()
                                self.mp2mp_signaling_protocol.parent = self
                                self._children_name_map["mp2mp_signaling_protocol"] = "mp2mp-signaling-protocol"
                                self._children_yang_names.add("mp2mp-signaling-protocol")

                                self.route_distinguisher = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.RouteDistinguisher()
                                self.route_distinguisher.parent = self
                                self._children_name_map["route_distinguisher"] = "route-distinguisher"
                                self._children_yang_names.add("route-distinguisher")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery, self).__setattr__(name, value)


                            class RouteDistinguisher(Entity):
                                """
                                Route Distinguisher
                                
                                .. attribute:: addr_index
                                
                                	Addr index
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: address
                                
                                	IPV4 address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: as_
                                
                                	Two byte or 4 byte AS number
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                .. attribute:: as_index
                                
                                	AS\:nn (hex or decimal format)
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: type
                                
                                	Router distinguisher type
                                	**type**\:   :py:class:`BgpRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteDistinguisher>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.RouteDistinguisher, self).__init__()

                                    self.yang_name = "route-distinguisher"
                                    self.yang_parent_name = "mp2mp-auto-discovery"

                                    self.addr_index = YLeaf(YType.uint32, "addr-index")

                                    self.address = YLeaf(YType.str, "address")

                                    self.as_ = YLeaf(YType.uint32, "as")

                                    self.as_index = YLeaf(YType.uint32, "as-index")

                                    self.type = YLeaf(YType.enumeration, "type")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("addr_index",
                                                    "address",
                                                    "as_",
                                                    "as_index",
                                                    "type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.RouteDistinguisher, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.RouteDistinguisher, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.addr_index.is_set or
                                        self.address.is_set or
                                        self.as_.is_set or
                                        self.as_index.is_set or
                                        self.type.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.addr_index.yfilter != YFilter.not_set or
                                        self.address.yfilter != YFilter.not_set or
                                        self.as_.yfilter != YFilter.not_set or
                                        self.as_index.yfilter != YFilter.not_set or
                                        self.type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "route-distinguisher" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.addr_index.get_name_leafdata())
                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address.get_name_leafdata())
                                    if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.as_.get_name_leafdata())
                                    if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.as_index.get_name_leafdata())
                                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "addr-index"):
                                        self.addr_index = value
                                        self.addr_index.value_namespace = name_space
                                        self.addr_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "address"):
                                        self.address = value
                                        self.address.value_namespace = name_space
                                        self.address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "as"):
                                        self.as_ = value
                                        self.as_.value_namespace = name_space
                                        self.as_.value_namespace_prefix = name_space_prefix
                                    if(value_path == "as-index"):
                                        self.as_index = value
                                        self.as_index.value_namespace = name_space
                                        self.as_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "type"):
                                        self.type = value
                                        self.type.value_namespace = name_space
                                        self.type.value_namespace_prefix = name_space_prefix


                            class Mp2MpRoutePolicy(Entity):
                                """
                                Route policy
                                
                                .. attribute:: export
                                
                                	Export route policy
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRoutePolicy, self).__init__()

                                    self.yang_name = "mp2mp-route-policy"
                                    self.yang_parent_name = "mp2mp-auto-discovery"

                                    self.export = YLeaf(YType.str, "export")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("export") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRoutePolicy, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRoutePolicy, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.export.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.export.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "mp2mp-route-policy" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.export.is_set or self.export.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.export.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "export"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "export"):
                                        self.export = value
                                        self.export.value_namespace = name_space
                                        self.export.value_namespace_prefix = name_space_prefix


                            class Mp2MpRouteTargets(Entity):
                                """
                                Route Target
                                
                                .. attribute:: mp2mp_route_target
                                
                                	Name of the Route Target
                                	**type**\: list of    :py:class:`Mp2MpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets, self).__init__()

                                    self.yang_name = "mp2mp-route-targets"
                                    self.yang_parent_name = "mp2mp-auto-discovery"

                                    self.mp2mp_route_target = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets, self).__setattr__(name, value)


                                class Mp2MpRouteTarget(Entity):
                                    """
                                    Name of the Route Target
                                    
                                    .. attribute:: role  <key>
                                    
                                    	Role of the router target type
                                    	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                                    
                                    .. attribute:: format  <key>
                                    
                                    	Format of the route target
                                    	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                                    
                                    .. attribute:: ipv4_address
                                    
                                    	ipv4 address
                                    	**type**\: list of    :py:class:`Ipv4Address <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.Ipv4Address>`
                                    
                                    .. attribute:: two_byte_as_or_four_byte_as
                                    
                                    	two byte as or four byte as
                                    	**type**\: list of    :py:class:`TwoByteAsOrFourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.TwoByteAsOrFourByteAs>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget, self).__init__()

                                        self.yang_name = "mp2mp-route-target"
                                        self.yang_parent_name = "mp2mp-route-targets"

                                        self.role = YLeaf(YType.enumeration, "role")

                                        self.format = YLeaf(YType.enumeration, "format")

                                        self.ipv4_address = YList(self)
                                        self.two_byte_as_or_four_byte_as = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("role",
                                                        "format") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget, self).__setattr__(name, value)


                                    class TwoByteAsOrFourByteAs(Entity):
                                        """
                                        two byte as or four byte as
                                        
                                        .. attribute:: as_  <key>
                                        
                                        	Two byte or 4 byte AS number
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        .. attribute:: as_index  <key>
                                        
                                        	AS\:nn (hex or decimal format)
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.TwoByteAsOrFourByteAs, self).__init__()

                                            self.yang_name = "two-byte-as-or-four-byte-as"
                                            self.yang_parent_name = "mp2mp-route-target"

                                            self.as_ = YLeaf(YType.uint32, "as")

                                            self.as_index = YLeaf(YType.uint32, "as-index")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("as_",
                                                            "as_index") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.TwoByteAsOrFourByteAs, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.TwoByteAsOrFourByteAs, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.as_.is_set or
                                                self.as_index.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.as_.yfilter != YFilter.not_set or
                                                self.as_index.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "two-byte-as-or-four-byte-as" + "[as='" + self.as_.get() + "']" + "[as-index='" + self.as_index.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.as_.get_name_leafdata())
                                            if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.as_index.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "as" or name == "as-index"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "as"):
                                                self.as_ = value
                                                self.as_.value_namespace = name_space
                                                self.as_.value_namespace_prefix = name_space_prefix
                                            if(value_path == "as-index"):
                                                self.as_index = value
                                                self.as_index.value_namespace = name_space
                                                self.as_index.value_namespace_prefix = name_space_prefix


                                    class Ipv4Address(Entity):
                                        """
                                        ipv4 address
                                        
                                        .. attribute:: address  <key>
                                        
                                        	IPV4 address
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: addr_index  <key>
                                        
                                        	Addr index
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.Ipv4Address, self).__init__()

                                            self.yang_name = "ipv4-address"
                                            self.yang_parent_name = "mp2mp-route-target"

                                            self.address = YLeaf(YType.str, "address")

                                            self.addr_index = YLeaf(YType.uint32, "addr-index")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("address",
                                                            "addr_index") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.Ipv4Address, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.Ipv4Address, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.address.is_set or
                                                self.addr_index.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.address.yfilter != YFilter.not_set or
                                                self.addr_index.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ipv4-address" + "[address='" + self.address.get() + "']" + "[addr-index='" + self.addr_index.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.address.get_name_leafdata())
                                            if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.addr_index.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "address" or name == "addr-index"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "address"):
                                                self.address = value
                                                self.address.value_namespace = name_space
                                                self.address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "addr-index"):
                                                self.addr_index = value
                                                self.addr_index.value_namespace = name_space
                                                self.addr_index.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.ipv4_address:
                                            if (c.has_data()):
                                                return True
                                        for c in self.two_byte_as_or_four_byte_as:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.role.is_set or
                                            self.format.is_set)

                                    def has_operation(self):
                                        for c in self.ipv4_address:
                                            if (c.has_operation()):
                                                return True
                                        for c in self.two_byte_as_or_four_byte_as:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.role.yfilter != YFilter.not_set or
                                            self.format.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mp2mp-route-target" + "[role='" + self.role.get() + "']" + "[format='" + self.format.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.role.get_name_leafdata())
                                        if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.format.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "ipv4-address"):
                                            for c in self.ipv4_address:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.Ipv4Address()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.ipv4_address.append(c)
                                            return c

                                        if (child_yang_name == "two-byte-as-or-four-byte-as"):
                                            for c in self.two_byte_as_or_four_byte_as:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget.TwoByteAsOrFourByteAs()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.two_byte_as_or_four_byte_as.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "ipv4-address" or name == "two-byte-as-or-four-byte-as" or name == "role" or name == "format"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "role"):
                                            self.role = value
                                            self.role.value_namespace = name_space
                                            self.role.value_namespace_prefix = name_space_prefix
                                        if(value_path == "format"):
                                            self.format = value
                                            self.format.value_namespace = name_space
                                            self.format.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.mp2mp_route_target:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.mp2mp_route_target:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "mp2mp-route-targets" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "mp2mp-route-target"):
                                        for c in self.mp2mp_route_target:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets.Mp2MpRouteTarget()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.mp2mp_route_target.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "mp2mp-route-target"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Mp2MpSignalingProtocol(Entity):
                                """
                                signaling protocol in this MP2MP
                                
                                .. attribute:: ce_range
                                
                                	Local Customer Edge Identifier
                                	**type**\:  int
                                
                                	**range:** 11..100
                                
                                .. attribute:: ceids
                                
                                	Local Customer Edge Identifier Table
                                	**type**\:   :py:class:`Ceids <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids>`
                                
                                .. attribute:: enable
                                
                                	Enable signaling protocol
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: flow_label_load_balance
                                
                                	Enable Flow Label based load balancing
                                	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.FlowLabelLoadBalance>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol, self).__init__()

                                    self.yang_name = "mp2mp-signaling-protocol"
                                    self.yang_parent_name = "mp2mp-auto-discovery"

                                    self.ce_range = YLeaf(YType.uint32, "ce-range")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.ceids = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids()
                                    self.ceids.parent = self
                                    self._children_name_map["ceids"] = "ceids"
                                    self._children_yang_names.add("ceids")

                                    self.flow_label_load_balance = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.FlowLabelLoadBalance()
                                    self.flow_label_load_balance.parent = self
                                    self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                                    self._children_yang_names.add("flow-label-load-balance")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ce_range",
                                                    "enable") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol, self).__setattr__(name, value)


                                class FlowLabelLoadBalance(Entity):
                                    """
                                    Enable Flow Label based load balancing
                                    
                                    .. attribute:: flow_label
                                    
                                    	Flow Label load balance type
                                    	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.FlowLabelLoadBalance>`
                                    
                                    .. attribute:: static
                                    
                                    	Static Flow Label
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.FlowLabelLoadBalance, self).__init__()

                                        self.yang_name = "flow-label-load-balance"
                                        self.yang_parent_name = "mp2mp-signaling-protocol"

                                        self.flow_label = YLeaf(YType.enumeration, "flow-label")

                                        self.static = YLeaf(YType.empty, "static")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("flow_label",
                                                        "static") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.FlowLabelLoadBalance, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.FlowLabelLoadBalance, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.flow_label.is_set or
                                            self.static.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.flow_label.yfilter != YFilter.not_set or
                                            self.static.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "flow-label-load-balance" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.flow_label.is_set or self.flow_label.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.flow_label.get_name_leafdata())
                                        if (self.static.is_set or self.static.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.static.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "flow-label" or name == "static"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "flow-label"):
                                            self.flow_label = value
                                            self.flow_label.value_namespace = name_space
                                            self.flow_label.value_namespace_prefix = name_space_prefix
                                        if(value_path == "static"):
                                            self.static = value
                                            self.static.value_namespace = name_space
                                            self.static.value_namespace_prefix = name_space_prefix


                                class Ceids(Entity):
                                    """
                                    Local Customer Edge Identifier Table
                                    
                                    .. attribute:: ceid
                                    
                                    	Local Customer Edge Identifier 
                                    	**type**\: list of    :py:class:`Ceid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids, self).__init__()

                                        self.yang_name = "ceids"
                                        self.yang_parent_name = "mp2mp-signaling-protocol"

                                        self.ceid = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids, self).__setattr__(name, value)


                                    class Ceid(Entity):
                                        """
                                        Local Customer Edge Identifier 
                                        
                                        .. attribute:: ce_id  <key>
                                        
                                        	Local Customer Edge Identifier
                                        	**type**\:  int
                                        
                                        	**range:** 1..16384
                                        
                                        .. attribute:: remote_ceid_attachment_circuits
                                        
                                        	AC And Remote Customer Edge Identifier Table
                                        	**type**\:   :py:class:`RemoteCeidAttachmentCircuits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid, self).__init__()

                                            self.yang_name = "ceid"
                                            self.yang_parent_name = "ceids"

                                            self.ce_id = YLeaf(YType.uint32, "ce-id")

                                            self.remote_ceid_attachment_circuits = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits()
                                            self.remote_ceid_attachment_circuits.parent = self
                                            self._children_name_map["remote_ceid_attachment_circuits"] = "remote-ceid-attachment-circuits"
                                            self._children_yang_names.add("remote-ceid-attachment-circuits")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("ce_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid, self).__setattr__(name, value)


                                        class RemoteCeidAttachmentCircuits(Entity):
                                            """
                                            AC And Remote Customer Edge Identifier
                                            Table
                                            
                                            .. attribute:: remote_ceid_attachment_circuit
                                            
                                            	AC And Remote Customer Edge Identifier
                                            	**type**\: list of    :py:class:`RemoteCeidAttachmentCircuit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits.RemoteCeidAttachmentCircuit>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits, self).__init__()

                                                self.yang_name = "remote-ceid-attachment-circuits"
                                                self.yang_parent_name = "ceid"

                                                self.remote_ceid_attachment_circuit = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits, self).__setattr__(name, value)


                                            class RemoteCeidAttachmentCircuit(Entity):
                                                """
                                                AC And Remote Customer Edge Identifier
                                                
                                                .. attribute:: name  <key>
                                                
                                                	The name of the Attachment Circuit
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                .. attribute:: remote_ce_id  <key>
                                                
                                                	Remote Customer Edge Identifier
                                                	**type**\:  int
                                                
                                                	**range:** 1..16384
                                                
                                                

                                                """

                                                _prefix = 'l2vpn-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits.RemoteCeidAttachmentCircuit, self).__init__()

                                                    self.yang_name = "remote-ceid-attachment-circuit"
                                                    self.yang_parent_name = "remote-ceid-attachment-circuits"

                                                    self.name = YLeaf(YType.str, "name")

                                                    self.remote_ce_id = YLeaf(YType.uint32, "remote-ce-id")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("name",
                                                                    "remote_ce_id") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits.RemoteCeidAttachmentCircuit, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits.RemoteCeidAttachmentCircuit, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.name.is_set or
                                                        self.remote_ce_id.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.name.yfilter != YFilter.not_set or
                                                        self.remote_ce_id.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "remote-ceid-attachment-circuit" + "[name='" + self.name.get() + "']" + "[remote-ce-id='" + self.remote_ce_id.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.name.get_name_leafdata())
                                                    if (self.remote_ce_id.is_set or self.remote_ce_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.remote_ce_id.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "name" or name == "remote-ce-id"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "name"):
                                                        self.name = value
                                                        self.name.value_namespace = name_space
                                                        self.name.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "remote-ce-id"):
                                                        self.remote_ce_id = value
                                                        self.remote_ce_id.value_namespace = name_space
                                                        self.remote_ce_id.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.remote_ceid_attachment_circuit:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.remote_ceid_attachment_circuit:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "remote-ceid-attachment-circuits" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "remote-ceid-attachment-circuit"):
                                                    for c in self.remote_ceid_attachment_circuit:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits.RemoteCeidAttachmentCircuit()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.remote_ceid_attachment_circuit.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "remote-ceid-attachment-circuit"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.ce_id.is_set or
                                                (self.remote_ceid_attachment_circuits is not None and self.remote_ceid_attachment_circuits.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.ce_id.yfilter != YFilter.not_set or
                                                (self.remote_ceid_attachment_circuits is not None and self.remote_ceid_attachment_circuits.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ceid" + "[ce-id='" + self.ce_id.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.ce_id.is_set or self.ce_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.ce_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "remote-ceid-attachment-circuits"):
                                                if (self.remote_ceid_attachment_circuits is None):
                                                    self.remote_ceid_attachment_circuits = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid.RemoteCeidAttachmentCircuits()
                                                    self.remote_ceid_attachment_circuits.parent = self
                                                    self._children_name_map["remote_ceid_attachment_circuits"] = "remote-ceid-attachment-circuits"
                                                return self.remote_ceid_attachment_circuits

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "remote-ceid-attachment-circuits" or name == "ce-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "ce-id"):
                                                self.ce_id = value
                                                self.ce_id.value_namespace = name_space
                                                self.ce_id.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.ceid:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.ceid:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ceids" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "ceid"):
                                            for c in self.ceid:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids.Ceid()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.ceid.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "ceid"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.ce_range.is_set or
                                        self.enable.is_set or
                                        (self.ceids is not None and self.ceids.has_data()) or
                                        (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ce_range.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        (self.ceids is not None and self.ceids.has_operation()) or
                                        (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "mp2mp-signaling-protocol" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ce_range.is_set or self.ce_range.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ce_range.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "ceids"):
                                        if (self.ceids is None):
                                            self.ceids = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.Ceids()
                                            self.ceids.parent = self
                                            self._children_name_map["ceids"] = "ceids"
                                        return self.ceids

                                    if (child_yang_name == "flow-label-load-balance"):
                                        if (self.flow_label_load_balance is None):
                                            self.flow_label_load_balance = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol.FlowLabelLoadBalance()
                                            self.flow_label_load_balance.parent = self
                                            self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                                        return self.flow_label_load_balance

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ceids" or name == "flow-label-load-balance" or name == "ce-range" or name == "enable"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ce-range"):
                                        self.ce_range = value
                                        self.ce_range.value_namespace = name_space
                                        self.ce_range.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    (self.mp2mp_route_policy is not None and self.mp2mp_route_policy.has_data()) or
                                    (self.mp2mp_route_targets is not None and self.mp2mp_route_targets.has_data()) or
                                    (self.mp2mp_signaling_protocol is not None and self.mp2mp_signaling_protocol.has_data()) or
                                    (self.route_distinguisher is not None and self.route_distinguisher.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    (self.mp2mp_route_policy is not None and self.mp2mp_route_policy.has_operation()) or
                                    (self.mp2mp_route_targets is not None and self.mp2mp_route_targets.has_operation()) or
                                    (self.mp2mp_signaling_protocol is not None and self.mp2mp_signaling_protocol.has_operation()) or
                                    (self.route_distinguisher is not None and self.route_distinguisher.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mp2mp-auto-discovery" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "mp2mp-route-policy"):
                                    if (self.mp2mp_route_policy is None):
                                        self.mp2mp_route_policy = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRoutePolicy()
                                        self.mp2mp_route_policy.parent = self
                                        self._children_name_map["mp2mp_route_policy"] = "mp2mp-route-policy"
                                    return self.mp2mp_route_policy

                                if (child_yang_name == "mp2mp-route-targets"):
                                    if (self.mp2mp_route_targets is None):
                                        self.mp2mp_route_targets = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpRouteTargets()
                                        self.mp2mp_route_targets.parent = self
                                        self._children_name_map["mp2mp_route_targets"] = "mp2mp-route-targets"
                                    return self.mp2mp_route_targets

                                if (child_yang_name == "mp2mp-signaling-protocol"):
                                    if (self.mp2mp_signaling_protocol is None):
                                        self.mp2mp_signaling_protocol = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.Mp2MpSignalingProtocol()
                                        self.mp2mp_signaling_protocol.parent = self
                                        self._children_name_map["mp2mp_signaling_protocol"] = "mp2mp-signaling-protocol"
                                    return self.mp2mp_signaling_protocol

                                if (child_yang_name == "route-distinguisher"):
                                    if (self.route_distinguisher is None):
                                        self.route_distinguisher = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery.RouteDistinguisher()
                                        self.route_distinguisher.parent = self
                                        self._children_name_map["route_distinguisher"] = "route-distinguisher"
                                    return self.route_distinguisher

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mp2mp-route-policy" or name == "mp2mp-route-targets" or name == "mp2mp-signaling-protocol" or name == "route-distinguisher" or name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.name.is_set or
                                self.mp2mp_control_word.is_set or
                                self.mp2mp_interworking.is_set or
                                self.mp2mp_shutdown.is_set or
                                self.mp2mpl2_encapsulation.is_set or
                                self.mp2mpmtu.is_set or
                                self.mp2mpvpn_id.is_set or
                                (self.mp2mp_auto_discovery is not None and self.mp2mp_auto_discovery.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.name.yfilter != YFilter.not_set or
                                self.mp2mp_control_word.yfilter != YFilter.not_set or
                                self.mp2mp_interworking.yfilter != YFilter.not_set or
                                self.mp2mp_shutdown.yfilter != YFilter.not_set or
                                self.mp2mpl2_encapsulation.yfilter != YFilter.not_set or
                                self.mp2mpmtu.yfilter != YFilter.not_set or
                                self.mp2mpvpn_id.yfilter != YFilter.not_set or
                                (self.mp2mp_auto_discovery is not None and self.mp2mp_auto_discovery.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "mp2mp-xconnect" + "[name='" + self.name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.name.get_name_leafdata())
                            if (self.mp2mp_control_word.is_set or self.mp2mp_control_word.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mp2mp_control_word.get_name_leafdata())
                            if (self.mp2mp_interworking.is_set or self.mp2mp_interworking.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mp2mp_interworking.get_name_leafdata())
                            if (self.mp2mp_shutdown.is_set or self.mp2mp_shutdown.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mp2mp_shutdown.get_name_leafdata())
                            if (self.mp2mpl2_encapsulation.is_set or self.mp2mpl2_encapsulation.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mp2mpl2_encapsulation.get_name_leafdata())
                            if (self.mp2mpmtu.is_set or self.mp2mpmtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mp2mpmtu.get_name_leafdata())
                            if (self.mp2mpvpn_id.is_set or self.mp2mpvpn_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mp2mpvpn_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "mp2mp-auto-discovery"):
                                if (self.mp2mp_auto_discovery is None):
                                    self.mp2mp_auto_discovery = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect.Mp2MpAutoDiscovery()
                                    self.mp2mp_auto_discovery.parent = self
                                    self._children_name_map["mp2mp_auto_discovery"] = "mp2mp-auto-discovery"
                                return self.mp2mp_auto_discovery

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mp2mp-auto-discovery" or name == "name" or name == "mp2mp-control-word" or name == "mp2mp-interworking" or name == "mp2mp-shutdown" or name == "mp2mpl2-encapsulation" or name == "mp2mpmtu" or name == "mp2mpvpn-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "name"):
                                self.name = value
                                self.name.value_namespace = name_space
                                self.name.value_namespace_prefix = name_space_prefix
                            if(value_path == "mp2mp-control-word"):
                                self.mp2mp_control_word = value
                                self.mp2mp_control_word.value_namespace = name_space
                                self.mp2mp_control_word.value_namespace_prefix = name_space_prefix
                            if(value_path == "mp2mp-interworking"):
                                self.mp2mp_interworking = value
                                self.mp2mp_interworking.value_namespace = name_space
                                self.mp2mp_interworking.value_namespace_prefix = name_space_prefix
                            if(value_path == "mp2mp-shutdown"):
                                self.mp2mp_shutdown = value
                                self.mp2mp_shutdown.value_namespace = name_space
                                self.mp2mp_shutdown.value_namespace_prefix = name_space_prefix
                            if(value_path == "mp2mpl2-encapsulation"):
                                self.mp2mpl2_encapsulation = value
                                self.mp2mpl2_encapsulation.value_namespace = name_space
                                self.mp2mpl2_encapsulation.value_namespace_prefix = name_space_prefix
                            if(value_path == "mp2mpmtu"):
                                self.mp2mpmtu = value
                                self.mp2mpmtu.value_namespace = name_space
                                self.mp2mpmtu.value_namespace_prefix = name_space_prefix
                            if(value_path == "mp2mpvpn-id"):
                                self.mp2mpvpn_id = value
                                self.mp2mpvpn_id.value_namespace = name_space
                                self.mp2mpvpn_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.mp2mp_xconnect:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.mp2mp_xconnect:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "mp2mp-xconnects" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "mp2mp-xconnect"):
                            for c in self.mp2mp_xconnect:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects.Mp2MpXconnect()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.mp2mp_xconnect.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "mp2mp-xconnect"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.mp2mp_xconnects is not None and self.mp2mp_xconnects.has_data()) or
                        (self.p2p_xconnects is not None and self.p2p_xconnects.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.mp2mp_xconnects is not None and self.mp2mp_xconnects.has_operation()) or
                        (self.p2p_xconnects is not None and self.p2p_xconnects.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "xconnect-group" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/xconnect-groups/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "mp2mp-xconnects"):
                        if (self.mp2mp_xconnects is None):
                            self.mp2mp_xconnects = L2Vpn.Database.XconnectGroups.XconnectGroup.Mp2MpXconnects()
                            self.mp2mp_xconnects.parent = self
                            self._children_name_map["mp2mp_xconnects"] = "mp2mp-xconnects"
                        return self.mp2mp_xconnects

                    if (child_yang_name == "p2p-xconnects"):
                        if (self.p2p_xconnects is None):
                            self.p2p_xconnects = L2Vpn.Database.XconnectGroups.XconnectGroup.P2PXconnects()
                            self.p2p_xconnects.parent = self
                            self._children_name_map["p2p_xconnects"] = "p2p-xconnects"
                        return self.p2p_xconnects

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "mp2mp-xconnects" or name == "p2p-xconnects" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.xconnect_group:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.xconnect_group:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "xconnect-groups" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "xconnect-group"):
                    for c in self.xconnect_group:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = L2Vpn.Database.XconnectGroups.XconnectGroup()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.xconnect_group.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "xconnect-group"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class BridgeDomainGroups(Entity):
            """
            List of bridge  groups
            
            .. attribute:: bridge_domain_group
            
            	Bridge group
            	**type**\: list of    :py:class:`BridgeDomainGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Database.BridgeDomainGroups, self).__init__()

                self.yang_name = "bridge-domain-groups"
                self.yang_parent_name = "database"

                self.bridge_domain_group = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.Database.BridgeDomainGroups, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.Database.BridgeDomainGroups, self).__setattr__(name, value)


            class BridgeDomainGroup(Entity):
                """
                Bridge group
                
                .. attribute:: name  <key>
                
                	Name of the Bridge group
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: bridge_domains
                
                	List of Bridge Domain
                	**type**\:   :py:class:`BridgeDomains <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup, self).__init__()

                    self.yang_name = "bridge-domain-group"
                    self.yang_parent_name = "bridge-domain-groups"

                    self.name = YLeaf(YType.str, "name")

                    self.bridge_domains = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains()
                    self.bridge_domains.parent = self
                    self._children_name_map["bridge_domains"] = "bridge-domains"
                    self._children_yang_names.add("bridge-domains")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup, self).__setattr__(name, value)


                class BridgeDomains(Entity):
                    """
                    List of Bridge Domain
                    
                    .. attribute:: bridge_domain
                    
                    	bridge domain
                    	**type**\: list of    :py:class:`BridgeDomain <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains, self).__init__()

                        self.yang_name = "bridge-domains"
                        self.yang_parent_name = "bridge-domain-group"

                        self.bridge_domain = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains, self).__setattr__(name, value)


                    class BridgeDomain(Entity):
                        """
                        bridge domain
                        
                        .. attribute:: name  <key>
                        
                        	Name of the bridge domain
                        	**type**\:  str
                        
                        	**length:** 1..27
                        
                        .. attribute:: access_vfis
                        
                        	Specify the access virtual forwarding interface name
                        	**type**\:   :py:class:`AccessVfis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis>`
                        
                        .. attribute:: bd_attachment_circuits
                        
                        	Attachment Circuit table
                        	**type**\:   :py:class:`BdAttachmentCircuits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits>`
                        
                        .. attribute:: bd_pseudowire_evpns
                        
                        	List of EVPN pseudowires
                        	**type**\:   :py:class:`BdPseudowireEvpns <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns>`
                        
                        .. attribute:: bd_pseudowires
                        
                        	List of pseudowires
                        	**type**\:   :py:class:`BdPseudowires <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires>`
                        
                        .. attribute:: bd_storm_controls
                        
                        	Storm Control
                        	**type**\:   :py:class:`BdStormControls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls>`
                        
                        .. attribute:: bridge_description
                        
                        	Bridge\-domain description Name
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: bridge_domain_evis
                        
                        	Bridge Domain EVI Table
                        	**type**\:   :py:class:`BridgeDomainEvis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis>`
                        
                        .. attribute:: bridge_domain_mac
                        
                        	MAC configuration commands
                        	**type**\:   :py:class:`BridgeDomainMac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac>`
                        
                        .. attribute:: bridge_domain_mtu
                        
                        	Maximum transmission unit for this Bridge Domain
                        	**type**\:  int
                        
                        	**range:** 46..65535
                        
                        	**units**\: byte
                        
                        .. attribute:: bridge_domain_pbb
                        
                        	Bridge Domain PBB
                        	**type**\:   :py:class:`BridgeDomainPbb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb>`
                        
                        .. attribute:: coupled_mode
                        
                        	Coupled\-mode configuration
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: dai
                        
                        	Dynamic ARP Inspection
                        	**type**\:   :py:class:`Dai <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai>`
                        
                        .. attribute:: dhcp
                        
                        	DHCPv4 Snooping profile name
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: flooding
                        
                        	Disable flooding
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: flooding_unknown_unicast
                        
                        	Disable Unknown Unicast flooding
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: igmp_snooping
                        
                        	Attach IGMP Snooping Profile Name
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: igmp_snooping_disable
                        
                        	Disable IGMP Snooping
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: ip_source_guard
                        
                        	IP Source Guard
                        	**type**\:   :py:class:`IpSourceGuard <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.IpSourceGuard>`
                        
                        .. attribute:: member_vnis
                        
                        	Bridge Domain VxLAN Network Identifier Table
                        	**type**\:   :py:class:`MemberVnis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis>`
                        
                        .. attribute:: mld_snooping
                        
                        	Attach MLD Snooping Profile Name
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: nv_satellite
                        
                        	nV Satellite
                        	**type**\:   :py:class:`NvSatellite <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.NvSatellite>`
                        
                        .. attribute:: routed_interfaces
                        
                        	Bridge Domain Routed Interface Table
                        	**type**\:   :py:class:`RoutedInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces>`
                        
                        .. attribute:: shutdown
                        
                        	shutdown the Bridge Domain
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: transport_mode
                        
                        	Bridge Domain Transport mode
                        	**type**\:   :py:class:`BridgeDomainTransportMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BridgeDomainTransportMode>`
                        
                        .. attribute:: vfis
                        
                        	Specify the virtual forwarding interface name
                        	**type**\:   :py:class:`Vfis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain, self).__init__()

                            self.yang_name = "bridge-domain"
                            self.yang_parent_name = "bridge-domains"

                            self.name = YLeaf(YType.str, "name")

                            self.bridge_description = YLeaf(YType.str, "bridge-description")

                            self.bridge_domain_mtu = YLeaf(YType.uint32, "bridge-domain-mtu")

                            self.coupled_mode = YLeaf(YType.empty, "coupled-mode")

                            self.dhcp = YLeaf(YType.str, "dhcp")

                            self.flooding = YLeaf(YType.empty, "flooding")

                            self.flooding_unknown_unicast = YLeaf(YType.empty, "flooding-unknown-unicast")

                            self.igmp_snooping = YLeaf(YType.str, "igmp-snooping")

                            self.igmp_snooping_disable = YLeaf(YType.empty, "igmp-snooping-disable")

                            self.mld_snooping = YLeaf(YType.str, "mld-snooping")

                            self.shutdown = YLeaf(YType.empty, "shutdown")

                            self.transport_mode = YLeaf(YType.enumeration, "transport-mode")

                            self.access_vfis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis()
                            self.access_vfis.parent = self
                            self._children_name_map["access_vfis"] = "access-vfis"
                            self._children_yang_names.add("access-vfis")

                            self.bd_attachment_circuits = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits()
                            self.bd_attachment_circuits.parent = self
                            self._children_name_map["bd_attachment_circuits"] = "bd-attachment-circuits"
                            self._children_yang_names.add("bd-attachment-circuits")

                            self.bd_pseudowire_evpns = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns()
                            self.bd_pseudowire_evpns.parent = self
                            self._children_name_map["bd_pseudowire_evpns"] = "bd-pseudowire-evpns"
                            self._children_yang_names.add("bd-pseudowire-evpns")

                            self.bd_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires()
                            self.bd_pseudowires.parent = self
                            self._children_name_map["bd_pseudowires"] = "bd-pseudowires"
                            self._children_yang_names.add("bd-pseudowires")

                            self.bd_storm_controls = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls()
                            self.bd_storm_controls.parent = self
                            self._children_name_map["bd_storm_controls"] = "bd-storm-controls"
                            self._children_yang_names.add("bd-storm-controls")

                            self.bridge_domain_evis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis()
                            self.bridge_domain_evis.parent = self
                            self._children_name_map["bridge_domain_evis"] = "bridge-domain-evis"
                            self._children_yang_names.add("bridge-domain-evis")

                            self.bridge_domain_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac()
                            self.bridge_domain_mac.parent = self
                            self._children_name_map["bridge_domain_mac"] = "bridge-domain-mac"
                            self._children_yang_names.add("bridge-domain-mac")

                            self.bridge_domain_pbb = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb()
                            self.bridge_domain_pbb.parent = self
                            self._children_name_map["bridge_domain_pbb"] = "bridge-domain-pbb"
                            self._children_yang_names.add("bridge-domain-pbb")

                            self.dai = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai()
                            self.dai.parent = self
                            self._children_name_map["dai"] = "dai"
                            self._children_yang_names.add("dai")

                            self.ip_source_guard = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.IpSourceGuard()
                            self.ip_source_guard.parent = self
                            self._children_name_map["ip_source_guard"] = "ip-source-guard"
                            self._children_yang_names.add("ip-source-guard")

                            self.member_vnis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis()
                            self.member_vnis.parent = self
                            self._children_name_map["member_vnis"] = "member-vnis"
                            self._children_yang_names.add("member-vnis")

                            self.nv_satellite = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.NvSatellite()
                            self.nv_satellite.parent = self
                            self._children_name_map["nv_satellite"] = "nv-satellite"
                            self._children_yang_names.add("nv-satellite")

                            self.routed_interfaces = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces()
                            self.routed_interfaces.parent = self
                            self._children_name_map["routed_interfaces"] = "routed-interfaces"
                            self._children_yang_names.add("routed-interfaces")

                            self.vfis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis()
                            self.vfis.parent = self
                            self._children_name_map["vfis"] = "vfis"
                            self._children_yang_names.add("vfis")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("name",
                                            "bridge_description",
                                            "bridge_domain_mtu",
                                            "coupled_mode",
                                            "dhcp",
                                            "flooding",
                                            "flooding_unknown_unicast",
                                            "igmp_snooping",
                                            "igmp_snooping_disable",
                                            "mld_snooping",
                                            "shutdown",
                                            "transport_mode") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain, self).__setattr__(name, value)


                        class BdStormControls(Entity):
                            """
                            Storm Control
                            
                            .. attribute:: bd_storm_control
                            
                            	Storm Control Type
                            	**type**\: list of    :py:class:`BdStormControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls, self).__init__()

                                self.yang_name = "bd-storm-controls"
                                self.yang_parent_name = "bridge-domain"

                                self.bd_storm_control = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls, self).__setattr__(name, value)


                            class BdStormControl(Entity):
                                """
                                Storm Control Type
                                
                                .. attribute:: sctype  <key>
                                
                                	Storm Control Type
                                	**type**\:   :py:class:`StormControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.StormControl>`
                                
                                .. attribute:: storm_control_unit
                                
                                	Specify units for Storm Control Configuration
                                	**type**\:   :py:class:`StormControlUnit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl.StormControlUnit>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl, self).__init__()

                                    self.yang_name = "bd-storm-control"
                                    self.yang_parent_name = "bd-storm-controls"

                                    self.sctype = YLeaf(YType.enumeration, "sctype")

                                    self.storm_control_unit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl.StormControlUnit()
                                    self.storm_control_unit.parent = self
                                    self._children_name_map["storm_control_unit"] = "storm-control-unit"
                                    self._children_yang_names.add("storm-control-unit")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("sctype") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl, self).__setattr__(name, value)


                                class StormControlUnit(Entity):
                                    """
                                    Specify units for Storm Control Configuration
                                    
                                    .. attribute:: kbits_per_sec
                                    
                                    	Kilobits Per Second, PktsPerSec and KbitsPerSec cannot be configured together
                                    	**type**\:  int
                                    
                                    	**range:** 64..1280000
                                    
                                    	**units**\: kbit/s
                                    
                                    .. attribute:: pkts_per_sec
                                    
                                    	Packets Per Second, PktsPerSec and KbitsPerSec cannot be configured together
                                    	**type**\:  int
                                    
                                    	**range:** 1..160000
                                    
                                    	**units**\: packet/s
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl.StormControlUnit, self).__init__()

                                        self.yang_name = "storm-control-unit"
                                        self.yang_parent_name = "bd-storm-control"

                                        self.kbits_per_sec = YLeaf(YType.uint32, "kbits-per-sec")

                                        self.pkts_per_sec = YLeaf(YType.uint32, "pkts-per-sec")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("kbits_per_sec",
                                                        "pkts_per_sec") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl.StormControlUnit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl.StormControlUnit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.kbits_per_sec.is_set or
                                            self.pkts_per_sec.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.kbits_per_sec.yfilter != YFilter.not_set or
                                            self.pkts_per_sec.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "storm-control-unit" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.kbits_per_sec.is_set or self.kbits_per_sec.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.kbits_per_sec.get_name_leafdata())
                                        if (self.pkts_per_sec.is_set or self.pkts_per_sec.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.pkts_per_sec.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "kbits-per-sec" or name == "pkts-per-sec"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "kbits-per-sec"):
                                            self.kbits_per_sec = value
                                            self.kbits_per_sec.value_namespace = name_space
                                            self.kbits_per_sec.value_namespace_prefix = name_space_prefix
                                        if(value_path == "pkts-per-sec"):
                                            self.pkts_per_sec = value
                                            self.pkts_per_sec.value_namespace = name_space
                                            self.pkts_per_sec.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.sctype.is_set or
                                        (self.storm_control_unit is not None and self.storm_control_unit.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.sctype.yfilter != YFilter.not_set or
                                        (self.storm_control_unit is not None and self.storm_control_unit.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bd-storm-control" + "[sctype='" + self.sctype.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.sctype.is_set or self.sctype.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sctype.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "storm-control-unit"):
                                        if (self.storm_control_unit is None):
                                            self.storm_control_unit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl.StormControlUnit()
                                            self.storm_control_unit.parent = self
                                            self._children_name_map["storm_control_unit"] = "storm-control-unit"
                                        return self.storm_control_unit

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "storm-control-unit" or name == "sctype"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "sctype"):
                                        self.sctype = value
                                        self.sctype.value_namespace = name_space
                                        self.sctype.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.bd_storm_control:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.bd_storm_control:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bd-storm-controls" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bd-storm-control"):
                                    for c in self.bd_storm_control:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls.BdStormControl()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.bd_storm_control.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bd-storm-control"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MemberVnis(Entity):
                            """
                            Bridge Domain VxLAN Network Identifier
                            Table
                            
                            .. attribute:: member_vni
                            
                            	Bridge Domain Member VxLAN Network Identifier 
                            	**type**\: list of    :py:class:`MemberVni <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis, self).__init__()

                                self.yang_name = "member-vnis"
                                self.yang_parent_name = "bridge-domain"

                                self.member_vni = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis, self).__setattr__(name, value)


                            class MemberVni(Entity):
                                """
                                Bridge Domain Member VxLAN Network
                                Identifier 
                                
                                .. attribute:: vni  <key>
                                
                                	VxLAN Network Identifier number
                                	**type**\:  int
                                
                                	**range:** 1..16777215
                                
                                .. attribute:: member_vni_static_mac_addresses
                                
                                	Static Mac Address Table
                                	**type**\:   :py:class:`MemberVniStaticMacAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni, self).__init__()

                                    self.yang_name = "member-vni"
                                    self.yang_parent_name = "member-vnis"

                                    self.vni = YLeaf(YType.uint32, "vni")

                                    self.member_vni_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses()
                                    self.member_vni_static_mac_addresses.parent = self
                                    self._children_name_map["member_vni_static_mac_addresses"] = "member-vni-static-mac-addresses"
                                    self._children_yang_names.add("member-vni-static-mac-addresses")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("vni") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni, self).__setattr__(name, value)


                                class MemberVniStaticMacAddresses(Entity):
                                    """
                                    Static Mac Address Table
                                    
                                    .. attribute:: member_vni_static_mac_address
                                    
                                    	Static Mac Address Configuration
                                    	**type**\: list of    :py:class:`MemberVniStaticMacAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses.MemberVniStaticMacAddress>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses, self).__init__()

                                        self.yang_name = "member-vni-static-mac-addresses"
                                        self.yang_parent_name = "member-vni"

                                        self.member_vni_static_mac_address = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses, self).__setattr__(name, value)


                                    class MemberVniStaticMacAddress(Entity):
                                        """
                                        Static Mac Address Configuration
                                        
                                        .. attribute:: mac_address  <key>
                                        
                                        	Static MAC address
                                        	**type**\:  str
                                        
                                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                        
                                        .. attribute:: next_hop_ip
                                        
                                        	Enable Static Mac Address Configuration
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses.MemberVniStaticMacAddress, self).__init__()

                                            self.yang_name = "member-vni-static-mac-address"
                                            self.yang_parent_name = "member-vni-static-mac-addresses"

                                            self.mac_address = YLeaf(YType.str, "mac-address")

                                            self.next_hop_ip = YLeaf(YType.str, "next-hop-ip")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("mac_address",
                                                            "next_hop_ip") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses.MemberVniStaticMacAddress, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses.MemberVniStaticMacAddress, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.mac_address.is_set or
                                                self.next_hop_ip.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.mac_address.yfilter != YFilter.not_set or
                                                self.next_hop_ip.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "member-vni-static-mac-address" + "[mac-address='" + self.mac_address.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.mac_address.get_name_leafdata())
                                            if (self.next_hop_ip.is_set or self.next_hop_ip.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.next_hop_ip.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "mac-address" or name == "next-hop-ip"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "mac-address"):
                                                self.mac_address = value
                                                self.mac_address.value_namespace = name_space
                                                self.mac_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "next-hop-ip"):
                                                self.next_hop_ip = value
                                                self.next_hop_ip.value_namespace = name_space
                                                self.next_hop_ip.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.member_vni_static_mac_address:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.member_vni_static_mac_address:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "member-vni-static-mac-addresses" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "member-vni-static-mac-address"):
                                            for c in self.member_vni_static_mac_address:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses.MemberVniStaticMacAddress()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.member_vni_static_mac_address.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "member-vni-static-mac-address"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.vni.is_set or
                                        (self.member_vni_static_mac_addresses is not None and self.member_vni_static_mac_addresses.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.vni.yfilter != YFilter.not_set or
                                        (self.member_vni_static_mac_addresses is not None and self.member_vni_static_mac_addresses.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "member-vni" + "[vni='" + self.vni.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.vni.is_set or self.vni.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.vni.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "member-vni-static-mac-addresses"):
                                        if (self.member_vni_static_mac_addresses is None):
                                            self.member_vni_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni.MemberVniStaticMacAddresses()
                                            self.member_vni_static_mac_addresses.parent = self
                                            self._children_name_map["member_vni_static_mac_addresses"] = "member-vni-static-mac-addresses"
                                        return self.member_vni_static_mac_addresses

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "member-vni-static-mac-addresses" or name == "vni"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "vni"):
                                        self.vni = value
                                        self.vni.value_namespace = name_space
                                        self.vni.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.member_vni:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.member_vni:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "member-vnis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "member-vni"):
                                    for c in self.member_vni:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis.MemberVni()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.member_vni.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "member-vni"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class BridgeDomainMac(Entity):
                            """
                            MAC configuration commands
                            
                            .. attribute:: bd_mac_aging
                            
                            	MAC\-Aging configuration commands
                            	**type**\:   :py:class:`BdMacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacAging>`
                            
                            .. attribute:: bd_mac_filters
                            
                            	Filter Mac Address
                            	**type**\:   :py:class:`BdMacFilters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters>`
                            
                            .. attribute:: bd_mac_learn
                            
                            	Mac Learning Type
                            	**type**\:   :py:class:`BdmacLearn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BdmacLearn>`
                            
                            .. attribute:: bd_mac_limit
                            
                            	MAC\-Limit configuration commands
                            	**type**\:   :py:class:`BdMacLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacLimit>`
                            
                            .. attribute:: bd_mac_port_down_flush
                            
                            	Disable MAC Flush when Port goes Down
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: bd_mac_withdraw
                            
                            	Disable Mac Withdraw
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: bd_mac_withdraw_access_pw_disable
                            
                            	MAC withdraw on Access PW
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: bd_mac_withdraw_behavior
                            
                            	MAC withdraw sent on bridge port down
                            	**type**\:   :py:class:`MacWithdrawBehavior <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacWithdrawBehavior>`
                            
                            .. attribute:: bd_mac_withdraw_relay
                            
                            	Mac withdraw sent from access PW to access PW
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: mac_secure
                            
                            	MAC Secure
                            	**type**\:   :py:class:`MacSecure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.MacSecure>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac, self).__init__()

                                self.yang_name = "bridge-domain-mac"
                                self.yang_parent_name = "bridge-domain"

                                self.bd_mac_learn = YLeaf(YType.enumeration, "bd-mac-learn")

                                self.bd_mac_port_down_flush = YLeaf(YType.empty, "bd-mac-port-down-flush")

                                self.bd_mac_withdraw = YLeaf(YType.empty, "bd-mac-withdraw")

                                self.bd_mac_withdraw_access_pw_disable = YLeaf(YType.empty, "bd-mac-withdraw-access-pw-disable")

                                self.bd_mac_withdraw_behavior = YLeaf(YType.enumeration, "bd-mac-withdraw-behavior")

                                self.bd_mac_withdraw_relay = YLeaf(YType.empty, "bd-mac-withdraw-relay")

                                self.bd_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacAging()
                                self.bd_mac_aging.parent = self
                                self._children_name_map["bd_mac_aging"] = "bd-mac-aging"
                                self._children_yang_names.add("bd-mac-aging")

                                self.bd_mac_filters = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters()
                                self.bd_mac_filters.parent = self
                                self._children_name_map["bd_mac_filters"] = "bd-mac-filters"
                                self._children_yang_names.add("bd-mac-filters")

                                self.bd_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacLimit()
                                self.bd_mac_limit.parent = self
                                self._children_name_map["bd_mac_limit"] = "bd-mac-limit"
                                self._children_yang_names.add("bd-mac-limit")

                                self.mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.MacSecure()
                                self.mac_secure.parent = self
                                self._children_name_map["mac_secure"] = "mac-secure"
                                self._children_yang_names.add("mac-secure")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bd_mac_learn",
                                                "bd_mac_port_down_flush",
                                                "bd_mac_withdraw",
                                                "bd_mac_withdraw_access_pw_disable",
                                                "bd_mac_withdraw_behavior",
                                                "bd_mac_withdraw_relay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac, self).__setattr__(name, value)


                            class BdMacLimit(Entity):
                                """
                                MAC\-Limit configuration commands
                                
                                .. attribute:: bd_mac_limit_action
                                
                                	MAC address limit enforcement action
                                	**type**\:   :py:class:`MacLimitAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLimitAction>`
                                
                                .. attribute:: bd_mac_limit_max
                                
                                	Number of MAC addresses after which MAC limit action is taken
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: bd_mac_limit_notif
                                
                                	Mac Address Limit Notification
                                	**type**\:   :py:class:`MacNotification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacNotification>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacLimit, self).__init__()

                                    self.yang_name = "bd-mac-limit"
                                    self.yang_parent_name = "bridge-domain-mac"

                                    self.bd_mac_limit_action = YLeaf(YType.enumeration, "bd-mac-limit-action")

                                    self.bd_mac_limit_max = YLeaf(YType.uint32, "bd-mac-limit-max")

                                    self.bd_mac_limit_notif = YLeaf(YType.enumeration, "bd-mac-limit-notif")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("bd_mac_limit_action",
                                                    "bd_mac_limit_max",
                                                    "bd_mac_limit_notif") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacLimit, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacLimit, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.bd_mac_limit_action.is_set or
                                        self.bd_mac_limit_max.is_set or
                                        self.bd_mac_limit_notif.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.bd_mac_limit_action.yfilter != YFilter.not_set or
                                        self.bd_mac_limit_max.yfilter != YFilter.not_set or
                                        self.bd_mac_limit_notif.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bd-mac-limit" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.bd_mac_limit_action.is_set or self.bd_mac_limit_action.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bd_mac_limit_action.get_name_leafdata())
                                    if (self.bd_mac_limit_max.is_set or self.bd_mac_limit_max.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bd_mac_limit_max.get_name_leafdata())
                                    if (self.bd_mac_limit_notif.is_set or self.bd_mac_limit_notif.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bd_mac_limit_notif.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bd-mac-limit-action" or name == "bd-mac-limit-max" or name == "bd-mac-limit-notif"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "bd-mac-limit-action"):
                                        self.bd_mac_limit_action = value
                                        self.bd_mac_limit_action.value_namespace = name_space
                                        self.bd_mac_limit_action.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bd-mac-limit-max"):
                                        self.bd_mac_limit_max = value
                                        self.bd_mac_limit_max.value_namespace = name_space
                                        self.bd_mac_limit_max.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bd-mac-limit-notif"):
                                        self.bd_mac_limit_notif = value
                                        self.bd_mac_limit_notif.value_namespace = name_space
                                        self.bd_mac_limit_notif.value_namespace_prefix = name_space_prefix


                            class BdMacFilters(Entity):
                                """
                                Filter Mac Address
                                
                                .. attribute:: bd_mac_filter
                                
                                	Static MAC address
                                	**type**\: list of    :py:class:`BdMacFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters.BdMacFilter>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters, self).__init__()

                                    self.yang_name = "bd-mac-filters"
                                    self.yang_parent_name = "bridge-domain-mac"

                                    self.bd_mac_filter = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters, self).__setattr__(name, value)


                                class BdMacFilter(Entity):
                                    """
                                    Static MAC address
                                    
                                    .. attribute:: address  <key>
                                    
                                    	Static MAC address
                                    	**type**\:  str
                                    
                                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                    
                                    .. attribute:: drop
                                    
                                    	MAC address for filtering
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters.BdMacFilter, self).__init__()

                                        self.yang_name = "bd-mac-filter"
                                        self.yang_parent_name = "bd-mac-filters"

                                        self.address = YLeaf(YType.str, "address")

                                        self.drop = YLeaf(YType.empty, "drop")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "drop") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters.BdMacFilter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters.BdMacFilter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.drop.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.drop.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bd-mac-filter" + "[address='" + self.address.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.drop.is_set or self.drop.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.drop.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "drop"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "drop"):
                                            self.drop = value
                                            self.drop.value_namespace = name_space
                                            self.drop.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.bd_mac_filter:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.bd_mac_filter:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bd-mac-filters" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "bd-mac-filter"):
                                        for c in self.bd_mac_filter:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters.BdMacFilter()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.bd_mac_filter.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bd-mac-filter"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class MacSecure(Entity):
                                """
                                MAC Secure
                                
                                .. attribute:: action
                                
                                	MAC secure enforcement action
                                	**type**\:   :py:class:`MacSecureAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacSecureAction>`
                                
                                .. attribute:: enable
                                
                                	Enable MAC Secure
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: logging
                                
                                	MAC Secure Logging
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.MacSecure, self).__init__()

                                    self.yang_name = "mac-secure"
                                    self.yang_parent_name = "bridge-domain-mac"

                                    self.action = YLeaf(YType.enumeration, "action")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.logging = YLeaf(YType.empty, "logging")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("action",
                                                    "enable",
                                                    "logging") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.MacSecure, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.MacSecure, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.action.is_set or
                                        self.enable.is_set or
                                        self.logging.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.action.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.logging.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "mac-secure" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.action.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.logging.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "action" or name == "enable" or name == "logging"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "action"):
                                        self.action = value
                                        self.action.value_namespace = name_space
                                        self.action.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "logging"):
                                        self.logging = value
                                        self.logging.value_namespace = name_space
                                        self.logging.value_namespace_prefix = name_space_prefix


                            class BdMacAging(Entity):
                                """
                                MAC\-Aging configuration commands
                                
                                .. attribute:: bd_mac_aging_time
                                
                                	Mac Aging Time
                                	**type**\:  int
                                
                                	**range:** 300..30000
                                
                                .. attribute:: bd_mac_aging_type
                                
                                	MAC address aging type
                                	**type**\:   :py:class:`MacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacAging>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacAging, self).__init__()

                                    self.yang_name = "bd-mac-aging"
                                    self.yang_parent_name = "bridge-domain-mac"

                                    self.bd_mac_aging_time = YLeaf(YType.uint32, "bd-mac-aging-time")

                                    self.bd_mac_aging_type = YLeaf(YType.enumeration, "bd-mac-aging-type")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("bd_mac_aging_time",
                                                    "bd_mac_aging_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacAging, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacAging, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.bd_mac_aging_time.is_set or
                                        self.bd_mac_aging_type.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.bd_mac_aging_time.yfilter != YFilter.not_set or
                                        self.bd_mac_aging_type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bd-mac-aging" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.bd_mac_aging_time.is_set or self.bd_mac_aging_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bd_mac_aging_time.get_name_leafdata())
                                    if (self.bd_mac_aging_type.is_set or self.bd_mac_aging_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bd_mac_aging_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bd-mac-aging-time" or name == "bd-mac-aging-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "bd-mac-aging-time"):
                                        self.bd_mac_aging_time = value
                                        self.bd_mac_aging_time.value_namespace = name_space
                                        self.bd_mac_aging_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bd-mac-aging-type"):
                                        self.bd_mac_aging_type = value
                                        self.bd_mac_aging_type.value_namespace = name_space
                                        self.bd_mac_aging_type.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.bd_mac_learn.is_set or
                                    self.bd_mac_port_down_flush.is_set or
                                    self.bd_mac_withdraw.is_set or
                                    self.bd_mac_withdraw_access_pw_disable.is_set or
                                    self.bd_mac_withdraw_behavior.is_set or
                                    self.bd_mac_withdraw_relay.is_set or
                                    (self.bd_mac_aging is not None and self.bd_mac_aging.has_data()) or
                                    (self.bd_mac_filters is not None and self.bd_mac_filters.has_data()) or
                                    (self.bd_mac_limit is not None and self.bd_mac_limit.has_data()) or
                                    (self.mac_secure is not None and self.mac_secure.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bd_mac_learn.yfilter != YFilter.not_set or
                                    self.bd_mac_port_down_flush.yfilter != YFilter.not_set or
                                    self.bd_mac_withdraw.yfilter != YFilter.not_set or
                                    self.bd_mac_withdraw_access_pw_disable.yfilter != YFilter.not_set or
                                    self.bd_mac_withdraw_behavior.yfilter != YFilter.not_set or
                                    self.bd_mac_withdraw_relay.yfilter != YFilter.not_set or
                                    (self.bd_mac_aging is not None and self.bd_mac_aging.has_operation()) or
                                    (self.bd_mac_filters is not None and self.bd_mac_filters.has_operation()) or
                                    (self.bd_mac_limit is not None and self.bd_mac_limit.has_operation()) or
                                    (self.mac_secure is not None and self.mac_secure.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bridge-domain-mac" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bd_mac_learn.is_set or self.bd_mac_learn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_mac_learn.get_name_leafdata())
                                if (self.bd_mac_port_down_flush.is_set or self.bd_mac_port_down_flush.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_mac_port_down_flush.get_name_leafdata())
                                if (self.bd_mac_withdraw.is_set or self.bd_mac_withdraw.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_mac_withdraw.get_name_leafdata())
                                if (self.bd_mac_withdraw_access_pw_disable.is_set or self.bd_mac_withdraw_access_pw_disable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_mac_withdraw_access_pw_disable.get_name_leafdata())
                                if (self.bd_mac_withdraw_behavior.is_set or self.bd_mac_withdraw_behavior.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_mac_withdraw_behavior.get_name_leafdata())
                                if (self.bd_mac_withdraw_relay.is_set or self.bd_mac_withdraw_relay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_mac_withdraw_relay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bd-mac-aging"):
                                    if (self.bd_mac_aging is None):
                                        self.bd_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacAging()
                                        self.bd_mac_aging.parent = self
                                        self._children_name_map["bd_mac_aging"] = "bd-mac-aging"
                                    return self.bd_mac_aging

                                if (child_yang_name == "bd-mac-filters"):
                                    if (self.bd_mac_filters is None):
                                        self.bd_mac_filters = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacFilters()
                                        self.bd_mac_filters.parent = self
                                        self._children_name_map["bd_mac_filters"] = "bd-mac-filters"
                                    return self.bd_mac_filters

                                if (child_yang_name == "bd-mac-limit"):
                                    if (self.bd_mac_limit is None):
                                        self.bd_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.BdMacLimit()
                                        self.bd_mac_limit.parent = self
                                        self._children_name_map["bd_mac_limit"] = "bd-mac-limit"
                                    return self.bd_mac_limit

                                if (child_yang_name == "mac-secure"):
                                    if (self.mac_secure is None):
                                        self.mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac.MacSecure()
                                        self.mac_secure.parent = self
                                        self._children_name_map["mac_secure"] = "mac-secure"
                                    return self.mac_secure

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bd-mac-aging" or name == "bd-mac-filters" or name == "bd-mac-limit" or name == "mac-secure" or name == "bd-mac-learn" or name == "bd-mac-port-down-flush" or name == "bd-mac-withdraw" or name == "bd-mac-withdraw-access-pw-disable" or name == "bd-mac-withdraw-behavior" or name == "bd-mac-withdraw-relay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bd-mac-learn"):
                                    self.bd_mac_learn = value
                                    self.bd_mac_learn.value_namespace = name_space
                                    self.bd_mac_learn.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-mac-port-down-flush"):
                                    self.bd_mac_port_down_flush = value
                                    self.bd_mac_port_down_flush.value_namespace = name_space
                                    self.bd_mac_port_down_flush.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-mac-withdraw"):
                                    self.bd_mac_withdraw = value
                                    self.bd_mac_withdraw.value_namespace = name_space
                                    self.bd_mac_withdraw.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-mac-withdraw-access-pw-disable"):
                                    self.bd_mac_withdraw_access_pw_disable = value
                                    self.bd_mac_withdraw_access_pw_disable.value_namespace = name_space
                                    self.bd_mac_withdraw_access_pw_disable.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-mac-withdraw-behavior"):
                                    self.bd_mac_withdraw_behavior = value
                                    self.bd_mac_withdraw_behavior.value_namespace = name_space
                                    self.bd_mac_withdraw_behavior.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-mac-withdraw-relay"):
                                    self.bd_mac_withdraw_relay = value
                                    self.bd_mac_withdraw_relay.value_namespace = name_space
                                    self.bd_mac_withdraw_relay.value_namespace_prefix = name_space_prefix


                        class NvSatellite(Entity):
                            """
                            nV Satellite
                            
                            .. attribute:: enable
                            
                            	Enable nV Satellite Settings
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: offload_ipv4_multicast_enable
                            
                            	Enable IPv4 Multicast Offload to Satellite Nodes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.NvSatellite, self).__init__()

                                self.yang_name = "nv-satellite"
                                self.yang_parent_name = "bridge-domain"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.offload_ipv4_multicast_enable = YLeaf(YType.empty, "offload-ipv4-multicast-enable")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "offload_ipv4_multicast_enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.NvSatellite, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.NvSatellite, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.offload_ipv4_multicast_enable.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.offload_ipv4_multicast_enable.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "nv-satellite" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.offload_ipv4_multicast_enable.is_set or self.offload_ipv4_multicast_enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.offload_ipv4_multicast_enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "offload-ipv4-multicast-enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "offload-ipv4-multicast-enable"):
                                    self.offload_ipv4_multicast_enable = value
                                    self.offload_ipv4_multicast_enable.value_namespace = name_space
                                    self.offload_ipv4_multicast_enable.value_namespace_prefix = name_space_prefix


                        class BridgeDomainPbb(Entity):
                            """
                            Bridge Domain PBB
                            
                            .. attribute:: pbb_core
                            
                            	PBB Core
                            	**type**\:   :py:class:`PbbCore <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore>`
                            
                            .. attribute:: pbb_edges
                            
                            	PBB Edge
                            	**type**\:   :py:class:`PbbEdges <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb, self).__init__()

                                self.yang_name = "bridge-domain-pbb"
                                self.yang_parent_name = "bridge-domain"

                                self.pbb_core = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore()
                                self.pbb_core.parent = self
                                self._children_name_map["pbb_core"] = "pbb-core"
                                self._children_yang_names.add("pbb-core")

                                self.pbb_edges = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges()
                                self.pbb_edges.parent = self
                                self._children_name_map["pbb_edges"] = "pbb-edges"
                                self._children_yang_names.add("pbb-edges")


                            class PbbEdges(Entity):
                                """
                                PBB Edge
                                
                                .. attribute:: pbb_edge
                                
                                	Configure BD as PBB Edge with ISID and associated PBB Core BD
                                	**type**\: list of    :py:class:`PbbEdge <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges, self).__init__()

                                    self.yang_name = "pbb-edges"
                                    self.yang_parent_name = "bridge-domain-pbb"

                                    self.pbb_edge = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges, self).__setattr__(name, value)


                                class PbbEdge(Entity):
                                    """
                                    Configure BD as PBB Edge with ISID and
                                    associated PBB Core BD
                                    
                                    .. attribute:: isid  <key>
                                    
                                    	ISID
                                    	**type**\:  int
                                    
                                    	**range:** 256..16777214
                                    
                                    .. attribute:: core_bd_name  <key>
                                    
                                    	Core BD Name
                                    	**type**\:  str
                                    
                                    	**length:** 1..27
                                    
                                    .. attribute:: pbb_edge_dhcp_profile
                                    
                                    	Attach a DHCP profile
                                    	**type**\:   :py:class:`PbbEdgeDhcpProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeDhcpProfile>`
                                    
                                    .. attribute:: pbb_edge_igmp_profile
                                    
                                    	Attach a IGMP Snooping profile
                                    	**type**\:  str
                                    
                                    	**length:** 1..32
                                    
                                    .. attribute:: pbb_edge_mac
                                    
                                    	MAC configuration commands
                                    	**type**\:   :py:class:`PbbEdgeMac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac>`
                                    
                                    .. attribute:: pbb_edge_split_horizon_group
                                    
                                    	Split Horizon Group
                                    	**type**\:   :py:class:`PbbEdgeSplitHorizonGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeSplitHorizonGroup>`
                                    
                                    .. attribute:: pbb_static_mac_mappings
                                    
                                    	PBB Static Mac Address Mapping Table
                                    	**type**\:   :py:class:`PbbStaticMacMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings>`
                                    
                                    .. attribute:: unknown_unicast_bmac
                                    
                                    	Configure Unknown Unicast BMAC address for PBB Edge Port
                                    	**type**\:  str
                                    
                                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge, self).__init__()

                                        self.yang_name = "pbb-edge"
                                        self.yang_parent_name = "pbb-edges"

                                        self.isid = YLeaf(YType.uint32, "isid")

                                        self.core_bd_name = YLeaf(YType.str, "core-bd-name")

                                        self.pbb_edge_igmp_profile = YLeaf(YType.str, "pbb-edge-igmp-profile")

                                        self.unknown_unicast_bmac = YLeaf(YType.str, "unknown-unicast-bmac")

                                        self.pbb_edge_dhcp_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeDhcpProfile()
                                        self.pbb_edge_dhcp_profile.parent = self
                                        self._children_name_map["pbb_edge_dhcp_profile"] = "pbb-edge-dhcp-profile"
                                        self._children_yang_names.add("pbb-edge-dhcp-profile")

                                        self.pbb_edge_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac()
                                        self.pbb_edge_mac.parent = self
                                        self._children_name_map["pbb_edge_mac"] = "pbb-edge-mac"
                                        self._children_yang_names.add("pbb-edge-mac")

                                        self.pbb_edge_split_horizon_group = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeSplitHorizonGroup()
                                        self.pbb_edge_split_horizon_group.parent = self
                                        self._children_name_map["pbb_edge_split_horizon_group"] = "pbb-edge-split-horizon-group"
                                        self._children_yang_names.add("pbb-edge-split-horizon-group")

                                        self.pbb_static_mac_mappings = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings()
                                        self.pbb_static_mac_mappings.parent = self
                                        self._children_name_map["pbb_static_mac_mappings"] = "pbb-static-mac-mappings"
                                        self._children_yang_names.add("pbb-static-mac-mappings")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("isid",
                                                        "core_bd_name",
                                                        "pbb_edge_igmp_profile",
                                                        "unknown_unicast_bmac") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge, self).__setattr__(name, value)


                                    class PbbEdgeSplitHorizonGroup(Entity):
                                        """
                                        Split Horizon Group
                                        
                                        .. attribute:: disable
                                        
                                        	Disable split horizon group
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeSplitHorizonGroup, self).__init__()

                                            self.yang_name = "pbb-edge-split-horizon-group"
                                            self.yang_parent_name = "pbb-edge"

                                            self.disable = YLeaf(YType.empty, "disable")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("disable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeSplitHorizonGroup, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeSplitHorizonGroup, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.disable.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.disable.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pbb-edge-split-horizon-group" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.disable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "disable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "disable"):
                                                self.disable = value
                                                self.disable.value_namespace = name_space
                                                self.disable.value_namespace_prefix = name_space_prefix


                                    class PbbStaticMacMappings(Entity):
                                        """
                                        PBB Static Mac Address Mapping Table
                                        
                                        .. attribute:: pbb_static_mac_mapping
                                        
                                        	PBB Static Mac Address Mapping Configuration
                                        	**type**\: list of    :py:class:`PbbStaticMacMapping <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings.PbbStaticMacMapping>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings, self).__init__()

                                            self.yang_name = "pbb-static-mac-mappings"
                                            self.yang_parent_name = "pbb-edge"

                                            self.pbb_static_mac_mapping = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings, self).__setattr__(name, value)


                                        class PbbStaticMacMapping(Entity):
                                            """
                                            PBB Static Mac Address Mapping
                                            Configuration
                                            
                                            .. attribute:: address  <key>
                                            
                                            	Static MAC address
                                            	**type**\:  str
                                            
                                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                            
                                            .. attribute:: pbb_static_mac_mapping_bmac
                                            
                                            	Static backbone MAC address to map with
                                            	**type**\:  str
                                            
                                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings.PbbStaticMacMapping, self).__init__()

                                                self.yang_name = "pbb-static-mac-mapping"
                                                self.yang_parent_name = "pbb-static-mac-mappings"

                                                self.address = YLeaf(YType.str, "address")

                                                self.pbb_static_mac_mapping_bmac = YLeaf(YType.str, "pbb-static-mac-mapping-bmac")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("address",
                                                                "pbb_static_mac_mapping_bmac") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings.PbbStaticMacMapping, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings.PbbStaticMacMapping, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.address.is_set or
                                                    self.pbb_static_mac_mapping_bmac.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.address.yfilter != YFilter.not_set or
                                                    self.pbb_static_mac_mapping_bmac.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "pbb-static-mac-mapping" + "[address='" + self.address.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.address.get_name_leafdata())
                                                if (self.pbb_static_mac_mapping_bmac.is_set or self.pbb_static_mac_mapping_bmac.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pbb_static_mac_mapping_bmac.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "address" or name == "pbb-static-mac-mapping-bmac"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "address"):
                                                    self.address = value
                                                    self.address.value_namespace = name_space
                                                    self.address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pbb-static-mac-mapping-bmac"):
                                                    self.pbb_static_mac_mapping_bmac = value
                                                    self.pbb_static_mac_mapping_bmac.value_namespace = name_space
                                                    self.pbb_static_mac_mapping_bmac.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.pbb_static_mac_mapping:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.pbb_static_mac_mapping:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pbb-static-mac-mappings" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "pbb-static-mac-mapping"):
                                                for c in self.pbb_static_mac_mapping:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings.PbbStaticMacMapping()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.pbb_static_mac_mapping.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pbb-static-mac-mapping"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class PbbEdgeDhcpProfile(Entity):
                                        """
                                        Attach a DHCP profile
                                        
                                        .. attribute:: dhcp_snooping_id
                                        
                                        	Disable DHCP snooping
                                        	**type**\:  str
                                        
                                        .. attribute:: profile_id
                                        
                                        	Set the snooping profile
                                        	**type**\:   :py:class:`InterfaceProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceProfile>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeDhcpProfile, self).__init__()

                                            self.yang_name = "pbb-edge-dhcp-profile"
                                            self.yang_parent_name = "pbb-edge"

                                            self.dhcp_snooping_id = YLeaf(YType.str, "dhcp-snooping-id")

                                            self.profile_id = YLeaf(YType.enumeration, "profile-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("dhcp_snooping_id",
                                                            "profile_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeDhcpProfile, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeDhcpProfile, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.dhcp_snooping_id.is_set or
                                                self.profile_id.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.dhcp_snooping_id.yfilter != YFilter.not_set or
                                                self.profile_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pbb-edge-dhcp-profile" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.dhcp_snooping_id.is_set or self.dhcp_snooping_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.dhcp_snooping_id.get_name_leafdata())
                                            if (self.profile_id.is_set or self.profile_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.profile_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "dhcp-snooping-id" or name == "profile-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "dhcp-snooping-id"):
                                                self.dhcp_snooping_id = value
                                                self.dhcp_snooping_id.value_namespace = name_space
                                                self.dhcp_snooping_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "profile-id"):
                                                self.profile_id = value
                                                self.profile_id.value_namespace = name_space
                                                self.profile_id.value_namespace_prefix = name_space_prefix


                                    class PbbEdgeMac(Entity):
                                        """
                                        MAC configuration commands
                                        
                                        .. attribute:: pbb_edge_mac_aging
                                        
                                        	MAC\-Aging configuration commands
                                        	**type**\:   :py:class:`PbbEdgeMacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacAging>`
                                        
                                        .. attribute:: pbb_edge_mac_learning
                                        
                                        	Enable Mac Learning
                                        	**type**\:   :py:class:`MacLearn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLearn>`
                                        
                                        .. attribute:: pbb_edge_mac_limit
                                        
                                        	MAC\-Limit configuration commands
                                        	**type**\:   :py:class:`PbbEdgeMacLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacLimit>`
                                        
                                        .. attribute:: pbb_edge_mac_secure
                                        
                                        	MAC Secure
                                        	**type**\:   :py:class:`PbbEdgeMacSecure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacSecure>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac, self).__init__()

                                            self.yang_name = "pbb-edge-mac"
                                            self.yang_parent_name = "pbb-edge"

                                            self.pbb_edge_mac_learning = YLeaf(YType.enumeration, "pbb-edge-mac-learning")

                                            self.pbb_edge_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacAging()
                                            self.pbb_edge_mac_aging.parent = self
                                            self._children_name_map["pbb_edge_mac_aging"] = "pbb-edge-mac-aging"
                                            self._children_yang_names.add("pbb-edge-mac-aging")

                                            self.pbb_edge_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacLimit()
                                            self.pbb_edge_mac_limit.parent = self
                                            self._children_name_map["pbb_edge_mac_limit"] = "pbb-edge-mac-limit"
                                            self._children_yang_names.add("pbb-edge-mac-limit")

                                            self.pbb_edge_mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacSecure()
                                            self.pbb_edge_mac_secure.parent = self
                                            self._children_name_map["pbb_edge_mac_secure"] = "pbb-edge-mac-secure"
                                            self._children_yang_names.add("pbb-edge-mac-secure")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("pbb_edge_mac_learning") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac, self).__setattr__(name, value)


                                        class PbbEdgeMacLimit(Entity):
                                            """
                                            MAC\-Limit configuration commands
                                            
                                            .. attribute:: pbb_edge_mac_limit_action
                                            
                                            	MAC address limit enforcement action
                                            	**type**\:   :py:class:`MacLimitAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLimitAction>`
                                            
                                            .. attribute:: pbb_edge_mac_limit_max
                                            
                                            	Number of MAC addresses after which MAC limit action is taken
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: pbb_edge_mac_limit_notif
                                            
                                            	MAC address limit notification action
                                            	**type**\:   :py:class:`MacNotification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacNotification>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacLimit, self).__init__()

                                                self.yang_name = "pbb-edge-mac-limit"
                                                self.yang_parent_name = "pbb-edge-mac"

                                                self.pbb_edge_mac_limit_action = YLeaf(YType.enumeration, "pbb-edge-mac-limit-action")

                                                self.pbb_edge_mac_limit_max = YLeaf(YType.uint32, "pbb-edge-mac-limit-max")

                                                self.pbb_edge_mac_limit_notif = YLeaf(YType.enumeration, "pbb-edge-mac-limit-notif")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("pbb_edge_mac_limit_action",
                                                                "pbb_edge_mac_limit_max",
                                                                "pbb_edge_mac_limit_notif") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacLimit, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacLimit, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.pbb_edge_mac_limit_action.is_set or
                                                    self.pbb_edge_mac_limit_max.is_set or
                                                    self.pbb_edge_mac_limit_notif.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.pbb_edge_mac_limit_action.yfilter != YFilter.not_set or
                                                    self.pbb_edge_mac_limit_max.yfilter != YFilter.not_set or
                                                    self.pbb_edge_mac_limit_notif.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "pbb-edge-mac-limit" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.pbb_edge_mac_limit_action.is_set or self.pbb_edge_mac_limit_action.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pbb_edge_mac_limit_action.get_name_leafdata())
                                                if (self.pbb_edge_mac_limit_max.is_set or self.pbb_edge_mac_limit_max.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pbb_edge_mac_limit_max.get_name_leafdata())
                                                if (self.pbb_edge_mac_limit_notif.is_set or self.pbb_edge_mac_limit_notif.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pbb_edge_mac_limit_notif.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "pbb-edge-mac-limit-action" or name == "pbb-edge-mac-limit-max" or name == "pbb-edge-mac-limit-notif"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "pbb-edge-mac-limit-action"):
                                                    self.pbb_edge_mac_limit_action = value
                                                    self.pbb_edge_mac_limit_action.value_namespace = name_space
                                                    self.pbb_edge_mac_limit_action.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pbb-edge-mac-limit-max"):
                                                    self.pbb_edge_mac_limit_max = value
                                                    self.pbb_edge_mac_limit_max.value_namespace = name_space
                                                    self.pbb_edge_mac_limit_max.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pbb-edge-mac-limit-notif"):
                                                    self.pbb_edge_mac_limit_notif = value
                                                    self.pbb_edge_mac_limit_notif.value_namespace = name_space
                                                    self.pbb_edge_mac_limit_notif.value_namespace_prefix = name_space_prefix


                                        class PbbEdgeMacAging(Entity):
                                            """
                                            MAC\-Aging configuration commands
                                            
                                            .. attribute:: pbb_edge_mac_aging_time
                                            
                                            	Mac Aging Time
                                            	**type**\:  int
                                            
                                            	**range:** 300..30000
                                            
                                            .. attribute:: pbb_edge_mac_aging_type
                                            
                                            	MAC address aging type
                                            	**type**\:   :py:class:`MacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacAging>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacAging, self).__init__()

                                                self.yang_name = "pbb-edge-mac-aging"
                                                self.yang_parent_name = "pbb-edge-mac"

                                                self.pbb_edge_mac_aging_time = YLeaf(YType.uint32, "pbb-edge-mac-aging-time")

                                                self.pbb_edge_mac_aging_type = YLeaf(YType.enumeration, "pbb-edge-mac-aging-type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("pbb_edge_mac_aging_time",
                                                                "pbb_edge_mac_aging_type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacAging, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacAging, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.pbb_edge_mac_aging_time.is_set or
                                                    self.pbb_edge_mac_aging_type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.pbb_edge_mac_aging_time.yfilter != YFilter.not_set or
                                                    self.pbb_edge_mac_aging_type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "pbb-edge-mac-aging" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.pbb_edge_mac_aging_time.is_set or self.pbb_edge_mac_aging_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pbb_edge_mac_aging_time.get_name_leafdata())
                                                if (self.pbb_edge_mac_aging_type.is_set or self.pbb_edge_mac_aging_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pbb_edge_mac_aging_type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "pbb-edge-mac-aging-time" or name == "pbb-edge-mac-aging-type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "pbb-edge-mac-aging-time"):
                                                    self.pbb_edge_mac_aging_time = value
                                                    self.pbb_edge_mac_aging_time.value_namespace = name_space
                                                    self.pbb_edge_mac_aging_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pbb-edge-mac-aging-type"):
                                                    self.pbb_edge_mac_aging_type = value
                                                    self.pbb_edge_mac_aging_type.value_namespace = name_space
                                                    self.pbb_edge_mac_aging_type.value_namespace_prefix = name_space_prefix


                                        class PbbEdgeMacSecure(Entity):
                                            """
                                            MAC Secure
                                            
                                            .. attribute:: accept_shutdown
                                            
                                            	Accept Virtual instance port to be shutdown on mac violation
                                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                            
                                            .. attribute:: action
                                            
                                            	MAC secure enforcement action
                                            	**type**\:   :py:class:`MacSecureAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacSecureAction>`
                                            
                                            .. attribute:: disable
                                            
                                            	Disable Virtual instance port MAC Secure
                                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                            
                                            .. attribute:: enable
                                            
                                            	Enable MAC Secure
                                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                            
                                            .. attribute:: logging
                                            
                                            	MAC Secure Logging
                                            	**type**\:   :py:class:`L2VpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnLogging>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacSecure, self).__init__()

                                                self.yang_name = "pbb-edge-mac-secure"
                                                self.yang_parent_name = "pbb-edge-mac"

                                                self.accept_shutdown = YLeaf(YType.empty, "accept-shutdown")

                                                self.action = YLeaf(YType.enumeration, "action")

                                                self.disable = YLeaf(YType.empty, "disable")

                                                self.enable = YLeaf(YType.empty, "enable")

                                                self.logging = YLeaf(YType.enumeration, "logging")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("accept_shutdown",
                                                                "action",
                                                                "disable",
                                                                "enable",
                                                                "logging") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacSecure, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacSecure, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.accept_shutdown.is_set or
                                                    self.action.is_set or
                                                    self.disable.is_set or
                                                    self.enable.is_set or
                                                    self.logging.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.accept_shutdown.yfilter != YFilter.not_set or
                                                    self.action.yfilter != YFilter.not_set or
                                                    self.disable.yfilter != YFilter.not_set or
                                                    self.enable.yfilter != YFilter.not_set or
                                                    self.logging.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "pbb-edge-mac-secure" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.accept_shutdown.is_set or self.accept_shutdown.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.accept_shutdown.get_name_leafdata())
                                                if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.action.get_name_leafdata())
                                                if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.disable.get_name_leafdata())
                                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                                if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.logging.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "accept-shutdown" or name == "action" or name == "disable" or name == "enable" or name == "logging"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "accept-shutdown"):
                                                    self.accept_shutdown = value
                                                    self.accept_shutdown.value_namespace = name_space
                                                    self.accept_shutdown.value_namespace_prefix = name_space_prefix
                                                if(value_path == "action"):
                                                    self.action = value
                                                    self.action.value_namespace = name_space
                                                    self.action.value_namespace_prefix = name_space_prefix
                                                if(value_path == "disable"):
                                                    self.disable = value
                                                    self.disable.value_namespace = name_space
                                                    self.disable.value_namespace_prefix = name_space_prefix
                                                if(value_path == "enable"):
                                                    self.enable = value
                                                    self.enable.value_namespace = name_space
                                                    self.enable.value_namespace_prefix = name_space_prefix
                                                if(value_path == "logging"):
                                                    self.logging = value
                                                    self.logging.value_namespace = name_space
                                                    self.logging.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.pbb_edge_mac_learning.is_set or
                                                (self.pbb_edge_mac_aging is not None and self.pbb_edge_mac_aging.has_data()) or
                                                (self.pbb_edge_mac_limit is not None and self.pbb_edge_mac_limit.has_data()) or
                                                (self.pbb_edge_mac_secure is not None and self.pbb_edge_mac_secure.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.pbb_edge_mac_learning.yfilter != YFilter.not_set or
                                                (self.pbb_edge_mac_aging is not None and self.pbb_edge_mac_aging.has_operation()) or
                                                (self.pbb_edge_mac_limit is not None and self.pbb_edge_mac_limit.has_operation()) or
                                                (self.pbb_edge_mac_secure is not None and self.pbb_edge_mac_secure.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pbb-edge-mac" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.pbb_edge_mac_learning.is_set or self.pbb_edge_mac_learning.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pbb_edge_mac_learning.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "pbb-edge-mac-aging"):
                                                if (self.pbb_edge_mac_aging is None):
                                                    self.pbb_edge_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacAging()
                                                    self.pbb_edge_mac_aging.parent = self
                                                    self._children_name_map["pbb_edge_mac_aging"] = "pbb-edge-mac-aging"
                                                return self.pbb_edge_mac_aging

                                            if (child_yang_name == "pbb-edge-mac-limit"):
                                                if (self.pbb_edge_mac_limit is None):
                                                    self.pbb_edge_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacLimit()
                                                    self.pbb_edge_mac_limit.parent = self
                                                    self._children_name_map["pbb_edge_mac_limit"] = "pbb-edge-mac-limit"
                                                return self.pbb_edge_mac_limit

                                            if (child_yang_name == "pbb-edge-mac-secure"):
                                                if (self.pbb_edge_mac_secure is None):
                                                    self.pbb_edge_mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac.PbbEdgeMacSecure()
                                                    self.pbb_edge_mac_secure.parent = self
                                                    self._children_name_map["pbb_edge_mac_secure"] = "pbb-edge-mac-secure"
                                                return self.pbb_edge_mac_secure

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pbb-edge-mac-aging" or name == "pbb-edge-mac-limit" or name == "pbb-edge-mac-secure" or name == "pbb-edge-mac-learning"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "pbb-edge-mac-learning"):
                                                self.pbb_edge_mac_learning = value
                                                self.pbb_edge_mac_learning.value_namespace = name_space
                                                self.pbb_edge_mac_learning.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.isid.is_set or
                                            self.core_bd_name.is_set or
                                            self.pbb_edge_igmp_profile.is_set or
                                            self.unknown_unicast_bmac.is_set or
                                            (self.pbb_edge_dhcp_profile is not None and self.pbb_edge_dhcp_profile.has_data()) or
                                            (self.pbb_edge_mac is not None and self.pbb_edge_mac.has_data()) or
                                            (self.pbb_edge_split_horizon_group is not None and self.pbb_edge_split_horizon_group.has_data()) or
                                            (self.pbb_static_mac_mappings is not None and self.pbb_static_mac_mappings.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.isid.yfilter != YFilter.not_set or
                                            self.core_bd_name.yfilter != YFilter.not_set or
                                            self.pbb_edge_igmp_profile.yfilter != YFilter.not_set or
                                            self.unknown_unicast_bmac.yfilter != YFilter.not_set or
                                            (self.pbb_edge_dhcp_profile is not None and self.pbb_edge_dhcp_profile.has_operation()) or
                                            (self.pbb_edge_mac is not None and self.pbb_edge_mac.has_operation()) or
                                            (self.pbb_edge_split_horizon_group is not None and self.pbb_edge_split_horizon_group.has_operation()) or
                                            (self.pbb_static_mac_mappings is not None and self.pbb_static_mac_mappings.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pbb-edge" + "[isid='" + self.isid.get() + "']" + "[core-bd-name='" + self.core_bd_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.isid.is_set or self.isid.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.isid.get_name_leafdata())
                                        if (self.core_bd_name.is_set or self.core_bd_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.core_bd_name.get_name_leafdata())
                                        if (self.pbb_edge_igmp_profile.is_set or self.pbb_edge_igmp_profile.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.pbb_edge_igmp_profile.get_name_leafdata())
                                        if (self.unknown_unicast_bmac.is_set or self.unknown_unicast_bmac.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.unknown_unicast_bmac.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "pbb-edge-dhcp-profile"):
                                            if (self.pbb_edge_dhcp_profile is None):
                                                self.pbb_edge_dhcp_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeDhcpProfile()
                                                self.pbb_edge_dhcp_profile.parent = self
                                                self._children_name_map["pbb_edge_dhcp_profile"] = "pbb-edge-dhcp-profile"
                                            return self.pbb_edge_dhcp_profile

                                        if (child_yang_name == "pbb-edge-mac"):
                                            if (self.pbb_edge_mac is None):
                                                self.pbb_edge_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeMac()
                                                self.pbb_edge_mac.parent = self
                                                self._children_name_map["pbb_edge_mac"] = "pbb-edge-mac"
                                            return self.pbb_edge_mac

                                        if (child_yang_name == "pbb-edge-split-horizon-group"):
                                            if (self.pbb_edge_split_horizon_group is None):
                                                self.pbb_edge_split_horizon_group = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbEdgeSplitHorizonGroup()
                                                self.pbb_edge_split_horizon_group.parent = self
                                                self._children_name_map["pbb_edge_split_horizon_group"] = "pbb-edge-split-horizon-group"
                                            return self.pbb_edge_split_horizon_group

                                        if (child_yang_name == "pbb-static-mac-mappings"):
                                            if (self.pbb_static_mac_mappings is None):
                                                self.pbb_static_mac_mappings = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge.PbbStaticMacMappings()
                                                self.pbb_static_mac_mappings.parent = self
                                                self._children_name_map["pbb_static_mac_mappings"] = "pbb-static-mac-mappings"
                                            return self.pbb_static_mac_mappings

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "pbb-edge-dhcp-profile" or name == "pbb-edge-mac" or name == "pbb-edge-split-horizon-group" or name == "pbb-static-mac-mappings" or name == "isid" or name == "core-bd-name" or name == "pbb-edge-igmp-profile" or name == "unknown-unicast-bmac"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "isid"):
                                            self.isid = value
                                            self.isid.value_namespace = name_space
                                            self.isid.value_namespace_prefix = name_space_prefix
                                        if(value_path == "core-bd-name"):
                                            self.core_bd_name = value
                                            self.core_bd_name.value_namespace = name_space
                                            self.core_bd_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "pbb-edge-igmp-profile"):
                                            self.pbb_edge_igmp_profile = value
                                            self.pbb_edge_igmp_profile.value_namespace = name_space
                                            self.pbb_edge_igmp_profile.value_namespace_prefix = name_space_prefix
                                        if(value_path == "unknown-unicast-bmac"):
                                            self.unknown_unicast_bmac = value
                                            self.unknown_unicast_bmac.value_namespace = name_space
                                            self.unknown_unicast_bmac.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.pbb_edge:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.pbb_edge:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "pbb-edges" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "pbb-edge"):
                                        for c in self.pbb_edge:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges.PbbEdge()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.pbb_edge.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "pbb-edge"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class PbbCore(Entity):
                                """
                                PBB Core
                                
                                .. attribute:: enable
                                
                                	Enable Bridge Domain PBB Core Configuration
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: pbb_core_dhcp_profile
                                
                                	Attach a DHCP profile
                                	**type**\:   :py:class:`PbbCoreDhcpProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreDhcpProfile>`
                                
                                .. attribute:: pbb_core_evis
                                
                                	PBB Core EVI Table
                                	**type**\:   :py:class:`PbbCoreEvis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis>`
                                
                                .. attribute:: pbb_core_igmp_profile
                                
                                	Attach a IGMP Snooping profile
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: pbb_core_mac
                                
                                	MAC configuration commands
                                	**type**\:   :py:class:`PbbCoreMac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac>`
                                
                                .. attribute:: pbb_core_mmrp_flood_optimization
                                
                                	Enabling MMRP PBB\-VPLS Flood Optimization
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: vlan_id
                                
                                	VLAN ID to push
                                	**type**\:  int
                                
                                	**range:** 1..4094
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore, self).__init__()

                                    self.yang_name = "pbb-core"
                                    self.yang_parent_name = "bridge-domain-pbb"

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.pbb_core_igmp_profile = YLeaf(YType.str, "pbb-core-igmp-profile")

                                    self.pbb_core_mmrp_flood_optimization = YLeaf(YType.empty, "pbb-core-mmrp-flood-optimization")

                                    self.vlan_id = YLeaf(YType.uint32, "vlan-id")

                                    self.pbb_core_dhcp_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreDhcpProfile()
                                    self.pbb_core_dhcp_profile.parent = self
                                    self._children_name_map["pbb_core_dhcp_profile"] = "pbb-core-dhcp-profile"
                                    self._children_yang_names.add("pbb-core-dhcp-profile")

                                    self.pbb_core_evis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis()
                                    self.pbb_core_evis.parent = self
                                    self._children_name_map["pbb_core_evis"] = "pbb-core-evis"
                                    self._children_yang_names.add("pbb-core-evis")

                                    self.pbb_core_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac()
                                    self.pbb_core_mac.parent = self
                                    self._children_name_map["pbb_core_mac"] = "pbb-core-mac"
                                    self._children_yang_names.add("pbb-core-mac")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("enable",
                                                    "pbb_core_igmp_profile",
                                                    "pbb_core_mmrp_flood_optimization",
                                                    "vlan_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore, self).__setattr__(name, value)


                                class PbbCoreMac(Entity):
                                    """
                                    MAC configuration commands
                                    
                                    .. attribute:: pbb_core_mac_aging
                                    
                                    	MAC\-Aging configuration commands
                                    	**type**\:   :py:class:`PbbCoreMacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacAging>`
                                    
                                    .. attribute:: pbb_core_mac_learning
                                    
                                    	Enable Mac Learning
                                    	**type**\:   :py:class:`MacLearn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLearn>`
                                    
                                    .. attribute:: pbb_core_mac_limit
                                    
                                    	MAC\-Limit configuration commands
                                    	**type**\:   :py:class:`PbbCoreMacLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacLimit>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac, self).__init__()

                                        self.yang_name = "pbb-core-mac"
                                        self.yang_parent_name = "pbb-core"

                                        self.pbb_core_mac_learning = YLeaf(YType.enumeration, "pbb-core-mac-learning")

                                        self.pbb_core_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacAging()
                                        self.pbb_core_mac_aging.parent = self
                                        self._children_name_map["pbb_core_mac_aging"] = "pbb-core-mac-aging"
                                        self._children_yang_names.add("pbb-core-mac-aging")

                                        self.pbb_core_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacLimit()
                                        self.pbb_core_mac_limit.parent = self
                                        self._children_name_map["pbb_core_mac_limit"] = "pbb-core-mac-limit"
                                        self._children_yang_names.add("pbb-core-mac-limit")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("pbb_core_mac_learning") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac, self).__setattr__(name, value)


                                    class PbbCoreMacAging(Entity):
                                        """
                                        MAC\-Aging configuration commands
                                        
                                        .. attribute:: pbb_core_mac_aging_time
                                        
                                        	Mac Aging Time
                                        	**type**\:  int
                                        
                                        	**range:** 300..30000
                                        
                                        .. attribute:: pbb_core_mac_aging_type
                                        
                                        	MAC address aging type
                                        	**type**\:   :py:class:`MacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacAging>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacAging, self).__init__()

                                            self.yang_name = "pbb-core-mac-aging"
                                            self.yang_parent_name = "pbb-core-mac"

                                            self.pbb_core_mac_aging_time = YLeaf(YType.uint32, "pbb-core-mac-aging-time")

                                            self.pbb_core_mac_aging_type = YLeaf(YType.enumeration, "pbb-core-mac-aging-type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("pbb_core_mac_aging_time",
                                                            "pbb_core_mac_aging_type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacAging, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacAging, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.pbb_core_mac_aging_time.is_set or
                                                self.pbb_core_mac_aging_type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.pbb_core_mac_aging_time.yfilter != YFilter.not_set or
                                                self.pbb_core_mac_aging_type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pbb-core-mac-aging" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.pbb_core_mac_aging_time.is_set or self.pbb_core_mac_aging_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pbb_core_mac_aging_time.get_name_leafdata())
                                            if (self.pbb_core_mac_aging_type.is_set or self.pbb_core_mac_aging_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pbb_core_mac_aging_type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pbb-core-mac-aging-time" or name == "pbb-core-mac-aging-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "pbb-core-mac-aging-time"):
                                                self.pbb_core_mac_aging_time = value
                                                self.pbb_core_mac_aging_time.value_namespace = name_space
                                                self.pbb_core_mac_aging_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pbb-core-mac-aging-type"):
                                                self.pbb_core_mac_aging_type = value
                                                self.pbb_core_mac_aging_type.value_namespace = name_space
                                                self.pbb_core_mac_aging_type.value_namespace_prefix = name_space_prefix


                                    class PbbCoreMacLimit(Entity):
                                        """
                                        MAC\-Limit configuration commands
                                        
                                        .. attribute:: pbb_core_mac_limit_action
                                        
                                        	MAC address limit enforcement action
                                        	**type**\:   :py:class:`MacLimitAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLimitAction>`
                                        
                                        .. attribute:: pbb_core_mac_limit_max
                                        
                                        	Number of MAC addresses after which MAC limit action is taken
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: pbb_core_mac_limit_notif
                                        
                                        	MAC address limit notification action
                                        	**type**\:   :py:class:`MacNotification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacNotification>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacLimit, self).__init__()

                                            self.yang_name = "pbb-core-mac-limit"
                                            self.yang_parent_name = "pbb-core-mac"

                                            self.pbb_core_mac_limit_action = YLeaf(YType.enumeration, "pbb-core-mac-limit-action")

                                            self.pbb_core_mac_limit_max = YLeaf(YType.uint32, "pbb-core-mac-limit-max")

                                            self.pbb_core_mac_limit_notif = YLeaf(YType.enumeration, "pbb-core-mac-limit-notif")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("pbb_core_mac_limit_action",
                                                            "pbb_core_mac_limit_max",
                                                            "pbb_core_mac_limit_notif") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacLimit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacLimit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.pbb_core_mac_limit_action.is_set or
                                                self.pbb_core_mac_limit_max.is_set or
                                                self.pbb_core_mac_limit_notif.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.pbb_core_mac_limit_action.yfilter != YFilter.not_set or
                                                self.pbb_core_mac_limit_max.yfilter != YFilter.not_set or
                                                self.pbb_core_mac_limit_notif.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pbb-core-mac-limit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.pbb_core_mac_limit_action.is_set or self.pbb_core_mac_limit_action.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pbb_core_mac_limit_action.get_name_leafdata())
                                            if (self.pbb_core_mac_limit_max.is_set or self.pbb_core_mac_limit_max.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pbb_core_mac_limit_max.get_name_leafdata())
                                            if (self.pbb_core_mac_limit_notif.is_set or self.pbb_core_mac_limit_notif.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pbb_core_mac_limit_notif.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pbb-core-mac-limit-action" or name == "pbb-core-mac-limit-max" or name == "pbb-core-mac-limit-notif"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "pbb-core-mac-limit-action"):
                                                self.pbb_core_mac_limit_action = value
                                                self.pbb_core_mac_limit_action.value_namespace = name_space
                                                self.pbb_core_mac_limit_action.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pbb-core-mac-limit-max"):
                                                self.pbb_core_mac_limit_max = value
                                                self.pbb_core_mac_limit_max.value_namespace = name_space
                                                self.pbb_core_mac_limit_max.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pbb-core-mac-limit-notif"):
                                                self.pbb_core_mac_limit_notif = value
                                                self.pbb_core_mac_limit_notif.value_namespace = name_space
                                                self.pbb_core_mac_limit_notif.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.pbb_core_mac_learning.is_set or
                                            (self.pbb_core_mac_aging is not None and self.pbb_core_mac_aging.has_data()) or
                                            (self.pbb_core_mac_limit is not None and self.pbb_core_mac_limit.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.pbb_core_mac_learning.yfilter != YFilter.not_set or
                                            (self.pbb_core_mac_aging is not None and self.pbb_core_mac_aging.has_operation()) or
                                            (self.pbb_core_mac_limit is not None and self.pbb_core_mac_limit.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pbb-core-mac" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.pbb_core_mac_learning.is_set or self.pbb_core_mac_learning.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.pbb_core_mac_learning.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "pbb-core-mac-aging"):
                                            if (self.pbb_core_mac_aging is None):
                                                self.pbb_core_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacAging()
                                                self.pbb_core_mac_aging.parent = self
                                                self._children_name_map["pbb_core_mac_aging"] = "pbb-core-mac-aging"
                                            return self.pbb_core_mac_aging

                                        if (child_yang_name == "pbb-core-mac-limit"):
                                            if (self.pbb_core_mac_limit is None):
                                                self.pbb_core_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac.PbbCoreMacLimit()
                                                self.pbb_core_mac_limit.parent = self
                                                self._children_name_map["pbb_core_mac_limit"] = "pbb-core-mac-limit"
                                            return self.pbb_core_mac_limit

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "pbb-core-mac-aging" or name == "pbb-core-mac-limit" or name == "pbb-core-mac-learning"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "pbb-core-mac-learning"):
                                            self.pbb_core_mac_learning = value
                                            self.pbb_core_mac_learning.value_namespace = name_space
                                            self.pbb_core_mac_learning.value_namespace_prefix = name_space_prefix


                                class PbbCoreEvis(Entity):
                                    """
                                    PBB Core EVI Table
                                    
                                    .. attribute:: pbb_core_evi
                                    
                                    	PBB Core EVI
                                    	**type**\: list of    :py:class:`PbbCoreEvi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis.PbbCoreEvi>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis, self).__init__()

                                        self.yang_name = "pbb-core-evis"
                                        self.yang_parent_name = "pbb-core"

                                        self.pbb_core_evi = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis, self).__setattr__(name, value)


                                    class PbbCoreEvi(Entity):
                                        """
                                        PBB Core EVI
                                        
                                        .. attribute:: eviid  <key>
                                        
                                        	Ethernet VPN ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis.PbbCoreEvi, self).__init__()

                                            self.yang_name = "pbb-core-evi"
                                            self.yang_parent_name = "pbb-core-evis"

                                            self.eviid = YLeaf(YType.uint32, "eviid")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("eviid") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis.PbbCoreEvi, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis.PbbCoreEvi, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.eviid.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.eviid.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pbb-core-evi" + "[eviid='" + self.eviid.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.eviid.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "eviid"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "eviid"):
                                                self.eviid = value
                                                self.eviid.value_namespace = name_space
                                                self.eviid.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.pbb_core_evi:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.pbb_core_evi:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pbb-core-evis" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "pbb-core-evi"):
                                            for c in self.pbb_core_evi:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis.PbbCoreEvi()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.pbb_core_evi.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "pbb-core-evi"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class PbbCoreDhcpProfile(Entity):
                                    """
                                    Attach a DHCP profile
                                    
                                    .. attribute:: dhcp_snooping_id
                                    
                                    	Disable DHCP snooping
                                    	**type**\:  str
                                    
                                    .. attribute:: profile_id
                                    
                                    	Set the snooping profile
                                    	**type**\:   :py:class:`InterfaceProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceProfile>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreDhcpProfile, self).__init__()

                                        self.yang_name = "pbb-core-dhcp-profile"
                                        self.yang_parent_name = "pbb-core"

                                        self.dhcp_snooping_id = YLeaf(YType.str, "dhcp-snooping-id")

                                        self.profile_id = YLeaf(YType.enumeration, "profile-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("dhcp_snooping_id",
                                                        "profile_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreDhcpProfile, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreDhcpProfile, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.dhcp_snooping_id.is_set or
                                            self.profile_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.dhcp_snooping_id.yfilter != YFilter.not_set or
                                            self.profile_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pbb-core-dhcp-profile" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.dhcp_snooping_id.is_set or self.dhcp_snooping_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dhcp_snooping_id.get_name_leafdata())
                                        if (self.profile_id.is_set or self.profile_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.profile_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "dhcp-snooping-id" or name == "profile-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "dhcp-snooping-id"):
                                            self.dhcp_snooping_id = value
                                            self.dhcp_snooping_id.value_namespace = name_space
                                            self.dhcp_snooping_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "profile-id"):
                                            self.profile_id = value
                                            self.profile_id.value_namespace = name_space
                                            self.profile_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.enable.is_set or
                                        self.pbb_core_igmp_profile.is_set or
                                        self.pbb_core_mmrp_flood_optimization.is_set or
                                        self.vlan_id.is_set or
                                        (self.pbb_core_dhcp_profile is not None and self.pbb_core_dhcp_profile.has_data()) or
                                        (self.pbb_core_evis is not None and self.pbb_core_evis.has_data()) or
                                        (self.pbb_core_mac is not None and self.pbb_core_mac.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.pbb_core_igmp_profile.yfilter != YFilter.not_set or
                                        self.pbb_core_mmrp_flood_optimization.yfilter != YFilter.not_set or
                                        self.vlan_id.yfilter != YFilter.not_set or
                                        (self.pbb_core_dhcp_profile is not None and self.pbb_core_dhcp_profile.has_operation()) or
                                        (self.pbb_core_evis is not None and self.pbb_core_evis.has_operation()) or
                                        (self.pbb_core_mac is not None and self.pbb_core_mac.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "pbb-core" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.pbb_core_igmp_profile.is_set or self.pbb_core_igmp_profile.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pbb_core_igmp_profile.get_name_leafdata())
                                    if (self.pbb_core_mmrp_flood_optimization.is_set or self.pbb_core_mmrp_flood_optimization.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pbb_core_mmrp_flood_optimization.get_name_leafdata())
                                    if (self.vlan_id.is_set or self.vlan_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.vlan_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "pbb-core-dhcp-profile"):
                                        if (self.pbb_core_dhcp_profile is None):
                                            self.pbb_core_dhcp_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreDhcpProfile()
                                            self.pbb_core_dhcp_profile.parent = self
                                            self._children_name_map["pbb_core_dhcp_profile"] = "pbb-core-dhcp-profile"
                                        return self.pbb_core_dhcp_profile

                                    if (child_yang_name == "pbb-core-evis"):
                                        if (self.pbb_core_evis is None):
                                            self.pbb_core_evis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreEvis()
                                            self.pbb_core_evis.parent = self
                                            self._children_name_map["pbb_core_evis"] = "pbb-core-evis"
                                        return self.pbb_core_evis

                                    if (child_yang_name == "pbb-core-mac"):
                                        if (self.pbb_core_mac is None):
                                            self.pbb_core_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore.PbbCoreMac()
                                            self.pbb_core_mac.parent = self
                                            self._children_name_map["pbb_core_mac"] = "pbb-core-mac"
                                        return self.pbb_core_mac

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "pbb-core-dhcp-profile" or name == "pbb-core-evis" or name == "pbb-core-mac" or name == "enable" or name == "pbb-core-igmp-profile" or name == "pbb-core-mmrp-flood-optimization" or name == "vlan-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pbb-core-igmp-profile"):
                                        self.pbb_core_igmp_profile = value
                                        self.pbb_core_igmp_profile.value_namespace = name_space
                                        self.pbb_core_igmp_profile.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pbb-core-mmrp-flood-optimization"):
                                        self.pbb_core_mmrp_flood_optimization = value
                                        self.pbb_core_mmrp_flood_optimization.value_namespace = name_space
                                        self.pbb_core_mmrp_flood_optimization.value_namespace_prefix = name_space_prefix
                                    if(value_path == "vlan-id"):
                                        self.vlan_id = value
                                        self.vlan_id.value_namespace = name_space
                                        self.vlan_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.pbb_core is not None and self.pbb_core.has_data()) or
                                    (self.pbb_edges is not None and self.pbb_edges.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.pbb_core is not None and self.pbb_core.has_operation()) or
                                    (self.pbb_edges is not None and self.pbb_edges.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bridge-domain-pbb" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "pbb-core"):
                                    if (self.pbb_core is None):
                                        self.pbb_core = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbCore()
                                        self.pbb_core.parent = self
                                        self._children_name_map["pbb_core"] = "pbb-core"
                                    return self.pbb_core

                                if (child_yang_name == "pbb-edges"):
                                    if (self.pbb_edges is None):
                                        self.pbb_edges = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb.PbbEdges()
                                        self.pbb_edges.parent = self
                                        self._children_name_map["pbb_edges"] = "pbb-edges"
                                    return self.pbb_edges

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "pbb-core" or name == "pbb-edges"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class BridgeDomainEvis(Entity):
                            """
                            Bridge Domain EVI Table
                            
                            .. attribute:: bridge_domain_evi
                            
                            	Bridge Domain EVI
                            	**type**\: list of    :py:class:`BridgeDomainEvi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis.BridgeDomainEvi>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis, self).__init__()

                                self.yang_name = "bridge-domain-evis"
                                self.yang_parent_name = "bridge-domain"

                                self.bridge_domain_evi = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis, self).__setattr__(name, value)


                            class BridgeDomainEvi(Entity):
                                """
                                Bridge Domain EVI
                                
                                .. attribute:: eviid  <key>
                                
                                	Ethernet VPN ID
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis.BridgeDomainEvi, self).__init__()

                                    self.yang_name = "bridge-domain-evi"
                                    self.yang_parent_name = "bridge-domain-evis"

                                    self.eviid = YLeaf(YType.uint32, "eviid")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("eviid") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis.BridgeDomainEvi, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis.BridgeDomainEvi, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.eviid.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.eviid.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bridge-domain-evi" + "[eviid='" + self.eviid.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.eviid.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "eviid"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "eviid"):
                                        self.eviid = value
                                        self.eviid.value_namespace = name_space
                                        self.eviid.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.bridge_domain_evi:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.bridge_domain_evi:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bridge-domain-evis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bridge-domain-evi"):
                                    for c in self.bridge_domain_evi:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis.BridgeDomainEvi()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.bridge_domain_evi.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bridge-domain-evi"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class AccessVfis(Entity):
                            """
                            Specify the access virtual forwarding
                            interface name
                            
                            .. attribute:: access_vfi
                            
                            	Name of the Acess Virtual Forwarding Interface
                            	**type**\: list of    :py:class:`AccessVfi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis, self).__init__()

                                self.yang_name = "access-vfis"
                                self.yang_parent_name = "bridge-domain"

                                self.access_vfi = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis, self).__setattr__(name, value)


                            class AccessVfi(Entity):
                                """
                                Name of the Acess Virtual Forwarding
                                Interface
                                
                                .. attribute:: name  <key>
                                
                                	Name of the AccessVirtual Forwarding Interface
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: access_vfi_pseudowires
                                
                                	List of pseudowires
                                	**type**\:   :py:class:`AccessVfiPseudowires <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi, self).__init__()

                                    self.yang_name = "access-vfi"
                                    self.yang_parent_name = "access-vfis"

                                    self.name = YLeaf(YType.str, "name")

                                    self.access_vfi_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires()
                                    self.access_vfi_pseudowires.parent = self
                                    self._children_name_map["access_vfi_pseudowires"] = "access-vfi-pseudowires"
                                    self._children_yang_names.add("access-vfi-pseudowires")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi, self).__setattr__(name, value)


                                class AccessVfiPseudowires(Entity):
                                    """
                                    List of pseudowires
                                    
                                    .. attribute:: access_vfi_pseudowire
                                    
                                    	Pseudowire configuration
                                    	**type**\: list of    :py:class:`AccessVfiPseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires, self).__init__()

                                        self.yang_name = "access-vfi-pseudowires"
                                        self.yang_parent_name = "access-vfi"

                                        self.access_vfi_pseudowire = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires, self).__setattr__(name, value)


                                    class AccessVfiPseudowire(Entity):
                                        """
                                        Pseudowire configuration
                                        
                                        .. attribute:: neighbor  <key>
                                        
                                        	Neighbor IP address
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: pseudowire_id  <key>
                                        
                                        	Pseudowire ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        .. attribute:: access_vfi_pseudowire_static_mac_addresses
                                        
                                        	Static Mac Address Table
                                        	**type**\:   :py:class:`AccessVfiPseudowireStaticMacAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire, self).__init__()

                                            self.yang_name = "access-vfi-pseudowire"
                                            self.yang_parent_name = "access-vfi-pseudowires"

                                            self.neighbor = YLeaf(YType.str, "neighbor")

                                            self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                                            self.access_vfi_pseudowire_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses()
                                            self.access_vfi_pseudowire_static_mac_addresses.parent = self
                                            self._children_name_map["access_vfi_pseudowire_static_mac_addresses"] = "access-vfi-pseudowire-static-mac-addresses"
                                            self._children_yang_names.add("access-vfi-pseudowire-static-mac-addresses")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("neighbor",
                                                            "pseudowire_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire, self).__setattr__(name, value)


                                        class AccessVfiPseudowireStaticMacAddresses(Entity):
                                            """
                                            Static Mac Address Table
                                            
                                            .. attribute:: access_vfi_pseudowire_static_mac_address
                                            
                                            	Static Mac Address Configuration
                                            	**type**\: list of    :py:class:`AccessVfiPseudowireStaticMacAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses.AccessVfiPseudowireStaticMacAddress>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses, self).__init__()

                                                self.yang_name = "access-vfi-pseudowire-static-mac-addresses"
                                                self.yang_parent_name = "access-vfi-pseudowire"

                                                self.access_vfi_pseudowire_static_mac_address = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses, self).__setattr__(name, value)


                                            class AccessVfiPseudowireStaticMacAddress(Entity):
                                                """
                                                Static Mac Address Configuration
                                                
                                                .. attribute:: address  <key>
                                                
                                                	Static MAC address
                                                	**type**\:  str
                                                
                                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                                
                                                

                                                """

                                                _prefix = 'l2vpn-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses.AccessVfiPseudowireStaticMacAddress, self).__init__()

                                                    self.yang_name = "access-vfi-pseudowire-static-mac-address"
                                                    self.yang_parent_name = "access-vfi-pseudowire-static-mac-addresses"

                                                    self.address = YLeaf(YType.str, "address")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("address") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses.AccessVfiPseudowireStaticMacAddress, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses.AccessVfiPseudowireStaticMacAddress, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.address.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.address.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "access-vfi-pseudowire-static-mac-address" + "[address='" + self.address.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.address.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "address"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "address"):
                                                        self.address = value
                                                        self.address.value_namespace = name_space
                                                        self.address.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.access_vfi_pseudowire_static_mac_address:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.access_vfi_pseudowire_static_mac_address:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "access-vfi-pseudowire-static-mac-addresses" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "access-vfi-pseudowire-static-mac-address"):
                                                    for c in self.access_vfi_pseudowire_static_mac_address:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses.AccessVfiPseudowireStaticMacAddress()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.access_vfi_pseudowire_static_mac_address.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "access-vfi-pseudowire-static-mac-address"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.neighbor.is_set or
                                                self.pseudowire_id.is_set or
                                                (self.access_vfi_pseudowire_static_mac_addresses is not None and self.access_vfi_pseudowire_static_mac_addresses.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.neighbor.yfilter != YFilter.not_set or
                                                self.pseudowire_id.yfilter != YFilter.not_set or
                                                (self.access_vfi_pseudowire_static_mac_addresses is not None and self.access_vfi_pseudowire_static_mac_addresses.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "access-vfi-pseudowire" + "[neighbor='" + self.neighbor.get() + "']" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.neighbor.get_name_leafdata())
                                            if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "access-vfi-pseudowire-static-mac-addresses"):
                                                if (self.access_vfi_pseudowire_static_mac_addresses is None):
                                                    self.access_vfi_pseudowire_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire.AccessVfiPseudowireStaticMacAddresses()
                                                    self.access_vfi_pseudowire_static_mac_addresses.parent = self
                                                    self._children_name_map["access_vfi_pseudowire_static_mac_addresses"] = "access-vfi-pseudowire-static-mac-addresses"
                                                return self.access_vfi_pseudowire_static_mac_addresses

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "access-vfi-pseudowire-static-mac-addresses" or name == "neighbor" or name == "pseudowire-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "neighbor"):
                                                self.neighbor = value
                                                self.neighbor.value_namespace = name_space
                                                self.neighbor.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pseudowire-id"):
                                                self.pseudowire_id = value
                                                self.pseudowire_id.value_namespace = name_space
                                                self.pseudowire_id.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.access_vfi_pseudowire:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.access_vfi_pseudowire:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "access-vfi-pseudowires" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "access-vfi-pseudowire"):
                                            for c in self.access_vfi_pseudowire:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires.AccessVfiPseudowire()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.access_vfi_pseudowire.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "access-vfi-pseudowire"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.name.is_set or
                                        (self.access_vfi_pseudowires is not None and self.access_vfi_pseudowires.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.name.yfilter != YFilter.not_set or
                                        (self.access_vfi_pseudowires is not None and self.access_vfi_pseudowires.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "access-vfi" + "[name='" + self.name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "access-vfi-pseudowires"):
                                        if (self.access_vfi_pseudowires is None):
                                            self.access_vfi_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi.AccessVfiPseudowires()
                                            self.access_vfi_pseudowires.parent = self
                                            self._children_name_map["access_vfi_pseudowires"] = "access-vfi-pseudowires"
                                        return self.access_vfi_pseudowires

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "access-vfi-pseudowires" or name == "name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "name"):
                                        self.name = value
                                        self.name.value_namespace = name_space
                                        self.name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.access_vfi:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.access_vfi:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "access-vfis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "access-vfi"):
                                    for c in self.access_vfi:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis.AccessVfi()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.access_vfi.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "access-vfi"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class BdPseudowires(Entity):
                            """
                            List of pseudowires
                            
                            .. attribute:: bd_pseudowire
                            
                            	Pseudowire configuration
                            	**type**\: list of    :py:class:`BdPseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires, self).__init__()

                                self.yang_name = "bd-pseudowires"
                                self.yang_parent_name = "bridge-domain"

                                self.bd_pseudowire = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires, self).__setattr__(name, value)


                            class BdPseudowire(Entity):
                                """
                                Pseudowire configuration
                                
                                .. attribute:: neighbor  <key>
                                
                                	Neighbor IP address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: pseudowire_id  <key>
                                
                                	Pseudowire ID
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                .. attribute:: bd_pw_class
                                
                                	PW class template name to use for this pseudowire
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: bd_pw_mpls_static_labels
                                
                                	MPLS static labels
                                	**type**\:   :py:class:`BdPwMplsStaticLabels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwMplsStaticLabels>`
                                
                                .. attribute:: bd_pw_split_horizon
                                
                                	Split Horizon
                                	**type**\:   :py:class:`BdPwSplitHorizon <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon>`
                                
                                .. attribute:: bd_pw_static_mac_addresses
                                
                                	Static Mac Address Table
                                	**type**\:   :py:class:`BdPwStaticMacAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses>`
                                
                                .. attribute:: bdpw_storm_control_types
                                
                                	Storm Control
                                	**type**\:   :py:class:`BdpwStormControlTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes>`
                                
                                .. attribute:: bridge_domain_backup_pseudowires
                                
                                	List of pseudowires
                                	**type**\:   :py:class:`BridgeDomainBackupPseudowires <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires>`
                                
                                .. attribute:: pseudowire_dai
                                
                                	Access Pseudowire Dynamic ARP Inspection
                                	**type**\:   :py:class:`PseudowireDai <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai>`
                                
                                .. attribute:: pseudowire_flooding
                                
                                	Bridge\-domain Pseudowire flooding
                                	**type**\:   :py:class:`InterfaceTrafficFlood <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceTrafficFlood>`
                                
                                .. attribute:: pseudowire_flooding_unknown_unicast
                                
                                	Bridge\-domain Pseudowire flooding Unknown Unicast
                                	**type**\:   :py:class:`InterfaceTrafficFlood <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceTrafficFlood>`
                                
                                .. attribute:: pseudowire_igmp_snoop
                                
                                	Attach a IGMP Snooping profile
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: pseudowire_ip_source_guard
                                
                                	IP Source Guard
                                	**type**\:   :py:class:`PseudowireIpSourceGuard <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireIpSourceGuard>`
                                
                                .. attribute:: pseudowire_mac
                                
                                	Bridge\-domain Pseudowire MAC configuration commands
                                	**type**\:   :py:class:`PseudowireMac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac>`
                                
                                .. attribute:: pseudowire_mld_snoop
                                
                                	Attach a MLD Snooping profile
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: pseudowire_profile
                                
                                	Attach a DHCP profile
                                	**type**\:   :py:class:`PseudowireProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireProfile>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire, self).__init__()

                                    self.yang_name = "bd-pseudowire"
                                    self.yang_parent_name = "bd-pseudowires"

                                    self.neighbor = YLeaf(YType.str, "neighbor")

                                    self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                                    self.bd_pw_class = YLeaf(YType.str, "bd-pw-class")

                                    self.pseudowire_flooding = YLeaf(YType.enumeration, "pseudowire-flooding")

                                    self.pseudowire_flooding_unknown_unicast = YLeaf(YType.enumeration, "pseudowire-flooding-unknown-unicast")

                                    self.pseudowire_igmp_snoop = YLeaf(YType.str, "pseudowire-igmp-snoop")

                                    self.pseudowire_mld_snoop = YLeaf(YType.str, "pseudowire-mld-snoop")

                                    self.bd_pw_mpls_static_labels = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwMplsStaticLabels()
                                    self.bd_pw_mpls_static_labels.parent = self
                                    self._children_name_map["bd_pw_mpls_static_labels"] = "bd-pw-mpls-static-labels"
                                    self._children_yang_names.add("bd-pw-mpls-static-labels")

                                    self.bd_pw_split_horizon = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon()
                                    self.bd_pw_split_horizon.parent = self
                                    self._children_name_map["bd_pw_split_horizon"] = "bd-pw-split-horizon"
                                    self._children_yang_names.add("bd-pw-split-horizon")

                                    self.bd_pw_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses()
                                    self.bd_pw_static_mac_addresses.parent = self
                                    self._children_name_map["bd_pw_static_mac_addresses"] = "bd-pw-static-mac-addresses"
                                    self._children_yang_names.add("bd-pw-static-mac-addresses")

                                    self.bdpw_storm_control_types = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes()
                                    self.bdpw_storm_control_types.parent = self
                                    self._children_name_map["bdpw_storm_control_types"] = "bdpw-storm-control-types"
                                    self._children_yang_names.add("bdpw-storm-control-types")

                                    self.bridge_domain_backup_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires()
                                    self.bridge_domain_backup_pseudowires.parent = self
                                    self._children_name_map["bridge_domain_backup_pseudowires"] = "bridge-domain-backup-pseudowires"
                                    self._children_yang_names.add("bridge-domain-backup-pseudowires")

                                    self.pseudowire_dai = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai()
                                    self.pseudowire_dai.parent = self
                                    self._children_name_map["pseudowire_dai"] = "pseudowire-dai"
                                    self._children_yang_names.add("pseudowire-dai")

                                    self.pseudowire_ip_source_guard = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireIpSourceGuard()
                                    self.pseudowire_ip_source_guard.parent = self
                                    self._children_name_map["pseudowire_ip_source_guard"] = "pseudowire-ip-source-guard"
                                    self._children_yang_names.add("pseudowire-ip-source-guard")

                                    self.pseudowire_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac()
                                    self.pseudowire_mac.parent = self
                                    self._children_name_map["pseudowire_mac"] = "pseudowire-mac"
                                    self._children_yang_names.add("pseudowire-mac")

                                    self.pseudowire_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireProfile()
                                    self.pseudowire_profile.parent = self
                                    self._children_name_map["pseudowire_profile"] = "pseudowire-profile"
                                    self._children_yang_names.add("pseudowire-profile")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("neighbor",
                                                    "pseudowire_id",
                                                    "bd_pw_class",
                                                    "pseudowire_flooding",
                                                    "pseudowire_flooding_unknown_unicast",
                                                    "pseudowire_igmp_snoop",
                                                    "pseudowire_mld_snoop") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire, self).__setattr__(name, value)


                                class PseudowireDai(Entity):
                                    """
                                    Access Pseudowire Dynamic ARP Inspection
                                    
                                    .. attribute:: disable
                                    
                                    	Disable Dynamic ARP Inspection
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: enable
                                    
                                    	Enable Access Pseudowire Dynamic ARP Inspection
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: logging
                                    
                                    	Logging Type
                                    	**type**\:   :py:class:`L2VpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnLogging>`
                                    
                                    .. attribute:: pseudowire_dai_address_validation
                                    
                                    	Address Validation
                                    	**type**\:   :py:class:`PseudowireDaiAddressValidation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai.PseudowireDaiAddressValidation>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai, self).__init__()

                                        self.yang_name = "pseudowire-dai"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.disable = YLeaf(YType.empty, "disable")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.logging = YLeaf(YType.enumeration, "logging")

                                        self.pseudowire_dai_address_validation = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai.PseudowireDaiAddressValidation()
                                        self.pseudowire_dai_address_validation.parent = self
                                        self._children_name_map["pseudowire_dai_address_validation"] = "pseudowire-dai-address-validation"
                                        self._children_yang_names.add("pseudowire-dai-address-validation")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("disable",
                                                        "enable",
                                                        "logging") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai, self).__setattr__(name, value)


                                    class PseudowireDaiAddressValidation(Entity):
                                        """
                                        Address Validation
                                        
                                        .. attribute:: destination_mac_verification
                                        
                                        	Destination MAC Verification
                                        	**type**\:   :py:class:`L2VpnVerification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnVerification>`
                                        
                                        .. attribute:: ipv4_verification
                                        
                                        	IPv4 Verification
                                        	**type**\:   :py:class:`L2VpnVerification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnVerification>`
                                        
                                        .. attribute:: source_mac_verification
                                        
                                        	Source MAC Verification
                                        	**type**\:   :py:class:`L2VpnVerification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnVerification>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai.PseudowireDaiAddressValidation, self).__init__()

                                            self.yang_name = "pseudowire-dai-address-validation"
                                            self.yang_parent_name = "pseudowire-dai"

                                            self.destination_mac_verification = YLeaf(YType.enumeration, "destination-mac-verification")

                                            self.ipv4_verification = YLeaf(YType.enumeration, "ipv4-verification")

                                            self.source_mac_verification = YLeaf(YType.enumeration, "source-mac-verification")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("destination_mac_verification",
                                                            "ipv4_verification",
                                                            "source_mac_verification") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai.PseudowireDaiAddressValidation, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai.PseudowireDaiAddressValidation, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.destination_mac_verification.is_set or
                                                self.ipv4_verification.is_set or
                                                self.source_mac_verification.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.destination_mac_verification.yfilter != YFilter.not_set or
                                                self.ipv4_verification.yfilter != YFilter.not_set or
                                                self.source_mac_verification.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pseudowire-dai-address-validation" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.destination_mac_verification.is_set or self.destination_mac_verification.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.destination_mac_verification.get_name_leafdata())
                                            if (self.ipv4_verification.is_set or self.ipv4_verification.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.ipv4_verification.get_name_leafdata())
                                            if (self.source_mac_verification.is_set or self.source_mac_verification.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.source_mac_verification.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "destination-mac-verification" or name == "ipv4-verification" or name == "source-mac-verification"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "destination-mac-verification"):
                                                self.destination_mac_verification = value
                                                self.destination_mac_verification.value_namespace = name_space
                                                self.destination_mac_verification.value_namespace_prefix = name_space_prefix
                                            if(value_path == "ipv4-verification"):
                                                self.ipv4_verification = value
                                                self.ipv4_verification.value_namespace = name_space
                                                self.ipv4_verification.value_namespace_prefix = name_space_prefix
                                            if(value_path == "source-mac-verification"):
                                                self.source_mac_verification = value
                                                self.source_mac_verification.value_namespace = name_space
                                                self.source_mac_verification.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.disable.is_set or
                                            self.enable.is_set or
                                            self.logging.is_set or
                                            (self.pseudowire_dai_address_validation is not None and self.pseudowire_dai_address_validation.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.disable.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.logging.yfilter != YFilter.not_set or
                                            (self.pseudowire_dai_address_validation is not None and self.pseudowire_dai_address_validation.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pseudowire-dai" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.disable.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.logging.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "pseudowire-dai-address-validation"):
                                            if (self.pseudowire_dai_address_validation is None):
                                                self.pseudowire_dai_address_validation = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai.PseudowireDaiAddressValidation()
                                                self.pseudowire_dai_address_validation.parent = self
                                                self._children_name_map["pseudowire_dai_address_validation"] = "pseudowire-dai-address-validation"
                                            return self.pseudowire_dai_address_validation

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "pseudowire-dai-address-validation" or name == "disable" or name == "enable" or name == "logging"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "disable"):
                                            self.disable = value
                                            self.disable.value_namespace = name_space
                                            self.disable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "logging"):
                                            self.logging = value
                                            self.logging.value_namespace = name_space
                                            self.logging.value_namespace_prefix = name_space_prefix


                                class BdpwStormControlTypes(Entity):
                                    """
                                    Storm Control
                                    
                                    .. attribute:: bdpw_storm_control_type
                                    
                                    	Storm Control Type
                                    	**type**\: list of    :py:class:`BdpwStormControlType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes, self).__init__()

                                        self.yang_name = "bdpw-storm-control-types"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.bdpw_storm_control_type = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes, self).__setattr__(name, value)


                                    class BdpwStormControlType(Entity):
                                        """
                                        Storm Control Type
                                        
                                        .. attribute:: sctype  <key>
                                        
                                        	Storm Control Type
                                        	**type**\:   :py:class:`StormControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.StormControl>`
                                        
                                        .. attribute:: storm_control_unit
                                        
                                        	Specify units for Storm Control Configuration
                                        	**type**\:   :py:class:`StormControlUnit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType.StormControlUnit>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType, self).__init__()

                                            self.yang_name = "bdpw-storm-control-type"
                                            self.yang_parent_name = "bdpw-storm-control-types"

                                            self.sctype = YLeaf(YType.enumeration, "sctype")

                                            self.storm_control_unit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType.StormControlUnit()
                                            self.storm_control_unit.parent = self
                                            self._children_name_map["storm_control_unit"] = "storm-control-unit"
                                            self._children_yang_names.add("storm-control-unit")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("sctype") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType, self).__setattr__(name, value)


                                        class StormControlUnit(Entity):
                                            """
                                            Specify units for Storm Control Configuration
                                            
                                            .. attribute:: kbits_per_sec
                                            
                                            	Kilobits Per Second, PktsPerSec and KbitsPerSec cannot be configured together
                                            	**type**\:  int
                                            
                                            	**range:** 64..1280000
                                            
                                            	**units**\: kbit/s
                                            
                                            .. attribute:: pkts_per_sec
                                            
                                            	Packets Per Second, PktsPerSec and KbitsPerSec cannot be configured together
                                            	**type**\:  int
                                            
                                            	**range:** 1..160000
                                            
                                            	**units**\: packet/s
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType.StormControlUnit, self).__init__()

                                                self.yang_name = "storm-control-unit"
                                                self.yang_parent_name = "bdpw-storm-control-type"

                                                self.kbits_per_sec = YLeaf(YType.uint32, "kbits-per-sec")

                                                self.pkts_per_sec = YLeaf(YType.uint32, "pkts-per-sec")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("kbits_per_sec",
                                                                "pkts_per_sec") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType.StormControlUnit, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType.StormControlUnit, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.kbits_per_sec.is_set or
                                                    self.pkts_per_sec.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.kbits_per_sec.yfilter != YFilter.not_set or
                                                    self.pkts_per_sec.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "storm-control-unit" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.kbits_per_sec.is_set or self.kbits_per_sec.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.kbits_per_sec.get_name_leafdata())
                                                if (self.pkts_per_sec.is_set or self.pkts_per_sec.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pkts_per_sec.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "kbits-per-sec" or name == "pkts-per-sec"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "kbits-per-sec"):
                                                    self.kbits_per_sec = value
                                                    self.kbits_per_sec.value_namespace = name_space
                                                    self.kbits_per_sec.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pkts-per-sec"):
                                                    self.pkts_per_sec = value
                                                    self.pkts_per_sec.value_namespace = name_space
                                                    self.pkts_per_sec.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.sctype.is_set or
                                                (self.storm_control_unit is not None and self.storm_control_unit.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.sctype.yfilter != YFilter.not_set or
                                                (self.storm_control_unit is not None and self.storm_control_unit.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bdpw-storm-control-type" + "[sctype='" + self.sctype.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.sctype.is_set or self.sctype.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sctype.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "storm-control-unit"):
                                                if (self.storm_control_unit is None):
                                                    self.storm_control_unit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType.StormControlUnit()
                                                    self.storm_control_unit.parent = self
                                                    self._children_name_map["storm_control_unit"] = "storm-control-unit"
                                                return self.storm_control_unit

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "storm-control-unit" or name == "sctype"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "sctype"):
                                                self.sctype = value
                                                self.sctype.value_namespace = name_space
                                                self.sctype.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.bdpw_storm_control_type:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.bdpw_storm_control_type:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bdpw-storm-control-types" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "bdpw-storm-control-type"):
                                            for c in self.bdpw_storm_control_type:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes.BdpwStormControlType()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.bdpw_storm_control_type.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "bdpw-storm-control-type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class PseudowireProfile(Entity):
                                    """
                                    Attach a DHCP profile
                                    
                                    .. attribute:: dhcp_snooping_id
                                    
                                    	Disable DHCP snooping
                                    	**type**\:  str
                                    
                                    .. attribute:: profile_id
                                    
                                    	Set the snooping profile
                                    	**type**\:   :py:class:`InterfaceProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceProfile>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireProfile, self).__init__()

                                        self.yang_name = "pseudowire-profile"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.dhcp_snooping_id = YLeaf(YType.str, "dhcp-snooping-id")

                                        self.profile_id = YLeaf(YType.enumeration, "profile-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("dhcp_snooping_id",
                                                        "profile_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireProfile, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireProfile, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.dhcp_snooping_id.is_set or
                                            self.profile_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.dhcp_snooping_id.yfilter != YFilter.not_set or
                                            self.profile_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pseudowire-profile" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.dhcp_snooping_id.is_set or self.dhcp_snooping_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dhcp_snooping_id.get_name_leafdata())
                                        if (self.profile_id.is_set or self.profile_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.profile_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "dhcp-snooping-id" or name == "profile-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "dhcp-snooping-id"):
                                            self.dhcp_snooping_id = value
                                            self.dhcp_snooping_id.value_namespace = name_space
                                            self.dhcp_snooping_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "profile-id"):
                                            self.profile_id = value
                                            self.profile_id.value_namespace = name_space
                                            self.profile_id.value_namespace_prefix = name_space_prefix


                                class BdPwStaticMacAddresses(Entity):
                                    """
                                    Static Mac Address Table
                                    
                                    .. attribute:: bd_pw_static_mac_address
                                    
                                    	Static Mac Address Configuration
                                    	**type**\: list of    :py:class:`BdPwStaticMacAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses.BdPwStaticMacAddress>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses, self).__init__()

                                        self.yang_name = "bd-pw-static-mac-addresses"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.bd_pw_static_mac_address = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses, self).__setattr__(name, value)


                                    class BdPwStaticMacAddress(Entity):
                                        """
                                        Static Mac Address Configuration
                                        
                                        .. attribute:: address  <key>
                                        
                                        	Static MAC address
                                        	**type**\:  str
                                        
                                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses.BdPwStaticMacAddress, self).__init__()

                                            self.yang_name = "bd-pw-static-mac-address"
                                            self.yang_parent_name = "bd-pw-static-mac-addresses"

                                            self.address = YLeaf(YType.str, "address")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("address") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses.BdPwStaticMacAddress, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses.BdPwStaticMacAddress, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.address.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.address.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bd-pw-static-mac-address" + "[address='" + self.address.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.address.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "address"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "address"):
                                                self.address = value
                                                self.address.value_namespace = name_space
                                                self.address.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.bd_pw_static_mac_address:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.bd_pw_static_mac_address:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bd-pw-static-mac-addresses" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "bd-pw-static-mac-address"):
                                            for c in self.bd_pw_static_mac_address:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses.BdPwStaticMacAddress()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.bd_pw_static_mac_address.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "bd-pw-static-mac-address"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class PseudowireIpSourceGuard(Entity):
                                    """
                                    IP Source Guard
                                    
                                    .. attribute:: disable
                                    
                                    	Disable Dynamic IP source guard
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: enable
                                    
                                    	Enable IP Source Guard
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: logging
                                    
                                    	Logging Type
                                    	**type**\:   :py:class:`L2VpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnLogging>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireIpSourceGuard, self).__init__()

                                        self.yang_name = "pseudowire-ip-source-guard"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.disable = YLeaf(YType.empty, "disable")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.logging = YLeaf(YType.enumeration, "logging")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("disable",
                                                        "enable",
                                                        "logging") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireIpSourceGuard, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireIpSourceGuard, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.disable.is_set or
                                            self.enable.is_set or
                                            self.logging.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.disable.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.logging.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pseudowire-ip-source-guard" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.disable.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.logging.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "disable" or name == "enable" or name == "logging"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "disable"):
                                            self.disable = value
                                            self.disable.value_namespace = name_space
                                            self.disable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "logging"):
                                            self.logging = value
                                            self.logging.value_namespace = name_space
                                            self.logging.value_namespace_prefix = name_space_prefix


                                class PseudowireMac(Entity):
                                    """
                                    Bridge\-domain Pseudowire MAC
                                    configuration commands
                                    
                                    .. attribute:: enable
                                    
                                    	Bridge\-domain Pseudowire MAC configuration mode
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: pseudowire_mac_aging
                                    
                                    	MAC\-Aging configuration commands
                                    	**type**\:   :py:class:`PseudowireMacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacAging>`
                                    
                                    .. attribute:: pseudowire_mac_learning
                                    
                                    	Enable MAC Learning
                                    	**type**\:   :py:class:`MacLearn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLearn>`
                                    
                                    .. attribute:: pseudowire_mac_limit
                                    
                                    	MAC\-Limit configuration commands
                                    	**type**\:   :py:class:`PseudowireMacLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacLimit>`
                                    
                                    .. attribute:: pseudowire_mac_port_down_flush
                                    
                                    	Enable/Disable MAC Flush When Port goes down
                                    	**type**\:   :py:class:`PortDownFlush <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.PortDownFlush>`
                                    
                                    .. attribute:: pseudowire_mac_secure
                                    
                                    	MAC Secure
                                    	**type**\:   :py:class:`PseudowireMacSecure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacSecure>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac, self).__init__()

                                        self.yang_name = "pseudowire-mac"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.pseudowire_mac_learning = YLeaf(YType.enumeration, "pseudowire-mac-learning")

                                        self.pseudowire_mac_port_down_flush = YLeaf(YType.enumeration, "pseudowire-mac-port-down-flush")

                                        self.pseudowire_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacAging()
                                        self.pseudowire_mac_aging.parent = self
                                        self._children_name_map["pseudowire_mac_aging"] = "pseudowire-mac-aging"
                                        self._children_yang_names.add("pseudowire-mac-aging")

                                        self.pseudowire_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacLimit()
                                        self.pseudowire_mac_limit.parent = self
                                        self._children_name_map["pseudowire_mac_limit"] = "pseudowire-mac-limit"
                                        self._children_yang_names.add("pseudowire-mac-limit")

                                        self.pseudowire_mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacSecure()
                                        self.pseudowire_mac_secure.parent = self
                                        self._children_name_map["pseudowire_mac_secure"] = "pseudowire-mac-secure"
                                        self._children_yang_names.add("pseudowire-mac-secure")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("enable",
                                                        "pseudowire_mac_learning",
                                                        "pseudowire_mac_port_down_flush") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac, self).__setattr__(name, value)


                                    class PseudowireMacSecure(Entity):
                                        """
                                        MAC Secure
                                        
                                        .. attribute:: action
                                        
                                        	MAC secure enforcement action
                                        	**type**\:   :py:class:`MacSecureAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacSecureAction>`
                                        
                                        .. attribute:: disable
                                        
                                        	Disable L2 Pseudowire MAC Secure
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: enable
                                        
                                        	Enable MAC Secure
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: logging
                                        
                                        	MAC Secure Logging
                                        	**type**\:   :py:class:`L2VpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnLogging>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacSecure, self).__init__()

                                            self.yang_name = "pseudowire-mac-secure"
                                            self.yang_parent_name = "pseudowire-mac"

                                            self.action = YLeaf(YType.enumeration, "action")

                                            self.disable = YLeaf(YType.empty, "disable")

                                            self.enable = YLeaf(YType.empty, "enable")

                                            self.logging = YLeaf(YType.enumeration, "logging")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("action",
                                                            "disable",
                                                            "enable",
                                                            "logging") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacSecure, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacSecure, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.action.is_set or
                                                self.disable.is_set or
                                                self.enable.is_set or
                                                self.logging.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.action.yfilter != YFilter.not_set or
                                                self.disable.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.logging.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pseudowire-mac-secure" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.action.get_name_leafdata())
                                            if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.disable.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.logging.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "action" or name == "disable" or name == "enable" or name == "logging"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "action"):
                                                self.action = value
                                                self.action.value_namespace = name_space
                                                self.action.value_namespace_prefix = name_space_prefix
                                            if(value_path == "disable"):
                                                self.disable = value
                                                self.disable.value_namespace = name_space
                                                self.disable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "logging"):
                                                self.logging = value
                                                self.logging.value_namespace = name_space
                                                self.logging.value_namespace_prefix = name_space_prefix


                                    class PseudowireMacAging(Entity):
                                        """
                                        MAC\-Aging configuration commands
                                        
                                        .. attribute:: pseudowire_mac_aging_time
                                        
                                        	MAC Aging Time
                                        	**type**\:  int
                                        
                                        	**range:** 300..30000
                                        
                                        .. attribute:: pseudowire_mac_aging_type
                                        
                                        	MAC address aging type
                                        	**type**\:   :py:class:`MacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacAging>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacAging, self).__init__()

                                            self.yang_name = "pseudowire-mac-aging"
                                            self.yang_parent_name = "pseudowire-mac"

                                            self.pseudowire_mac_aging_time = YLeaf(YType.uint32, "pseudowire-mac-aging-time")

                                            self.pseudowire_mac_aging_type = YLeaf(YType.enumeration, "pseudowire-mac-aging-type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("pseudowire_mac_aging_time",
                                                            "pseudowire_mac_aging_type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacAging, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacAging, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.pseudowire_mac_aging_time.is_set or
                                                self.pseudowire_mac_aging_type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.pseudowire_mac_aging_time.yfilter != YFilter.not_set or
                                                self.pseudowire_mac_aging_type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pseudowire-mac-aging" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.pseudowire_mac_aging_time.is_set or self.pseudowire_mac_aging_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_mac_aging_time.get_name_leafdata())
                                            if (self.pseudowire_mac_aging_type.is_set or self.pseudowire_mac_aging_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_mac_aging_type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pseudowire-mac-aging-time" or name == "pseudowire-mac-aging-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "pseudowire-mac-aging-time"):
                                                self.pseudowire_mac_aging_time = value
                                                self.pseudowire_mac_aging_time.value_namespace = name_space
                                                self.pseudowire_mac_aging_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pseudowire-mac-aging-type"):
                                                self.pseudowire_mac_aging_type = value
                                                self.pseudowire_mac_aging_type.value_namespace = name_space
                                                self.pseudowire_mac_aging_type.value_namespace_prefix = name_space_prefix


                                    class PseudowireMacLimit(Entity):
                                        """
                                        MAC\-Limit configuration commands
                                        
                                        .. attribute:: pseudowire_mac_limit_action
                                        
                                        	Bridge Access Pseudowire MAC address limit enforcement action
                                        	**type**\:   :py:class:`MacLimitAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLimitAction>`
                                        
                                        .. attribute:: pseudowire_mac_limit_max
                                        
                                        	Number of MAC addresses on a Bridge Access Pseudowire after which MAC limit action is taken
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: pseudowire_mac_limit_notif
                                        
                                        	MAC address limit notification action in a Bridge Access Pseudowire
                                        	**type**\:   :py:class:`MacNotification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacNotification>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacLimit, self).__init__()

                                            self.yang_name = "pseudowire-mac-limit"
                                            self.yang_parent_name = "pseudowire-mac"

                                            self.pseudowire_mac_limit_action = YLeaf(YType.enumeration, "pseudowire-mac-limit-action")

                                            self.pseudowire_mac_limit_max = YLeaf(YType.uint32, "pseudowire-mac-limit-max")

                                            self.pseudowire_mac_limit_notif = YLeaf(YType.enumeration, "pseudowire-mac-limit-notif")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("pseudowire_mac_limit_action",
                                                            "pseudowire_mac_limit_max",
                                                            "pseudowire_mac_limit_notif") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacLimit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacLimit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.pseudowire_mac_limit_action.is_set or
                                                self.pseudowire_mac_limit_max.is_set or
                                                self.pseudowire_mac_limit_notif.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.pseudowire_mac_limit_action.yfilter != YFilter.not_set or
                                                self.pseudowire_mac_limit_max.yfilter != YFilter.not_set or
                                                self.pseudowire_mac_limit_notif.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pseudowire-mac-limit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.pseudowire_mac_limit_action.is_set or self.pseudowire_mac_limit_action.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_mac_limit_action.get_name_leafdata())
                                            if (self.pseudowire_mac_limit_max.is_set or self.pseudowire_mac_limit_max.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_mac_limit_max.get_name_leafdata())
                                            if (self.pseudowire_mac_limit_notif.is_set or self.pseudowire_mac_limit_notif.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_mac_limit_notif.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pseudowire-mac-limit-action" or name == "pseudowire-mac-limit-max" or name == "pseudowire-mac-limit-notif"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "pseudowire-mac-limit-action"):
                                                self.pseudowire_mac_limit_action = value
                                                self.pseudowire_mac_limit_action.value_namespace = name_space
                                                self.pseudowire_mac_limit_action.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pseudowire-mac-limit-max"):
                                                self.pseudowire_mac_limit_max = value
                                                self.pseudowire_mac_limit_max.value_namespace = name_space
                                                self.pseudowire_mac_limit_max.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pseudowire-mac-limit-notif"):
                                                self.pseudowire_mac_limit_notif = value
                                                self.pseudowire_mac_limit_notif.value_namespace = name_space
                                                self.pseudowire_mac_limit_notif.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.enable.is_set or
                                            self.pseudowire_mac_learning.is_set or
                                            self.pseudowire_mac_port_down_flush.is_set or
                                            (self.pseudowire_mac_aging is not None and self.pseudowire_mac_aging.has_data()) or
                                            (self.pseudowire_mac_limit is not None and self.pseudowire_mac_limit.has_data()) or
                                            (self.pseudowire_mac_secure is not None and self.pseudowire_mac_secure.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.pseudowire_mac_learning.yfilter != YFilter.not_set or
                                            self.pseudowire_mac_port_down_flush.yfilter != YFilter.not_set or
                                            (self.pseudowire_mac_aging is not None and self.pseudowire_mac_aging.has_operation()) or
                                            (self.pseudowire_mac_limit is not None and self.pseudowire_mac_limit.has_operation()) or
                                            (self.pseudowire_mac_secure is not None and self.pseudowire_mac_secure.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "pseudowire-mac" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.pseudowire_mac_learning.is_set or self.pseudowire_mac_learning.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.pseudowire_mac_learning.get_name_leafdata())
                                        if (self.pseudowire_mac_port_down_flush.is_set or self.pseudowire_mac_port_down_flush.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.pseudowire_mac_port_down_flush.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "pseudowire-mac-aging"):
                                            if (self.pseudowire_mac_aging is None):
                                                self.pseudowire_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacAging()
                                                self.pseudowire_mac_aging.parent = self
                                                self._children_name_map["pseudowire_mac_aging"] = "pseudowire-mac-aging"
                                            return self.pseudowire_mac_aging

                                        if (child_yang_name == "pseudowire-mac-limit"):
                                            if (self.pseudowire_mac_limit is None):
                                                self.pseudowire_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacLimit()
                                                self.pseudowire_mac_limit.parent = self
                                                self._children_name_map["pseudowire_mac_limit"] = "pseudowire-mac-limit"
                                            return self.pseudowire_mac_limit

                                        if (child_yang_name == "pseudowire-mac-secure"):
                                            if (self.pseudowire_mac_secure is None):
                                                self.pseudowire_mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac.PseudowireMacSecure()
                                                self.pseudowire_mac_secure.parent = self
                                                self._children_name_map["pseudowire_mac_secure"] = "pseudowire-mac-secure"
                                            return self.pseudowire_mac_secure

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "pseudowire-mac-aging" or name == "pseudowire-mac-limit" or name == "pseudowire-mac-secure" or name == "enable" or name == "pseudowire-mac-learning" or name == "pseudowire-mac-port-down-flush"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "pseudowire-mac-learning"):
                                            self.pseudowire_mac_learning = value
                                            self.pseudowire_mac_learning.value_namespace = name_space
                                            self.pseudowire_mac_learning.value_namespace_prefix = name_space_prefix
                                        if(value_path == "pseudowire-mac-port-down-flush"):
                                            self.pseudowire_mac_port_down_flush = value
                                            self.pseudowire_mac_port_down_flush.value_namespace = name_space
                                            self.pseudowire_mac_port_down_flush.value_namespace_prefix = name_space_prefix


                                class BdPwSplitHorizon(Entity):
                                    """
                                    Split Horizon
                                    
                                    .. attribute:: bd_pw_split_horizon_group
                                    
                                    	Split Horizon Group
                                    	**type**\:   :py:class:`BdPwSplitHorizonGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon.BdPwSplitHorizonGroup>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon, self).__init__()

                                        self.yang_name = "bd-pw-split-horizon"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.bd_pw_split_horizon_group = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon.BdPwSplitHorizonGroup()
                                        self.bd_pw_split_horizon_group.parent = self
                                        self._children_name_map["bd_pw_split_horizon_group"] = "bd-pw-split-horizon-group"
                                        self._children_yang_names.add("bd-pw-split-horizon-group")


                                    class BdPwSplitHorizonGroup(Entity):
                                        """
                                        Split Horizon Group
                                        
                                        .. attribute:: enable
                                        
                                        	Enable split horizon group
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon.BdPwSplitHorizonGroup, self).__init__()

                                            self.yang_name = "bd-pw-split-horizon-group"
                                            self.yang_parent_name = "bd-pw-split-horizon"

                                            self.enable = YLeaf(YType.empty, "enable")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("enable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon.BdPwSplitHorizonGroup, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon.BdPwSplitHorizonGroup, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.enable.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bd-pw-split-horizon-group" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "enable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.bd_pw_split_horizon_group is not None and self.bd_pw_split_horizon_group.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.bd_pw_split_horizon_group is not None and self.bd_pw_split_horizon_group.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bd-pw-split-horizon" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "bd-pw-split-horizon-group"):
                                            if (self.bd_pw_split_horizon_group is None):
                                                self.bd_pw_split_horizon_group = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon.BdPwSplitHorizonGroup()
                                                self.bd_pw_split_horizon_group.parent = self
                                                self._children_name_map["bd_pw_split_horizon_group"] = "bd-pw-split-horizon-group"
                                            return self.bd_pw_split_horizon_group

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "bd-pw-split-horizon-group"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class BdPwMplsStaticLabels(Entity):
                                    """
                                    MPLS static labels
                                    
                                    .. attribute:: local_static_label
                                    
                                    	Pseudowire local static label
                                    	**type**\:  int
                                    
                                    	**range:** 16..1048575
                                    
                                    .. attribute:: remote_static_label
                                    
                                    	Pseudowire remote static label
                                    	**type**\:  int
                                    
                                    	**range:** 16..1048575
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwMplsStaticLabels, self).__init__()

                                        self.yang_name = "bd-pw-mpls-static-labels"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.local_static_label = YLeaf(YType.uint32, "local-static-label")

                                        self.remote_static_label = YLeaf(YType.uint32, "remote-static-label")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("local_static_label",
                                                        "remote_static_label") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwMplsStaticLabels, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwMplsStaticLabels, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.local_static_label.is_set or
                                            self.remote_static_label.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.local_static_label.yfilter != YFilter.not_set or
                                            self.remote_static_label.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bd-pw-mpls-static-labels" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.local_static_label.is_set or self.local_static_label.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.local_static_label.get_name_leafdata())
                                        if (self.remote_static_label.is_set or self.remote_static_label.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.remote_static_label.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "local-static-label" or name == "remote-static-label"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "local-static-label"):
                                            self.local_static_label = value
                                            self.local_static_label.value_namespace = name_space
                                            self.local_static_label.value_namespace_prefix = name_space_prefix
                                        if(value_path == "remote-static-label"):
                                            self.remote_static_label = value
                                            self.remote_static_label.value_namespace = name_space
                                            self.remote_static_label.value_namespace_prefix = name_space_prefix


                                class BridgeDomainBackupPseudowires(Entity):
                                    """
                                    List of pseudowires
                                    
                                    .. attribute:: bridge_domain_backup_pseudowire
                                    
                                    	Backup pseudowire configuration
                                    	**type**\: list of    :py:class:`BridgeDomainBackupPseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires.BridgeDomainBackupPseudowire>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires, self).__init__()

                                        self.yang_name = "bridge-domain-backup-pseudowires"
                                        self.yang_parent_name = "bd-pseudowire"

                                        self.bridge_domain_backup_pseudowire = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires, self).__setattr__(name, value)


                                    class BridgeDomainBackupPseudowire(Entity):
                                        """
                                        Backup pseudowire configuration
                                        
                                        .. attribute:: neighbor  <key>
                                        
                                        	Neighbor IP address
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: pseudowire_id  <key>
                                        
                                        	Pseudowire ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        .. attribute:: bridge_domain_backup_pw_class
                                        
                                        	PW class template name to use for this pseudowire
                                        	**type**\:  str
                                        
                                        	**length:** 1..32
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires.BridgeDomainBackupPseudowire, self).__init__()

                                            self.yang_name = "bridge-domain-backup-pseudowire"
                                            self.yang_parent_name = "bridge-domain-backup-pseudowires"

                                            self.neighbor = YLeaf(YType.str, "neighbor")

                                            self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                                            self.bridge_domain_backup_pw_class = YLeaf(YType.str, "bridge-domain-backup-pw-class")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("neighbor",
                                                            "pseudowire_id",
                                                            "bridge_domain_backup_pw_class") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires.BridgeDomainBackupPseudowire, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires.BridgeDomainBackupPseudowire, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.neighbor.is_set or
                                                self.pseudowire_id.is_set or
                                                self.bridge_domain_backup_pw_class.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.neighbor.yfilter != YFilter.not_set or
                                                self.pseudowire_id.yfilter != YFilter.not_set or
                                                self.bridge_domain_backup_pw_class.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bridge-domain-backup-pseudowire" + "[neighbor='" + self.neighbor.get() + "']" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.neighbor.get_name_leafdata())
                                            if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_id.get_name_leafdata())
                                            if (self.bridge_domain_backup_pw_class.is_set or self.bridge_domain_backup_pw_class.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bridge_domain_backup_pw_class.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "neighbor" or name == "pseudowire-id" or name == "bridge-domain-backup-pw-class"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "neighbor"):
                                                self.neighbor = value
                                                self.neighbor.value_namespace = name_space
                                                self.neighbor.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pseudowire-id"):
                                                self.pseudowire_id = value
                                                self.pseudowire_id.value_namespace = name_space
                                                self.pseudowire_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bridge-domain-backup-pw-class"):
                                                self.bridge_domain_backup_pw_class = value
                                                self.bridge_domain_backup_pw_class.value_namespace = name_space
                                                self.bridge_domain_backup_pw_class.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.bridge_domain_backup_pseudowire:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.bridge_domain_backup_pseudowire:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bridge-domain-backup-pseudowires" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "bridge-domain-backup-pseudowire"):
                                            for c in self.bridge_domain_backup_pseudowire:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires.BridgeDomainBackupPseudowire()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.bridge_domain_backup_pseudowire.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "bridge-domain-backup-pseudowire"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.neighbor.is_set or
                                        self.pseudowire_id.is_set or
                                        self.bd_pw_class.is_set or
                                        self.pseudowire_flooding.is_set or
                                        self.pseudowire_flooding_unknown_unicast.is_set or
                                        self.pseudowire_igmp_snoop.is_set or
                                        self.pseudowire_mld_snoop.is_set or
                                        (self.bd_pw_mpls_static_labels is not None and self.bd_pw_mpls_static_labels.has_data()) or
                                        (self.bd_pw_split_horizon is not None and self.bd_pw_split_horizon.has_data()) or
                                        (self.bd_pw_static_mac_addresses is not None and self.bd_pw_static_mac_addresses.has_data()) or
                                        (self.bdpw_storm_control_types is not None and self.bdpw_storm_control_types.has_data()) or
                                        (self.bridge_domain_backup_pseudowires is not None and self.bridge_domain_backup_pseudowires.has_data()) or
                                        (self.pseudowire_dai is not None and self.pseudowire_dai.has_data()) or
                                        (self.pseudowire_ip_source_guard is not None and self.pseudowire_ip_source_guard.has_data()) or
                                        (self.pseudowire_mac is not None and self.pseudowire_mac.has_data()) or
                                        (self.pseudowire_profile is not None and self.pseudowire_profile.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.neighbor.yfilter != YFilter.not_set or
                                        self.pseudowire_id.yfilter != YFilter.not_set or
                                        self.bd_pw_class.yfilter != YFilter.not_set or
                                        self.pseudowire_flooding.yfilter != YFilter.not_set or
                                        self.pseudowire_flooding_unknown_unicast.yfilter != YFilter.not_set or
                                        self.pseudowire_igmp_snoop.yfilter != YFilter.not_set or
                                        self.pseudowire_mld_snoop.yfilter != YFilter.not_set or
                                        (self.bd_pw_mpls_static_labels is not None and self.bd_pw_mpls_static_labels.has_operation()) or
                                        (self.bd_pw_split_horizon is not None and self.bd_pw_split_horizon.has_operation()) or
                                        (self.bd_pw_static_mac_addresses is not None and self.bd_pw_static_mac_addresses.has_operation()) or
                                        (self.bdpw_storm_control_types is not None and self.bdpw_storm_control_types.has_operation()) or
                                        (self.bridge_domain_backup_pseudowires is not None and self.bridge_domain_backup_pseudowires.has_operation()) or
                                        (self.pseudowire_dai is not None and self.pseudowire_dai.has_operation()) or
                                        (self.pseudowire_ip_source_guard is not None and self.pseudowire_ip_source_guard.has_operation()) or
                                        (self.pseudowire_mac is not None and self.pseudowire_mac.has_operation()) or
                                        (self.pseudowire_profile is not None and self.pseudowire_profile.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bd-pseudowire" + "[neighbor='" + self.neighbor.get() + "']" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbor.get_name_leafdata())
                                    if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pseudowire_id.get_name_leafdata())
                                    if (self.bd_pw_class.is_set or self.bd_pw_class.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bd_pw_class.get_name_leafdata())
                                    if (self.pseudowire_flooding.is_set or self.pseudowire_flooding.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pseudowire_flooding.get_name_leafdata())
                                    if (self.pseudowire_flooding_unknown_unicast.is_set or self.pseudowire_flooding_unknown_unicast.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pseudowire_flooding_unknown_unicast.get_name_leafdata())
                                    if (self.pseudowire_igmp_snoop.is_set or self.pseudowire_igmp_snoop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pseudowire_igmp_snoop.get_name_leafdata())
                                    if (self.pseudowire_mld_snoop.is_set or self.pseudowire_mld_snoop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pseudowire_mld_snoop.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "bd-pw-mpls-static-labels"):
                                        if (self.bd_pw_mpls_static_labels is None):
                                            self.bd_pw_mpls_static_labels = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwMplsStaticLabels()
                                            self.bd_pw_mpls_static_labels.parent = self
                                            self._children_name_map["bd_pw_mpls_static_labels"] = "bd-pw-mpls-static-labels"
                                        return self.bd_pw_mpls_static_labels

                                    if (child_yang_name == "bd-pw-split-horizon"):
                                        if (self.bd_pw_split_horizon is None):
                                            self.bd_pw_split_horizon = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwSplitHorizon()
                                            self.bd_pw_split_horizon.parent = self
                                            self._children_name_map["bd_pw_split_horizon"] = "bd-pw-split-horizon"
                                        return self.bd_pw_split_horizon

                                    if (child_yang_name == "bd-pw-static-mac-addresses"):
                                        if (self.bd_pw_static_mac_addresses is None):
                                            self.bd_pw_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdPwStaticMacAddresses()
                                            self.bd_pw_static_mac_addresses.parent = self
                                            self._children_name_map["bd_pw_static_mac_addresses"] = "bd-pw-static-mac-addresses"
                                        return self.bd_pw_static_mac_addresses

                                    if (child_yang_name == "bdpw-storm-control-types"):
                                        if (self.bdpw_storm_control_types is None):
                                            self.bdpw_storm_control_types = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BdpwStormControlTypes()
                                            self.bdpw_storm_control_types.parent = self
                                            self._children_name_map["bdpw_storm_control_types"] = "bdpw-storm-control-types"
                                        return self.bdpw_storm_control_types

                                    if (child_yang_name == "bridge-domain-backup-pseudowires"):
                                        if (self.bridge_domain_backup_pseudowires is None):
                                            self.bridge_domain_backup_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.BridgeDomainBackupPseudowires()
                                            self.bridge_domain_backup_pseudowires.parent = self
                                            self._children_name_map["bridge_domain_backup_pseudowires"] = "bridge-domain-backup-pseudowires"
                                        return self.bridge_domain_backup_pseudowires

                                    if (child_yang_name == "pseudowire-dai"):
                                        if (self.pseudowire_dai is None):
                                            self.pseudowire_dai = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireDai()
                                            self.pseudowire_dai.parent = self
                                            self._children_name_map["pseudowire_dai"] = "pseudowire-dai"
                                        return self.pseudowire_dai

                                    if (child_yang_name == "pseudowire-ip-source-guard"):
                                        if (self.pseudowire_ip_source_guard is None):
                                            self.pseudowire_ip_source_guard = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireIpSourceGuard()
                                            self.pseudowire_ip_source_guard.parent = self
                                            self._children_name_map["pseudowire_ip_source_guard"] = "pseudowire-ip-source-guard"
                                        return self.pseudowire_ip_source_guard

                                    if (child_yang_name == "pseudowire-mac"):
                                        if (self.pseudowire_mac is None):
                                            self.pseudowire_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireMac()
                                            self.pseudowire_mac.parent = self
                                            self._children_name_map["pseudowire_mac"] = "pseudowire-mac"
                                        return self.pseudowire_mac

                                    if (child_yang_name == "pseudowire-profile"):
                                        if (self.pseudowire_profile is None):
                                            self.pseudowire_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire.PseudowireProfile()
                                            self.pseudowire_profile.parent = self
                                            self._children_name_map["pseudowire_profile"] = "pseudowire-profile"
                                        return self.pseudowire_profile

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bd-pw-mpls-static-labels" or name == "bd-pw-split-horizon" or name == "bd-pw-static-mac-addresses" or name == "bdpw-storm-control-types" or name == "bridge-domain-backup-pseudowires" or name == "pseudowire-dai" or name == "pseudowire-ip-source-guard" or name == "pseudowire-mac" or name == "pseudowire-profile" or name == "neighbor" or name == "pseudowire-id" or name == "bd-pw-class" or name == "pseudowire-flooding" or name == "pseudowire-flooding-unknown-unicast" or name == "pseudowire-igmp-snoop" or name == "pseudowire-mld-snoop"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "neighbor"):
                                        self.neighbor = value
                                        self.neighbor.value_namespace = name_space
                                        self.neighbor.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pseudowire-id"):
                                        self.pseudowire_id = value
                                        self.pseudowire_id.value_namespace = name_space
                                        self.pseudowire_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bd-pw-class"):
                                        self.bd_pw_class = value
                                        self.bd_pw_class.value_namespace = name_space
                                        self.bd_pw_class.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pseudowire-flooding"):
                                        self.pseudowire_flooding = value
                                        self.pseudowire_flooding.value_namespace = name_space
                                        self.pseudowire_flooding.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pseudowire-flooding-unknown-unicast"):
                                        self.pseudowire_flooding_unknown_unicast = value
                                        self.pseudowire_flooding_unknown_unicast.value_namespace = name_space
                                        self.pseudowire_flooding_unknown_unicast.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pseudowire-igmp-snoop"):
                                        self.pseudowire_igmp_snoop = value
                                        self.pseudowire_igmp_snoop.value_namespace = name_space
                                        self.pseudowire_igmp_snoop.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pseudowire-mld-snoop"):
                                        self.pseudowire_mld_snoop = value
                                        self.pseudowire_mld_snoop.value_namespace = name_space
                                        self.pseudowire_mld_snoop.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.bd_pseudowire:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.bd_pseudowire:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bd-pseudowires" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bd-pseudowire"):
                                    for c in self.bd_pseudowire:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires.BdPseudowire()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.bd_pseudowire.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bd-pseudowire"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Vfis(Entity):
                            """
                            Specify the virtual forwarding interface
                            name
                            
                            .. attribute:: vfi
                            
                            	Name of the Virtual Forwarding Interface
                            	**type**\: list of    :py:class:`Vfi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis, self).__init__()

                                self.yang_name = "vfis"
                                self.yang_parent_name = "bridge-domain"

                                self.vfi = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis, self).__setattr__(name, value)


                            class Vfi(Entity):
                                """
                                Name of the Virtual Forwarding Interface
                                
                                .. attribute:: name  <key>
                                
                                	Name of the Virtual Forwarding Interface
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: bgp_auto_discovery
                                
                                	Enable Autodiscovery BGP in this VFI
                                	**type**\:   :py:class:`BgpAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery>`
                                
                                .. attribute:: multicast_p2mp
                                
                                	Enable Multicast P2MP in this VFI
                                	**type**\:   :py:class:`MulticastP2Mp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp>`
                                
                                .. attribute:: vfi_pseudowires
                                
                                	List of pseudowires
                                	**type**\:   :py:class:`VfiPseudowires <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires>`
                                
                                .. attribute:: vfi_shutdown
                                
                                	Enabling Shutdown
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: vpnid
                                
                                	VPN Identifier
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi, self).__init__()

                                    self.yang_name = "vfi"
                                    self.yang_parent_name = "vfis"

                                    self.name = YLeaf(YType.str, "name")

                                    self.vfi_shutdown = YLeaf(YType.empty, "vfi-shutdown")

                                    self.vpnid = YLeaf(YType.uint32, "vpnid")

                                    self.bgp_auto_discovery = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery()
                                    self.bgp_auto_discovery.parent = self
                                    self._children_name_map["bgp_auto_discovery"] = "bgp-auto-discovery"
                                    self._children_yang_names.add("bgp-auto-discovery")

                                    self.multicast_p2mp = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp()
                                    self.multicast_p2mp.parent = self
                                    self._children_name_map["multicast_p2mp"] = "multicast-p2mp"
                                    self._children_yang_names.add("multicast-p2mp")

                                    self.vfi_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires()
                                    self.vfi_pseudowires.parent = self
                                    self._children_name_map["vfi_pseudowires"] = "vfi-pseudowires"
                                    self._children_yang_names.add("vfi-pseudowires")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("name",
                                                    "vfi_shutdown",
                                                    "vpnid") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi, self).__setattr__(name, value)


                                class MulticastP2Mp(Entity):
                                    """
                                    Enable Multicast P2MP in this VFI
                                    
                                    .. attribute:: enable
                                    
                                    	Enable Autodiscovery P2MP
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: signalings
                                    
                                    	Multicast P2MP Signaling Type
                                    	**type**\:   :py:class:`Signalings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings>`
                                    
                                    .. attribute:: transports
                                    
                                    	Multicast P2MP Transport
                                    	**type**\:   :py:class:`Transports <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp, self).__init__()

                                        self.yang_name = "multicast-p2mp"
                                        self.yang_parent_name = "vfi"

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.signalings = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings()
                                        self.signalings.parent = self
                                        self._children_name_map["signalings"] = "signalings"
                                        self._children_yang_names.add("signalings")

                                        self.transports = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports()
                                        self.transports.parent = self
                                        self._children_name_map["transports"] = "transports"
                                        self._children_yang_names.add("transports")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("enable") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp, self).__setattr__(name, value)


                                    class Transports(Entity):
                                        """
                                        Multicast P2MP Transport
                                        
                                        .. attribute:: transport
                                        
                                        	Multicast P2MP Transport Type
                                        	**type**\: list of    :py:class:`Transport <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports.Transport>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports, self).__init__()

                                            self.yang_name = "transports"
                                            self.yang_parent_name = "multicast-p2mp"

                                            self.transport = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports, self).__setattr__(name, value)


                                        class Transport(Entity):
                                            """
                                            Multicast P2MP Transport Type
                                            
                                            .. attribute:: transport_name  <key>
                                            
                                            	Transport Type
                                            	**type**\:  str
                                            
                                            	**pattern:** (RSVP\_TE)
                                            
                                            .. attribute:: attribute_set_name
                                            
                                            	Multicast P2MP TE Attribute Set Name
                                            	**type**\:  str
                                            
                                            	**length:** 1..64
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports.Transport, self).__init__()

                                                self.yang_name = "transport"
                                                self.yang_parent_name = "transports"

                                                self.transport_name = YLeaf(YType.str, "transport-name")

                                                self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("transport_name",
                                                                "attribute_set_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports.Transport, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports.Transport, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.transport_name.is_set or
                                                    self.attribute_set_name.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.transport_name.yfilter != YFilter.not_set or
                                                    self.attribute_set_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "transport" + "[transport-name='" + self.transport_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.transport_name.is_set or self.transport_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.transport_name.get_name_leafdata())
                                                if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.attribute_set_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "transport-name" or name == "attribute-set-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "transport-name"):
                                                    self.transport_name = value
                                                    self.transport_name.value_namespace = name_space
                                                    self.transport_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "attribute-set-name"):
                                                    self.attribute_set_name = value
                                                    self.attribute_set_name.value_namespace = name_space
                                                    self.attribute_set_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.transport:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.transport:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "transports" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "transport"):
                                                for c in self.transport:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports.Transport()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.transport.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "transport"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class Signalings(Entity):
                                        """
                                        Multicast P2MP Signaling Type
                                        
                                        .. attribute:: signaling
                                        
                                        	Multicast P2MP Signaling Type
                                        	**type**\: list of    :py:class:`Signaling <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings.Signaling>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings, self).__init__()

                                            self.yang_name = "signalings"
                                            self.yang_parent_name = "multicast-p2mp"

                                            self.signaling = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings, self).__setattr__(name, value)


                                        class Signaling(Entity):
                                            """
                                            Multicast P2MP Signaling Type
                                            
                                            .. attribute:: signaling_name  <key>
                                            
                                            	Signaling Type
                                            	**type**\:  str
                                            
                                            	**pattern:** (BGP)
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings.Signaling, self).__init__()

                                                self.yang_name = "signaling"
                                                self.yang_parent_name = "signalings"

                                                self.signaling_name = YLeaf(YType.str, "signaling-name")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("signaling_name") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings.Signaling, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings.Signaling, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.signaling_name.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.signaling_name.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "signaling" + "[signaling-name='" + self.signaling_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.signaling_name.is_set or self.signaling_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.signaling_name.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "signaling-name"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "signaling-name"):
                                                    self.signaling_name = value
                                                    self.signaling_name.value_namespace = name_space
                                                    self.signaling_name.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.signaling:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.signaling:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "signalings" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "signaling"):
                                                for c in self.signaling:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings.Signaling()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.signaling.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "signaling"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.enable.is_set or
                                            (self.signalings is not None and self.signalings.has_data()) or
                                            (self.transports is not None and self.transports.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            (self.signalings is not None and self.signalings.has_operation()) or
                                            (self.transports is not None and self.transports.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "multicast-p2mp" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "signalings"):
                                            if (self.signalings is None):
                                                self.signalings = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Signalings()
                                                self.signalings.parent = self
                                                self._children_name_map["signalings"] = "signalings"
                                            return self.signalings

                                        if (child_yang_name == "transports"):
                                            if (self.transports is None):
                                                self.transports = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp.Transports()
                                                self.transports.parent = self
                                                self._children_name_map["transports"] = "transports"
                                            return self.transports

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "signalings" or name == "transports" or name == "enable"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix


                                class VfiPseudowires(Entity):
                                    """
                                    List of pseudowires
                                    
                                    .. attribute:: vfi_pseudowire
                                    
                                    	Pseudowire configuration
                                    	**type**\: list of    :py:class:`VfiPseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires, self).__init__()

                                        self.yang_name = "vfi-pseudowires"
                                        self.yang_parent_name = "vfi"

                                        self.vfi_pseudowire = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires, self).__setattr__(name, value)


                                    class VfiPseudowire(Entity):
                                        """
                                        Pseudowire configuration
                                        
                                        .. attribute:: neighbor  <key>
                                        
                                        	Neighbor IP address
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: pseudowire_id  <key>
                                        
                                        	Pseudowire ID
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        .. attribute:: pseudowire_static_mac_addresses
                                        
                                        	Static Mac Address Table
                                        	**type**\:   :py:class:`PseudowireStaticMacAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses>`
                                        
                                        .. attribute:: vfi_pw_class
                                        
                                        	PW class template name to use for this pseudowire
                                        	**type**\:  str
                                        
                                        	**length:** 1..32
                                        
                                        .. attribute:: vfi_pw_dhcp_snoop
                                        
                                        	Attach a DHCP Snooping profile
                                        	**type**\:   :py:class:`VfiPwDhcpSnoop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwDhcpSnoop>`
                                        
                                        .. attribute:: vfi_pw_igmp_snoop
                                        
                                        	Attach a IGMP Snooping profile
                                        	**type**\:  str
                                        
                                        	**length:** 1..32
                                        
                                        .. attribute:: vfi_pw_mld_snoop
                                        
                                        	Attach a MLD Snooping profile
                                        	**type**\:  str
                                        
                                        	**length:** 1..32
                                        
                                        .. attribute:: vfi_pw_mpls_static_labels
                                        
                                        	MPLS static labels
                                        	**type**\:   :py:class:`VfiPwMplsStaticLabels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwMplsStaticLabels>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire, self).__init__()

                                            self.yang_name = "vfi-pseudowire"
                                            self.yang_parent_name = "vfi-pseudowires"

                                            self.neighbor = YLeaf(YType.str, "neighbor")

                                            self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                                            self.vfi_pw_class = YLeaf(YType.str, "vfi-pw-class")

                                            self.vfi_pw_igmp_snoop = YLeaf(YType.str, "vfi-pw-igmp-snoop")

                                            self.vfi_pw_mld_snoop = YLeaf(YType.str, "vfi-pw-mld-snoop")

                                            self.pseudowire_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses()
                                            self.pseudowire_static_mac_addresses.parent = self
                                            self._children_name_map["pseudowire_static_mac_addresses"] = "pseudowire-static-mac-addresses"
                                            self._children_yang_names.add("pseudowire-static-mac-addresses")

                                            self.vfi_pw_dhcp_snoop = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwDhcpSnoop()
                                            self.vfi_pw_dhcp_snoop.parent = self
                                            self._children_name_map["vfi_pw_dhcp_snoop"] = "vfi-pw-dhcp-snoop"
                                            self._children_yang_names.add("vfi-pw-dhcp-snoop")

                                            self.vfi_pw_mpls_static_labels = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwMplsStaticLabels()
                                            self.vfi_pw_mpls_static_labels.parent = self
                                            self._children_name_map["vfi_pw_mpls_static_labels"] = "vfi-pw-mpls-static-labels"
                                            self._children_yang_names.add("vfi-pw-mpls-static-labels")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("neighbor",
                                                            "pseudowire_id",
                                                            "vfi_pw_class",
                                                            "vfi_pw_igmp_snoop",
                                                            "vfi_pw_mld_snoop") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire, self).__setattr__(name, value)


                                        class VfiPwDhcpSnoop(Entity):
                                            """
                                            Attach a DHCP Snooping profile
                                            
                                            .. attribute:: dhcp_snooping_id
                                            
                                            	Disable DHCP snooping
                                            	**type**\:  str
                                            
                                            .. attribute:: profile_id
                                            
                                            	Set the snooping profile
                                            	**type**\:   :py:class:`InterfaceProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceProfile>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwDhcpSnoop, self).__init__()

                                                self.yang_name = "vfi-pw-dhcp-snoop"
                                                self.yang_parent_name = "vfi-pseudowire"

                                                self.dhcp_snooping_id = YLeaf(YType.str, "dhcp-snooping-id")

                                                self.profile_id = YLeaf(YType.enumeration, "profile-id")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("dhcp_snooping_id",
                                                                "profile_id") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwDhcpSnoop, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwDhcpSnoop, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.dhcp_snooping_id.is_set or
                                                    self.profile_id.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.dhcp_snooping_id.yfilter != YFilter.not_set or
                                                    self.profile_id.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "vfi-pw-dhcp-snoop" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.dhcp_snooping_id.is_set or self.dhcp_snooping_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.dhcp_snooping_id.get_name_leafdata())
                                                if (self.profile_id.is_set or self.profile_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.profile_id.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "dhcp-snooping-id" or name == "profile-id"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "dhcp-snooping-id"):
                                                    self.dhcp_snooping_id = value
                                                    self.dhcp_snooping_id.value_namespace = name_space
                                                    self.dhcp_snooping_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "profile-id"):
                                                    self.profile_id = value
                                                    self.profile_id.value_namespace = name_space
                                                    self.profile_id.value_namespace_prefix = name_space_prefix


                                        class VfiPwMplsStaticLabels(Entity):
                                            """
                                            MPLS static labels
                                            
                                            .. attribute:: local_static_label
                                            
                                            	Pseudowire local static label
                                            	**type**\:  int
                                            
                                            	**range:** 16..1048575
                                            
                                            .. attribute:: remote_static_label
                                            
                                            	Pseudowire remote static label
                                            	**type**\:  int
                                            
                                            	**range:** 16..1048575
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwMplsStaticLabels, self).__init__()

                                                self.yang_name = "vfi-pw-mpls-static-labels"
                                                self.yang_parent_name = "vfi-pseudowire"

                                                self.local_static_label = YLeaf(YType.uint32, "local-static-label")

                                                self.remote_static_label = YLeaf(YType.uint32, "remote-static-label")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("local_static_label",
                                                                "remote_static_label") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwMplsStaticLabels, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwMplsStaticLabels, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.local_static_label.is_set or
                                                    self.remote_static_label.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.local_static_label.yfilter != YFilter.not_set or
                                                    self.remote_static_label.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "vfi-pw-mpls-static-labels" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.local_static_label.is_set or self.local_static_label.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.local_static_label.get_name_leafdata())
                                                if (self.remote_static_label.is_set or self.remote_static_label.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.remote_static_label.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "local-static-label" or name == "remote-static-label"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "local-static-label"):
                                                    self.local_static_label = value
                                                    self.local_static_label.value_namespace = name_space
                                                    self.local_static_label.value_namespace_prefix = name_space_prefix
                                                if(value_path == "remote-static-label"):
                                                    self.remote_static_label = value
                                                    self.remote_static_label.value_namespace = name_space
                                                    self.remote_static_label.value_namespace_prefix = name_space_prefix


                                        class PseudowireStaticMacAddresses(Entity):
                                            """
                                            Static Mac Address Table
                                            
                                            .. attribute:: pseudowire_static_mac_address
                                            
                                            	Static Mac Address Configuration
                                            	**type**\: list of    :py:class:`PseudowireStaticMacAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses.PseudowireStaticMacAddress>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses, self).__init__()

                                                self.yang_name = "pseudowire-static-mac-addresses"
                                                self.yang_parent_name = "vfi-pseudowire"

                                                self.pseudowire_static_mac_address = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses, self).__setattr__(name, value)


                                            class PseudowireStaticMacAddress(Entity):
                                                """
                                                Static Mac Address Configuration
                                                
                                                .. attribute:: address  <key>
                                                
                                                	Static MAC address
                                                	**type**\:  str
                                                
                                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                                
                                                

                                                """

                                                _prefix = 'l2vpn-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses.PseudowireStaticMacAddress, self).__init__()

                                                    self.yang_name = "pseudowire-static-mac-address"
                                                    self.yang_parent_name = "pseudowire-static-mac-addresses"

                                                    self.address = YLeaf(YType.str, "address")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("address") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses.PseudowireStaticMacAddress, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses.PseudowireStaticMacAddress, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.address.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.address.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "pseudowire-static-mac-address" + "[address='" + self.address.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.address.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "address"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "address"):
                                                        self.address = value
                                                        self.address.value_namespace = name_space
                                                        self.address.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.pseudowire_static_mac_address:
                                                    if (c.has_data()):
                                                        return True
                                                return False

                                            def has_operation(self):
                                                for c in self.pseudowire_static_mac_address:
                                                    if (c.has_operation()):
                                                        return True
                                                return self.yfilter != YFilter.not_set

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "pseudowire-static-mac-addresses" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "pseudowire-static-mac-address"):
                                                    for c in self.pseudowire_static_mac_address:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses.PseudowireStaticMacAddress()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.pseudowire_static_mac_address.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "pseudowire-static-mac-address"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.neighbor.is_set or
                                                self.pseudowire_id.is_set or
                                                self.vfi_pw_class.is_set or
                                                self.vfi_pw_igmp_snoop.is_set or
                                                self.vfi_pw_mld_snoop.is_set or
                                                (self.pseudowire_static_mac_addresses is not None and self.pseudowire_static_mac_addresses.has_data()) or
                                                (self.vfi_pw_dhcp_snoop is not None and self.vfi_pw_dhcp_snoop.has_data()) or
                                                (self.vfi_pw_mpls_static_labels is not None and self.vfi_pw_mpls_static_labels.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.neighbor.yfilter != YFilter.not_set or
                                                self.pseudowire_id.yfilter != YFilter.not_set or
                                                self.vfi_pw_class.yfilter != YFilter.not_set or
                                                self.vfi_pw_igmp_snoop.yfilter != YFilter.not_set or
                                                self.vfi_pw_mld_snoop.yfilter != YFilter.not_set or
                                                (self.pseudowire_static_mac_addresses is not None and self.pseudowire_static_mac_addresses.has_operation()) or
                                                (self.vfi_pw_dhcp_snoop is not None and self.vfi_pw_dhcp_snoop.has_operation()) or
                                                (self.vfi_pw_mpls_static_labels is not None and self.vfi_pw_mpls_static_labels.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "vfi-pseudowire" + "[neighbor='" + self.neighbor.get() + "']" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.neighbor.get_name_leafdata())
                                            if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pseudowire_id.get_name_leafdata())
                                            if (self.vfi_pw_class.is_set or self.vfi_pw_class.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.vfi_pw_class.get_name_leafdata())
                                            if (self.vfi_pw_igmp_snoop.is_set or self.vfi_pw_igmp_snoop.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.vfi_pw_igmp_snoop.get_name_leafdata())
                                            if (self.vfi_pw_mld_snoop.is_set or self.vfi_pw_mld_snoop.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.vfi_pw_mld_snoop.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "pseudowire-static-mac-addresses"):
                                                if (self.pseudowire_static_mac_addresses is None):
                                                    self.pseudowire_static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.PseudowireStaticMacAddresses()
                                                    self.pseudowire_static_mac_addresses.parent = self
                                                    self._children_name_map["pseudowire_static_mac_addresses"] = "pseudowire-static-mac-addresses"
                                                return self.pseudowire_static_mac_addresses

                                            if (child_yang_name == "vfi-pw-dhcp-snoop"):
                                                if (self.vfi_pw_dhcp_snoop is None):
                                                    self.vfi_pw_dhcp_snoop = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwDhcpSnoop()
                                                    self.vfi_pw_dhcp_snoop.parent = self
                                                    self._children_name_map["vfi_pw_dhcp_snoop"] = "vfi-pw-dhcp-snoop"
                                                return self.vfi_pw_dhcp_snoop

                                            if (child_yang_name == "vfi-pw-mpls-static-labels"):
                                                if (self.vfi_pw_mpls_static_labels is None):
                                                    self.vfi_pw_mpls_static_labels = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire.VfiPwMplsStaticLabels()
                                                    self.vfi_pw_mpls_static_labels.parent = self
                                                    self._children_name_map["vfi_pw_mpls_static_labels"] = "vfi-pw-mpls-static-labels"
                                                return self.vfi_pw_mpls_static_labels

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pseudowire-static-mac-addresses" or name == "vfi-pw-dhcp-snoop" or name == "vfi-pw-mpls-static-labels" or name == "neighbor" or name == "pseudowire-id" or name == "vfi-pw-class" or name == "vfi-pw-igmp-snoop" or name == "vfi-pw-mld-snoop"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "neighbor"):
                                                self.neighbor = value
                                                self.neighbor.value_namespace = name_space
                                                self.neighbor.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pseudowire-id"):
                                                self.pseudowire_id = value
                                                self.pseudowire_id.value_namespace = name_space
                                                self.pseudowire_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "vfi-pw-class"):
                                                self.vfi_pw_class = value
                                                self.vfi_pw_class.value_namespace = name_space
                                                self.vfi_pw_class.value_namespace_prefix = name_space_prefix
                                            if(value_path == "vfi-pw-igmp-snoop"):
                                                self.vfi_pw_igmp_snoop = value
                                                self.vfi_pw_igmp_snoop.value_namespace = name_space
                                                self.vfi_pw_igmp_snoop.value_namespace_prefix = name_space_prefix
                                            if(value_path == "vfi-pw-mld-snoop"):
                                                self.vfi_pw_mld_snoop = value
                                                self.vfi_pw_mld_snoop.value_namespace = name_space
                                                self.vfi_pw_mld_snoop.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.vfi_pseudowire:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.vfi_pseudowire:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "vfi-pseudowires" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "vfi-pseudowire"):
                                            for c in self.vfi_pseudowire:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires.VfiPseudowire()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.vfi_pseudowire.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "vfi-pseudowire"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class BgpAutoDiscovery(Entity):
                                    """
                                    Enable Autodiscovery BGP in this VFI
                                    
                                    .. attribute:: ad_control_word
                                    
                                    	Enable control\-word for this VFI
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: bgp_route_policy
                                    
                                    	Route policy
                                    	**type**\:   :py:class:`BgpRoutePolicy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpRoutePolicy>`
                                    
                                    .. attribute:: bgp_signaling_protocol
                                    
                                    	Enable Signaling Protocol BGP in this VFI
                                    	**type**\:   :py:class:`BgpSignalingProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol>`
                                    
                                    .. attribute:: enable
                                    
                                    	Enable Autodiscovery BGP
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: ldp_signaling_protocol
                                    
                                    	Signaling Protocol LDP in this VFI configuration
                                    	**type**\:   :py:class:`LdpSignalingProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol>`
                                    
                                    .. attribute:: route_distinguisher
                                    
                                    	Route Distinguisher
                                    	**type**\:   :py:class:`RouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteDistinguisher>`
                                    
                                    .. attribute:: route_targets
                                    
                                    	Route Target
                                    	**type**\:   :py:class:`RouteTargets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets>`
                                    
                                    .. attribute:: table_policy
                                    
                                    	Table Policy for installation of forwarding data to L2FIB
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery, self).__init__()

                                        self.yang_name = "bgp-auto-discovery"
                                        self.yang_parent_name = "vfi"

                                        self.ad_control_word = YLeaf(YType.empty, "ad-control-word")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.table_policy = YLeaf(YType.str, "table-policy")

                                        self.bgp_route_policy = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpRoutePolicy()
                                        self.bgp_route_policy.parent = self
                                        self._children_name_map["bgp_route_policy"] = "bgp-route-policy"
                                        self._children_yang_names.add("bgp-route-policy")

                                        self.bgp_signaling_protocol = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol()
                                        self.bgp_signaling_protocol.parent = self
                                        self._children_name_map["bgp_signaling_protocol"] = "bgp-signaling-protocol"
                                        self._children_yang_names.add("bgp-signaling-protocol")

                                        self.ldp_signaling_protocol = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol()
                                        self.ldp_signaling_protocol.parent = self
                                        self._children_name_map["ldp_signaling_protocol"] = "ldp-signaling-protocol"
                                        self._children_yang_names.add("ldp-signaling-protocol")

                                        self.route_distinguisher = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteDistinguisher()
                                        self.route_distinguisher.parent = self
                                        self._children_name_map["route_distinguisher"] = "route-distinguisher"
                                        self._children_yang_names.add("route-distinguisher")

                                        self.route_targets = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets()
                                        self.route_targets.parent = self
                                        self._children_name_map["route_targets"] = "route-targets"
                                        self._children_yang_names.add("route-targets")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("ad_control_word",
                                                        "enable",
                                                        "table_policy") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery, self).__setattr__(name, value)


                                    class LdpSignalingProtocol(Entity):
                                        """
                                        Signaling Protocol LDP in this VFI
                                        configuration
                                        
                                        .. attribute:: enable
                                        
                                        	Enable LDP as Signaling Protocol .Deletion of this object also causes deletion of all objects under LDPSignalingProtocol
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: flow_label_load_balance
                                        
                                        	Enable Flow Label based load balancing
                                        	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.FlowLabelLoadBalance>`
                                        
                                        .. attribute:: vplsid
                                        
                                        	VPLS ID
                                        	**type**\:   :py:class:`Vplsid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.Vplsid>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol, self).__init__()

                                            self.yang_name = "ldp-signaling-protocol"
                                            self.yang_parent_name = "bgp-auto-discovery"

                                            self.enable = YLeaf(YType.empty, "enable")

                                            self.flow_label_load_balance = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.FlowLabelLoadBalance()
                                            self.flow_label_load_balance.parent = self
                                            self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                                            self._children_yang_names.add("flow-label-load-balance")

                                            self.vplsid = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.Vplsid()
                                            self.vplsid.parent = self
                                            self._children_name_map["vplsid"] = "vplsid"
                                            self._children_yang_names.add("vplsid")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("enable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol, self).__setattr__(name, value)


                                        class Vplsid(Entity):
                                            """
                                            VPLS ID
                                            
                                            .. attribute:: address
                                            
                                            	IPV4 address
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: address_index
                                            
                                            	Address index
                                            	**type**\:  int
                                            
                                            	**range:** 0..32767
                                            
                                            .. attribute:: as_
                                            
                                            	Two byte AS number
                                            	**type**\:  int
                                            
                                            	**range:** 1..65535
                                            
                                            .. attribute:: as_index
                                            
                                            	AS index
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: type
                                            
                                            	VPLS\-ID Type
                                            	**type**\:   :py:class:`LdpVplsId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.LdpVplsId>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.Vplsid, self).__init__()

                                                self.yang_name = "vplsid"
                                                self.yang_parent_name = "ldp-signaling-protocol"

                                                self.address = YLeaf(YType.str, "address")

                                                self.address_index = YLeaf(YType.uint32, "address-index")

                                                self.as_ = YLeaf(YType.uint32, "as")

                                                self.as_index = YLeaf(YType.uint32, "as-index")

                                                self.type = YLeaf(YType.enumeration, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("address",
                                                                "address_index",
                                                                "as_",
                                                                "as_index",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.Vplsid, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.Vplsid, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.address.is_set or
                                                    self.address_index.is_set or
                                                    self.as_.is_set or
                                                    self.as_index.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.address.yfilter != YFilter.not_set or
                                                    self.address_index.yfilter != YFilter.not_set or
                                                    self.as_.yfilter != YFilter.not_set or
                                                    self.as_index.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "vplsid" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.address.get_name_leafdata())
                                                if (self.address_index.is_set or self.address_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.address_index.get_name_leafdata())
                                                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.as_.get_name_leafdata())
                                                if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.as_index.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "address" or name == "address-index" or name == "as" or name == "as-index" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "address"):
                                                    self.address = value
                                                    self.address.value_namespace = name_space
                                                    self.address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "address-index"):
                                                    self.address_index = value
                                                    self.address_index.value_namespace = name_space
                                                    self.address_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "as"):
                                                    self.as_ = value
                                                    self.as_.value_namespace = name_space
                                                    self.as_.value_namespace_prefix = name_space_prefix
                                                if(value_path == "as-index"):
                                                    self.as_index = value
                                                    self.as_index.value_namespace = name_space
                                                    self.as_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix


                                        class FlowLabelLoadBalance(Entity):
                                            """
                                            Enable Flow Label based load balancing
                                            
                                            .. attribute:: flow_label
                                            
                                            	Flow Label load balance type
                                            	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.FlowLabelLoadBalance>`
                                            
                                            .. attribute:: static
                                            
                                            	Static Flow Label
                                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.FlowLabelLoadBalance, self).__init__()

                                                self.yang_name = "flow-label-load-balance"
                                                self.yang_parent_name = "ldp-signaling-protocol"

                                                self.flow_label = YLeaf(YType.enumeration, "flow-label")

                                                self.static = YLeaf(YType.empty, "static")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("flow_label",
                                                                "static") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.FlowLabelLoadBalance, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.FlowLabelLoadBalance, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.flow_label.is_set or
                                                    self.static.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.flow_label.yfilter != YFilter.not_set or
                                                    self.static.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "flow-label-load-balance" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.flow_label.is_set or self.flow_label.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.flow_label.get_name_leafdata())
                                                if (self.static.is_set or self.static.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.static.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "flow-label" or name == "static"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "flow-label"):
                                                    self.flow_label = value
                                                    self.flow_label.value_namespace = name_space
                                                    self.flow_label.value_namespace_prefix = name_space_prefix
                                                if(value_path == "static"):
                                                    self.static = value
                                                    self.static.value_namespace = name_space
                                                    self.static.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.enable.is_set or
                                                (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_data()) or
                                                (self.vplsid is not None and self.vplsid.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_operation()) or
                                                (self.vplsid is not None and self.vplsid.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-signaling-protocol" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "flow-label-load-balance"):
                                                if (self.flow_label_load_balance is None):
                                                    self.flow_label_load_balance = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.FlowLabelLoadBalance()
                                                    self.flow_label_load_balance.parent = self
                                                    self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                                                return self.flow_label_load_balance

                                            if (child_yang_name == "vplsid"):
                                                if (self.vplsid is None):
                                                    self.vplsid = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol.Vplsid()
                                                    self.vplsid.parent = self
                                                    self._children_name_map["vplsid"] = "vplsid"
                                                return self.vplsid

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "flow-label-load-balance" or name == "vplsid" or name == "enable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix


                                    class BgpRoutePolicy(Entity):
                                        """
                                        Route policy
                                        
                                        .. attribute:: export
                                        
                                        	Export route policy
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpRoutePolicy, self).__init__()

                                            self.yang_name = "bgp-route-policy"
                                            self.yang_parent_name = "bgp-auto-discovery"

                                            self.export = YLeaf(YType.str, "export")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("export") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpRoutePolicy, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpRoutePolicy, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.export.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.export.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bgp-route-policy" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.export.is_set or self.export.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.export.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "export"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "export"):
                                                self.export = value
                                                self.export.value_namespace = name_space
                                                self.export.value_namespace_prefix = name_space_prefix


                                    class RouteDistinguisher(Entity):
                                        """
                                        Route Distinguisher
                                        
                                        .. attribute:: addr_index
                                        
                                        	Addr index
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        .. attribute:: address
                                        
                                        	IPV4 address
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: as_
                                        
                                        	Two byte or 4 byte AS number
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        .. attribute:: as_index
                                        
                                        	AS\:nn (hex or decimal format)
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: type
                                        
                                        	Router Distinguisher Type
                                        	**type**\:   :py:class:`BgpRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteDistinguisher>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteDistinguisher, self).__init__()

                                            self.yang_name = "route-distinguisher"
                                            self.yang_parent_name = "bgp-auto-discovery"

                                            self.addr_index = YLeaf(YType.uint32, "addr-index")

                                            self.address = YLeaf(YType.str, "address")

                                            self.as_ = YLeaf(YType.uint32, "as")

                                            self.as_index = YLeaf(YType.uint32, "as-index")

                                            self.type = YLeaf(YType.enumeration, "type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("addr_index",
                                                            "address",
                                                            "as_",
                                                            "as_index",
                                                            "type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteDistinguisher, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteDistinguisher, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.addr_index.is_set or
                                                self.address.is_set or
                                                self.as_.is_set or
                                                self.as_index.is_set or
                                                self.type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.addr_index.yfilter != YFilter.not_set or
                                                self.address.yfilter != YFilter.not_set or
                                                self.as_.yfilter != YFilter.not_set or
                                                self.as_index.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-distinguisher" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.addr_index.get_name_leafdata())
                                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.address.get_name_leafdata())
                                            if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.as_.get_name_leafdata())
                                            if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.as_index.get_name_leafdata())
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "addr-index"):
                                                self.addr_index = value
                                                self.addr_index.value_namespace = name_space
                                                self.addr_index.value_namespace_prefix = name_space_prefix
                                            if(value_path == "address"):
                                                self.address = value
                                                self.address.value_namespace = name_space
                                                self.address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "as"):
                                                self.as_ = value
                                                self.as_.value_namespace = name_space
                                                self.as_.value_namespace_prefix = name_space_prefix
                                            if(value_path == "as-index"):
                                                self.as_index = value
                                                self.as_index.value_namespace = name_space
                                                self.as_index.value_namespace_prefix = name_space_prefix
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix


                                    class BgpSignalingProtocol(Entity):
                                        """
                                        Enable Signaling Protocol BGP in this
                                        VFI
                                        
                                        .. attribute:: enable
                                        
                                        	Enable BGP as Signaling Protocol
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: flow_label_load_balance
                                        
                                        	Enable Flow Label based load balancing
                                        	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol.FlowLabelLoadBalance>`
                                        
                                        .. attribute:: ve_range
                                        
                                        	Local Virtual Edge Block Configurable Range
                                        	**type**\:  int
                                        
                                        	**range:** 11..100
                                        
                                        .. attribute:: veid
                                        
                                        	Local Virtual Edge Identifier
                                        	**type**\:  int
                                        
                                        	**range:** 1..16384
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol, self).__init__()

                                            self.yang_name = "bgp-signaling-protocol"
                                            self.yang_parent_name = "bgp-auto-discovery"

                                            self.enable = YLeaf(YType.empty, "enable")

                                            self.ve_range = YLeaf(YType.uint32, "ve-range")

                                            self.veid = YLeaf(YType.uint32, "veid")

                                            self.flow_label_load_balance = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol.FlowLabelLoadBalance()
                                            self.flow_label_load_balance.parent = self
                                            self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                                            self._children_yang_names.add("flow-label-load-balance")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("enable",
                                                            "ve_range",
                                                            "veid") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol, self).__setattr__(name, value)


                                        class FlowLabelLoadBalance(Entity):
                                            """
                                            Enable Flow Label based load balancing
                                            
                                            .. attribute:: flow_label
                                            
                                            	Flow Label load balance type
                                            	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.FlowLabelLoadBalance>`
                                            
                                            .. attribute:: static
                                            
                                            	Static Flow Label
                                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol.FlowLabelLoadBalance, self).__init__()

                                                self.yang_name = "flow-label-load-balance"
                                                self.yang_parent_name = "bgp-signaling-protocol"

                                                self.flow_label = YLeaf(YType.enumeration, "flow-label")

                                                self.static = YLeaf(YType.empty, "static")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("flow_label",
                                                                "static") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol.FlowLabelLoadBalance, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol.FlowLabelLoadBalance, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.flow_label.is_set or
                                                    self.static.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.flow_label.yfilter != YFilter.not_set or
                                                    self.static.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "flow-label-load-balance" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.flow_label.is_set or self.flow_label.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.flow_label.get_name_leafdata())
                                                if (self.static.is_set or self.static.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.static.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "flow-label" or name == "static"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "flow-label"):
                                                    self.flow_label = value
                                                    self.flow_label.value_namespace = name_space
                                                    self.flow_label.value_namespace_prefix = name_space_prefix
                                                if(value_path == "static"):
                                                    self.static = value
                                                    self.static.value_namespace = name_space
                                                    self.static.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.enable.is_set or
                                                self.ve_range.is_set or
                                                self.veid.is_set or
                                                (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.ve_range.yfilter != YFilter.not_set or
                                                self.veid.yfilter != YFilter.not_set or
                                                (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bgp-signaling-protocol" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.ve_range.is_set or self.ve_range.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.ve_range.get_name_leafdata())
                                            if (self.veid.is_set or self.veid.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.veid.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "flow-label-load-balance"):
                                                if (self.flow_label_load_balance is None):
                                                    self.flow_label_load_balance = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol.FlowLabelLoadBalance()
                                                    self.flow_label_load_balance.parent = self
                                                    self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                                                return self.flow_label_load_balance

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "flow-label-load-balance" or name == "enable" or name == "ve-range" or name == "veid"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "ve-range"):
                                                self.ve_range = value
                                                self.ve_range.value_namespace = name_space
                                                self.ve_range.value_namespace_prefix = name_space_prefix
                                            if(value_path == "veid"):
                                                self.veid = value
                                                self.veid.value_namespace = name_space
                                                self.veid.value_namespace_prefix = name_space_prefix


                                    class RouteTargets(Entity):
                                        """
                                        Route Target
                                        
                                        .. attribute:: route_target
                                        
                                        	Name of the Route Target
                                        	**type**\: list of    :py:class:`RouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets, self).__init__()

                                            self.yang_name = "route-targets"
                                            self.yang_parent_name = "bgp-auto-discovery"

                                            self.route_target = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets, self).__setattr__(name, value)


                                        class RouteTarget(Entity):
                                            """
                                            Name of the Route Target
                                            
                                            .. attribute:: role  <key>
                                            
                                            	Role of the router target type
                                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                                            
                                            .. attribute:: format  <key>
                                            
                                            	Format of the route target
                                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                                            
                                            .. attribute:: ipv4_address
                                            
                                            	ipv4 address
                                            	**type**\: list of    :py:class:`Ipv4Address <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.Ipv4Address>`
                                            
                                            .. attribute:: two_byte_as_or_four_byte_as
                                            
                                            	two byte as or four byte as
                                            	**type**\: list of    :py:class:`TwoByteAsOrFourByteAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.TwoByteAsOrFourByteAs>`
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget, self).__init__()

                                                self.yang_name = "route-target"
                                                self.yang_parent_name = "route-targets"

                                                self.role = YLeaf(YType.enumeration, "role")

                                                self.format = YLeaf(YType.enumeration, "format")

                                                self.ipv4_address = YList(self)
                                                self.two_byte_as_or_four_byte_as = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("role",
                                                                "format") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget, self).__setattr__(name, value)


                                            class TwoByteAsOrFourByteAs(Entity):
                                                """
                                                two byte as or four byte as
                                                
                                                .. attribute:: as_  <key>
                                                
                                                	Two byte or 4 byte AS number
                                                	**type**\:  int
                                                
                                                	**range:** 1..4294967295
                                                
                                                .. attribute:: as_index  <key>
                                                
                                                	AS\:nn (hex or decimal format)
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                

                                                """

                                                _prefix = 'l2vpn-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.TwoByteAsOrFourByteAs, self).__init__()

                                                    self.yang_name = "two-byte-as-or-four-byte-as"
                                                    self.yang_parent_name = "route-target"

                                                    self.as_ = YLeaf(YType.uint32, "as")

                                                    self.as_index = YLeaf(YType.uint32, "as-index")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("as_",
                                                                    "as_index") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.TwoByteAsOrFourByteAs, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.TwoByteAsOrFourByteAs, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.as_.is_set or
                                                        self.as_index.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.as_.yfilter != YFilter.not_set or
                                                        self.as_index.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "two-byte-as-or-four-byte-as" + "[as='" + self.as_.get() + "']" + "[as-index='" + self.as_index.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.as_.get_name_leafdata())
                                                    if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.as_index.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "as" or name == "as-index"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "as"):
                                                        self.as_ = value
                                                        self.as_.value_namespace = name_space
                                                        self.as_.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "as-index"):
                                                        self.as_index = value
                                                        self.as_index.value_namespace = name_space
                                                        self.as_index.value_namespace_prefix = name_space_prefix


                                            class Ipv4Address(Entity):
                                                """
                                                ipv4 address
                                                
                                                .. attribute:: address  <key>
                                                
                                                	IPV4 address
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: addr_index  <key>
                                                
                                                	Addr index
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                

                                                """

                                                _prefix = 'l2vpn-cfg'
                                                _revision = '2015-11-09'

                                                def __init__(self):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.Ipv4Address, self).__init__()

                                                    self.yang_name = "ipv4-address"
                                                    self.yang_parent_name = "route-target"

                                                    self.address = YLeaf(YType.str, "address")

                                                    self.addr_index = YLeaf(YType.uint32, "addr-index")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("address",
                                                                    "addr_index") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.Ipv4Address, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.Ipv4Address, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.address.is_set or
                                                        self.addr_index.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.address.yfilter != YFilter.not_set or
                                                        self.addr_index.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "ipv4-address" + "[address='" + self.address.get() + "']" + "[addr-index='" + self.addr_index.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.address.get_name_leafdata())
                                                    if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.addr_index.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "address" or name == "addr-index"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "address"):
                                                        self.address = value
                                                        self.address.value_namespace = name_space
                                                        self.address.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "addr-index"):
                                                        self.addr_index = value
                                                        self.addr_index.value_namespace = name_space
                                                        self.addr_index.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.ipv4_address:
                                                    if (c.has_data()):
                                                        return True
                                                for c in self.two_byte_as_or_four_byte_as:
                                                    if (c.has_data()):
                                                        return True
                                                return (
                                                    self.role.is_set or
                                                    self.format.is_set)

                                            def has_operation(self):
                                                for c in self.ipv4_address:
                                                    if (c.has_operation()):
                                                        return True
                                                for c in self.two_byte_as_or_four_byte_as:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.role.yfilter != YFilter.not_set or
                                                    self.format.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "route-target" + "[role='" + self.role.get() + "']" + "[format='" + self.format.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.role.get_name_leafdata())
                                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.format.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "ipv4-address"):
                                                    for c in self.ipv4_address:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.Ipv4Address()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.ipv4_address.append(c)
                                                    return c

                                                if (child_yang_name == "two-byte-as-or-four-byte-as"):
                                                    for c in self.two_byte_as_or_four_byte_as:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget.TwoByteAsOrFourByteAs()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.two_byte_as_or_four_byte_as.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "ipv4-address" or name == "two-byte-as-or-four-byte-as" or name == "role" or name == "format"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "role"):
                                                    self.role = value
                                                    self.role.value_namespace = name_space
                                                    self.role.value_namespace_prefix = name_space_prefix
                                                if(value_path == "format"):
                                                    self.format = value
                                                    self.format.value_namespace = name_space
                                                    self.format.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.route_target:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.route_target:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-targets" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "route-target"):
                                                for c in self.route_target:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets.RouteTarget()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.route_target.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "route-target"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.ad_control_word.is_set or
                                            self.enable.is_set or
                                            self.table_policy.is_set or
                                            (self.bgp_route_policy is not None and self.bgp_route_policy.has_data()) or
                                            (self.bgp_signaling_protocol is not None and self.bgp_signaling_protocol.has_data()) or
                                            (self.ldp_signaling_protocol is not None and self.ldp_signaling_protocol.has_data()) or
                                            (self.route_distinguisher is not None and self.route_distinguisher.has_data()) or
                                            (self.route_targets is not None and self.route_targets.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.ad_control_word.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.table_policy.yfilter != YFilter.not_set or
                                            (self.bgp_route_policy is not None and self.bgp_route_policy.has_operation()) or
                                            (self.bgp_signaling_protocol is not None and self.bgp_signaling_protocol.has_operation()) or
                                            (self.ldp_signaling_protocol is not None and self.ldp_signaling_protocol.has_operation()) or
                                            (self.route_distinguisher is not None and self.route_distinguisher.has_operation()) or
                                            (self.route_targets is not None and self.route_targets.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bgp-auto-discovery" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.ad_control_word.is_set or self.ad_control_word.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ad_control_word.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.table_policy.is_set or self.table_policy.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.table_policy.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "bgp-route-policy"):
                                            if (self.bgp_route_policy is None):
                                                self.bgp_route_policy = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpRoutePolicy()
                                                self.bgp_route_policy.parent = self
                                                self._children_name_map["bgp_route_policy"] = "bgp-route-policy"
                                            return self.bgp_route_policy

                                        if (child_yang_name == "bgp-signaling-protocol"):
                                            if (self.bgp_signaling_protocol is None):
                                                self.bgp_signaling_protocol = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.BgpSignalingProtocol()
                                                self.bgp_signaling_protocol.parent = self
                                                self._children_name_map["bgp_signaling_protocol"] = "bgp-signaling-protocol"
                                            return self.bgp_signaling_protocol

                                        if (child_yang_name == "ldp-signaling-protocol"):
                                            if (self.ldp_signaling_protocol is None):
                                                self.ldp_signaling_protocol = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.LdpSignalingProtocol()
                                                self.ldp_signaling_protocol.parent = self
                                                self._children_name_map["ldp_signaling_protocol"] = "ldp-signaling-protocol"
                                            return self.ldp_signaling_protocol

                                        if (child_yang_name == "route-distinguisher"):
                                            if (self.route_distinguisher is None):
                                                self.route_distinguisher = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteDistinguisher()
                                                self.route_distinguisher.parent = self
                                                self._children_name_map["route_distinguisher"] = "route-distinguisher"
                                            return self.route_distinguisher

                                        if (child_yang_name == "route-targets"):
                                            if (self.route_targets is None):
                                                self.route_targets = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery.RouteTargets()
                                                self.route_targets.parent = self
                                                self._children_name_map["route_targets"] = "route-targets"
                                            return self.route_targets

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "bgp-route-policy" or name == "bgp-signaling-protocol" or name == "ldp-signaling-protocol" or name == "route-distinguisher" or name == "route-targets" or name == "ad-control-word" or name == "enable" or name == "table-policy"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "ad-control-word"):
                                            self.ad_control_word = value
                                            self.ad_control_word.value_namespace = name_space
                                            self.ad_control_word.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "table-policy"):
                                            self.table_policy = value
                                            self.table_policy.value_namespace = name_space
                                            self.table_policy.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.name.is_set or
                                        self.vfi_shutdown.is_set or
                                        self.vpnid.is_set or
                                        (self.bgp_auto_discovery is not None and self.bgp_auto_discovery.has_data()) or
                                        (self.multicast_p2mp is not None and self.multicast_p2mp.has_data()) or
                                        (self.vfi_pseudowires is not None and self.vfi_pseudowires.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.name.yfilter != YFilter.not_set or
                                        self.vfi_shutdown.yfilter != YFilter.not_set or
                                        self.vpnid.yfilter != YFilter.not_set or
                                        (self.bgp_auto_discovery is not None and self.bgp_auto_discovery.has_operation()) or
                                        (self.multicast_p2mp is not None and self.multicast_p2mp.has_operation()) or
                                        (self.vfi_pseudowires is not None and self.vfi_pseudowires.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "vfi" + "[name='" + self.name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.name.get_name_leafdata())
                                    if (self.vfi_shutdown.is_set or self.vfi_shutdown.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.vfi_shutdown.get_name_leafdata())
                                    if (self.vpnid.is_set or self.vpnid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.vpnid.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "bgp-auto-discovery"):
                                        if (self.bgp_auto_discovery is None):
                                            self.bgp_auto_discovery = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.BgpAutoDiscovery()
                                            self.bgp_auto_discovery.parent = self
                                            self._children_name_map["bgp_auto_discovery"] = "bgp-auto-discovery"
                                        return self.bgp_auto_discovery

                                    if (child_yang_name == "multicast-p2mp"):
                                        if (self.multicast_p2mp is None):
                                            self.multicast_p2mp = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.MulticastP2Mp()
                                            self.multicast_p2mp.parent = self
                                            self._children_name_map["multicast_p2mp"] = "multicast-p2mp"
                                        return self.multicast_p2mp

                                    if (child_yang_name == "vfi-pseudowires"):
                                        if (self.vfi_pseudowires is None):
                                            self.vfi_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi.VfiPseudowires()
                                            self.vfi_pseudowires.parent = self
                                            self._children_name_map["vfi_pseudowires"] = "vfi-pseudowires"
                                        return self.vfi_pseudowires

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bgp-auto-discovery" or name == "multicast-p2mp" or name == "vfi-pseudowires" or name == "name" or name == "vfi-shutdown" or name == "vpnid"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "name"):
                                        self.name = value
                                        self.name.value_namespace = name_space
                                        self.name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "vfi-shutdown"):
                                        self.vfi_shutdown = value
                                        self.vfi_shutdown.value_namespace = name_space
                                        self.vfi_shutdown.value_namespace_prefix = name_space_prefix
                                    if(value_path == "vpnid"):
                                        self.vpnid = value
                                        self.vpnid.value_namespace = name_space
                                        self.vpnid.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.vfi:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.vfi:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "vfis" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "vfi"):
                                    for c in self.vfi:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis.Vfi()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.vfi.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "vfi"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class BdAttachmentCircuits(Entity):
                            """
                            Attachment Circuit table
                            
                            .. attribute:: bd_attachment_circuit
                            
                            	Name of the Attachment Circuit
                            	**type**\: list of    :py:class:`BdAttachmentCircuit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits, self).__init__()

                                self.yang_name = "bd-attachment-circuits"
                                self.yang_parent_name = "bridge-domain"

                                self.bd_attachment_circuit = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits, self).__setattr__(name, value)


                            class BdAttachmentCircuit(Entity):
                                """
                                Name of the Attachment Circuit
                                
                                .. attribute:: name  <key>
                                
                                	The name of the Attachment Circuit
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: bdac_storm_control_types
                                
                                	Storm Control
                                	**type**\:   :py:class:`BdacStormControlTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes>`
                                
                                .. attribute:: interface_dai
                                
                                	L2 Interface Dynamic ARP Inspection
                                	**type**\:   :py:class:`InterfaceDai <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai>`
                                
                                .. attribute:: interface_flooding
                                
                                	Enable or Disable Flooding
                                	**type**\:   :py:class:`InterfaceTrafficFlood <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceTrafficFlood>`
                                
                                .. attribute:: interface_flooding_unknown_unicast
                                
                                	Enable or Disable Unknown Unicast Flooding
                                	**type**\:   :py:class:`InterfaceTrafficFlood <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceTrafficFlood>`
                                
                                .. attribute:: interface_igmp_snoop
                                
                                	Attach a IGMP Snooping profile
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: interface_ip_source_guard
                                
                                	IP Source Guard
                                	**type**\:   :py:class:`InterfaceIpSourceGuard <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceIpSourceGuard>`
                                
                                .. attribute:: interface_mac
                                
                                	MAC configuration commands
                                	**type**\:   :py:class:`InterfaceMac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac>`
                                
                                .. attribute:: interface_mld_snoop
                                
                                	Attach a MLD Snooping profile
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: interface_profile
                                
                                	Attach a DHCP profile
                                	**type**\:   :py:class:`InterfaceProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceProfile>`
                                
                                .. attribute:: split_horizon
                                
                                	Split Horizon
                                	**type**\:   :py:class:`SplitHorizon <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon>`
                                
                                .. attribute:: static_mac_addresses
                                
                                	Static Mac Address Table
                                	**type**\:   :py:class:`StaticMacAddresses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit, self).__init__()

                                    self.yang_name = "bd-attachment-circuit"
                                    self.yang_parent_name = "bd-attachment-circuits"

                                    self.name = YLeaf(YType.str, "name")

                                    self.interface_flooding = YLeaf(YType.enumeration, "interface-flooding")

                                    self.interface_flooding_unknown_unicast = YLeaf(YType.enumeration, "interface-flooding-unknown-unicast")

                                    self.interface_igmp_snoop = YLeaf(YType.str, "interface-igmp-snoop")

                                    self.interface_mld_snoop = YLeaf(YType.str, "interface-mld-snoop")

                                    self.bdac_storm_control_types = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes()
                                    self.bdac_storm_control_types.parent = self
                                    self._children_name_map["bdac_storm_control_types"] = "bdac-storm-control-types"
                                    self._children_yang_names.add("bdac-storm-control-types")

                                    self.interface_dai = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai()
                                    self.interface_dai.parent = self
                                    self._children_name_map["interface_dai"] = "interface-dai"
                                    self._children_yang_names.add("interface-dai")

                                    self.interface_ip_source_guard = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceIpSourceGuard()
                                    self.interface_ip_source_guard.parent = self
                                    self._children_name_map["interface_ip_source_guard"] = "interface-ip-source-guard"
                                    self._children_yang_names.add("interface-ip-source-guard")

                                    self.interface_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac()
                                    self.interface_mac.parent = self
                                    self._children_name_map["interface_mac"] = "interface-mac"
                                    self._children_yang_names.add("interface-mac")

                                    self.interface_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceProfile()
                                    self.interface_profile.parent = self
                                    self._children_name_map["interface_profile"] = "interface-profile"
                                    self._children_yang_names.add("interface-profile")

                                    self.split_horizon = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon()
                                    self.split_horizon.parent = self
                                    self._children_name_map["split_horizon"] = "split-horizon"
                                    self._children_yang_names.add("split-horizon")

                                    self.static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses()
                                    self.static_mac_addresses.parent = self
                                    self._children_name_map["static_mac_addresses"] = "static-mac-addresses"
                                    self._children_yang_names.add("static-mac-addresses")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("name",
                                                    "interface_flooding",
                                                    "interface_flooding_unknown_unicast",
                                                    "interface_igmp_snoop",
                                                    "interface_mld_snoop") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit, self).__setattr__(name, value)


                                class InterfaceIpSourceGuard(Entity):
                                    """
                                    IP Source Guard
                                    
                                    .. attribute:: disable
                                    
                                    	Disable L2 Interface Dynamic IP source guard
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: enable
                                    
                                    	Enable IP Source Guard
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: logging
                                    
                                    	Logging Type
                                    	**type**\:   :py:class:`L2VpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnLogging>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceIpSourceGuard, self).__init__()

                                        self.yang_name = "interface-ip-source-guard"
                                        self.yang_parent_name = "bd-attachment-circuit"

                                        self.disable = YLeaf(YType.empty, "disable")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.logging = YLeaf(YType.enumeration, "logging")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("disable",
                                                        "enable",
                                                        "logging") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceIpSourceGuard, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceIpSourceGuard, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.disable.is_set or
                                            self.enable.is_set or
                                            self.logging.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.disable.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.logging.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-ip-source-guard" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.disable.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.logging.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "disable" or name == "enable" or name == "logging"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "disable"):
                                            self.disable = value
                                            self.disable.value_namespace = name_space
                                            self.disable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "logging"):
                                            self.logging = value
                                            self.logging.value_namespace = name_space
                                            self.logging.value_namespace_prefix = name_space_prefix


                                class InterfaceDai(Entity):
                                    """
                                    L2 Interface Dynamic ARP Inspection
                                    
                                    .. attribute:: disable
                                    
                                    	Disable L2 Interface Dynamic ARP Inspection
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: enable
                                    
                                    	Enable L2 Interface Dynamic ARP Inspection
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: interface_dai_address_validation
                                    
                                    	Address Validation
                                    	**type**\:   :py:class:`InterfaceDaiAddressValidation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai.InterfaceDaiAddressValidation>`
                                    
                                    .. attribute:: logging
                                    
                                    	Logging Type
                                    	**type**\:   :py:class:`L2VpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnLogging>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai, self).__init__()

                                        self.yang_name = "interface-dai"
                                        self.yang_parent_name = "bd-attachment-circuit"

                                        self.disable = YLeaf(YType.empty, "disable")

                                        self.enable = YLeaf(YType.empty, "enable")

                                        self.logging = YLeaf(YType.enumeration, "logging")

                                        self.interface_dai_address_validation = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai.InterfaceDaiAddressValidation()
                                        self.interface_dai_address_validation.parent = self
                                        self._children_name_map["interface_dai_address_validation"] = "interface-dai-address-validation"
                                        self._children_yang_names.add("interface-dai-address-validation")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("disable",
                                                        "enable",
                                                        "logging") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai, self).__setattr__(name, value)


                                    class InterfaceDaiAddressValidation(Entity):
                                        """
                                        Address Validation
                                        
                                        .. attribute:: destination_mac_verification
                                        
                                        	Destination MAC Verification
                                        	**type**\:   :py:class:`L2VpnVerification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnVerification>`
                                        
                                        .. attribute:: enable
                                        
                                        	Enable Address Validation
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: ipv4_verification
                                        
                                        	IPv4 Verification
                                        	**type**\:   :py:class:`L2VpnVerification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnVerification>`
                                        
                                        .. attribute:: source_mac_verification
                                        
                                        	Source MAC Verification
                                        	**type**\:   :py:class:`L2VpnVerification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnVerification>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai.InterfaceDaiAddressValidation, self).__init__()

                                            self.yang_name = "interface-dai-address-validation"
                                            self.yang_parent_name = "interface-dai"

                                            self.destination_mac_verification = YLeaf(YType.enumeration, "destination-mac-verification")

                                            self.enable = YLeaf(YType.empty, "enable")

                                            self.ipv4_verification = YLeaf(YType.enumeration, "ipv4-verification")

                                            self.source_mac_verification = YLeaf(YType.enumeration, "source-mac-verification")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("destination_mac_verification",
                                                            "enable",
                                                            "ipv4_verification",
                                                            "source_mac_verification") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai.InterfaceDaiAddressValidation, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai.InterfaceDaiAddressValidation, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.destination_mac_verification.is_set or
                                                self.enable.is_set or
                                                self.ipv4_verification.is_set or
                                                self.source_mac_verification.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.destination_mac_verification.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.ipv4_verification.yfilter != YFilter.not_set or
                                                self.source_mac_verification.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-dai-address-validation" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.destination_mac_verification.is_set or self.destination_mac_verification.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.destination_mac_verification.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.ipv4_verification.is_set or self.ipv4_verification.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.ipv4_verification.get_name_leafdata())
                                            if (self.source_mac_verification.is_set or self.source_mac_verification.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.source_mac_verification.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "destination-mac-verification" or name == "enable" or name == "ipv4-verification" or name == "source-mac-verification"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "destination-mac-verification"):
                                                self.destination_mac_verification = value
                                                self.destination_mac_verification.value_namespace = name_space
                                                self.destination_mac_verification.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "ipv4-verification"):
                                                self.ipv4_verification = value
                                                self.ipv4_verification.value_namespace = name_space
                                                self.ipv4_verification.value_namespace_prefix = name_space_prefix
                                            if(value_path == "source-mac-verification"):
                                                self.source_mac_verification = value
                                                self.source_mac_verification.value_namespace = name_space
                                                self.source_mac_verification.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.disable.is_set or
                                            self.enable.is_set or
                                            self.logging.is_set or
                                            (self.interface_dai_address_validation is not None and self.interface_dai_address_validation.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.disable.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.logging.yfilter != YFilter.not_set or
                                            (self.interface_dai_address_validation is not None and self.interface_dai_address_validation.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-dai" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.disable.get_name_leafdata())
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.logging.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "interface-dai-address-validation"):
                                            if (self.interface_dai_address_validation is None):
                                                self.interface_dai_address_validation = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai.InterfaceDaiAddressValidation()
                                                self.interface_dai_address_validation.parent = self
                                                self._children_name_map["interface_dai_address_validation"] = "interface-dai-address-validation"
                                            return self.interface_dai_address_validation

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-dai-address-validation" or name == "disable" or name == "enable" or name == "logging"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "disable"):
                                            self.disable = value
                                            self.disable.value_namespace = name_space
                                            self.disable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "logging"):
                                            self.logging = value
                                            self.logging.value_namespace = name_space
                                            self.logging.value_namespace_prefix = name_space_prefix


                                class InterfaceProfile(Entity):
                                    """
                                    Attach a DHCP profile
                                    
                                    .. attribute:: dhcp_snooping_id
                                    
                                    	Disable DHCP snooping
                                    	**type**\:  str
                                    
                                    .. attribute:: profile_id
                                    
                                    	Set the snooping profile
                                    	**type**\:   :py:class:`InterfaceProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.InterfaceProfile>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceProfile, self).__init__()

                                        self.yang_name = "interface-profile"
                                        self.yang_parent_name = "bd-attachment-circuit"

                                        self.dhcp_snooping_id = YLeaf(YType.str, "dhcp-snooping-id")

                                        self.profile_id = YLeaf(YType.enumeration, "profile-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("dhcp_snooping_id",
                                                        "profile_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceProfile, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceProfile, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.dhcp_snooping_id.is_set or
                                            self.profile_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.dhcp_snooping_id.yfilter != YFilter.not_set or
                                            self.profile_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-profile" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.dhcp_snooping_id.is_set or self.dhcp_snooping_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dhcp_snooping_id.get_name_leafdata())
                                        if (self.profile_id.is_set or self.profile_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.profile_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "dhcp-snooping-id" or name == "profile-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "dhcp-snooping-id"):
                                            self.dhcp_snooping_id = value
                                            self.dhcp_snooping_id.value_namespace = name_space
                                            self.dhcp_snooping_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "profile-id"):
                                            self.profile_id = value
                                            self.profile_id.value_namespace = name_space
                                            self.profile_id.value_namespace_prefix = name_space_prefix


                                class BdacStormControlTypes(Entity):
                                    """
                                    Storm Control
                                    
                                    .. attribute:: bdac_storm_control_type
                                    
                                    	Storm Control Type
                                    	**type**\: list of    :py:class:`BdacStormControlType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes, self).__init__()

                                        self.yang_name = "bdac-storm-control-types"
                                        self.yang_parent_name = "bd-attachment-circuit"

                                        self.bdac_storm_control_type = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes, self).__setattr__(name, value)


                                    class BdacStormControlType(Entity):
                                        """
                                        Storm Control Type
                                        
                                        .. attribute:: sctype  <key>
                                        
                                        	Storm Control Type
                                        	**type**\:   :py:class:`StormControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.StormControl>`
                                        
                                        .. attribute:: storm_control_unit
                                        
                                        	Specify units for Storm Control Configuration
                                        	**type**\:   :py:class:`StormControlUnit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType.StormControlUnit>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType, self).__init__()

                                            self.yang_name = "bdac-storm-control-type"
                                            self.yang_parent_name = "bdac-storm-control-types"

                                            self.sctype = YLeaf(YType.enumeration, "sctype")

                                            self.storm_control_unit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType.StormControlUnit()
                                            self.storm_control_unit.parent = self
                                            self._children_name_map["storm_control_unit"] = "storm-control-unit"
                                            self._children_yang_names.add("storm-control-unit")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("sctype") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType, self).__setattr__(name, value)


                                        class StormControlUnit(Entity):
                                            """
                                            Specify units for Storm Control Configuration
                                            
                                            .. attribute:: kbits_per_sec
                                            
                                            	Kilobits Per Second, PktsPerSec and KbitsPerSec cannot be configured together
                                            	**type**\:  int
                                            
                                            	**range:** 64..1280000
                                            
                                            	**units**\: kbit/s
                                            
                                            .. attribute:: pkts_per_sec
                                            
                                            	Packets Per Second, PktsPerSec and KbitsPerSec cannot be configured together
                                            	**type**\:  int
                                            
                                            	**range:** 1..160000
                                            
                                            	**units**\: packet/s
                                            
                                            

                                            """

                                            _prefix = 'l2vpn-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType.StormControlUnit, self).__init__()

                                                self.yang_name = "storm-control-unit"
                                                self.yang_parent_name = "bdac-storm-control-type"

                                                self.kbits_per_sec = YLeaf(YType.uint32, "kbits-per-sec")

                                                self.pkts_per_sec = YLeaf(YType.uint32, "pkts-per-sec")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("kbits_per_sec",
                                                                "pkts_per_sec") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType.StormControlUnit, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType.StormControlUnit, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.kbits_per_sec.is_set or
                                                    self.pkts_per_sec.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.kbits_per_sec.yfilter != YFilter.not_set or
                                                    self.pkts_per_sec.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "storm-control-unit" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.kbits_per_sec.is_set or self.kbits_per_sec.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.kbits_per_sec.get_name_leafdata())
                                                if (self.pkts_per_sec.is_set or self.pkts_per_sec.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.pkts_per_sec.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "kbits-per-sec" or name == "pkts-per-sec"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "kbits-per-sec"):
                                                    self.kbits_per_sec = value
                                                    self.kbits_per_sec.value_namespace = name_space
                                                    self.kbits_per_sec.value_namespace_prefix = name_space_prefix
                                                if(value_path == "pkts-per-sec"):
                                                    self.pkts_per_sec = value
                                                    self.pkts_per_sec.value_namespace = name_space
                                                    self.pkts_per_sec.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.sctype.is_set or
                                                (self.storm_control_unit is not None and self.storm_control_unit.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.sctype.yfilter != YFilter.not_set or
                                                (self.storm_control_unit is not None and self.storm_control_unit.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "bdac-storm-control-type" + "[sctype='" + self.sctype.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.sctype.is_set or self.sctype.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sctype.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "storm-control-unit"):
                                                if (self.storm_control_unit is None):
                                                    self.storm_control_unit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType.StormControlUnit()
                                                    self.storm_control_unit.parent = self
                                                    self._children_name_map["storm_control_unit"] = "storm-control-unit"
                                                return self.storm_control_unit

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "storm-control-unit" or name == "sctype"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "sctype"):
                                                self.sctype = value
                                                self.sctype.value_namespace = name_space
                                                self.sctype.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.bdac_storm_control_type:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.bdac_storm_control_type:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bdac-storm-control-types" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "bdac-storm-control-type"):
                                            for c in self.bdac_storm_control_type:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes.BdacStormControlType()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.bdac_storm_control_type.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "bdac-storm-control-type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class SplitHorizon(Entity):
                                    """
                                    Split Horizon
                                    
                                    .. attribute:: split_horizon_group_id
                                    
                                    	Split Horizon Group ID
                                    	**type**\:   :py:class:`SplitHorizonGroupId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon.SplitHorizonGroupId>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon, self).__init__()

                                        self.yang_name = "split-horizon"
                                        self.yang_parent_name = "bd-attachment-circuit"

                                        self.split_horizon_group_id = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon.SplitHorizonGroupId()
                                        self.split_horizon_group_id.parent = self
                                        self._children_name_map["split_horizon_group_id"] = "split-horizon-group-id"
                                        self._children_yang_names.add("split-horizon-group-id")


                                    class SplitHorizonGroupId(Entity):
                                        """
                                        Split Horizon Group ID
                                        
                                        .. attribute:: enable
                                        
                                        	Enable split horizon group
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon.SplitHorizonGroupId, self).__init__()

                                            self.yang_name = "split-horizon-group-id"
                                            self.yang_parent_name = "split-horizon"

                                            self.enable = YLeaf(YType.empty, "enable")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("enable") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon.SplitHorizonGroupId, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon.SplitHorizonGroupId, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.enable.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "split-horizon-group-id" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "enable"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.split_horizon_group_id is not None and self.split_horizon_group_id.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.split_horizon_group_id is not None and self.split_horizon_group_id.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "split-horizon" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "split-horizon-group-id"):
                                            if (self.split_horizon_group_id is None):
                                                self.split_horizon_group_id = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon.SplitHorizonGroupId()
                                                self.split_horizon_group_id.parent = self
                                                self._children_name_map["split_horizon_group_id"] = "split-horizon-group-id"
                                            return self.split_horizon_group_id

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "split-horizon-group-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class StaticMacAddresses(Entity):
                                    """
                                    Static Mac Address Table
                                    
                                    .. attribute:: static_mac_address
                                    
                                    	Static Mac Address Configuration
                                    	**type**\: list of    :py:class:`StaticMacAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses.StaticMacAddress>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses, self).__init__()

                                        self.yang_name = "static-mac-addresses"
                                        self.yang_parent_name = "bd-attachment-circuit"

                                        self.static_mac_address = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses, self).__setattr__(name, value)


                                    class StaticMacAddress(Entity):
                                        """
                                        Static Mac Address Configuration
                                        
                                        .. attribute:: address  <key>
                                        
                                        	Static MAC address
                                        	**type**\:  str
                                        
                                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses.StaticMacAddress, self).__init__()

                                            self.yang_name = "static-mac-address"
                                            self.yang_parent_name = "static-mac-addresses"

                                            self.address = YLeaf(YType.str, "address")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("address") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses.StaticMacAddress, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses.StaticMacAddress, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.address.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.address.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "static-mac-address" + "[address='" + self.address.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.address.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "address"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "address"):
                                                self.address = value
                                                self.address.value_namespace = name_space
                                                self.address.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.static_mac_address:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.static_mac_address:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "static-mac-addresses" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "static-mac-address"):
                                            for c in self.static_mac_address:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses.StaticMacAddress()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.static_mac_address.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "static-mac-address"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class InterfaceMac(Entity):
                                    """
                                    MAC configuration commands
                                    
                                    .. attribute:: interface_mac_aging
                                    
                                    	MAC\-Aging configuration commands
                                    	**type**\:   :py:class:`InterfaceMacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacAging>`
                                    
                                    .. attribute:: interface_mac_learning
                                    
                                    	Enable Mac Learning
                                    	**type**\:   :py:class:`MacLearn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLearn>`
                                    
                                    .. attribute:: interface_mac_limit
                                    
                                    	MAC\-Limit configuration commands
                                    	**type**\:   :py:class:`InterfaceMacLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacLimit>`
                                    
                                    .. attribute:: interface_mac_port_down_flush
                                    
                                    	Enable/Disable MAC Flush When Port goes down
                                    	**type**\:   :py:class:`PortDownFlush <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.PortDownFlush>`
                                    
                                    .. attribute:: interface_mac_secure
                                    
                                    	MAC Secure
                                    	**type**\:   :py:class:`InterfaceMacSecure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacSecure>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac, self).__init__()

                                        self.yang_name = "interface-mac"
                                        self.yang_parent_name = "bd-attachment-circuit"

                                        self.interface_mac_learning = YLeaf(YType.enumeration, "interface-mac-learning")

                                        self.interface_mac_port_down_flush = YLeaf(YType.enumeration, "interface-mac-port-down-flush")

                                        self.interface_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacAging()
                                        self.interface_mac_aging.parent = self
                                        self._children_name_map["interface_mac_aging"] = "interface-mac-aging"
                                        self._children_yang_names.add("interface-mac-aging")

                                        self.interface_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacLimit()
                                        self.interface_mac_limit.parent = self
                                        self._children_name_map["interface_mac_limit"] = "interface-mac-limit"
                                        self._children_yang_names.add("interface-mac-limit")

                                        self.interface_mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacSecure()
                                        self.interface_mac_secure.parent = self
                                        self._children_name_map["interface_mac_secure"] = "interface-mac-secure"
                                        self._children_yang_names.add("interface-mac-secure")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_mac_learning",
                                                        "interface_mac_port_down_flush") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac, self).__setattr__(name, value)


                                    class InterfaceMacAging(Entity):
                                        """
                                        MAC\-Aging configuration commands
                                        
                                        .. attribute:: interface_mac_aging_time
                                        
                                        	Mac Aging Time
                                        	**type**\:  int
                                        
                                        	**range:** 300..30000
                                        
                                        .. attribute:: interface_mac_aging_type
                                        
                                        	MAC address aging type
                                        	**type**\:   :py:class:`MacAging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacAging>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacAging, self).__init__()

                                            self.yang_name = "interface-mac-aging"
                                            self.yang_parent_name = "interface-mac"

                                            self.interface_mac_aging_time = YLeaf(YType.uint32, "interface-mac-aging-time")

                                            self.interface_mac_aging_type = YLeaf(YType.enumeration, "interface-mac-aging-type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("interface_mac_aging_time",
                                                            "interface_mac_aging_type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacAging, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacAging, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.interface_mac_aging_time.is_set or
                                                self.interface_mac_aging_type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.interface_mac_aging_time.yfilter != YFilter.not_set or
                                                self.interface_mac_aging_type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-mac-aging" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.interface_mac_aging_time.is_set or self.interface_mac_aging_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_mac_aging_time.get_name_leafdata())
                                            if (self.interface_mac_aging_type.is_set or self.interface_mac_aging_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_mac_aging_type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-mac-aging-time" or name == "interface-mac-aging-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "interface-mac-aging-time"):
                                                self.interface_mac_aging_time = value
                                                self.interface_mac_aging_time.value_namespace = name_space
                                                self.interface_mac_aging_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "interface-mac-aging-type"):
                                                self.interface_mac_aging_type = value
                                                self.interface_mac_aging_type.value_namespace = name_space
                                                self.interface_mac_aging_type.value_namespace_prefix = name_space_prefix


                                    class InterfaceMacSecure(Entity):
                                        """
                                        MAC Secure
                                        
                                        .. attribute:: action
                                        
                                        	MAC secure enforcement action
                                        	**type**\:   :py:class:`MacSecureAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacSecureAction>`
                                        
                                        .. attribute:: disable
                                        
                                        	Disable L2 Interface MAC Secure
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: enable
                                        
                                        	Enable MAC Secure
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: logging
                                        
                                        	MAC Secure Logging
                                        	**type**\:   :py:class:`L2VpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2VpnLogging>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacSecure, self).__init__()

                                            self.yang_name = "interface-mac-secure"
                                            self.yang_parent_name = "interface-mac"

                                            self.action = YLeaf(YType.enumeration, "action")

                                            self.disable = YLeaf(YType.empty, "disable")

                                            self.enable = YLeaf(YType.empty, "enable")

                                            self.logging = YLeaf(YType.enumeration, "logging")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("action",
                                                            "disable",
                                                            "enable",
                                                            "logging") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacSecure, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacSecure, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.action.is_set or
                                                self.disable.is_set or
                                                self.enable.is_set or
                                                self.logging.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.action.yfilter != YFilter.not_set or
                                                self.disable.yfilter != YFilter.not_set or
                                                self.enable.yfilter != YFilter.not_set or
                                                self.logging.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-mac-secure" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.action.get_name_leafdata())
                                            if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.disable.get_name_leafdata())
                                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enable.get_name_leafdata())
                                            if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.logging.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "action" or name == "disable" or name == "enable" or name == "logging"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "action"):
                                                self.action = value
                                                self.action.value_namespace = name_space
                                                self.action.value_namespace_prefix = name_space_prefix
                                            if(value_path == "disable"):
                                                self.disable = value
                                                self.disable.value_namespace = name_space
                                                self.disable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enable"):
                                                self.enable = value
                                                self.enable.value_namespace = name_space
                                                self.enable.value_namespace_prefix = name_space_prefix
                                            if(value_path == "logging"):
                                                self.logging = value
                                                self.logging.value_namespace = name_space
                                                self.logging.value_namespace_prefix = name_space_prefix


                                    class InterfaceMacLimit(Entity):
                                        """
                                        MAC\-Limit configuration commands
                                        
                                        .. attribute:: interface_mac_limit_action
                                        
                                        	Interface MAC address limit enforcement action
                                        	**type**\:   :py:class:`MacLimitAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacLimitAction>`
                                        
                                        .. attribute:: interface_mac_limit_max
                                        
                                        	Number of MAC addresses on an Interface after which MAC limit action is taken
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: interface_mac_limit_notif
                                        
                                        	MAC address limit notification action in a Interface
                                        	**type**\:   :py:class:`MacNotification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MacNotification>`
                                        
                                        

                                        """

                                        _prefix = 'l2vpn-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacLimit, self).__init__()

                                            self.yang_name = "interface-mac-limit"
                                            self.yang_parent_name = "interface-mac"

                                            self.interface_mac_limit_action = YLeaf(YType.enumeration, "interface-mac-limit-action")

                                            self.interface_mac_limit_max = YLeaf(YType.uint32, "interface-mac-limit-max")

                                            self.interface_mac_limit_notif = YLeaf(YType.enumeration, "interface-mac-limit-notif")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("interface_mac_limit_action",
                                                            "interface_mac_limit_max",
                                                            "interface_mac_limit_notif") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacLimit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacLimit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.interface_mac_limit_action.is_set or
                                                self.interface_mac_limit_max.is_set or
                                                self.interface_mac_limit_notif.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.interface_mac_limit_action.yfilter != YFilter.not_set or
                                                self.interface_mac_limit_max.yfilter != YFilter.not_set or
                                                self.interface_mac_limit_notif.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-mac-limit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.interface_mac_limit_action.is_set or self.interface_mac_limit_action.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_mac_limit_action.get_name_leafdata())
                                            if (self.interface_mac_limit_max.is_set or self.interface_mac_limit_max.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_mac_limit_max.get_name_leafdata())
                                            if (self.interface_mac_limit_notif.is_set or self.interface_mac_limit_notif.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.interface_mac_limit_notif.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-mac-limit-action" or name == "interface-mac-limit-max" or name == "interface-mac-limit-notif"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "interface-mac-limit-action"):
                                                self.interface_mac_limit_action = value
                                                self.interface_mac_limit_action.value_namespace = name_space
                                                self.interface_mac_limit_action.value_namespace_prefix = name_space_prefix
                                            if(value_path == "interface-mac-limit-max"):
                                                self.interface_mac_limit_max = value
                                                self.interface_mac_limit_max.value_namespace = name_space
                                                self.interface_mac_limit_max.value_namespace_prefix = name_space_prefix
                                            if(value_path == "interface-mac-limit-notif"):
                                                self.interface_mac_limit_notif = value
                                                self.interface_mac_limit_notif.value_namespace = name_space
                                                self.interface_mac_limit_notif.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.interface_mac_learning.is_set or
                                            self.interface_mac_port_down_flush.is_set or
                                            (self.interface_mac_aging is not None and self.interface_mac_aging.has_data()) or
                                            (self.interface_mac_limit is not None and self.interface_mac_limit.has_data()) or
                                            (self.interface_mac_secure is not None and self.interface_mac_secure.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_mac_learning.yfilter != YFilter.not_set or
                                            self.interface_mac_port_down_flush.yfilter != YFilter.not_set or
                                            (self.interface_mac_aging is not None and self.interface_mac_aging.has_operation()) or
                                            (self.interface_mac_limit is not None and self.interface_mac_limit.has_operation()) or
                                            (self.interface_mac_secure is not None and self.interface_mac_secure.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-mac" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_mac_learning.is_set or self.interface_mac_learning.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_mac_learning.get_name_leafdata())
                                        if (self.interface_mac_port_down_flush.is_set or self.interface_mac_port_down_flush.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_mac_port_down_flush.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "interface-mac-aging"):
                                            if (self.interface_mac_aging is None):
                                                self.interface_mac_aging = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacAging()
                                                self.interface_mac_aging.parent = self
                                                self._children_name_map["interface_mac_aging"] = "interface-mac-aging"
                                            return self.interface_mac_aging

                                        if (child_yang_name == "interface-mac-limit"):
                                            if (self.interface_mac_limit is None):
                                                self.interface_mac_limit = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacLimit()
                                                self.interface_mac_limit.parent = self
                                                self._children_name_map["interface_mac_limit"] = "interface-mac-limit"
                                            return self.interface_mac_limit

                                        if (child_yang_name == "interface-mac-secure"):
                                            if (self.interface_mac_secure is None):
                                                self.interface_mac_secure = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac.InterfaceMacSecure()
                                                self.interface_mac_secure.parent = self
                                                self._children_name_map["interface_mac_secure"] = "interface-mac-secure"
                                            return self.interface_mac_secure

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-mac-aging" or name == "interface-mac-limit" or name == "interface-mac-secure" or name == "interface-mac-learning" or name == "interface-mac-port-down-flush"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-mac-learning"):
                                            self.interface_mac_learning = value
                                            self.interface_mac_learning.value_namespace = name_space
                                            self.interface_mac_learning.value_namespace_prefix = name_space_prefix
                                        if(value_path == "interface-mac-port-down-flush"):
                                            self.interface_mac_port_down_flush = value
                                            self.interface_mac_port_down_flush.value_namespace = name_space
                                            self.interface_mac_port_down_flush.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.name.is_set or
                                        self.interface_flooding.is_set or
                                        self.interface_flooding_unknown_unicast.is_set or
                                        self.interface_igmp_snoop.is_set or
                                        self.interface_mld_snoop.is_set or
                                        (self.bdac_storm_control_types is not None and self.bdac_storm_control_types.has_data()) or
                                        (self.interface_dai is not None and self.interface_dai.has_data()) or
                                        (self.interface_ip_source_guard is not None and self.interface_ip_source_guard.has_data()) or
                                        (self.interface_mac is not None and self.interface_mac.has_data()) or
                                        (self.interface_profile is not None and self.interface_profile.has_data()) or
                                        (self.split_horizon is not None and self.split_horizon.has_data()) or
                                        (self.static_mac_addresses is not None and self.static_mac_addresses.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.name.yfilter != YFilter.not_set or
                                        self.interface_flooding.yfilter != YFilter.not_set or
                                        self.interface_flooding_unknown_unicast.yfilter != YFilter.not_set or
                                        self.interface_igmp_snoop.yfilter != YFilter.not_set or
                                        self.interface_mld_snoop.yfilter != YFilter.not_set or
                                        (self.bdac_storm_control_types is not None and self.bdac_storm_control_types.has_operation()) or
                                        (self.interface_dai is not None and self.interface_dai.has_operation()) or
                                        (self.interface_ip_source_guard is not None and self.interface_ip_source_guard.has_operation()) or
                                        (self.interface_mac is not None and self.interface_mac.has_operation()) or
                                        (self.interface_profile is not None and self.interface_profile.has_operation()) or
                                        (self.split_horizon is not None and self.split_horizon.has_operation()) or
                                        (self.static_mac_addresses is not None and self.static_mac_addresses.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bd-attachment-circuit" + "[name='" + self.name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.name.get_name_leafdata())
                                    if (self.interface_flooding.is_set or self.interface_flooding.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_flooding.get_name_leafdata())
                                    if (self.interface_flooding_unknown_unicast.is_set or self.interface_flooding_unknown_unicast.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_flooding_unknown_unicast.get_name_leafdata())
                                    if (self.interface_igmp_snoop.is_set or self.interface_igmp_snoop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_igmp_snoop.get_name_leafdata())
                                    if (self.interface_mld_snoop.is_set or self.interface_mld_snoop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_mld_snoop.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "bdac-storm-control-types"):
                                        if (self.bdac_storm_control_types is None):
                                            self.bdac_storm_control_types = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.BdacStormControlTypes()
                                            self.bdac_storm_control_types.parent = self
                                            self._children_name_map["bdac_storm_control_types"] = "bdac-storm-control-types"
                                        return self.bdac_storm_control_types

                                    if (child_yang_name == "interface-dai"):
                                        if (self.interface_dai is None):
                                            self.interface_dai = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceDai()
                                            self.interface_dai.parent = self
                                            self._children_name_map["interface_dai"] = "interface-dai"
                                        return self.interface_dai

                                    if (child_yang_name == "interface-ip-source-guard"):
                                        if (self.interface_ip_source_guard is None):
                                            self.interface_ip_source_guard = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceIpSourceGuard()
                                            self.interface_ip_source_guard.parent = self
                                            self._children_name_map["interface_ip_source_guard"] = "interface-ip-source-guard"
                                        return self.interface_ip_source_guard

                                    if (child_yang_name == "interface-mac"):
                                        if (self.interface_mac is None):
                                            self.interface_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceMac()
                                            self.interface_mac.parent = self
                                            self._children_name_map["interface_mac"] = "interface-mac"
                                        return self.interface_mac

                                    if (child_yang_name == "interface-profile"):
                                        if (self.interface_profile is None):
                                            self.interface_profile = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.InterfaceProfile()
                                            self.interface_profile.parent = self
                                            self._children_name_map["interface_profile"] = "interface-profile"
                                        return self.interface_profile

                                    if (child_yang_name == "split-horizon"):
                                        if (self.split_horizon is None):
                                            self.split_horizon = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.SplitHorizon()
                                            self.split_horizon.parent = self
                                            self._children_name_map["split_horizon"] = "split-horizon"
                                        return self.split_horizon

                                    if (child_yang_name == "static-mac-addresses"):
                                        if (self.static_mac_addresses is None):
                                            self.static_mac_addresses = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit.StaticMacAddresses()
                                            self.static_mac_addresses.parent = self
                                            self._children_name_map["static_mac_addresses"] = "static-mac-addresses"
                                        return self.static_mac_addresses

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bdac-storm-control-types" or name == "interface-dai" or name == "interface-ip-source-guard" or name == "interface-mac" or name == "interface-profile" or name == "split-horizon" or name == "static-mac-addresses" or name == "name" or name == "interface-flooding" or name == "interface-flooding-unknown-unicast" or name == "interface-igmp-snoop" or name == "interface-mld-snoop"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "name"):
                                        self.name = value
                                        self.name.value_namespace = name_space
                                        self.name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-flooding"):
                                        self.interface_flooding = value
                                        self.interface_flooding.value_namespace = name_space
                                        self.interface_flooding.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-flooding-unknown-unicast"):
                                        self.interface_flooding_unknown_unicast = value
                                        self.interface_flooding_unknown_unicast.value_namespace = name_space
                                        self.interface_flooding_unknown_unicast.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-igmp-snoop"):
                                        self.interface_igmp_snoop = value
                                        self.interface_igmp_snoop.value_namespace = name_space
                                        self.interface_igmp_snoop.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-mld-snoop"):
                                        self.interface_mld_snoop = value
                                        self.interface_mld_snoop.value_namespace = name_space
                                        self.interface_mld_snoop.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.bd_attachment_circuit:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.bd_attachment_circuit:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bd-attachment-circuits" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bd-attachment-circuit"):
                                    for c in self.bd_attachment_circuit:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits.BdAttachmentCircuit()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.bd_attachment_circuit.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bd-attachment-circuit"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class BdPseudowireEvpns(Entity):
                            """
                            List of EVPN pseudowires
                            
                            .. attribute:: bd_pseudowire_evpn
                            
                            	EVPN Pseudowire configuration
                            	**type**\: list of    :py:class:`BdPseudowireEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns.BdPseudowireEvpn>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns, self).__init__()

                                self.yang_name = "bd-pseudowire-evpns"
                                self.yang_parent_name = "bridge-domain"

                                self.bd_pseudowire_evpn = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns, self).__setattr__(name, value)


                            class BdPseudowireEvpn(Entity):
                                """
                                EVPN Pseudowire configuration
                                
                                .. attribute:: eviid  <key>
                                
                                	Ethernet VPN ID
                                	**type**\:  int
                                
                                	**range:** 1..65534
                                
                                .. attribute:: acid  <key>
                                
                                	AC ID
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns.BdPseudowireEvpn, self).__init__()

                                    self.yang_name = "bd-pseudowire-evpn"
                                    self.yang_parent_name = "bd-pseudowire-evpns"

                                    self.eviid = YLeaf(YType.uint32, "eviid")

                                    self.acid = YLeaf(YType.uint32, "acid")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("eviid",
                                                    "acid") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns.BdPseudowireEvpn, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns.BdPseudowireEvpn, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.eviid.is_set or
                                        self.acid.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.eviid.yfilter != YFilter.not_set or
                                        self.acid.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bd-pseudowire-evpn" + "[eviid='" + self.eviid.get() + "']" + "[acid='" + self.acid.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.eviid.get_name_leafdata())
                                    if (self.acid.is_set or self.acid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.acid.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "eviid" or name == "acid"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "eviid"):
                                        self.eviid = value
                                        self.eviid.value_namespace = name_space
                                        self.eviid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "acid"):
                                        self.acid = value
                                        self.acid.value_namespace = name_space
                                        self.acid.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.bd_pseudowire_evpn:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.bd_pseudowire_evpn:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bd-pseudowire-evpns" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "bd-pseudowire-evpn"):
                                    for c in self.bd_pseudowire_evpn:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns.BdPseudowireEvpn()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.bd_pseudowire_evpn.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bd-pseudowire-evpn"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class IpSourceGuard(Entity):
                            """
                            IP Source Guard
                            
                            .. attribute:: enable
                            
                            	Enable IP Source Guard
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: logging
                            
                            	Enable Logging
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.IpSourceGuard, self).__init__()

                                self.yang_name = "ip-source-guard"
                                self.yang_parent_name = "bridge-domain"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.logging = YLeaf(YType.empty, "logging")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "logging") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.IpSourceGuard, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.IpSourceGuard, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.logging.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.logging.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ip-source-guard" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.logging.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "logging"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "logging"):
                                    self.logging = value
                                    self.logging.value_namespace = name_space
                                    self.logging.value_namespace_prefix = name_space_prefix


                        class Dai(Entity):
                            """
                            Dynamic ARP Inspection
                            
                            .. attribute:: dai_address_validation
                            
                            	Address Validation
                            	**type**\:   :py:class:`DaiAddressValidation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai.DaiAddressValidation>`
                            
                            .. attribute:: enable
                            
                            	Enable Dynamic ARP Inspection
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: logging
                            
                            	Enable Logging
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai, self).__init__()

                                self.yang_name = "dai"
                                self.yang_parent_name = "bridge-domain"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.logging = YLeaf(YType.empty, "logging")

                                self.dai_address_validation = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai.DaiAddressValidation()
                                self.dai_address_validation.parent = self
                                self._children_name_map["dai_address_validation"] = "dai-address-validation"
                                self._children_yang_names.add("dai-address-validation")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "logging") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai, self).__setattr__(name, value)


                            class DaiAddressValidation(Entity):
                                """
                                Address Validation
                                
                                .. attribute:: destination_mac_verification
                                
                                	Enable Destination MAC Verification
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: enable
                                
                                	Enable Address Validation
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: ipv4_verification
                                
                                	Enable IPv4 Verification
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: source_mac_verification
                                
                                	Enable Source MAC Verification
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai.DaiAddressValidation, self).__init__()

                                    self.yang_name = "dai-address-validation"
                                    self.yang_parent_name = "dai"

                                    self.destination_mac_verification = YLeaf(YType.empty, "destination-mac-verification")

                                    self.enable = YLeaf(YType.empty, "enable")

                                    self.ipv4_verification = YLeaf(YType.empty, "ipv4-verification")

                                    self.source_mac_verification = YLeaf(YType.empty, "source-mac-verification")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("destination_mac_verification",
                                                    "enable",
                                                    "ipv4_verification",
                                                    "source_mac_verification") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai.DaiAddressValidation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai.DaiAddressValidation, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.destination_mac_verification.is_set or
                                        self.enable.is_set or
                                        self.ipv4_verification.is_set or
                                        self.source_mac_verification.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.destination_mac_verification.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.ipv4_verification.yfilter != YFilter.not_set or
                                        self.source_mac_verification.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "dai-address-validation" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.destination_mac_verification.is_set or self.destination_mac_verification.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.destination_mac_verification.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.ipv4_verification.is_set or self.ipv4_verification.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ipv4_verification.get_name_leafdata())
                                    if (self.source_mac_verification.is_set or self.source_mac_verification.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source_mac_verification.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "destination-mac-verification" or name == "enable" or name == "ipv4-verification" or name == "source-mac-verification"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "destination-mac-verification"):
                                        self.destination_mac_verification = value
                                        self.destination_mac_verification.value_namespace = name_space
                                        self.destination_mac_verification.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ipv4-verification"):
                                        self.ipv4_verification = value
                                        self.ipv4_verification.value_namespace = name_space
                                        self.ipv4_verification.value_namespace_prefix = name_space_prefix
                                    if(value_path == "source-mac-verification"):
                                        self.source_mac_verification = value
                                        self.source_mac_verification.value_namespace = name_space
                                        self.source_mac_verification.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.logging.is_set or
                                    (self.dai_address_validation is not None and self.dai_address_validation.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.logging.yfilter != YFilter.not_set or
                                    (self.dai_address_validation is not None and self.dai_address_validation.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dai" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.logging.is_set or self.logging.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.logging.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "dai-address-validation"):
                                    if (self.dai_address_validation is None):
                                        self.dai_address_validation = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai.DaiAddressValidation()
                                        self.dai_address_validation.parent = self
                                        self._children_name_map["dai_address_validation"] = "dai-address-validation"
                                    return self.dai_address_validation

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dai-address-validation" or name == "enable" or name == "logging"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "logging"):
                                    self.logging = value
                                    self.logging.value_namespace = name_space
                                    self.logging.value_namespace_prefix = name_space_prefix


                        class RoutedInterfaces(Entity):
                            """
                            Bridge Domain Routed Interface Table
                            
                            .. attribute:: routed_interface
                            
                            	Bridge Domain Routed Interface
                            	**type**\: list of    :py:class:`RoutedInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces, self).__init__()

                                self.yang_name = "routed-interfaces"
                                self.yang_parent_name = "bridge-domain"

                                self.routed_interface = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces, self).__setattr__(name, value)


                            class RoutedInterface(Entity):
                                """
                                Bridge Domain Routed Interface
                                
                                .. attribute:: interface_name  <key>
                                
                                	The name of the Routed Interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: routed_interface_split_horizon_group
                                
                                	Routed interface split horizon group
                                	**type**\:   :py:class:`RoutedInterfaceSplitHorizonGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface.RoutedInterfaceSplitHorizonGroup>`
                                
                                

                                """

                                _prefix = 'l2vpn-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface, self).__init__()

                                    self.yang_name = "routed-interface"
                                    self.yang_parent_name = "routed-interfaces"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.routed_interface_split_horizon_group = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface.RoutedInterfaceSplitHorizonGroup()
                                    self.routed_interface_split_horizon_group.parent = self
                                    self._children_name_map["routed_interface_split_horizon_group"] = "routed-interface-split-horizon-group"
                                    self._children_yang_names.add("routed-interface-split-horizon-group")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface, self).__setattr__(name, value)


                                class RoutedInterfaceSplitHorizonGroup(Entity):
                                    """
                                    Routed interface split horizon group
                                    
                                    .. attribute:: routed_interface_split_horizon_group_core
                                    
                                    	Configure BVI under SHG 1
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    

                                    """

                                    _prefix = 'l2vpn-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface.RoutedInterfaceSplitHorizonGroup, self).__init__()

                                        self.yang_name = "routed-interface-split-horizon-group"
                                        self.yang_parent_name = "routed-interface"

                                        self.routed_interface_split_horizon_group_core = YLeaf(YType.empty, "routed-interface-split-horizon-group-core")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("routed_interface_split_horizon_group_core") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface.RoutedInterfaceSplitHorizonGroup, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface.RoutedInterfaceSplitHorizonGroup, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.routed_interface_split_horizon_group_core.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.routed_interface_split_horizon_group_core.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "routed-interface-split-horizon-group" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.routed_interface_split_horizon_group_core.is_set or self.routed_interface_split_horizon_group_core.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.routed_interface_split_horizon_group_core.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "routed-interface-split-horizon-group-core"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "routed-interface-split-horizon-group-core"):
                                            self.routed_interface_split_horizon_group_core = value
                                            self.routed_interface_split_horizon_group_core.value_namespace = name_space
                                            self.routed_interface_split_horizon_group_core.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.interface_name.is_set or
                                        (self.routed_interface_split_horizon_group is not None and self.routed_interface_split_horizon_group.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        (self.routed_interface_split_horizon_group is not None and self.routed_interface_split_horizon_group.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "routed-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "routed-interface-split-horizon-group"):
                                        if (self.routed_interface_split_horizon_group is None):
                                            self.routed_interface_split_horizon_group = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface.RoutedInterfaceSplitHorizonGroup()
                                            self.routed_interface_split_horizon_group.parent = self
                                            self._children_name_map["routed_interface_split_horizon_group"] = "routed-interface-split-horizon-group"
                                        return self.routed_interface_split_horizon_group

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "routed-interface-split-horizon-group" or name == "interface-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.routed_interface:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.routed_interface:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "routed-interfaces" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "routed-interface"):
                                    for c in self.routed_interface:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces.RoutedInterface()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.routed_interface.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "routed-interface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.name.is_set or
                                self.bridge_description.is_set or
                                self.bridge_domain_mtu.is_set or
                                self.coupled_mode.is_set or
                                self.dhcp.is_set or
                                self.flooding.is_set or
                                self.flooding_unknown_unicast.is_set or
                                self.igmp_snooping.is_set or
                                self.igmp_snooping_disable.is_set or
                                self.mld_snooping.is_set or
                                self.shutdown.is_set or
                                self.transport_mode.is_set or
                                (self.access_vfis is not None and self.access_vfis.has_data()) or
                                (self.bd_attachment_circuits is not None and self.bd_attachment_circuits.has_data()) or
                                (self.bd_pseudowire_evpns is not None and self.bd_pseudowire_evpns.has_data()) or
                                (self.bd_pseudowires is not None and self.bd_pseudowires.has_data()) or
                                (self.bd_storm_controls is not None and self.bd_storm_controls.has_data()) or
                                (self.bridge_domain_evis is not None and self.bridge_domain_evis.has_data()) or
                                (self.bridge_domain_mac is not None and self.bridge_domain_mac.has_data()) or
                                (self.bridge_domain_pbb is not None and self.bridge_domain_pbb.has_data()) or
                                (self.dai is not None and self.dai.has_data()) or
                                (self.ip_source_guard is not None and self.ip_source_guard.has_data()) or
                                (self.member_vnis is not None and self.member_vnis.has_data()) or
                                (self.nv_satellite is not None and self.nv_satellite.has_data()) or
                                (self.routed_interfaces is not None and self.routed_interfaces.has_data()) or
                                (self.vfis is not None and self.vfis.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.name.yfilter != YFilter.not_set or
                                self.bridge_description.yfilter != YFilter.not_set or
                                self.bridge_domain_mtu.yfilter != YFilter.not_set or
                                self.coupled_mode.yfilter != YFilter.not_set or
                                self.dhcp.yfilter != YFilter.not_set or
                                self.flooding.yfilter != YFilter.not_set or
                                self.flooding_unknown_unicast.yfilter != YFilter.not_set or
                                self.igmp_snooping.yfilter != YFilter.not_set or
                                self.igmp_snooping_disable.yfilter != YFilter.not_set or
                                self.mld_snooping.yfilter != YFilter.not_set or
                                self.shutdown.yfilter != YFilter.not_set or
                                self.transport_mode.yfilter != YFilter.not_set or
                                (self.access_vfis is not None and self.access_vfis.has_operation()) or
                                (self.bd_attachment_circuits is not None and self.bd_attachment_circuits.has_operation()) or
                                (self.bd_pseudowire_evpns is not None and self.bd_pseudowire_evpns.has_operation()) or
                                (self.bd_pseudowires is not None and self.bd_pseudowires.has_operation()) or
                                (self.bd_storm_controls is not None and self.bd_storm_controls.has_operation()) or
                                (self.bridge_domain_evis is not None and self.bridge_domain_evis.has_operation()) or
                                (self.bridge_domain_mac is not None and self.bridge_domain_mac.has_operation()) or
                                (self.bridge_domain_pbb is not None and self.bridge_domain_pbb.has_operation()) or
                                (self.dai is not None and self.dai.has_operation()) or
                                (self.ip_source_guard is not None and self.ip_source_guard.has_operation()) or
                                (self.member_vnis is not None and self.member_vnis.has_operation()) or
                                (self.nv_satellite is not None and self.nv_satellite.has_operation()) or
                                (self.routed_interfaces is not None and self.routed_interfaces.has_operation()) or
                                (self.vfis is not None and self.vfis.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bridge-domain" + "[name='" + self.name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.name.get_name_leafdata())
                            if (self.bridge_description.is_set or self.bridge_description.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bridge_description.get_name_leafdata())
                            if (self.bridge_domain_mtu.is_set or self.bridge_domain_mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bridge_domain_mtu.get_name_leafdata())
                            if (self.coupled_mode.is_set or self.coupled_mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.coupled_mode.get_name_leafdata())
                            if (self.dhcp.is_set or self.dhcp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dhcp.get_name_leafdata())
                            if (self.flooding.is_set or self.flooding.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.flooding.get_name_leafdata())
                            if (self.flooding_unknown_unicast.is_set or self.flooding_unknown_unicast.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.flooding_unknown_unicast.get_name_leafdata())
                            if (self.igmp_snooping.is_set or self.igmp_snooping.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igmp_snooping.get_name_leafdata())
                            if (self.igmp_snooping_disable.is_set or self.igmp_snooping_disable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.igmp_snooping_disable.get_name_leafdata())
                            if (self.mld_snooping.is_set or self.mld_snooping.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mld_snooping.get_name_leafdata())
                            if (self.shutdown.is_set or self.shutdown.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.shutdown.get_name_leafdata())
                            if (self.transport_mode.is_set or self.transport_mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.transport_mode.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "access-vfis"):
                                if (self.access_vfis is None):
                                    self.access_vfis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.AccessVfis()
                                    self.access_vfis.parent = self
                                    self._children_name_map["access_vfis"] = "access-vfis"
                                return self.access_vfis

                            if (child_yang_name == "bd-attachment-circuits"):
                                if (self.bd_attachment_circuits is None):
                                    self.bd_attachment_circuits = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdAttachmentCircuits()
                                    self.bd_attachment_circuits.parent = self
                                    self._children_name_map["bd_attachment_circuits"] = "bd-attachment-circuits"
                                return self.bd_attachment_circuits

                            if (child_yang_name == "bd-pseudowire-evpns"):
                                if (self.bd_pseudowire_evpns is None):
                                    self.bd_pseudowire_evpns = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowireEvpns()
                                    self.bd_pseudowire_evpns.parent = self
                                    self._children_name_map["bd_pseudowire_evpns"] = "bd-pseudowire-evpns"
                                return self.bd_pseudowire_evpns

                            if (child_yang_name == "bd-pseudowires"):
                                if (self.bd_pseudowires is None):
                                    self.bd_pseudowires = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdPseudowires()
                                    self.bd_pseudowires.parent = self
                                    self._children_name_map["bd_pseudowires"] = "bd-pseudowires"
                                return self.bd_pseudowires

                            if (child_yang_name == "bd-storm-controls"):
                                if (self.bd_storm_controls is None):
                                    self.bd_storm_controls = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BdStormControls()
                                    self.bd_storm_controls.parent = self
                                    self._children_name_map["bd_storm_controls"] = "bd-storm-controls"
                                return self.bd_storm_controls

                            if (child_yang_name == "bridge-domain-evis"):
                                if (self.bridge_domain_evis is None):
                                    self.bridge_domain_evis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainEvis()
                                    self.bridge_domain_evis.parent = self
                                    self._children_name_map["bridge_domain_evis"] = "bridge-domain-evis"
                                return self.bridge_domain_evis

                            if (child_yang_name == "bridge-domain-mac"):
                                if (self.bridge_domain_mac is None):
                                    self.bridge_domain_mac = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainMac()
                                    self.bridge_domain_mac.parent = self
                                    self._children_name_map["bridge_domain_mac"] = "bridge-domain-mac"
                                return self.bridge_domain_mac

                            if (child_yang_name == "bridge-domain-pbb"):
                                if (self.bridge_domain_pbb is None):
                                    self.bridge_domain_pbb = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.BridgeDomainPbb()
                                    self.bridge_domain_pbb.parent = self
                                    self._children_name_map["bridge_domain_pbb"] = "bridge-domain-pbb"
                                return self.bridge_domain_pbb

                            if (child_yang_name == "dai"):
                                if (self.dai is None):
                                    self.dai = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Dai()
                                    self.dai.parent = self
                                    self._children_name_map["dai"] = "dai"
                                return self.dai

                            if (child_yang_name == "ip-source-guard"):
                                if (self.ip_source_guard is None):
                                    self.ip_source_guard = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.IpSourceGuard()
                                    self.ip_source_guard.parent = self
                                    self._children_name_map["ip_source_guard"] = "ip-source-guard"
                                return self.ip_source_guard

                            if (child_yang_name == "member-vnis"):
                                if (self.member_vnis is None):
                                    self.member_vnis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.MemberVnis()
                                    self.member_vnis.parent = self
                                    self._children_name_map["member_vnis"] = "member-vnis"
                                return self.member_vnis

                            if (child_yang_name == "nv-satellite"):
                                if (self.nv_satellite is None):
                                    self.nv_satellite = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.NvSatellite()
                                    self.nv_satellite.parent = self
                                    self._children_name_map["nv_satellite"] = "nv-satellite"
                                return self.nv_satellite

                            if (child_yang_name == "routed-interfaces"):
                                if (self.routed_interfaces is None):
                                    self.routed_interfaces = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.RoutedInterfaces()
                                    self.routed_interfaces.parent = self
                                    self._children_name_map["routed_interfaces"] = "routed-interfaces"
                                return self.routed_interfaces

                            if (child_yang_name == "vfis"):
                                if (self.vfis is None):
                                    self.vfis = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain.Vfis()
                                    self.vfis.parent = self
                                    self._children_name_map["vfis"] = "vfis"
                                return self.vfis

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "access-vfis" or name == "bd-attachment-circuits" or name == "bd-pseudowire-evpns" or name == "bd-pseudowires" or name == "bd-storm-controls" or name == "bridge-domain-evis" or name == "bridge-domain-mac" or name == "bridge-domain-pbb" or name == "dai" or name == "ip-source-guard" or name == "member-vnis" or name == "nv-satellite" or name == "routed-interfaces" or name == "vfis" or name == "name" or name == "bridge-description" or name == "bridge-domain-mtu" or name == "coupled-mode" or name == "dhcp" or name == "flooding" or name == "flooding-unknown-unicast" or name == "igmp-snooping" or name == "igmp-snooping-disable" or name == "mld-snooping" or name == "shutdown" or name == "transport-mode"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "name"):
                                self.name = value
                                self.name.value_namespace = name_space
                                self.name.value_namespace_prefix = name_space_prefix
                            if(value_path == "bridge-description"):
                                self.bridge_description = value
                                self.bridge_description.value_namespace = name_space
                                self.bridge_description.value_namespace_prefix = name_space_prefix
                            if(value_path == "bridge-domain-mtu"):
                                self.bridge_domain_mtu = value
                                self.bridge_domain_mtu.value_namespace = name_space
                                self.bridge_domain_mtu.value_namespace_prefix = name_space_prefix
                            if(value_path == "coupled-mode"):
                                self.coupled_mode = value
                                self.coupled_mode.value_namespace = name_space
                                self.coupled_mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "dhcp"):
                                self.dhcp = value
                                self.dhcp.value_namespace = name_space
                                self.dhcp.value_namespace_prefix = name_space_prefix
                            if(value_path == "flooding"):
                                self.flooding = value
                                self.flooding.value_namespace = name_space
                                self.flooding.value_namespace_prefix = name_space_prefix
                            if(value_path == "flooding-unknown-unicast"):
                                self.flooding_unknown_unicast = value
                                self.flooding_unknown_unicast.value_namespace = name_space
                                self.flooding_unknown_unicast.value_namespace_prefix = name_space_prefix
                            if(value_path == "igmp-snooping"):
                                self.igmp_snooping = value
                                self.igmp_snooping.value_namespace = name_space
                                self.igmp_snooping.value_namespace_prefix = name_space_prefix
                            if(value_path == "igmp-snooping-disable"):
                                self.igmp_snooping_disable = value
                                self.igmp_snooping_disable.value_namespace = name_space
                                self.igmp_snooping_disable.value_namespace_prefix = name_space_prefix
                            if(value_path == "mld-snooping"):
                                self.mld_snooping = value
                                self.mld_snooping.value_namespace = name_space
                                self.mld_snooping.value_namespace_prefix = name_space_prefix
                            if(value_path == "shutdown"):
                                self.shutdown = value
                                self.shutdown.value_namespace = name_space
                                self.shutdown.value_namespace_prefix = name_space_prefix
                            if(value_path == "transport-mode"):
                                self.transport_mode = value
                                self.transport_mode.value_namespace = name_space
                                self.transport_mode.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.bridge_domain:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.bridge_domain:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bridge-domains" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bridge-domain"):
                            for c in self.bridge_domain:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains.BridgeDomain()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.bridge_domain.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bridge-domain"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.bridge_domains is not None and self.bridge_domains.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.bridge_domains is not None and self.bridge_domains.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "bridge-domain-group" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/bridge-domain-groups/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bridge-domains"):
                        if (self.bridge_domains is None):
                            self.bridge_domains = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup.BridgeDomains()
                            self.bridge_domains.parent = self
                            self._children_name_map["bridge_domains"] = "bridge-domains"
                        return self.bridge_domains

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bridge-domains" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.bridge_domain_group:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.bridge_domain_group:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bridge-domain-groups" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "bridge-domain-group"):
                    for c in self.bridge_domain_group:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = L2Vpn.Database.BridgeDomainGroups.BridgeDomainGroup()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.bridge_domain_group.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "bridge-domain-group"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class PseudowireClasses(Entity):
            """
            List of pseudowire classes
            
            .. attribute:: pseudowire_class
            
            	Pseudowire class
            	**type**\: list of    :py:class:`PseudowireClass <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Database.PseudowireClasses, self).__init__()

                self.yang_name = "pseudowire-classes"
                self.yang_parent_name = "database"

                self.pseudowire_class = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.Database.PseudowireClasses, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.Database.PseudowireClasses, self).__setattr__(name, value)


            class PseudowireClass(Entity):
                """
                Pseudowire class
                
                .. attribute:: name  <key>
                
                	Name of the pseudowire class
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: backup_disable_delay
                
                	Back Up Pseudowire class
                	**type**\:   :py:class:`BackupDisableDelay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.BackupDisableDelay>`
                
                .. attribute:: enable
                
                	Enable pseudowire class
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: l2tpv3_encapsulation
                
                	L2TPv3 encapsulation
                	**type**\:   :py:class:`L2Tpv3Encapsulation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation>`
                
                .. attribute:: mac_withdraw
                
                	Enable backup MAC withdraw
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: mpls_encapsulation
                
                	MPLS encapsulation
                	**type**\:   :py:class:`MplsEncapsulation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass, self).__init__()

                    self.yang_name = "pseudowire-class"
                    self.yang_parent_name = "pseudowire-classes"

                    self.name = YLeaf(YType.str, "name")

                    self.enable = YLeaf(YType.empty, "enable")

                    self.mac_withdraw = YLeaf(YType.empty, "mac-withdraw")

                    self.backup_disable_delay = L2Vpn.Database.PseudowireClasses.PseudowireClass.BackupDisableDelay()
                    self.backup_disable_delay.parent = self
                    self._children_name_map["backup_disable_delay"] = "backup-disable-delay"
                    self._children_yang_names.add("backup-disable-delay")

                    self.l2tpv3_encapsulation = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation()
                    self.l2tpv3_encapsulation.parent = self
                    self._children_name_map["l2tpv3_encapsulation"] = "l2tpv3-encapsulation"
                    self._children_yang_names.add("l2tpv3-encapsulation")

                    self.mpls_encapsulation = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation()
                    self.mpls_encapsulation.parent = self
                    self._children_name_map["mpls_encapsulation"] = "mpls-encapsulation"
                    self._children_yang_names.add("mpls-encapsulation")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name",
                                    "enable",
                                    "mac_withdraw") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Database.PseudowireClasses.PseudowireClass, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass, self).__setattr__(name, value)


                class L2Tpv3Encapsulation(Entity):
                    """
                    L2TPv3 encapsulation
                    
                    .. attribute:: cookie_size
                    
                    	Cookie size
                    	**type**\:   :py:class:`L2TpCookieSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpCookieSize>`
                    
                    	**default value**\: zero
                    
                    .. attribute:: df_bit_set
                    
                    	Set the do not fragment bit to 1
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: enable
                    
                    	Enable L2TPv3 encapsulation
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: path_mtu
                    
                    	Path maximum transmission unit
                    	**type**\:   :py:class:`PathMtu <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.PathMtu>`
                    
                    .. attribute:: sequencing
                    
                    	Sequencing
                    	**type**\:   :py:class:`Sequencing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.Sequencing>`
                    
                    .. attribute:: signaling_protocol
                    
                    	L2TPv3 signaling protocol
                    	**type**\:   :py:class:`SignalingProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.SignalingProtocol>`
                    
                    .. attribute:: source_address
                    
                    	Source IP address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: time_to_live
                    
                    	Time to live
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    .. attribute:: transport_mode
                    
                    	Transport mode
                    	**type**\:   :py:class:`TransportMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.TransportMode>`
                    
                    .. attribute:: type_of_service
                    
                    	Type of service
                    	**type**\:   :py:class:`TypeOfService <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.TypeOfService>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation, self).__init__()

                        self.yang_name = "l2tpv3-encapsulation"
                        self.yang_parent_name = "pseudowire-class"

                        self.cookie_size = YLeaf(YType.enumeration, "cookie-size")

                        self.df_bit_set = YLeaf(YType.empty, "df-bit-set")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.source_address = YLeaf(YType.str, "source-address")

                        self.time_to_live = YLeaf(YType.uint32, "time-to-live")

                        self.transport_mode = YLeaf(YType.enumeration, "transport-mode")

                        self.path_mtu = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.PathMtu()
                        self.path_mtu.parent = self
                        self._children_name_map["path_mtu"] = "path-mtu"
                        self._children_yang_names.add("path-mtu")

                        self.sequencing = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.Sequencing()
                        self.sequencing.parent = self
                        self._children_name_map["sequencing"] = "sequencing"
                        self._children_yang_names.add("sequencing")

                        self.signaling_protocol = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.SignalingProtocol()
                        self.signaling_protocol.parent = self
                        self._children_name_map["signaling_protocol"] = "signaling-protocol"
                        self._children_yang_names.add("signaling-protocol")

                        self.type_of_service = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.TypeOfService()
                        self.type_of_service.parent = self
                        self._children_name_map["type_of_service"] = "type-of-service"
                        self._children_yang_names.add("type-of-service")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("cookie_size",
                                        "df_bit_set",
                                        "enable",
                                        "source_address",
                                        "time_to_live",
                                        "transport_mode") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation, self).__setattr__(name, value)


                    class Sequencing(Entity):
                        """
                        Sequencing
                        
                        .. attribute:: resync_threshold
                        
                        	Out of sequence threshold
                        	**type**\:  int
                        
                        	**range:** 5..65535
                        
                        	**default value**\: 5
                        
                        .. attribute:: sequencing
                        
                        	Sequencing
                        	**type**\:   :py:class:`L2Tpv3Sequencing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Tpv3Sequencing>`
                        
                        	**default value**\: off
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.Sequencing, self).__init__()

                            self.yang_name = "sequencing"
                            self.yang_parent_name = "l2tpv3-encapsulation"

                            self.resync_threshold = YLeaf(YType.uint32, "resync-threshold")

                            self.sequencing = YLeaf(YType.enumeration, "sequencing")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("resync_threshold",
                                            "sequencing") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.Sequencing, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.Sequencing, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.resync_threshold.is_set or
                                self.sequencing.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.resync_threshold.yfilter != YFilter.not_set or
                                self.sequencing.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sequencing" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.resync_threshold.is_set or self.resync_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.resync_threshold.get_name_leafdata())
                            if (self.sequencing.is_set or self.sequencing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sequencing.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "resync-threshold" or name == "sequencing"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "resync-threshold"):
                                self.resync_threshold = value
                                self.resync_threshold.value_namespace = name_space
                                self.resync_threshold.value_namespace_prefix = name_space_prefix
                            if(value_path == "sequencing"):
                                self.sequencing = value
                                self.sequencing.value_namespace = name_space
                                self.sequencing.value_namespace_prefix = name_space_prefix


                    class TypeOfService(Entity):
                        """
                        Type of service
                        
                        .. attribute:: type_of_service_mode
                        
                        	Type of service mode
                        	**type**\:   :py:class:`TypeOfServiceMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.TypeOfServiceMode>`
                        
                        .. attribute:: type_of_service_value
                        
                        	Type of service value
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.TypeOfService, self).__init__()

                            self.yang_name = "type-of-service"
                            self.yang_parent_name = "l2tpv3-encapsulation"

                            self.type_of_service_mode = YLeaf(YType.enumeration, "type-of-service-mode")

                            self.type_of_service_value = YLeaf(YType.uint32, "type-of-service-value")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("type_of_service_mode",
                                            "type_of_service_value") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.TypeOfService, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.TypeOfService, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.type_of_service_mode.is_set or
                                self.type_of_service_value.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.type_of_service_mode.yfilter != YFilter.not_set or
                                self.type_of_service_value.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "type-of-service" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.type_of_service_mode.is_set or self.type_of_service_mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type_of_service_mode.get_name_leafdata())
                            if (self.type_of_service_value.is_set or self.type_of_service_value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type_of_service_value.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "type-of-service-mode" or name == "type-of-service-value"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "type-of-service-mode"):
                                self.type_of_service_mode = value
                                self.type_of_service_mode.value_namespace = name_space
                                self.type_of_service_mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "type-of-service-value"):
                                self.type_of_service_value = value
                                self.type_of_service_value.value_namespace = name_space
                                self.type_of_service_value.value_namespace_prefix = name_space_prefix


                    class SignalingProtocol(Entity):
                        """
                        L2TPv3 signaling protocol
                        
                        .. attribute:: l2tpv3_class_name
                        
                        	Name of the L2TPv3 class name
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: protocol
                        
                        	L2TPv3 signaling protocol
                        	**type**\:   :py:class:`L2TpSignalingProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2TpSignalingProtocol>`
                        
                        	**default value**\: l2tpv3
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.SignalingProtocol, self).__init__()

                            self.yang_name = "signaling-protocol"
                            self.yang_parent_name = "l2tpv3-encapsulation"

                            self.l2tpv3_class_name = YLeaf(YType.str, "l2tpv3-class-name")

                            self.protocol = YLeaf(YType.enumeration, "protocol")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("l2tpv3_class_name",
                                            "protocol") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.SignalingProtocol, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.SignalingProtocol, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.l2tpv3_class_name.is_set or
                                self.protocol.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.l2tpv3_class_name.yfilter != YFilter.not_set or
                                self.protocol.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "signaling-protocol" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.l2tpv3_class_name.is_set or self.l2tpv3_class_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.l2tpv3_class_name.get_name_leafdata())
                            if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protocol.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "l2tpv3-class-name" or name == "protocol"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "l2tpv3-class-name"):
                                self.l2tpv3_class_name = value
                                self.l2tpv3_class_name.value_namespace = name_space
                                self.l2tpv3_class_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "protocol"):
                                self.protocol = value
                                self.protocol.value_namespace = name_space
                                self.protocol.value_namespace_prefix = name_space_prefix


                    class PathMtu(Entity):
                        """
                        Path maximum transmission unit
                        
                        .. attribute:: enable
                        
                        	Enable path MTU
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: max_path_mtu
                        
                        	Maximum path maximum transmission unit
                        	**type**\:  int
                        
                        	**range:** 68..65535
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.PathMtu, self).__init__()

                            self.yang_name = "path-mtu"
                            self.yang_parent_name = "l2tpv3-encapsulation"

                            self.enable = YLeaf(YType.empty, "enable")

                            self.max_path_mtu = YLeaf(YType.uint32, "max-path-mtu")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "max_path_mtu") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.PathMtu, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.PathMtu, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.max_path_mtu.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.max_path_mtu.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-mtu" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.max_path_mtu.is_set or self.max_path_mtu.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.max_path_mtu.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable" or name == "max-path-mtu"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "max-path-mtu"):
                                self.max_path_mtu = value
                                self.max_path_mtu.value_namespace = name_space
                                self.max_path_mtu.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.cookie_size.is_set or
                            self.df_bit_set.is_set or
                            self.enable.is_set or
                            self.source_address.is_set or
                            self.time_to_live.is_set or
                            self.transport_mode.is_set or
                            (self.path_mtu is not None and self.path_mtu.has_data()) or
                            (self.sequencing is not None and self.sequencing.has_data()) or
                            (self.signaling_protocol is not None and self.signaling_protocol.has_data()) or
                            (self.type_of_service is not None and self.type_of_service.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.cookie_size.yfilter != YFilter.not_set or
                            self.df_bit_set.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.source_address.yfilter != YFilter.not_set or
                            self.time_to_live.yfilter != YFilter.not_set or
                            self.transport_mode.yfilter != YFilter.not_set or
                            (self.path_mtu is not None and self.path_mtu.has_operation()) or
                            (self.sequencing is not None and self.sequencing.has_operation()) or
                            (self.signaling_protocol is not None and self.signaling_protocol.has_operation()) or
                            (self.type_of_service is not None and self.type_of_service.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "l2tpv3-encapsulation" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.cookie_size.is_set or self.cookie_size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.cookie_size.get_name_leafdata())
                        if (self.df_bit_set.is_set or self.df_bit_set.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.df_bit_set.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_address.get_name_leafdata())
                        if (self.time_to_live.is_set or self.time_to_live.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.time_to_live.get_name_leafdata())
                        if (self.transport_mode.is_set or self.transport_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.transport_mode.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "path-mtu"):
                            if (self.path_mtu is None):
                                self.path_mtu = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.PathMtu()
                                self.path_mtu.parent = self
                                self._children_name_map["path_mtu"] = "path-mtu"
                            return self.path_mtu

                        if (child_yang_name == "sequencing"):
                            if (self.sequencing is None):
                                self.sequencing = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.Sequencing()
                                self.sequencing.parent = self
                                self._children_name_map["sequencing"] = "sequencing"
                            return self.sequencing

                        if (child_yang_name == "signaling-protocol"):
                            if (self.signaling_protocol is None):
                                self.signaling_protocol = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.SignalingProtocol()
                                self.signaling_protocol.parent = self
                                self._children_name_map["signaling_protocol"] = "signaling-protocol"
                            return self.signaling_protocol

                        if (child_yang_name == "type-of-service"):
                            if (self.type_of_service is None):
                                self.type_of_service = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation.TypeOfService()
                                self.type_of_service.parent = self
                                self._children_name_map["type_of_service"] = "type-of-service"
                            return self.type_of_service

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "path-mtu" or name == "sequencing" or name == "signaling-protocol" or name == "type-of-service" or name == "cookie-size" or name == "df-bit-set" or name == "enable" or name == "source-address" or name == "time-to-live" or name == "transport-mode"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "cookie-size"):
                            self.cookie_size = value
                            self.cookie_size.value_namespace = name_space
                            self.cookie_size.value_namespace_prefix = name_space_prefix
                        if(value_path == "df-bit-set"):
                            self.df_bit_set = value
                            self.df_bit_set.value_namespace = name_space
                            self.df_bit_set.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-address"):
                            self.source_address = value
                            self.source_address.value_namespace = name_space
                            self.source_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "time-to-live"):
                            self.time_to_live = value
                            self.time_to_live.value_namespace = name_space
                            self.time_to_live.value_namespace_prefix = name_space_prefix
                        if(value_path == "transport-mode"):
                            self.transport_mode = value
                            self.transport_mode.value_namespace = name_space
                            self.transport_mode.value_namespace_prefix = name_space_prefix


                class BackupDisableDelay(Entity):
                    """
                    Back Up Pseudowire class
                    
                    .. attribute:: disable_backup
                    
                    	Disable backup delay
                    	**type**\:  int
                    
                    	**range:** 0..180
                    
                    .. attribute:: type
                    
                    	Delay or Never
                    	**type**\:   :py:class:`BackupDisable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BackupDisable>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.BackupDisableDelay, self).__init__()

                        self.yang_name = "backup-disable-delay"
                        self.yang_parent_name = "pseudowire-class"

                        self.disable_backup = YLeaf(YType.uint32, "disable-backup")

                        self.type = YLeaf(YType.enumeration, "type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable_backup",
                                        "type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.BackupDisableDelay, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.PseudowireClasses.PseudowireClass.BackupDisableDelay, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.disable_backup.is_set or
                            self.type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable_backup.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "backup-disable-delay" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable_backup.is_set or self.disable_backup.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable_backup.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable-backup" or name == "type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable-backup"):
                            self.disable_backup = value
                            self.disable_backup.value_namespace = name_space
                            self.disable_backup.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix


                class MplsEncapsulation(Entity):
                    """
                    MPLS encapsulation
                    
                    .. attribute:: control_word
                    
                    	Enable control word
                    	**type**\:   :py:class:`ControlWord <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.ControlWord>`
                    
                    .. attribute:: enable
                    
                    	Enable MPLS encapsulation
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: load_balance_group
                    
                    	Load Balancing
                    	**type**\:   :py:class:`LoadBalanceGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup>`
                    
                    .. attribute:: mpls_redundancy
                    
                    	Redundancy options for MPLS encapsulation
                    	**type**\:   :py:class:`MplsRedundancy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.MplsRedundancy>`
                    
                    .. attribute:: preferred_path
                    
                    	Preferred path
                    	**type**\:   :py:class:`PreferredPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.PreferredPath>`
                    
                    .. attribute:: pw_switching_tlv
                    
                    	Pseudowire Switching Point Tlv
                    	**type**\:   :py:class:`PwSwitchingPointTlv <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.PwSwitchingPointTlv>`
                    
                    .. attribute:: sequencing
                    
                    	Sequencing
                    	**type**\:   :py:class:`Sequencing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.Sequencing>`
                    
                    .. attribute:: signaling_protocol
                    
                    	MPLS signaling protocol
                    	**type**\:   :py:class:`MplsSignalingProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MplsSignalingProtocol>`
                    
                    	**default value**\: ldp
                    
                    .. attribute:: source_address
                    
                    	Source IP address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: static_tag_rewrite
                    
                    	Static Tag rewrite
                    	**type**\:  int
                    
                    	**range:** 1..4094
                    
                    .. attribute:: transport_mode
                    
                    	Transport mode
                    	**type**\:   :py:class:`TransportMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.TransportMode>`
                    
                    .. attribute:: vccv_type
                    
                    	VCCV verification type
                    	**type**\:   :py:class:`VccvVerification <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.VccvVerification>`
                    
                    	**default value**\: lsp-ping
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation, self).__init__()

                        self.yang_name = "mpls-encapsulation"
                        self.yang_parent_name = "pseudowire-class"

                        self.control_word = YLeaf(YType.enumeration, "control-word")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.pw_switching_tlv = YLeaf(YType.enumeration, "pw-switching-tlv")

                        self.signaling_protocol = YLeaf(YType.enumeration, "signaling-protocol")

                        self.source_address = YLeaf(YType.str, "source-address")

                        self.static_tag_rewrite = YLeaf(YType.uint32, "static-tag-rewrite")

                        self.transport_mode = YLeaf(YType.enumeration, "transport-mode")

                        self.vccv_type = YLeaf(YType.enumeration, "vccv-type")

                        self.load_balance_group = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup()
                        self.load_balance_group.parent = self
                        self._children_name_map["load_balance_group"] = "load-balance-group"
                        self._children_yang_names.add("load-balance-group")

                        self.mpls_redundancy = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.MplsRedundancy()
                        self.mpls_redundancy.parent = self
                        self._children_name_map["mpls_redundancy"] = "mpls-redundancy"
                        self._children_yang_names.add("mpls-redundancy")

                        self.preferred_path = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.PreferredPath()
                        self.preferred_path.parent = self
                        self._children_name_map["preferred_path"] = "preferred-path"
                        self._children_yang_names.add("preferred-path")

                        self.sequencing = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.Sequencing()
                        self.sequencing.parent = self
                        self._children_name_map["sequencing"] = "sequencing"
                        self._children_yang_names.add("sequencing")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("control_word",
                                        "enable",
                                        "pw_switching_tlv",
                                        "signaling_protocol",
                                        "source_address",
                                        "static_tag_rewrite",
                                        "transport_mode",
                                        "vccv_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation, self).__setattr__(name, value)


                    class Sequencing(Entity):
                        """
                        Sequencing
                        
                        .. attribute:: resync_threshold
                        
                        	Out of sequence threshold
                        	**type**\:  int
                        
                        	**range:** 5..65535
                        
                        	**default value**\: 5
                        
                        .. attribute:: sequencing
                        
                        	Sequencing
                        	**type**\:   :py:class:`MplsSequencing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.MplsSequencing>`
                        
                        	**default value**\: off
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.Sequencing, self).__init__()

                            self.yang_name = "sequencing"
                            self.yang_parent_name = "mpls-encapsulation"

                            self.resync_threshold = YLeaf(YType.uint32, "resync-threshold")

                            self.sequencing = YLeaf(YType.enumeration, "sequencing")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("resync_threshold",
                                            "sequencing") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.Sequencing, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.Sequencing, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.resync_threshold.is_set or
                                self.sequencing.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.resync_threshold.yfilter != YFilter.not_set or
                                self.sequencing.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sequencing" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.resync_threshold.is_set or self.resync_threshold.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.resync_threshold.get_name_leafdata())
                            if (self.sequencing.is_set or self.sequencing.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sequencing.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "resync-threshold" or name == "sequencing"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "resync-threshold"):
                                self.resync_threshold = value
                                self.resync_threshold.value_namespace = name_space
                                self.resync_threshold.value_namespace_prefix = name_space_prefix
                            if(value_path == "sequencing"):
                                self.sequencing = value
                                self.sequencing.value_namespace = name_space
                                self.sequencing.value_namespace_prefix = name_space_prefix


                    class MplsRedundancy(Entity):
                        """
                        Redundancy options for MPLS encapsulation
                        
                        .. attribute:: redundancy_initial_delay
                        
                        	Initial delay before activating the redundant PW, in seconds
                        	**type**\:  int
                        
                        	**range:** 0..120
                        
                        	**units**\: second
                        
                        .. attribute:: redundancy_one_way
                        
                        	Force one\-way PW redundancy behavior in Redundancy Group
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.MplsRedundancy, self).__init__()

                            self.yang_name = "mpls-redundancy"
                            self.yang_parent_name = "mpls-encapsulation"

                            self.redundancy_initial_delay = YLeaf(YType.uint32, "redundancy-initial-delay")

                            self.redundancy_one_way = YLeaf(YType.empty, "redundancy-one-way")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("redundancy_initial_delay",
                                            "redundancy_one_way") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.MplsRedundancy, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.MplsRedundancy, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.redundancy_initial_delay.is_set or
                                self.redundancy_one_way.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.redundancy_initial_delay.yfilter != YFilter.not_set or
                                self.redundancy_one_way.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "mpls-redundancy" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.redundancy_initial_delay.is_set or self.redundancy_initial_delay.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.redundancy_initial_delay.get_name_leafdata())
                            if (self.redundancy_one_way.is_set or self.redundancy_one_way.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.redundancy_one_way.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "redundancy-initial-delay" or name == "redundancy-one-way"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "redundancy-initial-delay"):
                                self.redundancy_initial_delay = value
                                self.redundancy_initial_delay.value_namespace = name_space
                                self.redundancy_initial_delay.value_namespace_prefix = name_space_prefix
                            if(value_path == "redundancy-one-way"):
                                self.redundancy_one_way = value
                                self.redundancy_one_way.value_namespace = name_space
                                self.redundancy_one_way.value_namespace_prefix = name_space_prefix


                    class PreferredPath(Entity):
                        """
                        Preferred path
                        
                        .. attribute:: fallback_disable
                        
                        	Fallback disable
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: interface_tunnel_number
                        
                        	Interface Tunnel number for preferred path
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: type
                        
                        	Preferred Path Type
                        	**type**\:   :py:class:`PreferredPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.PreferredPath>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.PreferredPath, self).__init__()

                            self.yang_name = "preferred-path"
                            self.yang_parent_name = "mpls-encapsulation"

                            self.fallback_disable = YLeaf(YType.empty, "fallback-disable")

                            self.interface_tunnel_number = YLeaf(YType.uint32, "interface-tunnel-number")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("fallback_disable",
                                            "interface_tunnel_number",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.PreferredPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.PreferredPath, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.fallback_disable.is_set or
                                self.interface_tunnel_number.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.fallback_disable.yfilter != YFilter.not_set or
                                self.interface_tunnel_number.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "preferred-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.fallback_disable.is_set or self.fallback_disable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fallback_disable.get_name_leafdata())
                            if (self.interface_tunnel_number.is_set or self.interface_tunnel_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_tunnel_number.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "fallback-disable" or name == "interface-tunnel-number" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "fallback-disable"):
                                self.fallback_disable = value
                                self.fallback_disable.value_namespace = name_space
                                self.fallback_disable.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface-tunnel-number"):
                                self.interface_tunnel_number = value
                                self.interface_tunnel_number.value_namespace = name_space
                                self.interface_tunnel_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix


                    class LoadBalanceGroup(Entity):
                        """
                        Load Balancing
                        
                        .. attribute:: flow_label_load_balance
                        
                        	Enable Flow Label based load balancing
                        	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup.FlowLabelLoadBalance>`
                        
                        .. attribute:: flow_label_load_balance_code
                        
                        	Enable Legacy Flow Label TLV code
                        	**type**\:   :py:class:`FlowLabelTlvCode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.FlowLabelTlvCode>`
                        
                        .. attribute:: pw_label_load_balance
                        
                        	Enable PW Label based Load Balancing
                        	**type**\:   :py:class:`LoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.LoadBalance>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup, self).__init__()

                            self.yang_name = "load-balance-group"
                            self.yang_parent_name = "mpls-encapsulation"

                            self.flow_label_load_balance_code = YLeaf(YType.enumeration, "flow-label-load-balance-code")

                            self.pw_label_load_balance = YLeaf(YType.enumeration, "pw-label-load-balance")

                            self.flow_label_load_balance = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup.FlowLabelLoadBalance()
                            self.flow_label_load_balance.parent = self
                            self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                            self._children_yang_names.add("flow-label-load-balance")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("flow_label_load_balance_code",
                                            "pw_label_load_balance") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup, self).__setattr__(name, value)


                        class FlowLabelLoadBalance(Entity):
                            """
                            Enable Flow Label based load balancing
                            
                            .. attribute:: flow_label
                            
                            	Flow Label load balance type
                            	**type**\:   :py:class:`FlowLabelLoadBalance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.FlowLabelLoadBalance>`
                            
                            .. attribute:: static
                            
                            	Static Flow Label
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup.FlowLabelLoadBalance, self).__init__()

                                self.yang_name = "flow-label-load-balance"
                                self.yang_parent_name = "load-balance-group"

                                self.flow_label = YLeaf(YType.enumeration, "flow-label")

                                self.static = YLeaf(YType.empty, "static")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("flow_label",
                                                "static") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup.FlowLabelLoadBalance, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup.FlowLabelLoadBalance, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.flow_label.is_set or
                                    self.static.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.flow_label.yfilter != YFilter.not_set or
                                    self.static.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "flow-label-load-balance" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.flow_label.is_set or self.flow_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.flow_label.get_name_leafdata())
                                if (self.static.is_set or self.static.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.static.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "flow-label" or name == "static"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "flow-label"):
                                    self.flow_label = value
                                    self.flow_label.value_namespace = name_space
                                    self.flow_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "static"):
                                    self.static = value
                                    self.static.value_namespace = name_space
                                    self.static.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.flow_label_load_balance_code.is_set or
                                self.pw_label_load_balance.is_set or
                                (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.flow_label_load_balance_code.yfilter != YFilter.not_set or
                                self.pw_label_load_balance.yfilter != YFilter.not_set or
                                (self.flow_label_load_balance is not None and self.flow_label_load_balance.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "load-balance-group" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.flow_label_load_balance_code.is_set or self.flow_label_load_balance_code.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.flow_label_load_balance_code.get_name_leafdata())
                            if (self.pw_label_load_balance.is_set or self.pw_label_load_balance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pw_label_load_balance.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "flow-label-load-balance"):
                                if (self.flow_label_load_balance is None):
                                    self.flow_label_load_balance = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup.FlowLabelLoadBalance()
                                    self.flow_label_load_balance.parent = self
                                    self._children_name_map["flow_label_load_balance"] = "flow-label-load-balance"
                                return self.flow_label_load_balance

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "flow-label-load-balance" or name == "flow-label-load-balance-code" or name == "pw-label-load-balance"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "flow-label-load-balance-code"):
                                self.flow_label_load_balance_code = value
                                self.flow_label_load_balance_code.value_namespace = name_space
                                self.flow_label_load_balance_code.value_namespace_prefix = name_space_prefix
                            if(value_path == "pw-label-load-balance"):
                                self.pw_label_load_balance = value
                                self.pw_label_load_balance.value_namespace = name_space
                                self.pw_label_load_balance.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.control_word.is_set or
                            self.enable.is_set or
                            self.pw_switching_tlv.is_set or
                            self.signaling_protocol.is_set or
                            self.source_address.is_set or
                            self.static_tag_rewrite.is_set or
                            self.transport_mode.is_set or
                            self.vccv_type.is_set or
                            (self.load_balance_group is not None and self.load_balance_group.has_data()) or
                            (self.mpls_redundancy is not None and self.mpls_redundancy.has_data()) or
                            (self.preferred_path is not None and self.preferred_path.has_data()) or
                            (self.sequencing is not None and self.sequencing.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.control_word.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.pw_switching_tlv.yfilter != YFilter.not_set or
                            self.signaling_protocol.yfilter != YFilter.not_set or
                            self.source_address.yfilter != YFilter.not_set or
                            self.static_tag_rewrite.yfilter != YFilter.not_set or
                            self.transport_mode.yfilter != YFilter.not_set or
                            self.vccv_type.yfilter != YFilter.not_set or
                            (self.load_balance_group is not None and self.load_balance_group.has_operation()) or
                            (self.mpls_redundancy is not None and self.mpls_redundancy.has_operation()) or
                            (self.preferred_path is not None and self.preferred_path.has_operation()) or
                            (self.sequencing is not None and self.sequencing.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "mpls-encapsulation" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.control_word.is_set or self.control_word.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_word.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.pw_switching_tlv.is_set or self.pw_switching_tlv.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pw_switching_tlv.get_name_leafdata())
                        if (self.signaling_protocol.is_set or self.signaling_protocol.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.signaling_protocol.get_name_leafdata())
                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_address.get_name_leafdata())
                        if (self.static_tag_rewrite.is_set or self.static_tag_rewrite.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.static_tag_rewrite.get_name_leafdata())
                        if (self.transport_mode.is_set or self.transport_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.transport_mode.get_name_leafdata())
                        if (self.vccv_type.is_set or self.vccv_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vccv_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "load-balance-group"):
                            if (self.load_balance_group is None):
                                self.load_balance_group = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.LoadBalanceGroup()
                                self.load_balance_group.parent = self
                                self._children_name_map["load_balance_group"] = "load-balance-group"
                            return self.load_balance_group

                        if (child_yang_name == "mpls-redundancy"):
                            if (self.mpls_redundancy is None):
                                self.mpls_redundancy = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.MplsRedundancy()
                                self.mpls_redundancy.parent = self
                                self._children_name_map["mpls_redundancy"] = "mpls-redundancy"
                            return self.mpls_redundancy

                        if (child_yang_name == "preferred-path"):
                            if (self.preferred_path is None):
                                self.preferred_path = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.PreferredPath()
                                self.preferred_path.parent = self
                                self._children_name_map["preferred_path"] = "preferred-path"
                            return self.preferred_path

                        if (child_yang_name == "sequencing"):
                            if (self.sequencing is None):
                                self.sequencing = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation.Sequencing()
                                self.sequencing.parent = self
                                self._children_name_map["sequencing"] = "sequencing"
                            return self.sequencing

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "load-balance-group" or name == "mpls-redundancy" or name == "preferred-path" or name == "sequencing" or name == "control-word" or name == "enable" or name == "pw-switching-tlv" or name == "signaling-protocol" or name == "source-address" or name == "static-tag-rewrite" or name == "transport-mode" or name == "vccv-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "control-word"):
                            self.control_word = value
                            self.control_word.value_namespace = name_space
                            self.control_word.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "pw-switching-tlv"):
                            self.pw_switching_tlv = value
                            self.pw_switching_tlv.value_namespace = name_space
                            self.pw_switching_tlv.value_namespace_prefix = name_space_prefix
                        if(value_path == "signaling-protocol"):
                            self.signaling_protocol = value
                            self.signaling_protocol.value_namespace = name_space
                            self.signaling_protocol.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-address"):
                            self.source_address = value
                            self.source_address.value_namespace = name_space
                            self.source_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "static-tag-rewrite"):
                            self.static_tag_rewrite = value
                            self.static_tag_rewrite.value_namespace = name_space
                            self.static_tag_rewrite.value_namespace_prefix = name_space_prefix
                        if(value_path == "transport-mode"):
                            self.transport_mode = value
                            self.transport_mode.value_namespace = name_space
                            self.transport_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "vccv-type"):
                            self.vccv_type = value
                            self.vccv_type.value_namespace = name_space
                            self.vccv_type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.name.is_set or
                        self.enable.is_set or
                        self.mac_withdraw.is_set or
                        (self.backup_disable_delay is not None and self.backup_disable_delay.has_data()) or
                        (self.l2tpv3_encapsulation is not None and self.l2tpv3_encapsulation.has_data()) or
                        (self.mpls_encapsulation is not None and self.mpls_encapsulation.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.mac_withdraw.yfilter != YFilter.not_set or
                        (self.backup_disable_delay is not None and self.backup_disable_delay.has_operation()) or
                        (self.l2tpv3_encapsulation is not None and self.l2tpv3_encapsulation.has_operation()) or
                        (self.mpls_encapsulation is not None and self.mpls_encapsulation.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "pseudowire-class" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/pseudowire-classes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.mac_withdraw.is_set or self.mac_withdraw.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_withdraw.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "backup-disable-delay"):
                        if (self.backup_disable_delay is None):
                            self.backup_disable_delay = L2Vpn.Database.PseudowireClasses.PseudowireClass.BackupDisableDelay()
                            self.backup_disable_delay.parent = self
                            self._children_name_map["backup_disable_delay"] = "backup-disable-delay"
                        return self.backup_disable_delay

                    if (child_yang_name == "l2tpv3-encapsulation"):
                        if (self.l2tpv3_encapsulation is None):
                            self.l2tpv3_encapsulation = L2Vpn.Database.PseudowireClasses.PseudowireClass.L2Tpv3Encapsulation()
                            self.l2tpv3_encapsulation.parent = self
                            self._children_name_map["l2tpv3_encapsulation"] = "l2tpv3-encapsulation"
                        return self.l2tpv3_encapsulation

                    if (child_yang_name == "mpls-encapsulation"):
                        if (self.mpls_encapsulation is None):
                            self.mpls_encapsulation = L2Vpn.Database.PseudowireClasses.PseudowireClass.MplsEncapsulation()
                            self.mpls_encapsulation.parent = self
                            self._children_name_map["mpls_encapsulation"] = "mpls-encapsulation"
                        return self.mpls_encapsulation

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "backup-disable-delay" or name == "l2tpv3-encapsulation" or name == "mpls-encapsulation" or name == "name" or name == "enable" or name == "mac-withdraw"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-withdraw"):
                        self.mac_withdraw = value
                        self.mac_withdraw.value_namespace = name_space
                        self.mac_withdraw.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.pseudowire_class:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.pseudowire_class:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "pseudowire-classes" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "pseudowire-class"):
                    for c in self.pseudowire_class:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = L2Vpn.Database.PseudowireClasses.PseudowireClass()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.pseudowire_class.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "pseudowire-class"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class FlexibleXconnectServiceTable(Entity):
            """
            List of Flexible XConnect Services
            
            .. attribute:: vlan_aware_flexible_xconnect_services
            
            	List of Vlan\-Aware Flexible XConnect Services
            	**type**\:   :py:class:`VlanAwareFlexibleXconnectServices <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices>`
            
            .. attribute:: vlan_unaware_flexible_xconnect_services
            
            	List of Vlan\-Unaware Flexible XConnect Services
            	**type**\:   :py:class:`VlanUnawareFlexibleXconnectServices <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Database.FlexibleXconnectServiceTable, self).__init__()

                self.yang_name = "flexible-xconnect-service-table"
                self.yang_parent_name = "database"

                self.vlan_aware_flexible_xconnect_services = L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices()
                self.vlan_aware_flexible_xconnect_services.parent = self
                self._children_name_map["vlan_aware_flexible_xconnect_services"] = "vlan-aware-flexible-xconnect-services"
                self._children_yang_names.add("vlan-aware-flexible-xconnect-services")

                self.vlan_unaware_flexible_xconnect_services = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices()
                self.vlan_unaware_flexible_xconnect_services.parent = self
                self._children_name_map["vlan_unaware_flexible_xconnect_services"] = "vlan-unaware-flexible-xconnect-services"
                self._children_yang_names.add("vlan-unaware-flexible-xconnect-services")


            class VlanUnawareFlexibleXconnectServices(Entity):
                """
                List of Vlan\-Unaware Flexible XConnect
                Services
                
                .. attribute:: vlan_unaware_flexible_xconnect_service
                
                	Flexible XConnect Service
                	**type**\: list of    :py:class:`VlanUnawareFlexibleXconnectService <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices, self).__init__()

                    self.yang_name = "vlan-unaware-flexible-xconnect-services"
                    self.yang_parent_name = "flexible-xconnect-service-table"

                    self.vlan_unaware_flexible_xconnect_service = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices, self).__setattr__(name, value)


                class VlanUnawareFlexibleXconnectService(Entity):
                    """
                    Flexible XConnect Service
                    
                    .. attribute:: name  <key>
                    
                    	Name of the Flexible XConnect Service
                    	**type**\:  str
                    
                    	**length:** 1..23
                    
                    .. attribute:: vlan_unaware_fxc_attachment_circuits
                    
                    	List of attachment circuits
                    	**type**\:   :py:class:`VlanUnawareFxcAttachmentCircuits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits>`
                    
                    .. attribute:: vlan_unaware_fxc_pseudowire_evpns
                    
                    	List of EVPN Services
                    	**type**\:   :py:class:`VlanUnawareFxcPseudowireEvpns <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService, self).__init__()

                        self.yang_name = "vlan-unaware-flexible-xconnect-service"
                        self.yang_parent_name = "vlan-unaware-flexible-xconnect-services"

                        self.name = YLeaf(YType.str, "name")

                        self.vlan_unaware_fxc_attachment_circuits = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits()
                        self.vlan_unaware_fxc_attachment_circuits.parent = self
                        self._children_name_map["vlan_unaware_fxc_attachment_circuits"] = "vlan-unaware-fxc-attachment-circuits"
                        self._children_yang_names.add("vlan-unaware-fxc-attachment-circuits")

                        self.vlan_unaware_fxc_pseudowire_evpns = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns()
                        self.vlan_unaware_fxc_pseudowire_evpns.parent = self
                        self._children_name_map["vlan_unaware_fxc_pseudowire_evpns"] = "vlan-unaware-fxc-pseudowire-evpns"
                        self._children_yang_names.add("vlan-unaware-fxc-pseudowire-evpns")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService, self).__setattr__(name, value)


                    class VlanUnawareFxcAttachmentCircuits(Entity):
                        """
                        List of attachment circuits
                        
                        .. attribute:: vlan_unaware_fxc_attachment_circuit
                        
                        	Attachment circuit interface
                        	**type**\: list of    :py:class:`VlanUnawareFxcAttachmentCircuit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits.VlanUnawareFxcAttachmentCircuit>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits, self).__init__()

                            self.yang_name = "vlan-unaware-fxc-attachment-circuits"
                            self.yang_parent_name = "vlan-unaware-flexible-xconnect-service"

                            self.vlan_unaware_fxc_attachment_circuit = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits, self).__setattr__(name, value)


                        class VlanUnawareFxcAttachmentCircuit(Entity):
                            """
                            Attachment circuit interface
                            
                            .. attribute:: name  <key>
                            
                            	Name of the attachment circuit interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits.VlanUnawareFxcAttachmentCircuit, self).__init__()

                                self.yang_name = "vlan-unaware-fxc-attachment-circuit"
                                self.yang_parent_name = "vlan-unaware-fxc-attachment-circuits"

                                self.name = YLeaf(YType.str, "name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits.VlanUnawareFxcAttachmentCircuit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits.VlanUnawareFxcAttachmentCircuit, self).__setattr__(name, value)

                            def has_data(self):
                                return self.name.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "vlan-unaware-fxc-attachment-circuit" + "[name='" + self.name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.vlan_unaware_fxc_attachment_circuit:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.vlan_unaware_fxc_attachment_circuit:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "vlan-unaware-fxc-attachment-circuits" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "vlan-unaware-fxc-attachment-circuit"):
                                for c in self.vlan_unaware_fxc_attachment_circuit:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits.VlanUnawareFxcAttachmentCircuit()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.vlan_unaware_fxc_attachment_circuit.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "vlan-unaware-fxc-attachment-circuit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class VlanUnawareFxcPseudowireEvpns(Entity):
                        """
                        List of EVPN Services
                        
                        .. attribute:: vlan_unaware_fxc_pseudowire_evpn
                        
                        	EVPN FXC Service Configuration
                        	**type**\: list of    :py:class:`VlanUnawareFxcPseudowireEvpn <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns.VlanUnawareFxcPseudowireEvpn>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns, self).__init__()

                            self.yang_name = "vlan-unaware-fxc-pseudowire-evpns"
                            self.yang_parent_name = "vlan-unaware-flexible-xconnect-service"

                            self.vlan_unaware_fxc_pseudowire_evpn = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns, self).__setattr__(name, value)


                        class VlanUnawareFxcPseudowireEvpn(Entity):
                            """
                            EVPN FXC Service Configuration
                            
                            .. attribute:: eviid  <key>
                            
                            	Ethernet VPN ID
                            	**type**\:  int
                            
                            	**range:** 1..65534
                            
                            .. attribute:: acid  <key>
                            
                            	AC ID
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns.VlanUnawareFxcPseudowireEvpn, self).__init__()

                                self.yang_name = "vlan-unaware-fxc-pseudowire-evpn"
                                self.yang_parent_name = "vlan-unaware-fxc-pseudowire-evpns"

                                self.eviid = YLeaf(YType.uint32, "eviid")

                                self.acid = YLeaf(YType.uint32, "acid")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("eviid",
                                                "acid") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns.VlanUnawareFxcPseudowireEvpn, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns.VlanUnawareFxcPseudowireEvpn, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.eviid.is_set or
                                    self.acid.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.eviid.yfilter != YFilter.not_set or
                                    self.acid.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "vlan-unaware-fxc-pseudowire-evpn" + "[eviid='" + self.eviid.get() + "']" + "[acid='" + self.acid.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eviid.get_name_leafdata())
                                if (self.acid.is_set or self.acid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.acid.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "eviid" or name == "acid"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "eviid"):
                                    self.eviid = value
                                    self.eviid.value_namespace = name_space
                                    self.eviid.value_namespace_prefix = name_space_prefix
                                if(value_path == "acid"):
                                    self.acid = value
                                    self.acid.value_namespace = name_space
                                    self.acid.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.vlan_unaware_fxc_pseudowire_evpn:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.vlan_unaware_fxc_pseudowire_evpn:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "vlan-unaware-fxc-pseudowire-evpns" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "vlan-unaware-fxc-pseudowire-evpn"):
                                for c in self.vlan_unaware_fxc_pseudowire_evpn:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns.VlanUnawareFxcPseudowireEvpn()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.vlan_unaware_fxc_pseudowire_evpn.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "vlan-unaware-fxc-pseudowire-evpn"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.name.is_set or
                            (self.vlan_unaware_fxc_attachment_circuits is not None and self.vlan_unaware_fxc_attachment_circuits.has_data()) or
                            (self.vlan_unaware_fxc_pseudowire_evpns is not None and self.vlan_unaware_fxc_pseudowire_evpns.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            (self.vlan_unaware_fxc_attachment_circuits is not None and self.vlan_unaware_fxc_attachment_circuits.has_operation()) or
                            (self.vlan_unaware_fxc_pseudowire_evpns is not None and self.vlan_unaware_fxc_pseudowire_evpns.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "vlan-unaware-flexible-xconnect-service" + "[name='" + self.name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/flexible-xconnect-service-table/vlan-unaware-flexible-xconnect-services/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "vlan-unaware-fxc-attachment-circuits"):
                            if (self.vlan_unaware_fxc_attachment_circuits is None):
                                self.vlan_unaware_fxc_attachment_circuits = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcAttachmentCircuits()
                                self.vlan_unaware_fxc_attachment_circuits.parent = self
                                self._children_name_map["vlan_unaware_fxc_attachment_circuits"] = "vlan-unaware-fxc-attachment-circuits"
                            return self.vlan_unaware_fxc_attachment_circuits

                        if (child_yang_name == "vlan-unaware-fxc-pseudowire-evpns"):
                            if (self.vlan_unaware_fxc_pseudowire_evpns is None):
                                self.vlan_unaware_fxc_pseudowire_evpns = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService.VlanUnawareFxcPseudowireEvpns()
                                self.vlan_unaware_fxc_pseudowire_evpns.parent = self
                                self._children_name_map["vlan_unaware_fxc_pseudowire_evpns"] = "vlan-unaware-fxc-pseudowire-evpns"
                            return self.vlan_unaware_fxc_pseudowire_evpns

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "vlan-unaware-fxc-attachment-circuits" or name == "vlan-unaware-fxc-pseudowire-evpns" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.vlan_unaware_flexible_xconnect_service:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.vlan_unaware_flexible_xconnect_service:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "vlan-unaware-flexible-xconnect-services" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/flexible-xconnect-service-table/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "vlan-unaware-flexible-xconnect-service"):
                        for c in self.vlan_unaware_flexible_xconnect_service:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices.VlanUnawareFlexibleXconnectService()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.vlan_unaware_flexible_xconnect_service.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vlan-unaware-flexible-xconnect-service"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class VlanAwareFlexibleXconnectServices(Entity):
                """
                List of Vlan\-Aware Flexible XConnect Services
                
                .. attribute:: vlan_aware_flexible_xconnect_service
                
                	Flexible XConnect Service
                	**type**\: list of    :py:class:`VlanAwareFlexibleXconnectService <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices, self).__init__()

                    self.yang_name = "vlan-aware-flexible-xconnect-services"
                    self.yang_parent_name = "flexible-xconnect-service-table"

                    self.vlan_aware_flexible_xconnect_service = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices, self).__setattr__(name, value)


                class VlanAwareFlexibleXconnectService(Entity):
                    """
                    Flexible XConnect Service
                    
                    .. attribute:: eviid  <key>
                    
                    	Ethernet VPN ID
                    	**type**\:  int
                    
                    	**range:** 1..65534
                    
                    .. attribute:: vlan_aware_fxc_attachment_circuits
                    
                    	List of attachment circuits
                    	**type**\:   :py:class:`VlanAwareFxcAttachmentCircuits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService, self).__init__()

                        self.yang_name = "vlan-aware-flexible-xconnect-service"
                        self.yang_parent_name = "vlan-aware-flexible-xconnect-services"

                        self.eviid = YLeaf(YType.uint32, "eviid")

                        self.vlan_aware_fxc_attachment_circuits = L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits()
                        self.vlan_aware_fxc_attachment_circuits.parent = self
                        self._children_name_map["vlan_aware_fxc_attachment_circuits"] = "vlan-aware-fxc-attachment-circuits"
                        self._children_yang_names.add("vlan-aware-fxc-attachment-circuits")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("eviid") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService, self).__setattr__(name, value)


                    class VlanAwareFxcAttachmentCircuits(Entity):
                        """
                        List of attachment circuits
                        
                        .. attribute:: vlan_aware_fxc_attachment_circuit
                        
                        	Attachment circuit interface
                        	**type**\: list of    :py:class:`VlanAwareFxcAttachmentCircuit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits.VlanAwareFxcAttachmentCircuit>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits, self).__init__()

                            self.yang_name = "vlan-aware-fxc-attachment-circuits"
                            self.yang_parent_name = "vlan-aware-flexible-xconnect-service"

                            self.vlan_aware_fxc_attachment_circuit = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits, self).__setattr__(name, value)


                        class VlanAwareFxcAttachmentCircuit(Entity):
                            """
                            Attachment circuit interface
                            
                            .. attribute:: name  <key>
                            
                            	Name of the attachment circuit interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits.VlanAwareFxcAttachmentCircuit, self).__init__()

                                self.yang_name = "vlan-aware-fxc-attachment-circuit"
                                self.yang_parent_name = "vlan-aware-fxc-attachment-circuits"

                                self.name = YLeaf(YType.str, "name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits.VlanAwareFxcAttachmentCircuit, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits.VlanAwareFxcAttachmentCircuit, self).__setattr__(name, value)

                            def has_data(self):
                                return self.name.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "vlan-aware-fxc-attachment-circuit" + "[name='" + self.name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.vlan_aware_fxc_attachment_circuit:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.vlan_aware_fxc_attachment_circuit:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "vlan-aware-fxc-attachment-circuits" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "vlan-aware-fxc-attachment-circuit"):
                                for c in self.vlan_aware_fxc_attachment_circuit:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits.VlanAwareFxcAttachmentCircuit()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.vlan_aware_fxc_attachment_circuit.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "vlan-aware-fxc-attachment-circuit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.eviid.is_set or
                            (self.vlan_aware_fxc_attachment_circuits is not None and self.vlan_aware_fxc_attachment_circuits.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.eviid.yfilter != YFilter.not_set or
                            (self.vlan_aware_fxc_attachment_circuits is not None and self.vlan_aware_fxc_attachment_circuits.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "vlan-aware-flexible-xconnect-service" + "[eviid='" + self.eviid.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/flexible-xconnect-service-table/vlan-aware-flexible-xconnect-services/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eviid.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "vlan-aware-fxc-attachment-circuits"):
                            if (self.vlan_aware_fxc_attachment_circuits is None):
                                self.vlan_aware_fxc_attachment_circuits = L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService.VlanAwareFxcAttachmentCircuits()
                                self.vlan_aware_fxc_attachment_circuits.parent = self
                                self._children_name_map["vlan_aware_fxc_attachment_circuits"] = "vlan-aware-fxc-attachment-circuits"
                            return self.vlan_aware_fxc_attachment_circuits

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "vlan-aware-fxc-attachment-circuits" or name == "eviid"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "eviid"):
                            self.eviid = value
                            self.eviid.value_namespace = name_space
                            self.eviid.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.vlan_aware_flexible_xconnect_service:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.vlan_aware_flexible_xconnect_service:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "vlan-aware-flexible-xconnect-services" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/flexible-xconnect-service-table/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "vlan-aware-flexible-xconnect-service"):
                        for c in self.vlan_aware_flexible_xconnect_service:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices.VlanAwareFlexibleXconnectService()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.vlan_aware_flexible_xconnect_service.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vlan-aware-flexible-xconnect-service"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.vlan_aware_flexible_xconnect_services is not None and self.vlan_aware_flexible_xconnect_services.has_data()) or
                    (self.vlan_unaware_flexible_xconnect_services is not None and self.vlan_unaware_flexible_xconnect_services.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.vlan_aware_flexible_xconnect_services is not None and self.vlan_aware_flexible_xconnect_services.has_operation()) or
                    (self.vlan_unaware_flexible_xconnect_services is not None and self.vlan_unaware_flexible_xconnect_services.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "flexible-xconnect-service-table" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "vlan-aware-flexible-xconnect-services"):
                    if (self.vlan_aware_flexible_xconnect_services is None):
                        self.vlan_aware_flexible_xconnect_services = L2Vpn.Database.FlexibleXconnectServiceTable.VlanAwareFlexibleXconnectServices()
                        self.vlan_aware_flexible_xconnect_services.parent = self
                        self._children_name_map["vlan_aware_flexible_xconnect_services"] = "vlan-aware-flexible-xconnect-services"
                    return self.vlan_aware_flexible_xconnect_services

                if (child_yang_name == "vlan-unaware-flexible-xconnect-services"):
                    if (self.vlan_unaware_flexible_xconnect_services is None):
                        self.vlan_unaware_flexible_xconnect_services = L2Vpn.Database.FlexibleXconnectServiceTable.VlanUnawareFlexibleXconnectServices()
                        self.vlan_unaware_flexible_xconnect_services.parent = self
                        self._children_name_map["vlan_unaware_flexible_xconnect_services"] = "vlan-unaware-flexible-xconnect-services"
                    return self.vlan_unaware_flexible_xconnect_services

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "vlan-aware-flexible-xconnect-services" or name == "vlan-unaware-flexible-xconnect-services"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Redundancy(Entity):
            """
            Redundancy groups
            
            .. attribute:: enable
            
            	Enable redundancy groups
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: iccp_redundancy_groups
            
            	List of Inter\-Chassis Communication Protocol redundancy groups
            	**type**\:   :py:class:`IccpRedundancyGroups <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.Redundancy.IccpRedundancyGroups>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Database.Redundancy, self).__init__()

                self.yang_name = "redundancy"
                self.yang_parent_name = "database"

                self.enable = YLeaf(YType.empty, "enable")

                self.iccp_redundancy_groups = L2Vpn.Database.Redundancy.IccpRedundancyGroups()
                self.iccp_redundancy_groups.parent = self
                self._children_name_map["iccp_redundancy_groups"] = "iccp-redundancy-groups"
                self._children_yang_names.add("iccp-redundancy-groups")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.Database.Redundancy, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.Database.Redundancy, self).__setattr__(name, value)


            class IccpRedundancyGroups(Entity):
                """
                List of Inter\-Chassis Communication Protocol
                redundancy groups
                
                .. attribute:: iccp_redundancy_group
                
                	ICCP Redundancy group
                	**type**\: list of    :py:class:`IccpRedundancyGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Database.Redundancy.IccpRedundancyGroups, self).__init__()

                    self.yang_name = "iccp-redundancy-groups"
                    self.yang_parent_name = "redundancy"

                    self.iccp_redundancy_group = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Database.Redundancy.IccpRedundancyGroups, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Database.Redundancy.IccpRedundancyGroups, self).__setattr__(name, value)


                class IccpRedundancyGroup(Entity):
                    """
                    ICCP Redundancy group
                    
                    .. attribute:: group_id  <key>
                    
                    	Group ID
                    	**type**\:  int
                    
                    	**range:** 1..4294967295
                    
                    .. attribute:: iccp_interfaces
                    
                    	List of interfaces
                    	**type**\:   :py:class:`IccpInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces>`
                    
                    .. attribute:: multi_homing_node_id
                    
                    	ICCP\-based service multi\-homing node ID
                    	**type**\:  int
                    
                    	**range:** 0..254
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup, self).__init__()

                        self.yang_name = "iccp-redundancy-group"
                        self.yang_parent_name = "iccp-redundancy-groups"

                        self.group_id = YLeaf(YType.uint32, "group-id")

                        self.multi_homing_node_id = YLeaf(YType.uint32, "multi-homing-node-id")

                        self.iccp_interfaces = L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces()
                        self.iccp_interfaces.parent = self
                        self._children_name_map["iccp_interfaces"] = "iccp-interfaces"
                        self._children_yang_names.add("iccp-interfaces")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("group_id",
                                        "multi_homing_node_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup, self).__setattr__(name, value)


                    class IccpInterfaces(Entity):
                        """
                        List of interfaces
                        
                        .. attribute:: iccp_interface
                        
                        	Interface name
                        	**type**\: list of    :py:class:`IccpInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces.IccpInterface>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces, self).__init__()

                            self.yang_name = "iccp-interfaces"
                            self.yang_parent_name = "iccp-redundancy-group"

                            self.iccp_interface = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces, self).__setattr__(name, value)


                        class IccpInterface(Entity):
                            """
                            Interface name
                            
                            .. attribute:: interface_name  <key>
                            
                            	Interface name
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: mac_flush_tcn
                            
                            	Enable STP\-TCN MAC flushing
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: primary_vlan_range
                            
                            	Primary VLAN range, in the form of 1\-3,5 ,8\-11
                            	**type**\:  str
                            
                            .. attribute:: recovery_delay
                            
                            	Failure clear recovery delay
                            	**type**\:  int
                            
                            	**range:** 30..3600
                            
                            	**default value**\: 180
                            
                            .. attribute:: secondary_vlan_range
                            
                            	Secondary VLAN range, in the form of 1\-3,5 ,8\-11
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces.IccpInterface, self).__init__()

                                self.yang_name = "iccp-interface"
                                self.yang_parent_name = "iccp-interfaces"

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.mac_flush_tcn = YLeaf(YType.empty, "mac-flush-tcn")

                                self.primary_vlan_range = YLeaf(YType.str, "primary-vlan-range")

                                self.recovery_delay = YLeaf(YType.uint32, "recovery-delay")

                                self.secondary_vlan_range = YLeaf(YType.str, "secondary-vlan-range")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interface_name",
                                                "mac_flush_tcn",
                                                "primary_vlan_range",
                                                "recovery_delay",
                                                "secondary_vlan_range") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces.IccpInterface, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces.IccpInterface, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.interface_name.is_set or
                                    self.mac_flush_tcn.is_set or
                                    self.primary_vlan_range.is_set or
                                    self.recovery_delay.is_set or
                                    self.secondary_vlan_range.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.mac_flush_tcn.yfilter != YFilter.not_set or
                                    self.primary_vlan_range.yfilter != YFilter.not_set or
                                    self.recovery_delay.yfilter != YFilter.not_set or
                                    self.secondary_vlan_range.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "iccp-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.mac_flush_tcn.is_set or self.mac_flush_tcn.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_flush_tcn.get_name_leafdata())
                                if (self.primary_vlan_range.is_set or self.primary_vlan_range.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.primary_vlan_range.get_name_leafdata())
                                if (self.recovery_delay.is_set or self.recovery_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.recovery_delay.get_name_leafdata())
                                if (self.secondary_vlan_range.is_set or self.secondary_vlan_range.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.secondary_vlan_range.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface-name" or name == "mac-flush-tcn" or name == "primary-vlan-range" or name == "recovery-delay" or name == "secondary-vlan-range"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-flush-tcn"):
                                    self.mac_flush_tcn = value
                                    self.mac_flush_tcn.value_namespace = name_space
                                    self.mac_flush_tcn.value_namespace_prefix = name_space_prefix
                                if(value_path == "primary-vlan-range"):
                                    self.primary_vlan_range = value
                                    self.primary_vlan_range.value_namespace = name_space
                                    self.primary_vlan_range.value_namespace_prefix = name_space_prefix
                                if(value_path == "recovery-delay"):
                                    self.recovery_delay = value
                                    self.recovery_delay.value_namespace = name_space
                                    self.recovery_delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "secondary-vlan-range"):
                                    self.secondary_vlan_range = value
                                    self.secondary_vlan_range.value_namespace = name_space
                                    self.secondary_vlan_range.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.iccp_interface:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.iccp_interface:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "iccp-interfaces" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "iccp-interface"):
                                for c in self.iccp_interface:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces.IccpInterface()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.iccp_interface.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "iccp-interface"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.group_id.is_set or
                            self.multi_homing_node_id.is_set or
                            (self.iccp_interfaces is not None and self.iccp_interfaces.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.group_id.yfilter != YFilter.not_set or
                            self.multi_homing_node_id.yfilter != YFilter.not_set or
                            (self.iccp_interfaces is not None and self.iccp_interfaces.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "iccp-redundancy-group" + "[group-id='" + self.group_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/redundancy/iccp-redundancy-groups/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.group_id.is_set or self.group_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.group_id.get_name_leafdata())
                        if (self.multi_homing_node_id.is_set or self.multi_homing_node_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multi_homing_node_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "iccp-interfaces"):
                            if (self.iccp_interfaces is None):
                                self.iccp_interfaces = L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup.IccpInterfaces()
                                self.iccp_interfaces.parent = self
                                self._children_name_map["iccp_interfaces"] = "iccp-interfaces"
                            return self.iccp_interfaces

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "iccp-interfaces" or name == "group-id" or name == "multi-homing-node-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "group-id"):
                            self.group_id = value
                            self.group_id.value_namespace = name_space
                            self.group_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "multi-homing-node-id"):
                            self.multi_homing_node_id = value
                            self.multi_homing_node_id.value_namespace = name_space
                            self.multi_homing_node_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.iccp_redundancy_group:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.iccp_redundancy_group:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "iccp-redundancy-groups" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/redundancy/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "iccp-redundancy-group"):
                        for c in self.iccp_redundancy_group:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = L2Vpn.Database.Redundancy.IccpRedundancyGroups.IccpRedundancyGroup()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.iccp_redundancy_group.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "iccp-redundancy-group"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.enable.is_set or
                    (self.iccp_redundancy_groups is not None and self.iccp_redundancy_groups.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    (self.iccp_redundancy_groups is not None and self.iccp_redundancy_groups.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "redundancy" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/database/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "iccp-redundancy-groups"):
                    if (self.iccp_redundancy_groups is None):
                        self.iccp_redundancy_groups = L2Vpn.Database.Redundancy.IccpRedundancyGroups()
                        self.iccp_redundancy_groups.parent = self
                        self._children_name_map["iccp_redundancy_groups"] = "iccp-redundancy-groups"
                    return self.iccp_redundancy_groups

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "iccp-redundancy-groups" or name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                (self.bridge_domain_groups is not None and self.bridge_domain_groups.has_data()) or
                (self.flexible_xconnect_service_table is not None and self.flexible_xconnect_service_table.has_data()) or
                (self.g8032_rings is not None and self.g8032_rings.has_data()) or
                (self.pseudowire_classes is not None and self.pseudowire_classes.has_data()) or
                (self.redundancy is not None and self.redundancy.has_data()) or
                (self.xconnect_groups is not None and self.xconnect_groups.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.bridge_domain_groups is not None and self.bridge_domain_groups.has_operation()) or
                (self.flexible_xconnect_service_table is not None and self.flexible_xconnect_service_table.has_operation()) or
                (self.g8032_rings is not None and self.g8032_rings.has_operation()) or
                (self.pseudowire_classes is not None and self.pseudowire_classes.has_operation()) or
                (self.redundancy is not None and self.redundancy.has_operation()) or
                (self.xconnect_groups is not None and self.xconnect_groups.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "database" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "bridge-domain-groups"):
                if (self.bridge_domain_groups is None):
                    self.bridge_domain_groups = L2Vpn.Database.BridgeDomainGroups()
                    self.bridge_domain_groups.parent = self
                    self._children_name_map["bridge_domain_groups"] = "bridge-domain-groups"
                return self.bridge_domain_groups

            if (child_yang_name == "flexible-xconnect-service-table"):
                if (self.flexible_xconnect_service_table is None):
                    self.flexible_xconnect_service_table = L2Vpn.Database.FlexibleXconnectServiceTable()
                    self.flexible_xconnect_service_table.parent = self
                    self._children_name_map["flexible_xconnect_service_table"] = "flexible-xconnect-service-table"
                return self.flexible_xconnect_service_table

            if (child_yang_name == "g8032-rings"):
                if (self.g8032_rings is None):
                    self.g8032_rings = L2Vpn.Database.G8032Rings()
                    self.g8032_rings.parent = self
                    self._children_name_map["g8032_rings"] = "g8032-rings"
                return self.g8032_rings

            if (child_yang_name == "pseudowire-classes"):
                if (self.pseudowire_classes is None):
                    self.pseudowire_classes = L2Vpn.Database.PseudowireClasses()
                    self.pseudowire_classes.parent = self
                    self._children_name_map["pseudowire_classes"] = "pseudowire-classes"
                return self.pseudowire_classes

            if (child_yang_name == "redundancy"):
                if (self.redundancy is None):
                    self.redundancy = L2Vpn.Database.Redundancy()
                    self.redundancy.parent = self
                    self._children_name_map["redundancy"] = "redundancy"
                return self.redundancy

            if (child_yang_name == "xconnect-groups"):
                if (self.xconnect_groups is None):
                    self.xconnect_groups = L2Vpn.Database.XconnectGroups()
                    self.xconnect_groups.parent = self
                    self._children_name_map["xconnect_groups"] = "xconnect-groups"
                return self.xconnect_groups

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "bridge-domain-groups" or name == "flexible-xconnect-service-table" or name == "g8032-rings" or name == "pseudowire-classes" or name == "redundancy" or name == "xconnect-groups"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Pbb(Entity):
        """
        L2VPN PBB Global
        
        .. attribute:: backbone_source_mac
        
        	Backbone Source MAC
        	**type**\:  str
        
        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Vpn.Pbb, self).__init__()

            self.yang_name = "pbb"
            self.yang_parent_name = "l2vpn"

            self.backbone_source_mac = YLeaf(YType.str, "backbone-source-mac")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("backbone_source_mac") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(L2Vpn.Pbb, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(L2Vpn.Pbb, self).__setattr__(name, value)

        def has_data(self):
            return self.backbone_source_mac.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.backbone_source_mac.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "pbb" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.backbone_source_mac.is_set or self.backbone_source_mac.yfilter != YFilter.not_set):
                leaf_name_data.append(self.backbone_source_mac.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "backbone-source-mac"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "backbone-source-mac"):
                self.backbone_source_mac = value
                self.backbone_source_mac.value_namespace = name_space
                self.backbone_source_mac.value_namespace_prefix = name_space_prefix


    class AutoDiscovery(Entity):
        """
        Global auto\-discovery attributes
        
        .. attribute:: bgp_signaling
        
        	Global bgp signaling attributes
        	**type**\:   :py:class:`BgpSignaling <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.AutoDiscovery.BgpSignaling>`
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Vpn.AutoDiscovery, self).__init__()

            self.yang_name = "auto-discovery"
            self.yang_parent_name = "l2vpn"

            self.bgp_signaling = L2Vpn.AutoDiscovery.BgpSignaling()
            self.bgp_signaling.parent = self
            self._children_name_map["bgp_signaling"] = "bgp-signaling"
            self._children_yang_names.add("bgp-signaling")


        class BgpSignaling(Entity):
            """
            Global bgp signaling attributes
            
            .. attribute:: mtu_mismatch_ignore
            
            	Ignore MTU mismatch for auto\-discovered pseudowires
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.AutoDiscovery.BgpSignaling, self).__init__()

                self.yang_name = "bgp-signaling"
                self.yang_parent_name = "auto-discovery"

                self.mtu_mismatch_ignore = YLeaf(YType.empty, "mtu-mismatch-ignore")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("mtu_mismatch_ignore") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.AutoDiscovery.BgpSignaling, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.AutoDiscovery.BgpSignaling, self).__setattr__(name, value)

            def has_data(self):
                return self.mtu_mismatch_ignore.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.mtu_mismatch_ignore.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bgp-signaling" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/auto-discovery/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.mtu_mismatch_ignore.is_set or self.mtu_mismatch_ignore.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.mtu_mismatch_ignore.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "mtu-mismatch-ignore"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "mtu-mismatch-ignore"):
                    self.mtu_mismatch_ignore = value
                    self.mtu_mismatch_ignore.value_namespace = name_space
                    self.mtu_mismatch_ignore.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.bgp_signaling is not None and self.bgp_signaling.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.bgp_signaling is not None and self.bgp_signaling.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "auto-discovery" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "bgp-signaling"):
                if (self.bgp_signaling is None):
                    self.bgp_signaling = L2Vpn.AutoDiscovery.BgpSignaling()
                    self.bgp_signaling.parent = self
                    self._children_name_map["bgp_signaling"] = "bgp-signaling"
                return self.bgp_signaling

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "bgp-signaling"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Utility(Entity):
        """
        L2VPN utilities
        
        .. attribute:: logging
        
        	L2VPN logging utility
        	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Utility.Logging>`
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Vpn.Utility, self).__init__()

            self.yang_name = "utility"
            self.yang_parent_name = "l2vpn"

            self.logging = L2Vpn.Utility.Logging()
            self.logging.parent = self
            self._children_name_map["logging"] = "logging"
            self._children_yang_names.add("logging")


        class Logging(Entity):
            """
            L2VPN logging utility
            
            .. attribute:: bridge_domain_state_change
            
            	Enable Bridge Domain state change logging
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: nsr_state_change
            
            	Enable Non Stop Routing state change logging
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: pseudowire_state_change
            
            	Enable pseudowire state change logging
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: pwhe_replication_state_change
            
            	Enable PW\-HE Replication state change logging
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: vfi
            
            	Enable VFI state change logging
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Utility.Logging, self).__init__()

                self.yang_name = "logging"
                self.yang_parent_name = "utility"

                self.bridge_domain_state_change = YLeaf(YType.empty, "bridge-domain-state-change")

                self.nsr_state_change = YLeaf(YType.empty, "nsr-state-change")

                self.pseudowire_state_change = YLeaf(YType.empty, "pseudowire-state-change")

                self.pwhe_replication_state_change = YLeaf(YType.empty, "pwhe-replication-state-change")

                self.vfi = YLeaf(YType.empty, "vfi")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("bridge_domain_state_change",
                                "nsr_state_change",
                                "pseudowire_state_change",
                                "pwhe_replication_state_change",
                                "vfi") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(L2Vpn.Utility.Logging, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(L2Vpn.Utility.Logging, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.bridge_domain_state_change.is_set or
                    self.nsr_state_change.is_set or
                    self.pseudowire_state_change.is_set or
                    self.pwhe_replication_state_change.is_set or
                    self.vfi.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.bridge_domain_state_change.yfilter != YFilter.not_set or
                    self.nsr_state_change.yfilter != YFilter.not_set or
                    self.pseudowire_state_change.yfilter != YFilter.not_set or
                    self.pwhe_replication_state_change.yfilter != YFilter.not_set or
                    self.vfi.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "logging" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/utility/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.bridge_domain_state_change.is_set or self.bridge_domain_state_change.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.bridge_domain_state_change.get_name_leafdata())
                if (self.nsr_state_change.is_set or self.nsr_state_change.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr_state_change.get_name_leafdata())
                if (self.pseudowire_state_change.is_set or self.pseudowire_state_change.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pseudowire_state_change.get_name_leafdata())
                if (self.pwhe_replication_state_change.is_set or self.pwhe_replication_state_change.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pwhe_replication_state_change.get_name_leafdata())
                if (self.vfi.is_set or self.vfi.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vfi.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "bridge-domain-state-change" or name == "nsr-state-change" or name == "pseudowire-state-change" or name == "pwhe-replication-state-change" or name == "vfi"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "bridge-domain-state-change"):
                    self.bridge_domain_state_change = value
                    self.bridge_domain_state_change.value_namespace = name_space
                    self.bridge_domain_state_change.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr-state-change"):
                    self.nsr_state_change = value
                    self.nsr_state_change.value_namespace = name_space
                    self.nsr_state_change.value_namespace_prefix = name_space_prefix
                if(value_path == "pseudowire-state-change"):
                    self.pseudowire_state_change = value
                    self.pseudowire_state_change.value_namespace = name_space
                    self.pseudowire_state_change.value_namespace_prefix = name_space_prefix
                if(value_path == "pwhe-replication-state-change"):
                    self.pwhe_replication_state_change = value
                    self.pwhe_replication_state_change.value_namespace = name_space
                    self.pwhe_replication_state_change.value_namespace_prefix = name_space_prefix
                if(value_path == "vfi"):
                    self.vfi = value
                    self.vfi.value_namespace = name_space
                    self.vfi.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.logging is not None and self.logging.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.logging is not None and self.logging.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "utility" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "logging"):
                if (self.logging is None):
                    self.logging = L2Vpn.Utility.Logging()
                    self.logging.parent = self
                    self._children_name_map["logging"] = "logging"
                return self.logging

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "logging"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Snmp(Entity):
        """
        SNMP related configuration
        
        .. attribute:: mib
        
        	MIB related configuration
        	**type**\:   :py:class:`Mib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Snmp.Mib>`
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(L2Vpn.Snmp, self).__init__()

            self.yang_name = "snmp"
            self.yang_parent_name = "l2vpn"

            self.mib = L2Vpn.Snmp.Mib()
            self.mib.parent = self
            self._children_name_map["mib"] = "mib"
            self._children_yang_names.add("mib")


        class Mib(Entity):
            """
            MIB related configuration
            
            .. attribute:: mib_interface
            
            	Interface related configuration for MIB
            	**type**\:   :py:class:`MibInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Snmp.Mib.MibInterface>`
            
            .. attribute:: mib_pseudowire
            
            	Pseudowire related configuration for MIB
            	**type**\:   :py:class:`MibPseudowire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Snmp.Mib.MibPseudowire>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(L2Vpn.Snmp.Mib, self).__init__()

                self.yang_name = "mib"
                self.yang_parent_name = "snmp"

                self.mib_interface = L2Vpn.Snmp.Mib.MibInterface()
                self.mib_interface.parent = self
                self._children_name_map["mib_interface"] = "mib-interface"
                self._children_yang_names.add("mib-interface")

                self.mib_pseudowire = L2Vpn.Snmp.Mib.MibPseudowire()
                self.mib_pseudowire.parent = self
                self._children_name_map["mib_pseudowire"] = "mib-pseudowire"
                self._children_yang_names.add("mib-pseudowire")


            class MibInterface(Entity):
                """
                Interface related configuration for MIB
                
                .. attribute:: format
                
                	MIB interface name output format
                	**type**\:   :py:class:`Format <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.L2Vpn.Snmp.Mib.MibInterface.Format>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Snmp.Mib.MibInterface, self).__init__()

                    self.yang_name = "mib-interface"
                    self.yang_parent_name = "mib"

                    self.format = L2Vpn.Snmp.Mib.MibInterface.Format()
                    self.format.parent = self
                    self._children_name_map["format"] = "format"
                    self._children_yang_names.add("format")


                class Format(Entity):
                    """
                    MIB interface name output format
                    
                    .. attribute:: external_interface_format
                    
                    	Set MIB interface name output in slash format (/)
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(L2Vpn.Snmp.Mib.MibInterface.Format, self).__init__()

                        self.yang_name = "format"
                        self.yang_parent_name = "mib-interface"

                        self.external_interface_format = YLeaf(YType.empty, "external-interface-format")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("external_interface_format") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(L2Vpn.Snmp.Mib.MibInterface.Format, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(L2Vpn.Snmp.Mib.MibInterface.Format, self).__setattr__(name, value)

                    def has_data(self):
                        return self.external_interface_format.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.external_interface_format.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "format" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/snmp/mib/mib-interface/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.external_interface_format.is_set or self.external_interface_format.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_interface_format.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "external-interface-format"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "external-interface-format"):
                            self.external_interface_format = value
                            self.external_interface_format.value_namespace = name_space
                            self.external_interface_format.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (self.format is not None and self.format.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.format is not None and self.format.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mib-interface" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/snmp/mib/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "format"):
                        if (self.format is None):
                            self.format = L2Vpn.Snmp.Mib.MibInterface.Format()
                            self.format.parent = self
                            self._children_name_map["format"] = "format"
                        return self.format

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "format"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class MibPseudowire(Entity):
                """
                Pseudowire related configuration for MIB
                
                .. attribute:: statistics
                
                	Enable pseudowire statistics in MIB output
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(L2Vpn.Snmp.Mib.MibPseudowire, self).__init__()

                    self.yang_name = "mib-pseudowire"
                    self.yang_parent_name = "mib"

                    self.statistics = YLeaf(YType.empty, "statistics")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("statistics") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(L2Vpn.Snmp.Mib.MibPseudowire, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(L2Vpn.Snmp.Mib.MibPseudowire, self).__setattr__(name, value)

                def has_data(self):
                    return self.statistics.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.statistics.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mib-pseudowire" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/snmp/mib/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.statistics.is_set or self.statistics.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.statistics.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "statistics"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "statistics"):
                        self.statistics = value
                        self.statistics.value_namespace = name_space
                        self.statistics.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.mib_interface is not None and self.mib_interface.has_data()) or
                    (self.mib_pseudowire is not None and self.mib_pseudowire.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.mib_interface is not None and self.mib_interface.has_operation()) or
                    (self.mib_pseudowire is not None and self.mib_pseudowire.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "mib" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/snmp/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "mib-interface"):
                    if (self.mib_interface is None):
                        self.mib_interface = L2Vpn.Snmp.Mib.MibInterface()
                        self.mib_interface.parent = self
                        self._children_name_map["mib_interface"] = "mib-interface"
                    return self.mib_interface

                if (child_yang_name == "mib-pseudowire"):
                    if (self.mib_pseudowire is None):
                        self.mib_pseudowire = L2Vpn.Snmp.Mib.MibPseudowire()
                        self.mib_pseudowire.parent = self
                        self._children_name_map["mib_pseudowire"] = "mib-pseudowire"
                    return self.mib_pseudowire

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "mib-interface" or name == "mib-pseudowire"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.mib is not None and self.mib.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.mib is not None and self.mib.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "snmp" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "mib"):
                if (self.mib is None):
                    self.mib = L2Vpn.Snmp.Mib()
                    self.mib.parent = self
                    self._children_name_map["mib"] = "mib"
                return self.mib

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "mib"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            self.capability.is_set or
            self.enable.is_set or
            self.l2vpn_router_id.is_set or
            self.load_balance.is_set or
            self.mspw_description.is_set or
            self.mtu_mismatch_ignore.is_set or
            self.nsr.is_set or
            self.pw_grouping.is_set or
            self.pw_status_disable.is_set or
            self.pwoam_refresh.is_set or
            self.tcn_propagation.is_set or
            (self.auto_discovery is not None and self.auto_discovery.has_data()) or
            (self.database is not None and self.database.has_data()) or
            (self.neighbor is not None and self.neighbor.has_data()) or
            (self.pbb is not None and self.pbb.has_data()) or
            (self.pw_routing is not None and self.pw_routing.has_data()) or
            (self.snmp is not None and self.snmp.has_data()) or
            (self.utility is not None and self.utility.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            self.capability.yfilter != YFilter.not_set or
            self.enable.yfilter != YFilter.not_set or
            self.l2vpn_router_id.yfilter != YFilter.not_set or
            self.load_balance.yfilter != YFilter.not_set or
            self.mspw_description.yfilter != YFilter.not_set or
            self.mtu_mismatch_ignore.yfilter != YFilter.not_set or
            self.nsr.yfilter != YFilter.not_set or
            self.pw_grouping.yfilter != YFilter.not_set or
            self.pw_status_disable.yfilter != YFilter.not_set or
            self.pwoam_refresh.yfilter != YFilter.not_set or
            self.tcn_propagation.yfilter != YFilter.not_set or
            (self.auto_discovery is not None and self.auto_discovery.has_operation()) or
            (self.database is not None and self.database.has_operation()) or
            (self.neighbor is not None and self.neighbor.has_operation()) or
            (self.pbb is not None and self.pbb.has_operation()) or
            (self.pw_routing is not None and self.pw_routing.has_operation()) or
            (self.snmp is not None and self.snmp.has_operation()) or
            (self.utility is not None and self.utility.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:l2vpn" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()
        if (self.capability.is_set or self.capability.yfilter != YFilter.not_set):
            leaf_name_data.append(self.capability.get_name_leafdata())
        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
            leaf_name_data.append(self.enable.get_name_leafdata())
        if (self.l2vpn_router_id.is_set or self.l2vpn_router_id.yfilter != YFilter.not_set):
            leaf_name_data.append(self.l2vpn_router_id.get_name_leafdata())
        if (self.load_balance.is_set or self.load_balance.yfilter != YFilter.not_set):
            leaf_name_data.append(self.load_balance.get_name_leafdata())
        if (self.mspw_description.is_set or self.mspw_description.yfilter != YFilter.not_set):
            leaf_name_data.append(self.mspw_description.get_name_leafdata())
        if (self.mtu_mismatch_ignore.is_set or self.mtu_mismatch_ignore.yfilter != YFilter.not_set):
            leaf_name_data.append(self.mtu_mismatch_ignore.get_name_leafdata())
        if (self.nsr.is_set or self.nsr.yfilter != YFilter.not_set):
            leaf_name_data.append(self.nsr.get_name_leafdata())
        if (self.pw_grouping.is_set or self.pw_grouping.yfilter != YFilter.not_set):
            leaf_name_data.append(self.pw_grouping.get_name_leafdata())
        if (self.pw_status_disable.is_set or self.pw_status_disable.yfilter != YFilter.not_set):
            leaf_name_data.append(self.pw_status_disable.get_name_leafdata())
        if (self.pwoam_refresh.is_set or self.pwoam_refresh.yfilter != YFilter.not_set):
            leaf_name_data.append(self.pwoam_refresh.get_name_leafdata())
        if (self.tcn_propagation.is_set or self.tcn_propagation.yfilter != YFilter.not_set):
            leaf_name_data.append(self.tcn_propagation.get_name_leafdata())

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "auto-discovery"):
            if (self.auto_discovery is None):
                self.auto_discovery = L2Vpn.AutoDiscovery()
                self.auto_discovery.parent = self
                self._children_name_map["auto_discovery"] = "auto-discovery"
            return self.auto_discovery

        if (child_yang_name == "database"):
            if (self.database is None):
                self.database = L2Vpn.Database()
                self.database.parent = self
                self._children_name_map["database"] = "database"
            return self.database

        if (child_yang_name == "neighbor"):
            if (self.neighbor is None):
                self.neighbor = L2Vpn.Neighbor()
                self.neighbor.parent = self
                self._children_name_map["neighbor"] = "neighbor"
            return self.neighbor

        if (child_yang_name == "pbb"):
            if (self.pbb is None):
                self.pbb = L2Vpn.Pbb()
                self.pbb.parent = self
                self._children_name_map["pbb"] = "pbb"
            return self.pbb

        if (child_yang_name == "pw-routing"):
            if (self.pw_routing is None):
                self.pw_routing = L2Vpn.PwRouting()
                self.pw_routing.parent = self
                self._children_name_map["pw_routing"] = "pw-routing"
            return self.pw_routing

        if (child_yang_name == "snmp"):
            if (self.snmp is None):
                self.snmp = L2Vpn.Snmp()
                self.snmp.parent = self
                self._children_name_map["snmp"] = "snmp"
            return self.snmp

        if (child_yang_name == "utility"):
            if (self.utility is None):
                self.utility = L2Vpn.Utility()
                self.utility.parent = self
                self._children_name_map["utility"] = "utility"
            return self.utility

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "auto-discovery" or name == "database" or name == "neighbor" or name == "pbb" or name == "pw-routing" or name == "snmp" or name == "utility" or name == "capability" or name == "enable" or name == "l2vpn-router-id" or name == "load-balance" or name == "mspw-description" or name == "mtu-mismatch-ignore" or name == "nsr" or name == "pw-grouping" or name == "pw-status-disable" or name == "pwoam-refresh" or name == "tcn-propagation"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        if(value_path == "capability"):
            self.capability = value
            self.capability.value_namespace = name_space
            self.capability.value_namespace_prefix = name_space_prefix
        if(value_path == "enable"):
            self.enable = value
            self.enable.value_namespace = name_space
            self.enable.value_namespace_prefix = name_space_prefix
        if(value_path == "l2vpn-router-id"):
            self.l2vpn_router_id = value
            self.l2vpn_router_id.value_namespace = name_space
            self.l2vpn_router_id.value_namespace_prefix = name_space_prefix
        if(value_path == "load-balance"):
            self.load_balance = value
            self.load_balance.value_namespace = name_space
            self.load_balance.value_namespace_prefix = name_space_prefix
        if(value_path == "mspw-description"):
            self.mspw_description = value
            self.mspw_description.value_namespace = name_space
            self.mspw_description.value_namespace_prefix = name_space_prefix
        if(value_path == "mtu-mismatch-ignore"):
            self.mtu_mismatch_ignore = value
            self.mtu_mismatch_ignore.value_namespace = name_space
            self.mtu_mismatch_ignore.value_namespace_prefix = name_space_prefix
        if(value_path == "nsr"):
            self.nsr = value
            self.nsr.value_namespace = name_space
            self.nsr.value_namespace_prefix = name_space_prefix
        if(value_path == "pw-grouping"):
            self.pw_grouping = value
            self.pw_grouping.value_namespace = name_space
            self.pw_grouping.value_namespace_prefix = name_space_prefix
        if(value_path == "pw-status-disable"):
            self.pw_status_disable = value
            self.pw_status_disable.value_namespace = name_space
            self.pw_status_disable.value_namespace_prefix = name_space_prefix
        if(value_path == "pwoam-refresh"):
            self.pwoam_refresh = value
            self.pwoam_refresh.value_namespace = name_space
            self.pwoam_refresh.value_namespace_prefix = name_space_prefix
        if(value_path == "tcn-propagation"):
            self.tcn_propagation = value
            self.tcn_propagation.value_namespace = name_space
            self.tcn_propagation.value_namespace_prefix = name_space_prefix

    def clone_ptr(self):
        self._top_entity = L2Vpn()
        return self._top_entity

class GenericInterfaceLists(Entity):
    """
    generic interface lists
    
    .. attribute:: generic_interface
    
    	Bridge group
    	**type**\: list of    :py:class:`GenericInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.GenericInterfaceLists.GenericInterface>`
    
    

    """

    _prefix = 'l2vpn-cfg'
    _revision = '2015-11-09'

    def __init__(self):
        super(GenericInterfaceLists, self).__init__()
        self._top_entity = None

        self.yang_name = "generic-interface-lists"
        self.yang_parent_name = "Cisco-IOS-XR-l2vpn-cfg"

        self.generic_interface = YList(self)

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in () and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(GenericInterfaceLists, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(GenericInterfaceLists, self).__setattr__(name, value)


    class GenericInterface(Entity):
        """
        Bridge group
        
        .. attribute:: generic_interface_list_name  <key>
        
        	Name of the interface list
        	**type**\:  str
        
        	**length:** 1..32
        
        .. attribute:: enable
        
        	Enable interface list
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: interfaces
        
        	Interface table
        	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.GenericInterfaceLists.GenericInterface.Interfaces>`
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(GenericInterfaceLists.GenericInterface, self).__init__()

            self.yang_name = "generic-interface"
            self.yang_parent_name = "generic-interface-lists"

            self.generic_interface_list_name = YLeaf(YType.str, "generic-interface-list-name")

            self.enable = YLeaf(YType.empty, "enable")

            self.interfaces = GenericInterfaceLists.GenericInterface.Interfaces()
            self.interfaces.parent = self
            self._children_name_map["interfaces"] = "interfaces"
            self._children_yang_names.add("interfaces")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("generic_interface_list_name",
                            "enable") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(GenericInterfaceLists.GenericInterface, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(GenericInterfaceLists.GenericInterface, self).__setattr__(name, value)


        class Interfaces(Entity):
            """
            Interface table
            
            .. attribute:: interface
            
            	Interface
            	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.GenericInterfaceLists.GenericInterface.Interfaces.Interface>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(GenericInterfaceLists.GenericInterface.Interfaces, self).__init__()

                self.yang_name = "interfaces"
                self.yang_parent_name = "generic-interface"

                self.interface = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(GenericInterfaceLists.GenericInterface.Interfaces, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(GenericInterfaceLists.GenericInterface.Interfaces, self).__setattr__(name, value)


            class Interface(Entity):
                """
                Interface
                
                .. attribute:: interface_name  <key>
                
                	Name of the interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: enable
                
                	Enable interface
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(GenericInterfaceLists.GenericInterface.Interfaces.Interface, self).__init__()

                    self.yang_name = "interface"
                    self.yang_parent_name = "interfaces"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.enable = YLeaf(YType.empty, "enable")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "enable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(GenericInterfaceLists.GenericInterface.Interfaces.Interface, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(GenericInterfaceLists.GenericInterface.Interfaces.Interface, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.enable.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-name" or name == "enable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.interface:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.interface:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interfaces" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interface"):
                    for c in self.interface:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = GenericInterfaceLists.GenericInterface.Interfaces.Interface()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.interface.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.generic_interface_list_name.is_set or
                self.enable.is_set or
                (self.interfaces is not None and self.interfaces.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.generic_interface_list_name.yfilter != YFilter.not_set or
                self.enable.yfilter != YFilter.not_set or
                (self.interfaces is not None and self.interfaces.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "generic-interface" + "[generic-interface-list-name='" + self.generic_interface_list_name.get() + "']" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:generic-interface-lists/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.generic_interface_list_name.is_set or self.generic_interface_list_name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.generic_interface_list_name.get_name_leafdata())
            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                leaf_name_data.append(self.enable.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interfaces"):
                if (self.interfaces is None):
                    self.interfaces = GenericInterfaceLists.GenericInterface.Interfaces()
                    self.interfaces.parent = self
                    self._children_name_map["interfaces"] = "interfaces"
                return self.interfaces

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interfaces" or name == "generic-interface-list-name" or name == "enable"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "generic-interface-list-name"):
                self.generic_interface_list_name = value
                self.generic_interface_list_name.value_namespace = name_space
                self.generic_interface_list_name.value_namespace_prefix = name_space_prefix
            if(value_path == "enable"):
                self.enable = value
                self.enable.value_namespace = name_space
                self.enable.value_namespace_prefix = name_space_prefix

    def has_data(self):
        for c in self.generic_interface:
            if (c.has_data()):
                return True
        return False

    def has_operation(self):
        for c in self.generic_interface:
            if (c.has_operation()):
                return True
        return self.yfilter != YFilter.not_set

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:generic-interface-lists" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "generic-interface"):
            for c in self.generic_interface:
                segment = c.get_segment_path()
                if (segment_path == segment):
                    return c
            c = GenericInterfaceLists.GenericInterface()
            c.parent = self
            local_reference_key = "ydk::seg::%s" % segment_path
            self._local_refs[local_reference_key] = c
            self.generic_interface.append(c)
            return c

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "generic-interface"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = GenericInterfaceLists()
        return self._top_entity

class Evpn(Entity):
    """
    evpn
    
    .. attribute:: enable
    
    	Enable EVPN feature
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: evpn_tables
    
    	EVPN submodes
    	**type**\:   :py:class:`EvpnTables <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables>`
    
    

    """

    _prefix = 'l2vpn-cfg'
    _revision = '2015-11-09'

    def __init__(self):
        super(Evpn, self).__init__()
        self._top_entity = None

        self.yang_name = "evpn"
        self.yang_parent_name = "Cisco-IOS-XR-l2vpn-cfg"

        self.enable = YLeaf(YType.empty, "enable")

        self.evpn_tables = Evpn.EvpnTables()
        self.evpn_tables.parent = self
        self._children_name_map["evpn_tables"] = "evpn-tables"
        self._children_yang_names.add("evpn-tables")

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in ("enable") and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(Evpn, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(Evpn, self).__setattr__(name, value)


    class EvpnTables(Entity):
        """
        EVPN submodes
        
        .. attribute:: evpn_ethernet_segment
        
        	EVPN Global Ethernet Segment submode
        	**type**\:   :py:class:`EvpnEthernetSegment <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnEthernetSegment>`
        
        .. attribute:: evpn_instances
        
        	Enter EVPN Instance configuration submode
        	**type**\:   :py:class:`EvpnInstances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances>`
        
        .. attribute:: evpn_interfaces
        
        	Attachment Circuit interfaces
        	**type**\:   :py:class:`EvpnInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInterfaces>`
        
        .. attribute:: evpn_load_balancing
        
        	Enter EVPN Loadbalancing configuration submode
        	**type**\:   :py:class:`EvpnLoadBalancing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnLoadBalancing>`
        
        .. attribute:: evpn_logging
        
        	Enter EVPN Logging configuration submode
        	**type**\:   :py:class:`EvpnLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnLogging>`
        
        .. attribute:: evpn_source_interface
        
        	Configure EVPN router\-id implicitly through Loopback Interface
        	**type**\:  str
        
        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
        
        .. attribute:: evpn_timers
        
        	Enter EVPN timers configuration submode
        	**type**\:   :py:class:`EvpnTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnTimers>`
        
        .. attribute:: evpn_virtual_access_pws
        
        	Virtual Access Pseudowire interfaces
        	**type**\:   :py:class:`EvpnVirtualAccessPws <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessPws>`
        
        .. attribute:: evpn_virtual_access_vfis
        
        	Virtual Access VFI interfaces
        	**type**\:   :py:class:`EvpnVirtualAccessVfis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessVfis>`
        
        .. attribute:: evpnbgp_auto_discovery
        
        	Enable Autodiscovery BGP in EVPN
        	**type**\:   :py:class:`EvpnbgpAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnbgpAutoDiscovery>`
        
        .. attribute:: evpnevis
        
        	Enter EVPN Instance configuration submode
        	**type**\:   :py:class:`Evpnevis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis>`
        
        

        """

        _prefix = 'l2vpn-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Evpn.EvpnTables, self).__init__()

            self.yang_name = "evpn-tables"
            self.yang_parent_name = "evpn"

            self.evpn_source_interface = YLeaf(YType.str, "evpn-source-interface")

            self.evpn_ethernet_segment = Evpn.EvpnTables.EvpnEthernetSegment()
            self.evpn_ethernet_segment.parent = self
            self._children_name_map["evpn_ethernet_segment"] = "evpn-ethernet-segment"
            self._children_yang_names.add("evpn-ethernet-segment")

            self.evpn_instances = Evpn.EvpnTables.EvpnInstances()
            self.evpn_instances.parent = self
            self._children_name_map["evpn_instances"] = "evpn-instances"
            self._children_yang_names.add("evpn-instances")

            self.evpn_interfaces = Evpn.EvpnTables.EvpnInterfaces()
            self.evpn_interfaces.parent = self
            self._children_name_map["evpn_interfaces"] = "evpn-interfaces"
            self._children_yang_names.add("evpn-interfaces")

            self.evpn_load_balancing = Evpn.EvpnTables.EvpnLoadBalancing()
            self.evpn_load_balancing.parent = self
            self._children_name_map["evpn_load_balancing"] = "evpn-load-balancing"
            self._children_yang_names.add("evpn-load-balancing")

            self.evpn_logging = Evpn.EvpnTables.EvpnLogging()
            self.evpn_logging.parent = self
            self._children_name_map["evpn_logging"] = "evpn-logging"
            self._children_yang_names.add("evpn-logging")

            self.evpn_timers = Evpn.EvpnTables.EvpnTimers()
            self.evpn_timers.parent = self
            self._children_name_map["evpn_timers"] = "evpn-timers"
            self._children_yang_names.add("evpn-timers")

            self.evpn_virtual_access_pws = Evpn.EvpnTables.EvpnVirtualAccessPws()
            self.evpn_virtual_access_pws.parent = self
            self._children_name_map["evpn_virtual_access_pws"] = "evpn-virtual-access-pws"
            self._children_yang_names.add("evpn-virtual-access-pws")

            self.evpn_virtual_access_vfis = Evpn.EvpnTables.EvpnVirtualAccessVfis()
            self.evpn_virtual_access_vfis.parent = self
            self._children_name_map["evpn_virtual_access_vfis"] = "evpn-virtual-access-vfis"
            self._children_yang_names.add("evpn-virtual-access-vfis")

            self.evpnbgp_auto_discovery = Evpn.EvpnTables.EvpnbgpAutoDiscovery()
            self.evpnbgp_auto_discovery.parent = self
            self._children_name_map["evpnbgp_auto_discovery"] = "evpnbgp-auto-discovery"
            self._children_yang_names.add("evpnbgp-auto-discovery")

            self.evpnevis = Evpn.EvpnTables.Evpnevis()
            self.evpnevis.parent = self
            self._children_name_map["evpnevis"] = "evpnevis"
            self._children_yang_names.add("evpnevis")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("evpn_source_interface") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Evpn.EvpnTables, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Evpn.EvpnTables, self).__setattr__(name, value)


        class EvpnTimers(Entity):
            """
            Enter EVPN timers configuration submode
            
            .. attribute:: enable
            
            	Enable EVPN timers
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: evpn_peering
            
            	Global Peering timer
            	**type**\:  int
            
            	**range:** 0..300
            
            	**default value**\: 3
            
            .. attribute:: evpn_recovery
            
            	Global Recovery timer
            	**type**\:  int
            
            	**range:** 20..3600
            
            	**default value**\: 30
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnTimers, self).__init__()

                self.yang_name = "evpn-timers"
                self.yang_parent_name = "evpn-tables"

                self.enable = YLeaf(YType.empty, "enable")

                self.evpn_peering = YLeaf(YType.uint32, "evpn-peering")

                self.evpn_recovery = YLeaf(YType.uint32, "evpn-recovery")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "evpn_peering",
                                "evpn_recovery") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnTimers, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnTimers, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.evpn_peering.is_set or
                    self.evpn_recovery.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.evpn_peering.yfilter != YFilter.not_set or
                    self.evpn_recovery.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-timers" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.evpn_peering.is_set or self.evpn_peering.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.evpn_peering.get_name_leafdata())
                if (self.evpn_recovery.is_set or self.evpn_recovery.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.evpn_recovery.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "evpn-peering" or name == "evpn-recovery"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "evpn-peering"):
                    self.evpn_peering = value
                    self.evpn_peering.value_namespace = name_space
                    self.evpn_peering.value_namespace_prefix = name_space_prefix
                if(value_path == "evpn-recovery"):
                    self.evpn_recovery = value
                    self.evpn_recovery.value_namespace = name_space
                    self.evpn_recovery.value_namespace_prefix = name_space_prefix


        class Evpnevis(Entity):
            """
            Enter EVPN Instance configuration submode
            
            .. attribute:: evpnevi
            
            	Enter EVPN Instance configuration submode
            	**type**\: list of    :py:class:`Evpnevi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.Evpnevis, self).__init__()

                self.yang_name = "evpnevis"
                self.yang_parent_name = "evpn-tables"

                self.evpnevi = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.Evpnevis, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.Evpnevis, self).__setattr__(name, value)


            class Evpnevi(Entity):
                """
                Enter EVPN Instance configuration submode
                
                .. attribute:: eviid  <key>
                
                	EVI ID
                	**type**\:  int
                
                	**range:** 1..65534
                
                .. attribute:: evi_advertise_mac
                
                	Enter Advertise local MAC\-only routes configuration submode
                	**type**\:   :py:class:`EviAdvertiseMac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EviAdvertiseMac>`
                
                .. attribute:: evi_load_balancing
                
                	Enter Loadbalancing configuration submode
                	**type**\:   :py:class:`EviLoadBalancing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EviLoadBalancing>`
                
                .. attribute:: evi_reorig_disable
                
                	Disable route re\-origination
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: evi_unknown_unicast_flooding_disable
                
                	Disable Unknown Unicast Flooding on this EVI
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: evpn_evi_cw_disable
                
                	CW disable for EVPN EVI
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: evpnevi_description
                
                	EVPN Instance description
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: evpnevibgp_auto_discovery
                
                	Enable Autodiscovery BGP in EVPN EVI
                	**type**\:   :py:class:`EvpnevibgpAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.EvpnTables.Evpnevis.Evpnevi, self).__init__()

                    self.yang_name = "evpnevi"
                    self.yang_parent_name = "evpnevis"

                    self.eviid = YLeaf(YType.uint32, "eviid")

                    self.evi_reorig_disable = YLeaf(YType.empty, "evi-reorig-disable")

                    self.evi_unknown_unicast_flooding_disable = YLeaf(YType.empty, "evi-unknown-unicast-flooding-disable")

                    self.evpn_evi_cw_disable = YLeaf(YType.empty, "evpn-evi-cw-disable")

                    self.evpnevi_description = YLeaf(YType.str, "evpnevi-description")

                    self.evi_advertise_mac = Evpn.EvpnTables.Evpnevis.Evpnevi.EviAdvertiseMac()
                    self.evi_advertise_mac.parent = self
                    self._children_name_map["evi_advertise_mac"] = "evi-advertise-mac"
                    self._children_yang_names.add("evi-advertise-mac")

                    self.evi_load_balancing = Evpn.EvpnTables.Evpnevis.Evpnevi.EviLoadBalancing()
                    self.evi_load_balancing.parent = self
                    self._children_name_map["evi_load_balancing"] = "evi-load-balancing"
                    self._children_yang_names.add("evi-load-balancing")

                    self.evpnevibgp_auto_discovery = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery()
                    self.evpnevibgp_auto_discovery.parent = self
                    self._children_name_map["evpnevibgp_auto_discovery"] = "evpnevibgp-auto-discovery"
                    self._children_yang_names.add("evpnevibgp-auto-discovery")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("eviid",
                                    "evi_reorig_disable",
                                    "evi_unknown_unicast_flooding_disable",
                                    "evpn_evi_cw_disable",
                                    "evpnevi_description") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.EvpnTables.Evpnevis.Evpnevi, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.EvpnTables.Evpnevis.Evpnevi, self).__setattr__(name, value)


                class EviLoadBalancing(Entity):
                    """
                    Enter Loadbalancing configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Loadbalancing
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evi_flow_label
                    
                    	Enable Flow Label based load balancing
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EviLoadBalancing, self).__init__()

                        self.yang_name = "evi-load-balancing"
                        self.yang_parent_name = "evpnevi"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.evi_flow_label = YLeaf(YType.empty, "evi-flow-label")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "evi_flow_label") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.Evpnevis.Evpnevi.EviLoadBalancing, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.Evpnevis.Evpnevi.EviLoadBalancing, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.evi_flow_label.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.evi_flow_label.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evi-load-balancing" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.evi_flow_label.is_set or self.evi_flow_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_flow_label.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "evi-flow-label"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-flow-label"):
                            self.evi_flow_label = value
                            self.evi_flow_label.value_namespace = name_space
                            self.evi_flow_label.value_namespace_prefix = name_space_prefix


                class EvpnevibgpAutoDiscovery(Entity):
                    """
                    Enable Autodiscovery BGP in EVPN EVI
                    
                    .. attribute:: enable
                    
                    	Enable Autodiscovery BGP
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evpn_route_distinguisher
                    
                    	Route Distinguisher
                    	**type**\:   :py:class:`EvpnRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteDistinguisher>`
                    
                    .. attribute:: evpn_route_targets
                    
                    	Route Target
                    	**type**\:   :py:class:`EvpnRouteTargets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets>`
                    
                    .. attribute:: table_policy
                    
                    	Table Policy for installation of forwarding data to L2FIB
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery, self).__init__()

                        self.yang_name = "evpnevibgp-auto-discovery"
                        self.yang_parent_name = "evpnevi"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.table_policy = YLeaf(YType.str, "table-policy")

                        self.evpn_route_distinguisher = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteDistinguisher()
                        self.evpn_route_distinguisher.parent = self
                        self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                        self._children_yang_names.add("evpn-route-distinguisher")

                        self.evpn_route_targets = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets()
                        self.evpn_route_targets.parent = self
                        self._children_name_map["evpn_route_targets"] = "evpn-route-targets"
                        self._children_yang_names.add("evpn-route-targets")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "table_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery, self).__setattr__(name, value)


                    class EvpnRouteDistinguisher(Entity):
                        """
                        Route Distinguisher
                        
                        .. attribute:: addr_index
                        
                        	Addr index
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: address
                        
                        	IPV4 address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: as_
                        
                        	Two byte or 4 byte AS number
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: as_index
                        
                        	AS\:nn (hex or decimal format)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: type
                        
                        	Router Distinguisher Type
                        	**type**\:   :py:class:`BgpRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteDistinguisher>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteDistinguisher, self).__init__()

                            self.yang_name = "evpn-route-distinguisher"
                            self.yang_parent_name = "evpnevibgp-auto-discovery"

                            self.addr_index = YLeaf(YType.uint32, "addr-index")

                            self.address = YLeaf(YType.str, "address")

                            self.as_ = YLeaf(YType.uint32, "as")

                            self.as_index = YLeaf(YType.uint32, "as-index")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("addr_index",
                                            "address",
                                            "as_",
                                            "as_index",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteDistinguisher, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteDistinguisher, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.addr_index.is_set or
                                self.address.is_set or
                                self.as_.is_set or
                                self.as_index.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.addr_index.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.as_.yfilter != YFilter.not_set or
                                self.as_index.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "evpn-route-distinguisher" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.addr_index.get_name_leafdata())
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_.get_name_leafdata())
                            if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_index.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "addr-index"):
                                self.addr_index = value
                                self.addr_index.value_namespace = name_space
                                self.addr_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "as"):
                                self.as_ = value
                                self.as_.value_namespace = name_space
                                self.as_.value_namespace_prefix = name_space_prefix
                            if(value_path == "as-index"):
                                self.as_index = value
                                self.as_index.value_namespace = name_space
                                self.as_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix


                    class EvpnRouteTargets(Entity):
                        """
                        Route Target
                        
                        .. attribute:: evpn_route_target_as
                        
                        	Name of the Route Target
                        	**type**\: list of    :py:class:`EvpnRouteTargetAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs>`
                        
                        .. attribute:: evpn_route_target_ipv4_address
                        
                        	Name of the Route Target
                        	**type**\: list of    :py:class:`EvpnRouteTargetIpv4Address <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address>`
                        
                        .. attribute:: evpn_route_target_none
                        
                        	Name of the Route Target
                        	**type**\: list of    :py:class:`EvpnRouteTargetNone <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets, self).__init__()

                            self.yang_name = "evpn-route-targets"
                            self.yang_parent_name = "evpnevibgp-auto-discovery"

                            self.evpn_route_target_as = YList(self)
                            self.evpn_route_target_ipv4_address = YList(self)
                            self.evpn_route_target_none = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets, self).__setattr__(name, value)


                        class EvpnRouteTargetAs(Entity):
                            """
                            Name of the Route Target
                            
                            .. attribute:: format  <key>
                            
                            	Format of the route target
                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                            
                            .. attribute:: role  <key>
                            
                            	Role of the router target type
                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                            
                            .. attribute:: as_  <key>
                            
                            	Two byte or 4 byte AS number
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            .. attribute:: as_index  <key>
                            
                            	AS\:nn (hex or decimal format)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stitching  <key>
                            
                            	whether RT is Stitching RT
                            	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTarget>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs, self).__init__()

                                self.yang_name = "evpn-route-target-as"
                                self.yang_parent_name = "evpn-route-targets"

                                self.format = YLeaf(YType.enumeration, "format")

                                self.role = YLeaf(YType.enumeration, "role")

                                self.as_ = YLeaf(YType.uint32, "as")

                                self.as_index = YLeaf(YType.uint32, "as-index")

                                self.stitching = YLeaf(YType.enumeration, "stitching")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("format",
                                                "role",
                                                "as_",
                                                "as_index",
                                                "stitching") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.format.is_set or
                                    self.role.is_set or
                                    self.as_.is_set or
                                    self.as_index.is_set or
                                    self.stitching.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.format.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set or
                                    self.as_.yfilter != YFilter.not_set or
                                    self.as_index.yfilter != YFilter.not_set or
                                    self.stitching.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "evpn-route-target-as" + "[format='" + self.format.get() + "']" + "[role='" + self.role.get() + "']" + "[as='" + self.as_.get() + "']" + "[as-index='" + self.as_index.get() + "']" + "[stitching='" + self.stitching.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.format.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())
                                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_.get_name_leafdata())
                                if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_index.get_name_leafdata())
                                if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stitching.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "format" or name == "role" or name == "as" or name == "as-index" or name == "stitching"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "format"):
                                    self.format = value
                                    self.format.value_namespace = name_space
                                    self.format.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix
                                if(value_path == "as"):
                                    self.as_ = value
                                    self.as_.value_namespace = name_space
                                    self.as_.value_namespace_prefix = name_space_prefix
                                if(value_path == "as-index"):
                                    self.as_index = value
                                    self.as_index.value_namespace = name_space
                                    self.as_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "stitching"):
                                    self.stitching = value
                                    self.stitching.value_namespace = name_space
                                    self.stitching.value_namespace_prefix = name_space_prefix


                        class EvpnRouteTargetNone(Entity):
                            """
                            Name of the Route Target
                            
                            .. attribute:: format  <key>
                            
                            	Format of the route target
                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                            
                            .. attribute:: role  <key>
                            
                            	Role of the router target type
                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                            
                            .. attribute:: stitching  <key>
                            
                            	whether RT is Stitching RT
                            	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTarget>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone, self).__init__()

                                self.yang_name = "evpn-route-target-none"
                                self.yang_parent_name = "evpn-route-targets"

                                self.format = YLeaf(YType.enumeration, "format")

                                self.role = YLeaf(YType.enumeration, "role")

                                self.stitching = YLeaf(YType.enumeration, "stitching")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("format",
                                                "role",
                                                "stitching") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.format.is_set or
                                    self.role.is_set or
                                    self.stitching.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.format.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set or
                                    self.stitching.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "evpn-route-target-none" + "[format='" + self.format.get() + "']" + "[role='" + self.role.get() + "']" + "[stitching='" + self.stitching.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.format.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())
                                if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stitching.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "format" or name == "role" or name == "stitching"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "format"):
                                    self.format = value
                                    self.format.value_namespace = name_space
                                    self.format.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix
                                if(value_path == "stitching"):
                                    self.stitching = value
                                    self.stitching.value_namespace = name_space
                                    self.stitching.value_namespace_prefix = name_space_prefix


                        class EvpnRouteTargetIpv4Address(Entity):
                            """
                            Name of the Route Target
                            
                            .. attribute:: format  <key>
                            
                            	Format of the route target
                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                            
                            .. attribute:: role  <key>
                            
                            	Role of the router target type
                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                            
                            .. attribute:: address  <key>
                            
                            	IPV4 address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: addr_index  <key>
                            
                            	Addr index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: stitching  <key>
                            
                            	whether RT is Stitching RT
                            	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTarget>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address, self).__init__()

                                self.yang_name = "evpn-route-target-ipv4-address"
                                self.yang_parent_name = "evpn-route-targets"

                                self.format = YLeaf(YType.enumeration, "format")

                                self.role = YLeaf(YType.enumeration, "role")

                                self.address = YLeaf(YType.str, "address")

                                self.addr_index = YLeaf(YType.uint32, "addr-index")

                                self.stitching = YLeaf(YType.enumeration, "stitching")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("format",
                                                "role",
                                                "address",
                                                "addr_index",
                                                "stitching") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.format.is_set or
                                    self.role.is_set or
                                    self.address.is_set or
                                    self.addr_index.is_set or
                                    self.stitching.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.format.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.addr_index.yfilter != YFilter.not_set or
                                    self.stitching.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "evpn-route-target-ipv4-address" + "[format='" + self.format.get() + "']" + "[role='" + self.role.get() + "']" + "[address='" + self.address.get() + "']" + "[addr-index='" + self.addr_index.get() + "']" + "[stitching='" + self.stitching.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.format.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.addr_index.get_name_leafdata())
                                if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stitching.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "format" or name == "role" or name == "address" or name == "addr-index" or name == "stitching"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "format"):
                                    self.format = value
                                    self.format.value_namespace = name_space
                                    self.format.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "addr-index"):
                                    self.addr_index = value
                                    self.addr_index.value_namespace = name_space
                                    self.addr_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "stitching"):
                                    self.stitching = value
                                    self.stitching.value_namespace = name_space
                                    self.stitching.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.evpn_route_target_as:
                                if (c.has_data()):
                                    return True
                            for c in self.evpn_route_target_ipv4_address:
                                if (c.has_data()):
                                    return True
                            for c in self.evpn_route_target_none:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.evpn_route_target_as:
                                if (c.has_operation()):
                                    return True
                            for c in self.evpn_route_target_ipv4_address:
                                if (c.has_operation()):
                                    return True
                            for c in self.evpn_route_target_none:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "evpn-route-targets" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "evpn-route-target-as"):
                                for c in self.evpn_route_target_as:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.evpn_route_target_as.append(c)
                                return c

                            if (child_yang_name == "evpn-route-target-ipv4-address"):
                                for c in self.evpn_route_target_ipv4_address:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.evpn_route_target_ipv4_address.append(c)
                                return c

                            if (child_yang_name == "evpn-route-target-none"):
                                for c in self.evpn_route_target_none:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.evpn_route_target_none.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "evpn-route-target-as" or name == "evpn-route-target-ipv4-address" or name == "evpn-route-target-none"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.table_policy.is_set or
                            (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_data()) or
                            (self.evpn_route_targets is not None and self.evpn_route_targets.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.table_policy.yfilter != YFilter.not_set or
                            (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_operation()) or
                            (self.evpn_route_targets is not None and self.evpn_route_targets.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpnevibgp-auto-discovery" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.table_policy.is_set or self.table_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.table_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "evpn-route-distinguisher"):
                            if (self.evpn_route_distinguisher is None):
                                self.evpn_route_distinguisher = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteDistinguisher()
                                self.evpn_route_distinguisher.parent = self
                                self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                            return self.evpn_route_distinguisher

                        if (child_yang_name == "evpn-route-targets"):
                            if (self.evpn_route_targets is None):
                                self.evpn_route_targets = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery.EvpnRouteTargets()
                                self.evpn_route_targets.parent = self
                                self._children_name_map["evpn_route_targets"] = "evpn-route-targets"
                            return self.evpn_route_targets

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "evpn-route-distinguisher" or name == "evpn-route-targets" or name == "enable" or name == "table-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "table-policy"):
                            self.table_policy = value
                            self.table_policy.value_namespace = name_space
                            self.table_policy.value_namespace_prefix = name_space_prefix


                class EviAdvertiseMac(Entity):
                    """
                    Enter Advertise local MAC\-only routes
                    configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Advertise local MAC\-only routes
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evi_advertise_mac_bvi
                    
                    	Advertise local MAC\-only and BVI MAC routes
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.Evpnevis.Evpnevi.EviAdvertiseMac, self).__init__()

                        self.yang_name = "evi-advertise-mac"
                        self.yang_parent_name = "evpnevi"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.evi_advertise_mac_bvi = YLeaf(YType.empty, "evi-advertise-mac-bvi")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "evi_advertise_mac_bvi") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.Evpnevis.Evpnevi.EviAdvertiseMac, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.Evpnevis.Evpnevi.EviAdvertiseMac, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.evi_advertise_mac_bvi.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.evi_advertise_mac_bvi.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evi-advertise-mac" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.evi_advertise_mac_bvi.is_set or self.evi_advertise_mac_bvi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_advertise_mac_bvi.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "evi-advertise-mac-bvi"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-advertise-mac-bvi"):
                            self.evi_advertise_mac_bvi = value
                            self.evi_advertise_mac_bvi.value_namespace = name_space
                            self.evi_advertise_mac_bvi.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.eviid.is_set or
                        self.evi_reorig_disable.is_set or
                        self.evi_unknown_unicast_flooding_disable.is_set or
                        self.evpn_evi_cw_disable.is_set or
                        self.evpnevi_description.is_set or
                        (self.evi_advertise_mac is not None and self.evi_advertise_mac.has_data()) or
                        (self.evi_load_balancing is not None and self.evi_load_balancing.has_data()) or
                        (self.evpnevibgp_auto_discovery is not None and self.evpnevibgp_auto_discovery.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.eviid.yfilter != YFilter.not_set or
                        self.evi_reorig_disable.yfilter != YFilter.not_set or
                        self.evi_unknown_unicast_flooding_disable.yfilter != YFilter.not_set or
                        self.evpn_evi_cw_disable.yfilter != YFilter.not_set or
                        self.evpnevi_description.yfilter != YFilter.not_set or
                        (self.evi_advertise_mac is not None and self.evi_advertise_mac.has_operation()) or
                        (self.evi_load_balancing is not None and self.evi_load_balancing.has_operation()) or
                        (self.evpnevibgp_auto_discovery is not None and self.evpnevibgp_auto_discovery.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpnevi" + "[eviid='" + self.eviid.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpnevis/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.eviid.get_name_leafdata())
                    if (self.evi_reorig_disable.is_set or self.evi_reorig_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_reorig_disable.get_name_leafdata())
                    if (self.evi_unknown_unicast_flooding_disable.is_set or self.evi_unknown_unicast_flooding_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_unknown_unicast_flooding_disable.get_name_leafdata())
                    if (self.evpn_evi_cw_disable.is_set or self.evpn_evi_cw_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evpn_evi_cw_disable.get_name_leafdata())
                    if (self.evpnevi_description.is_set or self.evpnevi_description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evpnevi_description.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "evi-advertise-mac"):
                        if (self.evi_advertise_mac is None):
                            self.evi_advertise_mac = Evpn.EvpnTables.Evpnevis.Evpnevi.EviAdvertiseMac()
                            self.evi_advertise_mac.parent = self
                            self._children_name_map["evi_advertise_mac"] = "evi-advertise-mac"
                        return self.evi_advertise_mac

                    if (child_yang_name == "evi-load-balancing"):
                        if (self.evi_load_balancing is None):
                            self.evi_load_balancing = Evpn.EvpnTables.Evpnevis.Evpnevi.EviLoadBalancing()
                            self.evi_load_balancing.parent = self
                            self._children_name_map["evi_load_balancing"] = "evi-load-balancing"
                        return self.evi_load_balancing

                    if (child_yang_name == "evpnevibgp-auto-discovery"):
                        if (self.evpnevibgp_auto_discovery is None):
                            self.evpnevibgp_auto_discovery = Evpn.EvpnTables.Evpnevis.Evpnevi.EvpnevibgpAutoDiscovery()
                            self.evpnevibgp_auto_discovery.parent = self
                            self._children_name_map["evpnevibgp_auto_discovery"] = "evpnevibgp-auto-discovery"
                        return self.evpnevibgp_auto_discovery

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evi-advertise-mac" or name == "evi-load-balancing" or name == "evpnevibgp-auto-discovery" or name == "eviid" or name == "evi-reorig-disable" or name == "evi-unknown-unicast-flooding-disable" or name == "evpn-evi-cw-disable" or name == "evpnevi-description"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "eviid"):
                        self.eviid = value
                        self.eviid.value_namespace = name_space
                        self.eviid.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-reorig-disable"):
                        self.evi_reorig_disable = value
                        self.evi_reorig_disable.value_namespace = name_space
                        self.evi_reorig_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-unknown-unicast-flooding-disable"):
                        self.evi_unknown_unicast_flooding_disable = value
                        self.evi_unknown_unicast_flooding_disable.value_namespace = name_space
                        self.evi_unknown_unicast_flooding_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "evpn-evi-cw-disable"):
                        self.evpn_evi_cw_disable = value
                        self.evpn_evi_cw_disable.value_namespace = name_space
                        self.evpn_evi_cw_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "evpnevi-description"):
                        self.evpnevi_description = value
                        self.evpnevi_description.value_namespace = name_space
                        self.evpnevi_description.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.evpnevi:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.evpnevi:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpnevis" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpnevi"):
                    for c in self.evpnevi:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.EvpnTables.Evpnevis.Evpnevi()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.evpnevi.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpnevi"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EvpnVirtualAccessVfis(Entity):
            """
            Virtual Access VFI interfaces
            
            .. attribute:: evpn_virtual_access_vfi
            
            	Virtual Access VFI
            	**type**\: list of    :py:class:`EvpnVirtualAccessVfi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnVirtualAccessVfis, self).__init__()

                self.yang_name = "evpn-virtual-access-vfis"
                self.yang_parent_name = "evpn-tables"

                self.evpn_virtual_access_vfi = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnVirtualAccessVfis, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnVirtualAccessVfis, self).__setattr__(name, value)


            class EvpnVirtualAccessVfi(Entity):
                """
                Virtual Access VFI
                
                .. attribute:: name  <key>
                
                	Name of the Virtual Access VFI
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: evpn_virtual_access_vfi_timers
                
                	Enter Virtual Forwarding Interface timers configuration submode
                	**type**\:   :py:class:`EvpnVirtualAccessVfiTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualAccessVfiTimers>`
                
                .. attribute:: evpn_virtual_ethernet_segment
                
                	Enter Ethernet Segment configuration submode
                	**type**\:   :py:class:`EvpnVirtualEthernetSegment <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi, self).__init__()

                    self.yang_name = "evpn-virtual-access-vfi"
                    self.yang_parent_name = "evpn-virtual-access-vfis"

                    self.name = YLeaf(YType.str, "name")

                    self.evpn_virtual_access_vfi_timers = Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualAccessVfiTimers()
                    self.evpn_virtual_access_vfi_timers.parent = self
                    self._children_name_map["evpn_virtual_access_vfi_timers"] = "evpn-virtual-access-vfi-timers"
                    self._children_yang_names.add("evpn-virtual-access-vfi-timers")

                    self.evpn_virtual_ethernet_segment = Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment()
                    self.evpn_virtual_ethernet_segment.parent = self
                    self._children_name_map["evpn_virtual_ethernet_segment"] = "evpn-virtual-ethernet-segment"
                    self._children_yang_names.add("evpn-virtual-ethernet-segment")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi, self).__setattr__(name, value)


                class EvpnVirtualAccessVfiTimers(Entity):
                    """
                    Enter Virtual Forwarding Interface timers
                    configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Virtual Forwarding Interface timers
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evpn_virtual_access_vfi_peering
                    
                    	Virtual Forwarding Interface\-specific Peering timer
                    	**type**\:  int
                    
                    	**range:** 0..300
                    
                    	**default value**\: 3
                    
                    .. attribute:: evpn_virtual_access_vfi_recovery
                    
                    	Virtual Forwarding Interface\-specific Recovery timer
                    	**type**\:  int
                    
                    	**range:** 20..3600
                    
                    	**default value**\: 30
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualAccessVfiTimers, self).__init__()

                        self.yang_name = "evpn-virtual-access-vfi-timers"
                        self.yang_parent_name = "evpn-virtual-access-vfi"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.evpn_virtual_access_vfi_peering = YLeaf(YType.uint32, "evpn-virtual-access-vfi-peering")

                        self.evpn_virtual_access_vfi_recovery = YLeaf(YType.uint32, "evpn-virtual-access-vfi-recovery")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "evpn_virtual_access_vfi_peering",
                                        "evpn_virtual_access_vfi_recovery") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualAccessVfiTimers, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualAccessVfiTimers, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.evpn_virtual_access_vfi_peering.is_set or
                            self.evpn_virtual_access_vfi_recovery.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.evpn_virtual_access_vfi_peering.yfilter != YFilter.not_set or
                            self.evpn_virtual_access_vfi_recovery.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-virtual-access-vfi-timers" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.evpn_virtual_access_vfi_peering.is_set or self.evpn_virtual_access_vfi_peering.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evpn_virtual_access_vfi_peering.get_name_leafdata())
                        if (self.evpn_virtual_access_vfi_recovery.is_set or self.evpn_virtual_access_vfi_recovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evpn_virtual_access_vfi_recovery.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "evpn-virtual-access-vfi-peering" or name == "evpn-virtual-access-vfi-recovery"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "evpn-virtual-access-vfi-peering"):
                            self.evpn_virtual_access_vfi_peering = value
                            self.evpn_virtual_access_vfi_peering.value_namespace = name_space
                            self.evpn_virtual_access_vfi_peering.value_namespace_prefix = name_space_prefix
                        if(value_path == "evpn-virtual-access-vfi-recovery"):
                            self.evpn_virtual_access_vfi_recovery = value
                            self.evpn_virtual_access_vfi_recovery.value_namespace = name_space
                            self.evpn_virtual_access_vfi_recovery.value_namespace_prefix = name_space_prefix


                class EvpnVirtualEthernetSegment(Entity):
                    """
                    Enter Ethernet Segment configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Ethernet Segment
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: es_import_route_target
                    
                    	ES\-Import Route Target
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: identifier
                    
                    	Ethernet segment identifier
                    	**type**\:   :py:class:`Identifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment.Identifier>`
                    
                    	**presence node**\: True
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment, self).__init__()

                        self.yang_name = "evpn-virtual-ethernet-segment"
                        self.yang_parent_name = "evpn-virtual-access-vfi"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.es_import_route_target = YLeaf(YType.str, "es-import-route-target")

                        self.identifier = None
                        self._children_name_map["identifier"] = "identifier"
                        self._children_yang_names.add("identifier")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "es_import_route_target") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment, self).__setattr__(name, value)


                    class Identifier(Entity):
                        """
                        Ethernet segment identifier
                        
                        .. attribute:: bytes01
                        
                        	Type 0's 1st Byte or Type Byte and 1st Byte
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: bytes23
                        
                        	2nd and 3rd Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes45
                        
                        	4th and 5th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes67
                        
                        	6th and 7th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes89
                        
                        	8th and 9th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: type
                        
                        	Ethernet segment identifier type
                        	**type**\:   :py:class:`EthernetSegmentIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.EthernetSegmentIdentifier>`
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment.Identifier, self).__init__()

                            self.yang_name = "identifier"
                            self.yang_parent_name = "evpn-virtual-ethernet-segment"
                            self.is_presence_container = True

                            self.bytes01 = YLeaf(YType.str, "bytes01")

                            self.bytes23 = YLeaf(YType.str, "bytes23")

                            self.bytes45 = YLeaf(YType.str, "bytes45")

                            self.bytes67 = YLeaf(YType.str, "bytes67")

                            self.bytes89 = YLeaf(YType.str, "bytes89")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bytes01",
                                            "bytes23",
                                            "bytes45",
                                            "bytes67",
                                            "bytes89",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment.Identifier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment.Identifier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bytes01.is_set or
                                self.bytes23.is_set or
                                self.bytes45.is_set or
                                self.bytes67.is_set or
                                self.bytes89.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bytes01.yfilter != YFilter.not_set or
                                self.bytes23.yfilter != YFilter.not_set or
                                self.bytes45.yfilter != YFilter.not_set or
                                self.bytes67.yfilter != YFilter.not_set or
                                self.bytes89.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "identifier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bytes01.is_set or self.bytes01.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes01.get_name_leafdata())
                            if (self.bytes23.is_set or self.bytes23.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes23.get_name_leafdata())
                            if (self.bytes45.is_set or self.bytes45.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes45.get_name_leafdata())
                            if (self.bytes67.is_set or self.bytes67.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes67.get_name_leafdata())
                            if (self.bytes89.is_set or self.bytes89.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes89.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bytes01" or name == "bytes23" or name == "bytes45" or name == "bytes67" or name == "bytes89" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bytes01"):
                                self.bytes01 = value
                                self.bytes01.value_namespace = name_space
                                self.bytes01.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes23"):
                                self.bytes23 = value
                                self.bytes23.value_namespace = name_space
                                self.bytes23.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes45"):
                                self.bytes45 = value
                                self.bytes45.value_namespace = name_space
                                self.bytes45.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes67"):
                                self.bytes67 = value
                                self.bytes67.value_namespace = name_space
                                self.bytes67.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes89"):
                                self.bytes89 = value
                                self.bytes89.value_namespace = name_space
                                self.bytes89.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.es_import_route_target.is_set or
                            (self.identifier is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.es_import_route_target.yfilter != YFilter.not_set or
                            (self.identifier is not None and self.identifier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-virtual-ethernet-segment" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.es_import_route_target.is_set or self.es_import_route_target.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.es_import_route_target.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "identifier"):
                            if (self.identifier is None):
                                self.identifier = Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment.Identifier()
                                self.identifier.parent = self
                                self._children_name_map["identifier"] = "identifier"
                            return self.identifier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "identifier" or name == "enable" or name == "es-import-route-target"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "es-import-route-target"):
                            self.es_import_route_target = value
                            self.es_import_route_target.value_namespace = name_space
                            self.es_import_route_target.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.evpn_virtual_access_vfi_timers is not None and self.evpn_virtual_access_vfi_timers.has_data()) or
                        (self.evpn_virtual_ethernet_segment is not None and self.evpn_virtual_ethernet_segment.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.evpn_virtual_access_vfi_timers is not None and self.evpn_virtual_access_vfi_timers.has_operation()) or
                        (self.evpn_virtual_ethernet_segment is not None and self.evpn_virtual_ethernet_segment.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpn-virtual-access-vfi" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpn-virtual-access-vfis/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "evpn-virtual-access-vfi-timers"):
                        if (self.evpn_virtual_access_vfi_timers is None):
                            self.evpn_virtual_access_vfi_timers = Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualAccessVfiTimers()
                            self.evpn_virtual_access_vfi_timers.parent = self
                            self._children_name_map["evpn_virtual_access_vfi_timers"] = "evpn-virtual-access-vfi-timers"
                        return self.evpn_virtual_access_vfi_timers

                    if (child_yang_name == "evpn-virtual-ethernet-segment"):
                        if (self.evpn_virtual_ethernet_segment is None):
                            self.evpn_virtual_ethernet_segment = Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi.EvpnVirtualEthernetSegment()
                            self.evpn_virtual_ethernet_segment.parent = self
                            self._children_name_map["evpn_virtual_ethernet_segment"] = "evpn-virtual-ethernet-segment"
                        return self.evpn_virtual_ethernet_segment

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evpn-virtual-access-vfi-timers" or name == "evpn-virtual-ethernet-segment" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.evpn_virtual_access_vfi:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.evpn_virtual_access_vfi:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-virtual-access-vfis" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpn-virtual-access-vfi"):
                    for c in self.evpn_virtual_access_vfi:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.EvpnTables.EvpnVirtualAccessVfis.EvpnVirtualAccessVfi()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.evpn_virtual_access_vfi.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpn-virtual-access-vfi"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EvpnLoadBalancing(Entity):
            """
            Enter EVPN Loadbalancing configuration submode
            
            .. attribute:: enable
            
            	Enable EVPN Loadbalancing
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: evpn_flow_label
            
            	Enable Flow Label based load balancing
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnLoadBalancing, self).__init__()

                self.yang_name = "evpn-load-balancing"
                self.yang_parent_name = "evpn-tables"

                self.enable = YLeaf(YType.empty, "enable")

                self.evpn_flow_label = YLeaf(YType.empty, "evpn-flow-label")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "evpn_flow_label") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnLoadBalancing, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnLoadBalancing, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.evpn_flow_label.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.evpn_flow_label.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-load-balancing" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.evpn_flow_label.is_set or self.evpn_flow_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.evpn_flow_label.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "evpn-flow-label"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "evpn-flow-label"):
                    self.evpn_flow_label = value
                    self.evpn_flow_label.value_namespace = name_space
                    self.evpn_flow_label.value_namespace_prefix = name_space_prefix


        class EvpnbgpAutoDiscovery(Entity):
            """
            Enable Autodiscovery BGP in EVPN
            
            .. attribute:: enable
            
            	Enable Autodiscovery BGP
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: evpn_route_distinguisher
            
            	Route Distinguisher
            	**type**\:   :py:class:`EvpnRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnbgpAutoDiscovery.EvpnRouteDistinguisher>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnbgpAutoDiscovery, self).__init__()

                self.yang_name = "evpnbgp-auto-discovery"
                self.yang_parent_name = "evpn-tables"

                self.enable = YLeaf(YType.empty, "enable")

                self.evpn_route_distinguisher = Evpn.EvpnTables.EvpnbgpAutoDiscovery.EvpnRouteDistinguisher()
                self.evpn_route_distinguisher.parent = self
                self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                self._children_yang_names.add("evpn-route-distinguisher")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnbgpAutoDiscovery, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnbgpAutoDiscovery, self).__setattr__(name, value)


            class EvpnRouteDistinguisher(Entity):
                """
                Route Distinguisher
                
                .. attribute:: addr_index
                
                	Addr index
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: address
                
                	IPV4 address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: as_
                
                	Two byte or 4 byte AS number
                	**type**\:  int
                
                	**range:** 1..4294967295
                
                .. attribute:: as_index
                
                	AS\:nn (hex or decimal format)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: type
                
                	Router Distinguisher Type
                	**type**\:   :py:class:`BgpRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteDistinguisher>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.EvpnTables.EvpnbgpAutoDiscovery.EvpnRouteDistinguisher, self).__init__()

                    self.yang_name = "evpn-route-distinguisher"
                    self.yang_parent_name = "evpnbgp-auto-discovery"

                    self.addr_index = YLeaf(YType.uint32, "addr-index")

                    self.address = YLeaf(YType.str, "address")

                    self.as_ = YLeaf(YType.uint32, "as")

                    self.as_index = YLeaf(YType.uint32, "as-index")

                    self.type = YLeaf(YType.enumeration, "type")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("addr_index",
                                    "address",
                                    "as_",
                                    "as_index",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.EvpnTables.EvpnbgpAutoDiscovery.EvpnRouteDistinguisher, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.EvpnTables.EvpnbgpAutoDiscovery.EvpnRouteDistinguisher, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.addr_index.is_set or
                        self.address.is_set or
                        self.as_.is_set or
                        self.as_index.is_set or
                        self.type.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.addr_index.yfilter != YFilter.not_set or
                        self.address.yfilter != YFilter.not_set or
                        self.as_.yfilter != YFilter.not_set or
                        self.as_index.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpn-route-distinguisher" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpnbgp-auto-discovery/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.addr_index.get_name_leafdata())
                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address.get_name_leafdata())
                    if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.as_.get_name_leafdata())
                    if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.as_index.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "addr-index"):
                        self.addr_index = value
                        self.addr_index.value_namespace = name_space
                        self.addr_index.value_namespace_prefix = name_space_prefix
                    if(value_path == "address"):
                        self.address = value
                        self.address.value_namespace = name_space
                        self.address.value_namespace_prefix = name_space_prefix
                    if(value_path == "as"):
                        self.as_ = value
                        self.as_.value_namespace = name_space
                        self.as_.value_namespace_prefix = name_space_prefix
                    if(value_path == "as-index"):
                        self.as_index = value
                        self.as_index.value_namespace = name_space
                        self.as_index.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.enable.is_set or
                    (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpnbgp-auto-discovery" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpn-route-distinguisher"):
                    if (self.evpn_route_distinguisher is None):
                        self.evpn_route_distinguisher = Evpn.EvpnTables.EvpnbgpAutoDiscovery.EvpnRouteDistinguisher()
                        self.evpn_route_distinguisher.parent = self
                        self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                    return self.evpn_route_distinguisher

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpn-route-distinguisher" or name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class EvpnInstances(Entity):
            """
            Enter EVPN Instance configuration submode
            
            .. attribute:: evpn_instance
            
            	Enter EVPN Instance configuration submode
            	**type**\: list of    :py:class:`EvpnInstance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnInstances, self).__init__()

                self.yang_name = "evpn-instances"
                self.yang_parent_name = "evpn-tables"

                self.evpn_instance = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnInstances, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnInstances, self).__setattr__(name, value)


            class EvpnInstance(Entity):
                """
                Enter EVPN Instance configuration submode
                
                .. attribute:: eviid  <key>
                
                	EVPN Instance ID
                	**type**\:  int
                
                	**range:** 1..65534
                
                .. attribute:: encapsulation  <key>
                
                	EVPN Instance Encapsulation
                	**type**\:   :py:class:`EvpnEncapsulation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.EvpnEncapsulation>`
                
                .. attribute:: side  <key>
                
                	EVPN Instance Side
                	**type**\:   :py:class:`EvpnSide <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.EvpnSide>`
                
                .. attribute:: evi_reorig_disable
                
                	Disable route re\-origination
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: evi_unknown_unicast_flooding_disable
                
                	Disable Unknown Unicast Flooding on this EVI
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: evpn_evi_cw_disable
                
                	CW disable for EVPN EVI
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: evpn_instance_advertise_mac
                
                	Enter Advertise local MAC\-only routes configuration submode
                	**type**\:   :py:class:`EvpnInstanceAdvertiseMac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceAdvertiseMac>`
                
                .. attribute:: evpn_instance_bgp_auto_discovery
                
                	Enable Autodiscovery BGP in EVPN Instance
                	**type**\:   :py:class:`EvpnInstanceBgpAutoDiscovery <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery>`
                
                .. attribute:: evpn_instance_load_balancing
                
                	Enter Loadbalancing configuration submode
                	**type**\:   :py:class:`EvpnInstanceLoadBalancing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceLoadBalancing>`
                
                .. attribute:: evpnevi_description
                
                	EVPN Instance description
                	**type**\:  str
                
                	**length:** 1..64
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.EvpnTables.EvpnInstances.EvpnInstance, self).__init__()

                    self.yang_name = "evpn-instance"
                    self.yang_parent_name = "evpn-instances"

                    self.eviid = YLeaf(YType.uint32, "eviid")

                    self.encapsulation = YLeaf(YType.enumeration, "encapsulation")

                    self.side = YLeaf(YType.enumeration, "side")

                    self.evi_reorig_disable = YLeaf(YType.empty, "evi-reorig-disable")

                    self.evi_unknown_unicast_flooding_disable = YLeaf(YType.empty, "evi-unknown-unicast-flooding-disable")

                    self.evpn_evi_cw_disable = YLeaf(YType.empty, "evpn-evi-cw-disable")

                    self.evpnevi_description = YLeaf(YType.str, "evpnevi-description")

                    self.evpn_instance_advertise_mac = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceAdvertiseMac()
                    self.evpn_instance_advertise_mac.parent = self
                    self._children_name_map["evpn_instance_advertise_mac"] = "evpn-instance-advertise-mac"
                    self._children_yang_names.add("evpn-instance-advertise-mac")

                    self.evpn_instance_bgp_auto_discovery = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery()
                    self.evpn_instance_bgp_auto_discovery.parent = self
                    self._children_name_map["evpn_instance_bgp_auto_discovery"] = "evpn-instance-bgp-auto-discovery"
                    self._children_yang_names.add("evpn-instance-bgp-auto-discovery")

                    self.evpn_instance_load_balancing = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceLoadBalancing()
                    self.evpn_instance_load_balancing.parent = self
                    self._children_name_map["evpn_instance_load_balancing"] = "evpn-instance-load-balancing"
                    self._children_yang_names.add("evpn-instance-load-balancing")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("eviid",
                                    "encapsulation",
                                    "side",
                                    "evi_reorig_disable",
                                    "evi_unknown_unicast_flooding_disable",
                                    "evpn_evi_cw_disable",
                                    "evpnevi_description") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.EvpnTables.EvpnInstances.EvpnInstance, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.EvpnTables.EvpnInstances.EvpnInstance, self).__setattr__(name, value)


                class EvpnInstanceBgpAutoDiscovery(Entity):
                    """
                    Enable Autodiscovery BGP in EVPN Instance
                    
                    .. attribute:: enable
                    
                    	Enable Autodiscovery BGP
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evpn_route_distinguisher
                    
                    	Route Distinguisher
                    	**type**\:   :py:class:`EvpnRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteDistinguisher>`
                    
                    .. attribute:: evpn_route_targets
                    
                    	Route Target
                    	**type**\:   :py:class:`EvpnRouteTargets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets>`
                    
                    .. attribute:: table_policy
                    
                    	Table Policy for installation of forwarding data to L2FIB
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery, self).__init__()

                        self.yang_name = "evpn-instance-bgp-auto-discovery"
                        self.yang_parent_name = "evpn-instance"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.table_policy = YLeaf(YType.str, "table-policy")

                        self.evpn_route_distinguisher = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteDistinguisher()
                        self.evpn_route_distinguisher.parent = self
                        self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                        self._children_yang_names.add("evpn-route-distinguisher")

                        self.evpn_route_targets = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets()
                        self.evpn_route_targets.parent = self
                        self._children_name_map["evpn_route_targets"] = "evpn-route-targets"
                        self._children_yang_names.add("evpn-route-targets")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "table_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery, self).__setattr__(name, value)


                    class EvpnRouteDistinguisher(Entity):
                        """
                        Route Distinguisher
                        
                        .. attribute:: addr_index
                        
                        	Addr index
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: address
                        
                        	IPV4 address
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: as_
                        
                        	Two byte or 4 byte AS number
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: as_index
                        
                        	AS\:nn (hex or decimal format)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: type
                        
                        	Router Distinguisher Type
                        	**type**\:   :py:class:`BgpRouteDistinguisher <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteDistinguisher>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteDistinguisher, self).__init__()

                            self.yang_name = "evpn-route-distinguisher"
                            self.yang_parent_name = "evpn-instance-bgp-auto-discovery"

                            self.addr_index = YLeaf(YType.uint32, "addr-index")

                            self.address = YLeaf(YType.str, "address")

                            self.as_ = YLeaf(YType.uint32, "as")

                            self.as_index = YLeaf(YType.uint32, "as-index")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("addr_index",
                                            "address",
                                            "as_",
                                            "as_index",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteDistinguisher, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteDistinguisher, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.addr_index.is_set or
                                self.address.is_set or
                                self.as_.is_set or
                                self.as_index.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.addr_index.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.as_.yfilter != YFilter.not_set or
                                self.as_index.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "evpn-route-distinguisher" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.addr_index.get_name_leafdata())
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_.get_name_leafdata())
                            if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.as_index.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "addr-index" or name == "address" or name == "as" or name == "as-index" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "addr-index"):
                                self.addr_index = value
                                self.addr_index.value_namespace = name_space
                                self.addr_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "as"):
                                self.as_ = value
                                self.as_.value_namespace = name_space
                                self.as_.value_namespace_prefix = name_space_prefix
                            if(value_path == "as-index"):
                                self.as_index = value
                                self.as_index.value_namespace = name_space
                                self.as_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix


                    class EvpnRouteTargets(Entity):
                        """
                        Route Target
                        
                        .. attribute:: evpn_route_target_as
                        
                        	Name of the Route Target
                        	**type**\: list of    :py:class:`EvpnRouteTargetAs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs>`
                        
                        .. attribute:: evpn_route_target_ipv4_address
                        
                        	Name of the Route Target
                        	**type**\: list of    :py:class:`EvpnRouteTargetIpv4Address <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address>`
                        
                        .. attribute:: evpn_route_target_none
                        
                        	Name of the Route Target
                        	**type**\: list of    :py:class:`EvpnRouteTargetNone <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets, self).__init__()

                            self.yang_name = "evpn-route-targets"
                            self.yang_parent_name = "evpn-instance-bgp-auto-discovery"

                            self.evpn_route_target_as = YList(self)
                            self.evpn_route_target_ipv4_address = YList(self)
                            self.evpn_route_target_none = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets, self).__setattr__(name, value)


                        class EvpnRouteTargetAs(Entity):
                            """
                            Name of the Route Target
                            
                            .. attribute:: format  <key>
                            
                            	Format of the route target
                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                            
                            .. attribute:: role  <key>
                            
                            	Role of the router target type
                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                            
                            .. attribute:: as_  <key>
                            
                            	Two byte or 4 byte AS number
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            .. attribute:: as_index  <key>
                            
                            	AS\:nn (hex or decimal format)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: stitching  <key>
                            
                            	whether RT is Stitching RT
                            	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTarget>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs, self).__init__()

                                self.yang_name = "evpn-route-target-as"
                                self.yang_parent_name = "evpn-route-targets"

                                self.format = YLeaf(YType.enumeration, "format")

                                self.role = YLeaf(YType.enumeration, "role")

                                self.as_ = YLeaf(YType.uint32, "as")

                                self.as_index = YLeaf(YType.uint32, "as-index")

                                self.stitching = YLeaf(YType.enumeration, "stitching")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("format",
                                                "role",
                                                "as_",
                                                "as_index",
                                                "stitching") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.format.is_set or
                                    self.role.is_set or
                                    self.as_.is_set or
                                    self.as_index.is_set or
                                    self.stitching.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.format.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set or
                                    self.as_.yfilter != YFilter.not_set or
                                    self.as_index.yfilter != YFilter.not_set or
                                    self.stitching.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "evpn-route-target-as" + "[format='" + self.format.get() + "']" + "[role='" + self.role.get() + "']" + "[as='" + self.as_.get() + "']" + "[as-index='" + self.as_index.get() + "']" + "[stitching='" + self.stitching.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.format.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())
                                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_.get_name_leafdata())
                                if (self.as_index.is_set or self.as_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_index.get_name_leafdata())
                                if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stitching.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "format" or name == "role" or name == "as" or name == "as-index" or name == "stitching"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "format"):
                                    self.format = value
                                    self.format.value_namespace = name_space
                                    self.format.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix
                                if(value_path == "as"):
                                    self.as_ = value
                                    self.as_.value_namespace = name_space
                                    self.as_.value_namespace_prefix = name_space_prefix
                                if(value_path == "as-index"):
                                    self.as_index = value
                                    self.as_index.value_namespace = name_space
                                    self.as_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "stitching"):
                                    self.stitching = value
                                    self.stitching.value_namespace = name_space
                                    self.stitching.value_namespace_prefix = name_space_prefix


                        class EvpnRouteTargetNone(Entity):
                            """
                            Name of the Route Target
                            
                            .. attribute:: format  <key>
                            
                            	Format of the route target
                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                            
                            .. attribute:: role  <key>
                            
                            	Role of the router target type
                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                            
                            .. attribute:: stitching  <key>
                            
                            	whether RT is Stitching RT
                            	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTarget>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone, self).__init__()

                                self.yang_name = "evpn-route-target-none"
                                self.yang_parent_name = "evpn-route-targets"

                                self.format = YLeaf(YType.enumeration, "format")

                                self.role = YLeaf(YType.enumeration, "role")

                                self.stitching = YLeaf(YType.enumeration, "stitching")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("format",
                                                "role",
                                                "stitching") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.format.is_set or
                                    self.role.is_set or
                                    self.stitching.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.format.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set or
                                    self.stitching.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "evpn-route-target-none" + "[format='" + self.format.get() + "']" + "[role='" + self.role.get() + "']" + "[stitching='" + self.stitching.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.format.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())
                                if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stitching.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "format" or name == "role" or name == "stitching"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "format"):
                                    self.format = value
                                    self.format.value_namespace = name_space
                                    self.format.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix
                                if(value_path == "stitching"):
                                    self.stitching = value
                                    self.stitching.value_namespace = name_space
                                    self.stitching.value_namespace_prefix = name_space_prefix


                        class EvpnRouteTargetIpv4Address(Entity):
                            """
                            Name of the Route Target
                            
                            .. attribute:: format  <key>
                            
                            	Format of the route target
                            	**type**\:   :py:class:`BgpRouteTargetFormat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetFormat>`
                            
                            .. attribute:: role  <key>
                            
                            	Role of the router target type
                            	**type**\:   :py:class:`BgpRouteTargetRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTargetRole>`
                            
                            .. attribute:: address  <key>
                            
                            	IPV4 address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: addr_index  <key>
                            
                            	Addr index
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: stitching  <key>
                            
                            	whether RT is Stitching RT
                            	**type**\:   :py:class:`BgpRouteTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.BgpRouteTarget>`
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address, self).__init__()

                                self.yang_name = "evpn-route-target-ipv4-address"
                                self.yang_parent_name = "evpn-route-targets"

                                self.format = YLeaf(YType.enumeration, "format")

                                self.role = YLeaf(YType.enumeration, "role")

                                self.address = YLeaf(YType.str, "address")

                                self.addr_index = YLeaf(YType.uint32, "addr-index")

                                self.stitching = YLeaf(YType.enumeration, "stitching")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("format",
                                                "role",
                                                "address",
                                                "addr_index",
                                                "stitching") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.format.is_set or
                                    self.role.is_set or
                                    self.address.is_set or
                                    self.addr_index.is_set or
                                    self.stitching.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.format.yfilter != YFilter.not_set or
                                    self.role.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.addr_index.yfilter != YFilter.not_set or
                                    self.stitching.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "evpn-route-target-ipv4-address" + "[format='" + self.format.get() + "']" + "[role='" + self.role.get() + "']" + "[address='" + self.address.get() + "']" + "[addr-index='" + self.addr_index.get() + "']" + "[stitching='" + self.stitching.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.format.is_set or self.format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.format.get_name_leafdata())
                                if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.role.get_name_leafdata())
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.addr_index.is_set or self.addr_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.addr_index.get_name_leafdata())
                                if (self.stitching.is_set or self.stitching.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stitching.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "format" or name == "role" or name == "address" or name == "addr-index" or name == "stitching"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "format"):
                                    self.format = value
                                    self.format.value_namespace = name_space
                                    self.format.value_namespace_prefix = name_space_prefix
                                if(value_path == "role"):
                                    self.role = value
                                    self.role.value_namespace = name_space
                                    self.role.value_namespace_prefix = name_space_prefix
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "addr-index"):
                                    self.addr_index = value
                                    self.addr_index.value_namespace = name_space
                                    self.addr_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "stitching"):
                                    self.stitching = value
                                    self.stitching.value_namespace = name_space
                                    self.stitching.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.evpn_route_target_as:
                                if (c.has_data()):
                                    return True
                            for c in self.evpn_route_target_ipv4_address:
                                if (c.has_data()):
                                    return True
                            for c in self.evpn_route_target_none:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.evpn_route_target_as:
                                if (c.has_operation()):
                                    return True
                            for c in self.evpn_route_target_ipv4_address:
                                if (c.has_operation()):
                                    return True
                            for c in self.evpn_route_target_none:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "evpn-route-targets" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "evpn-route-target-as"):
                                for c in self.evpn_route_target_as:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetAs()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.evpn_route_target_as.append(c)
                                return c

                            if (child_yang_name == "evpn-route-target-ipv4-address"):
                                for c in self.evpn_route_target_ipv4_address:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetIpv4Address()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.evpn_route_target_ipv4_address.append(c)
                                return c

                            if (child_yang_name == "evpn-route-target-none"):
                                for c in self.evpn_route_target_none:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets.EvpnRouteTargetNone()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.evpn_route_target_none.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "evpn-route-target-as" or name == "evpn-route-target-ipv4-address" or name == "evpn-route-target-none"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.table_policy.is_set or
                            (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_data()) or
                            (self.evpn_route_targets is not None and self.evpn_route_targets.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.table_policy.yfilter != YFilter.not_set or
                            (self.evpn_route_distinguisher is not None and self.evpn_route_distinguisher.has_operation()) or
                            (self.evpn_route_targets is not None and self.evpn_route_targets.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-instance-bgp-auto-discovery" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.table_policy.is_set or self.table_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.table_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "evpn-route-distinguisher"):
                            if (self.evpn_route_distinguisher is None):
                                self.evpn_route_distinguisher = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteDistinguisher()
                                self.evpn_route_distinguisher.parent = self
                                self._children_name_map["evpn_route_distinguisher"] = "evpn-route-distinguisher"
                            return self.evpn_route_distinguisher

                        if (child_yang_name == "evpn-route-targets"):
                            if (self.evpn_route_targets is None):
                                self.evpn_route_targets = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery.EvpnRouteTargets()
                                self.evpn_route_targets.parent = self
                                self._children_name_map["evpn_route_targets"] = "evpn-route-targets"
                            return self.evpn_route_targets

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "evpn-route-distinguisher" or name == "evpn-route-targets" or name == "enable" or name == "table-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "table-policy"):
                            self.table_policy = value
                            self.table_policy.value_namespace = name_space
                            self.table_policy.value_namespace_prefix = name_space_prefix


                class EvpnInstanceAdvertiseMac(Entity):
                    """
                    Enter Advertise local MAC\-only routes
                    configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Advertise local MAC\-only routes
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evi_advertise_mac_bvi
                    
                    	Advertise local MAC\-only and BVI MAC routes
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceAdvertiseMac, self).__init__()

                        self.yang_name = "evpn-instance-advertise-mac"
                        self.yang_parent_name = "evpn-instance"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.evi_advertise_mac_bvi = YLeaf(YType.empty, "evi-advertise-mac-bvi")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "evi_advertise_mac_bvi") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceAdvertiseMac, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceAdvertiseMac, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.evi_advertise_mac_bvi.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.evi_advertise_mac_bvi.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-instance-advertise-mac" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.evi_advertise_mac_bvi.is_set or self.evi_advertise_mac_bvi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_advertise_mac_bvi.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "evi-advertise-mac-bvi"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-advertise-mac-bvi"):
                            self.evi_advertise_mac_bvi = value
                            self.evi_advertise_mac_bvi.value_namespace = name_space
                            self.evi_advertise_mac_bvi.value_namespace_prefix = name_space_prefix


                class EvpnInstanceLoadBalancing(Entity):
                    """
                    Enter Loadbalancing configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Loadbalancing
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evi_flow_label
                    
                    	Enable Flow Label based load balancing
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceLoadBalancing, self).__init__()

                        self.yang_name = "evpn-instance-load-balancing"
                        self.yang_parent_name = "evpn-instance"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.evi_flow_label = YLeaf(YType.empty, "evi-flow-label")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "evi_flow_label") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceLoadBalancing, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceLoadBalancing, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.evi_flow_label.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.evi_flow_label.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-instance-load-balancing" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.evi_flow_label.is_set or self.evi_flow_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evi_flow_label.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "evi-flow-label"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "evi-flow-label"):
                            self.evi_flow_label = value
                            self.evi_flow_label.value_namespace = name_space
                            self.evi_flow_label.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.eviid.is_set or
                        self.encapsulation.is_set or
                        self.side.is_set or
                        self.evi_reorig_disable.is_set or
                        self.evi_unknown_unicast_flooding_disable.is_set or
                        self.evpn_evi_cw_disable.is_set or
                        self.evpnevi_description.is_set or
                        (self.evpn_instance_advertise_mac is not None and self.evpn_instance_advertise_mac.has_data()) or
                        (self.evpn_instance_bgp_auto_discovery is not None and self.evpn_instance_bgp_auto_discovery.has_data()) or
                        (self.evpn_instance_load_balancing is not None and self.evpn_instance_load_balancing.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.eviid.yfilter != YFilter.not_set or
                        self.encapsulation.yfilter != YFilter.not_set or
                        self.side.yfilter != YFilter.not_set or
                        self.evi_reorig_disable.yfilter != YFilter.not_set or
                        self.evi_unknown_unicast_flooding_disable.yfilter != YFilter.not_set or
                        self.evpn_evi_cw_disable.yfilter != YFilter.not_set or
                        self.evpnevi_description.yfilter != YFilter.not_set or
                        (self.evpn_instance_advertise_mac is not None and self.evpn_instance_advertise_mac.has_operation()) or
                        (self.evpn_instance_bgp_auto_discovery is not None and self.evpn_instance_bgp_auto_discovery.has_operation()) or
                        (self.evpn_instance_load_balancing is not None and self.evpn_instance_load_balancing.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpn-instance" + "[eviid='" + self.eviid.get() + "']" + "[encapsulation='" + self.encapsulation.get() + "']" + "[side='" + self.side.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpn-instances/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.eviid.is_set or self.eviid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.eviid.get_name_leafdata())
                    if (self.encapsulation.is_set or self.encapsulation.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.encapsulation.get_name_leafdata())
                    if (self.side.is_set or self.side.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.side.get_name_leafdata())
                    if (self.evi_reorig_disable.is_set or self.evi_reorig_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_reorig_disable.get_name_leafdata())
                    if (self.evi_unknown_unicast_flooding_disable.is_set or self.evi_unknown_unicast_flooding_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evi_unknown_unicast_flooding_disable.get_name_leafdata())
                    if (self.evpn_evi_cw_disable.is_set or self.evpn_evi_cw_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evpn_evi_cw_disable.get_name_leafdata())
                    if (self.evpnevi_description.is_set or self.evpnevi_description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.evpnevi_description.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "evpn-instance-advertise-mac"):
                        if (self.evpn_instance_advertise_mac is None):
                            self.evpn_instance_advertise_mac = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceAdvertiseMac()
                            self.evpn_instance_advertise_mac.parent = self
                            self._children_name_map["evpn_instance_advertise_mac"] = "evpn-instance-advertise-mac"
                        return self.evpn_instance_advertise_mac

                    if (child_yang_name == "evpn-instance-bgp-auto-discovery"):
                        if (self.evpn_instance_bgp_auto_discovery is None):
                            self.evpn_instance_bgp_auto_discovery = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceBgpAutoDiscovery()
                            self.evpn_instance_bgp_auto_discovery.parent = self
                            self._children_name_map["evpn_instance_bgp_auto_discovery"] = "evpn-instance-bgp-auto-discovery"
                        return self.evpn_instance_bgp_auto_discovery

                    if (child_yang_name == "evpn-instance-load-balancing"):
                        if (self.evpn_instance_load_balancing is None):
                            self.evpn_instance_load_balancing = Evpn.EvpnTables.EvpnInstances.EvpnInstance.EvpnInstanceLoadBalancing()
                            self.evpn_instance_load_balancing.parent = self
                            self._children_name_map["evpn_instance_load_balancing"] = "evpn-instance-load-balancing"
                        return self.evpn_instance_load_balancing

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evpn-instance-advertise-mac" or name == "evpn-instance-bgp-auto-discovery" or name == "evpn-instance-load-balancing" or name == "eviid" or name == "encapsulation" or name == "side" or name == "evi-reorig-disable" or name == "evi-unknown-unicast-flooding-disable" or name == "evpn-evi-cw-disable" or name == "evpnevi-description"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "eviid"):
                        self.eviid = value
                        self.eviid.value_namespace = name_space
                        self.eviid.value_namespace_prefix = name_space_prefix
                    if(value_path == "encapsulation"):
                        self.encapsulation = value
                        self.encapsulation.value_namespace = name_space
                        self.encapsulation.value_namespace_prefix = name_space_prefix
                    if(value_path == "side"):
                        self.side = value
                        self.side.value_namespace = name_space
                        self.side.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-reorig-disable"):
                        self.evi_reorig_disable = value
                        self.evi_reorig_disable.value_namespace = name_space
                        self.evi_reorig_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "evi-unknown-unicast-flooding-disable"):
                        self.evi_unknown_unicast_flooding_disable = value
                        self.evi_unknown_unicast_flooding_disable.value_namespace = name_space
                        self.evi_unknown_unicast_flooding_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "evpn-evi-cw-disable"):
                        self.evpn_evi_cw_disable = value
                        self.evpn_evi_cw_disable.value_namespace = name_space
                        self.evpn_evi_cw_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "evpnevi-description"):
                        self.evpnevi_description = value
                        self.evpnevi_description.value_namespace = name_space
                        self.evpnevi_description.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.evpn_instance:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.evpn_instance:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-instances" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpn-instance"):
                    for c in self.evpn_instance:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.EvpnTables.EvpnInstances.EvpnInstance()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.evpn_instance.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpn-instance"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EvpnLogging(Entity):
            """
            Enter EVPN Logging configuration submode
            
            .. attribute:: enable
            
            	Enable EVPN Logging
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: evpn_df_election
            
            	Enable Designated Forwarder election logging
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnLogging, self).__init__()

                self.yang_name = "evpn-logging"
                self.yang_parent_name = "evpn-tables"

                self.enable = YLeaf(YType.empty, "enable")

                self.evpn_df_election = YLeaf(YType.empty, "evpn-df-election")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "evpn_df_election") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnLogging, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnLogging, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.evpn_df_election.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.evpn_df_election.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-logging" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.evpn_df_election.is_set or self.evpn_df_election.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.evpn_df_election.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "evpn-df-election"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "evpn-df-election"):
                    self.evpn_df_election = value
                    self.evpn_df_election.value_namespace = name_space
                    self.evpn_df_election.value_namespace_prefix = name_space_prefix


        class EvpnInterfaces(Entity):
            """
            Attachment Circuit interfaces
            
            .. attribute:: evpn_interface
            
            	Attachment circuit interface
            	**type**\: list of    :py:class:`EvpnInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInterfaces.EvpnInterface>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnInterfaces, self).__init__()

                self.yang_name = "evpn-interfaces"
                self.yang_parent_name = "evpn-tables"

                self.evpn_interface = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnInterfaces, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnInterfaces, self).__setattr__(name, value)


            class EvpnInterface(Entity):
                """
                Attachment circuit interface
                
                .. attribute:: interface_name  <key>
                
                	Name of the attachment circuit interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: ethernet_segment
                
                	Enter Ethernet Segment configuration submode
                	**type**\:   :py:class:`EthernetSegment <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment>`
                
                .. attribute:: evpnac_timers
                
                	Enter Interface\-specific timers configuration submode
                	**type**\:   :py:class:`EvpnacTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EvpnacTimers>`
                
                .. attribute:: mac_flush
                
                	Enable MVRP MAC Flush mode
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface, self).__init__()

                    self.yang_name = "evpn-interface"
                    self.yang_parent_name = "evpn-interfaces"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.mac_flush = YLeaf(YType.empty, "mac-flush")

                    self.ethernet_segment = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment()
                    self.ethernet_segment.parent = self
                    self._children_name_map["ethernet_segment"] = "ethernet-segment"
                    self._children_yang_names.add("ethernet-segment")

                    self.evpnac_timers = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EvpnacTimers()
                    self.evpnac_timers.parent = self
                    self._children_name_map["evpnac_timers"] = "evpnac-timers"
                    self._children_yang_names.add("evpnac-timers")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "mac_flush") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface, self).__setattr__(name, value)


                class EvpnacTimers(Entity):
                    """
                    Enter Interface\-specific timers configuration
                    submode
                    
                    .. attribute:: enable
                    
                    	Enable Interface\-specific timers
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evpnac_peering
                    
                    	Interface\-specific Peering timer
                    	**type**\:  int
                    
                    	**range:** 0..300
                    
                    	**default value**\: 3
                    
                    .. attribute:: evpnac_recovery
                    
                    	Interface\-specific Recovery timer
                    	**type**\:  int
                    
                    	**range:** 20..3600
                    
                    	**default value**\: 30
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EvpnacTimers, self).__init__()

                        self.yang_name = "evpnac-timers"
                        self.yang_parent_name = "evpn-interface"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.evpnac_peering = YLeaf(YType.uint32, "evpnac-peering")

                        self.evpnac_recovery = YLeaf(YType.uint32, "evpnac-recovery")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "evpnac_peering",
                                        "evpnac_recovery") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EvpnacTimers, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EvpnacTimers, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.evpnac_peering.is_set or
                            self.evpnac_recovery.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.evpnac_peering.yfilter != YFilter.not_set or
                            self.evpnac_recovery.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpnac-timers" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.evpnac_peering.is_set or self.evpnac_peering.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evpnac_peering.get_name_leafdata())
                        if (self.evpnac_recovery.is_set or self.evpnac_recovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evpnac_recovery.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "evpnac-peering" or name == "evpnac-recovery"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "evpnac-peering"):
                            self.evpnac_peering = value
                            self.evpnac_peering.value_namespace = name_space
                            self.evpnac_peering.value_namespace_prefix = name_space_prefix
                        if(value_path == "evpnac-recovery"):
                            self.evpnac_recovery = value
                            self.evpnac_recovery.value_namespace = name_space
                            self.evpnac_recovery.value_namespace_prefix = name_space_prefix


                class EthernetSegment(Entity):
                    """
                    Enter Ethernet Segment configuration submode
                    
                    .. attribute:: backbone_source_mac
                    
                    	Backbone Source MAC
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: enable
                    
                    	Enable Ethernet Segment
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: es_import_route_target
                    
                    	ES\-Import Route Target
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: force_single_homed
                    
                    	Force ethernet segment to remain single\-homed
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: identifier
                    
                    	Ethernet segment identifier
                    	**type**\:   :py:class:`Identifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.Identifier>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: load_balancing_single_active
                    
                    	Enable single\-active load balancing mode
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: manual_service_carving
                    
                    	Enter Manual service carving configuration submode
                    	**type**\:   :py:class:`ManualServiceCarving <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment, self).__init__()

                        self.yang_name = "ethernet-segment"
                        self.yang_parent_name = "evpn-interface"

                        self.backbone_source_mac = YLeaf(YType.str, "backbone-source-mac")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.es_import_route_target = YLeaf(YType.str, "es-import-route-target")

                        self.force_single_homed = YLeaf(YType.empty, "force-single-homed")

                        self.load_balancing_single_active = YLeaf(YType.empty, "load-balancing-single-active")

                        self.identifier = None
                        self._children_name_map["identifier"] = "identifier"
                        self._children_yang_names.add("identifier")

                        self.manual_service_carving = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving()
                        self.manual_service_carving.parent = self
                        self._children_name_map["manual_service_carving"] = "manual-service-carving"
                        self._children_yang_names.add("manual-service-carving")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("backbone_source_mac",
                                        "enable",
                                        "es_import_route_target",
                                        "force_single_homed",
                                        "load_balancing_single_active") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment, self).__setattr__(name, value)


                    class ManualServiceCarving(Entity):
                        """
                        Enter Manual service carving configuration
                        submode
                        
                        .. attribute:: enable
                        
                        	Enable Manual service carving
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: service_list
                        
                        	Manual service carving primary,secondary lists
                        	**type**\:   :py:class:`ServiceList <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving.ServiceList>`
                        
                        

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving, self).__init__()

                            self.yang_name = "manual-service-carving"
                            self.yang_parent_name = "ethernet-segment"

                            self.enable = YLeaf(YType.empty, "enable")

                            self.service_list = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving.ServiceList()
                            self.service_list.parent = self
                            self._children_name_map["service_list"] = "service-list"
                            self._children_yang_names.add("service-list")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving, self).__setattr__(name, value)


                        class ServiceList(Entity):
                            """
                            Manual service carving primary,secondary
                            lists
                            
                            .. attribute:: primary
                            
                            	Primary services list
                            	**type**\:  str
                            
                            	**length:** 1..150
                            
                            .. attribute:: secondary
                            
                            	Secondary services list
                            	**type**\:  str
                            
                            	**length:** 1..150
                            
                            

                            """

                            _prefix = 'l2vpn-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving.ServiceList, self).__init__()

                                self.yang_name = "service-list"
                                self.yang_parent_name = "manual-service-carving"

                                self.primary = YLeaf(YType.str, "primary")

                                self.secondary = YLeaf(YType.str, "secondary")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("primary",
                                                "secondary") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving.ServiceList, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving.ServiceList, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.primary.is_set or
                                    self.secondary.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.primary.yfilter != YFilter.not_set or
                                    self.secondary.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "service-list" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.primary.is_set or self.primary.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.primary.get_name_leafdata())
                                if (self.secondary.is_set or self.secondary.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.secondary.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "primary" or name == "secondary"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "primary"):
                                    self.primary = value
                                    self.primary.value_namespace = name_space
                                    self.primary.value_namespace_prefix = name_space_prefix
                                if(value_path == "secondary"):
                                    self.secondary = value
                                    self.secondary.value_namespace = name_space
                                    self.secondary.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                (self.service_list is not None and self.service_list.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                (self.service_list is not None and self.service_list.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "manual-service-carving" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "service-list"):
                                if (self.service_list is None):
                                    self.service_list = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving.ServiceList()
                                    self.service_list.parent = self
                                    self._children_name_map["service_list"] = "service-list"
                                return self.service_list

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "service-list" or name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix


                    class Identifier(Entity):
                        """
                        Ethernet segment identifier
                        
                        .. attribute:: bytes01
                        
                        	Type 0's 1st Byte or Type Byte and 1st Byte
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: bytes23
                        
                        	2nd and 3rd Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes45
                        
                        	4th and 5th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes67
                        
                        	6th and 7th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes89
                        
                        	8th and 9th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: type
                        
                        	Ethernet segment identifier type
                        	**type**\:   :py:class:`EthernetSegmentIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.EthernetSegmentIdentifier>`
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.Identifier, self).__init__()

                            self.yang_name = "identifier"
                            self.yang_parent_name = "ethernet-segment"
                            self.is_presence_container = True

                            self.bytes01 = YLeaf(YType.str, "bytes01")

                            self.bytes23 = YLeaf(YType.str, "bytes23")

                            self.bytes45 = YLeaf(YType.str, "bytes45")

                            self.bytes67 = YLeaf(YType.str, "bytes67")

                            self.bytes89 = YLeaf(YType.str, "bytes89")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bytes01",
                                            "bytes23",
                                            "bytes45",
                                            "bytes67",
                                            "bytes89",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.Identifier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.Identifier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bytes01.is_set or
                                self.bytes23.is_set or
                                self.bytes45.is_set or
                                self.bytes67.is_set or
                                self.bytes89.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bytes01.yfilter != YFilter.not_set or
                                self.bytes23.yfilter != YFilter.not_set or
                                self.bytes45.yfilter != YFilter.not_set or
                                self.bytes67.yfilter != YFilter.not_set or
                                self.bytes89.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "identifier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bytes01.is_set or self.bytes01.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes01.get_name_leafdata())
                            if (self.bytes23.is_set or self.bytes23.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes23.get_name_leafdata())
                            if (self.bytes45.is_set or self.bytes45.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes45.get_name_leafdata())
                            if (self.bytes67.is_set or self.bytes67.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes67.get_name_leafdata())
                            if (self.bytes89.is_set or self.bytes89.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes89.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bytes01" or name == "bytes23" or name == "bytes45" or name == "bytes67" or name == "bytes89" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bytes01"):
                                self.bytes01 = value
                                self.bytes01.value_namespace = name_space
                                self.bytes01.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes23"):
                                self.bytes23 = value
                                self.bytes23.value_namespace = name_space
                                self.bytes23.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes45"):
                                self.bytes45 = value
                                self.bytes45.value_namespace = name_space
                                self.bytes45.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes67"):
                                self.bytes67 = value
                                self.bytes67.value_namespace = name_space
                                self.bytes67.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes89"):
                                self.bytes89 = value
                                self.bytes89.value_namespace = name_space
                                self.bytes89.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.backbone_source_mac.is_set or
                            self.enable.is_set or
                            self.es_import_route_target.is_set or
                            self.force_single_homed.is_set or
                            self.load_balancing_single_active.is_set or
                            (self.manual_service_carving is not None and self.manual_service_carving.has_data()) or
                            (self.identifier is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.backbone_source_mac.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.es_import_route_target.yfilter != YFilter.not_set or
                            self.force_single_homed.yfilter != YFilter.not_set or
                            self.load_balancing_single_active.yfilter != YFilter.not_set or
                            (self.identifier is not None and self.identifier.has_operation()) or
                            (self.manual_service_carving is not None and self.manual_service_carving.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ethernet-segment" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.backbone_source_mac.is_set or self.backbone_source_mac.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.backbone_source_mac.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.es_import_route_target.is_set or self.es_import_route_target.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.es_import_route_target.get_name_leafdata())
                        if (self.force_single_homed.is_set or self.force_single_homed.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.force_single_homed.get_name_leafdata())
                        if (self.load_balancing_single_active.is_set or self.load_balancing_single_active.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.load_balancing_single_active.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "identifier"):
                            if (self.identifier is None):
                                self.identifier = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.Identifier()
                                self.identifier.parent = self
                                self._children_name_map["identifier"] = "identifier"
                            return self.identifier

                        if (child_yang_name == "manual-service-carving"):
                            if (self.manual_service_carving is None):
                                self.manual_service_carving = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment.ManualServiceCarving()
                                self.manual_service_carving.parent = self
                                self._children_name_map["manual_service_carving"] = "manual-service-carving"
                            return self.manual_service_carving

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "identifier" or name == "manual-service-carving" or name == "backbone-source-mac" or name == "enable" or name == "es-import-route-target" or name == "force-single-homed" or name == "load-balancing-single-active"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "backbone-source-mac"):
                            self.backbone_source_mac = value
                            self.backbone_source_mac.value_namespace = name_space
                            self.backbone_source_mac.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "es-import-route-target"):
                            self.es_import_route_target = value
                            self.es_import_route_target.value_namespace = name_space
                            self.es_import_route_target.value_namespace_prefix = name_space_prefix
                        if(value_path == "force-single-homed"):
                            self.force_single_homed = value
                            self.force_single_homed.value_namespace = name_space
                            self.force_single_homed.value_namespace_prefix = name_space_prefix
                        if(value_path == "load-balancing-single-active"):
                            self.load_balancing_single_active = value
                            self.load_balancing_single_active.value_namespace = name_space
                            self.load_balancing_single_active.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.mac_flush.is_set or
                        (self.ethernet_segment is not None and self.ethernet_segment.has_data()) or
                        (self.evpnac_timers is not None and self.evpnac_timers.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.mac_flush.yfilter != YFilter.not_set or
                        (self.ethernet_segment is not None and self.ethernet_segment.has_operation()) or
                        (self.evpnac_timers is not None and self.evpnac_timers.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpn-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpn-interfaces/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.mac_flush.is_set or self.mac_flush.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_flush.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ethernet-segment"):
                        if (self.ethernet_segment is None):
                            self.ethernet_segment = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EthernetSegment()
                            self.ethernet_segment.parent = self
                            self._children_name_map["ethernet_segment"] = "ethernet-segment"
                        return self.ethernet_segment

                    if (child_yang_name == "evpnac-timers"):
                        if (self.evpnac_timers is None):
                            self.evpnac_timers = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface.EvpnacTimers()
                            self.evpnac_timers.parent = self
                            self._children_name_map["evpnac_timers"] = "evpnac-timers"
                        return self.evpnac_timers

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ethernet-segment" or name == "evpnac-timers" or name == "interface-name" or name == "mac-flush"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-flush"):
                        self.mac_flush = value
                        self.mac_flush.value_namespace = name_space
                        self.mac_flush.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.evpn_interface:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.evpn_interface:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-interfaces" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpn-interface"):
                    for c in self.evpn_interface:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.EvpnTables.EvpnInterfaces.EvpnInterface()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.evpn_interface.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpn-interface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EvpnVirtualAccessPws(Entity):
            """
            Virtual Access Pseudowire interfaces
            
            .. attribute:: evpn_virtual_access_pw
            
            	Virtual Access Pseudowire
            	**type**\: list of    :py:class:`EvpnVirtualAccessPw <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnVirtualAccessPws, self).__init__()

                self.yang_name = "evpn-virtual-access-pws"
                self.yang_parent_name = "evpn-tables"

                self.evpn_virtual_access_pw = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnVirtualAccessPws, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnVirtualAccessPws, self).__setattr__(name, value)


            class EvpnVirtualAccessPw(Entity):
                """
                Virtual Access Pseudowire
                
                .. attribute:: neighbor  <key>
                
                	Neighbor IP address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: pseudowire_id  <key>
                
                	Pseudowire ID
                	**type**\:  int
                
                	**range:** 1..4294967295
                
                .. attribute:: evpn_virtual_access_pw_timers
                
                	Enter Virtual Access Pseudowire\-specific timers configuration submode
                	**type**\:   :py:class:`EvpnVirtualAccessPwTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualAccessPwTimers>`
                
                .. attribute:: evpn_virtual_ethernet_segment
                
                	Enter Ethernet Segment configuration submode
                	**type**\:   :py:class:`EvpnVirtualEthernetSegment <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw, self).__init__()

                    self.yang_name = "evpn-virtual-access-pw"
                    self.yang_parent_name = "evpn-virtual-access-pws"

                    self.neighbor = YLeaf(YType.str, "neighbor")

                    self.pseudowire_id = YLeaf(YType.uint32, "pseudowire-id")

                    self.evpn_virtual_access_pw_timers = Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualAccessPwTimers()
                    self.evpn_virtual_access_pw_timers.parent = self
                    self._children_name_map["evpn_virtual_access_pw_timers"] = "evpn-virtual-access-pw-timers"
                    self._children_yang_names.add("evpn-virtual-access-pw-timers")

                    self.evpn_virtual_ethernet_segment = Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment()
                    self.evpn_virtual_ethernet_segment.parent = self
                    self._children_name_map["evpn_virtual_ethernet_segment"] = "evpn-virtual-ethernet-segment"
                    self._children_yang_names.add("evpn-virtual-ethernet-segment")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("neighbor",
                                    "pseudowire_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw, self).__setattr__(name, value)


                class EvpnVirtualAccessPwTimers(Entity):
                    """
                    Enter Virtual Access Pseudowire\-specific
                    timers configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Virtual Access Pseudowire\-specific timers
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: evpn_virtual_access_pw_peering
                    
                    	Virtual Access Pseudowire\-specific Peering timer
                    	**type**\:  int
                    
                    	**range:** 0..300
                    
                    	**default value**\: 3
                    
                    .. attribute:: evpn_virtual_access_pw_recovery
                    
                    	Virtual Access Pseudowire\-specific Recovery timer
                    	**type**\:  int
                    
                    	**range:** 20..3600
                    
                    	**default value**\: 30
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualAccessPwTimers, self).__init__()

                        self.yang_name = "evpn-virtual-access-pw-timers"
                        self.yang_parent_name = "evpn-virtual-access-pw"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.evpn_virtual_access_pw_peering = YLeaf(YType.uint32, "evpn-virtual-access-pw-peering")

                        self.evpn_virtual_access_pw_recovery = YLeaf(YType.uint32, "evpn-virtual-access-pw-recovery")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "evpn_virtual_access_pw_peering",
                                        "evpn_virtual_access_pw_recovery") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualAccessPwTimers, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualAccessPwTimers, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.evpn_virtual_access_pw_peering.is_set or
                            self.evpn_virtual_access_pw_recovery.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.evpn_virtual_access_pw_peering.yfilter != YFilter.not_set or
                            self.evpn_virtual_access_pw_recovery.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-virtual-access-pw-timers" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.evpn_virtual_access_pw_peering.is_set or self.evpn_virtual_access_pw_peering.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evpn_virtual_access_pw_peering.get_name_leafdata())
                        if (self.evpn_virtual_access_pw_recovery.is_set or self.evpn_virtual_access_pw_recovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.evpn_virtual_access_pw_recovery.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "evpn-virtual-access-pw-peering" or name == "evpn-virtual-access-pw-recovery"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "evpn-virtual-access-pw-peering"):
                            self.evpn_virtual_access_pw_peering = value
                            self.evpn_virtual_access_pw_peering.value_namespace = name_space
                            self.evpn_virtual_access_pw_peering.value_namespace_prefix = name_space_prefix
                        if(value_path == "evpn-virtual-access-pw-recovery"):
                            self.evpn_virtual_access_pw_recovery = value
                            self.evpn_virtual_access_pw_recovery.value_namespace = name_space
                            self.evpn_virtual_access_pw_recovery.value_namespace_prefix = name_space_prefix


                class EvpnVirtualEthernetSegment(Entity):
                    """
                    Enter Ethernet Segment configuration submode
                    
                    .. attribute:: enable
                    
                    	Enable Ethernet Segment
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: es_import_route_target
                    
                    	ES\-Import Route Target
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: identifier
                    
                    	Ethernet segment identifier
                    	**type**\:   :py:class:`Identifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment.Identifier>`
                    
                    	**presence node**\: True
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment, self).__init__()

                        self.yang_name = "evpn-virtual-ethernet-segment"
                        self.yang_parent_name = "evpn-virtual-access-pw"

                        self.enable = YLeaf(YType.empty, "enable")

                        self.es_import_route_target = YLeaf(YType.str, "es-import-route-target")

                        self.identifier = None
                        self._children_name_map["identifier"] = "identifier"
                        self._children_yang_names.add("identifier")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "es_import_route_target") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment, self).__setattr__(name, value)


                    class Identifier(Entity):
                        """
                        Ethernet segment identifier
                        
                        .. attribute:: bytes01
                        
                        	Type 0's 1st Byte or Type Byte and 1st Byte
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: bytes23
                        
                        	2nd and 3rd Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes45
                        
                        	4th and 5th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes67
                        
                        	6th and 7th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: bytes89
                        
                        	8th and 9th Bytes
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        	**units**\: byte
                        
                        .. attribute:: type
                        
                        	Ethernet segment identifier type
                        	**type**\:   :py:class:`EthernetSegmentIdentifier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.EthernetSegmentIdentifier>`
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'l2vpn-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment.Identifier, self).__init__()

                            self.yang_name = "identifier"
                            self.yang_parent_name = "evpn-virtual-ethernet-segment"
                            self.is_presence_container = True

                            self.bytes01 = YLeaf(YType.str, "bytes01")

                            self.bytes23 = YLeaf(YType.str, "bytes23")

                            self.bytes45 = YLeaf(YType.str, "bytes45")

                            self.bytes67 = YLeaf(YType.str, "bytes67")

                            self.bytes89 = YLeaf(YType.str, "bytes89")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bytes01",
                                            "bytes23",
                                            "bytes45",
                                            "bytes67",
                                            "bytes89",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment.Identifier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment.Identifier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bytes01.is_set or
                                self.bytes23.is_set or
                                self.bytes45.is_set or
                                self.bytes67.is_set or
                                self.bytes89.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bytes01.yfilter != YFilter.not_set or
                                self.bytes23.yfilter != YFilter.not_set or
                                self.bytes45.yfilter != YFilter.not_set or
                                self.bytes67.yfilter != YFilter.not_set or
                                self.bytes89.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "identifier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bytes01.is_set or self.bytes01.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes01.get_name_leafdata())
                            if (self.bytes23.is_set or self.bytes23.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes23.get_name_leafdata())
                            if (self.bytes45.is_set or self.bytes45.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes45.get_name_leafdata())
                            if (self.bytes67.is_set or self.bytes67.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes67.get_name_leafdata())
                            if (self.bytes89.is_set or self.bytes89.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes89.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bytes01" or name == "bytes23" or name == "bytes45" or name == "bytes67" or name == "bytes89" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bytes01"):
                                self.bytes01 = value
                                self.bytes01.value_namespace = name_space
                                self.bytes01.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes23"):
                                self.bytes23 = value
                                self.bytes23.value_namespace = name_space
                                self.bytes23.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes45"):
                                self.bytes45 = value
                                self.bytes45.value_namespace = name_space
                                self.bytes45.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes67"):
                                self.bytes67 = value
                                self.bytes67.value_namespace = name_space
                                self.bytes67.value_namespace_prefix = name_space_prefix
                            if(value_path == "bytes89"):
                                self.bytes89 = value
                                self.bytes89.value_namespace = name_space
                                self.bytes89.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.es_import_route_target.is_set or
                            (self.identifier is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.es_import_route_target.yfilter != YFilter.not_set or
                            (self.identifier is not None and self.identifier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-virtual-ethernet-segment" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.es_import_route_target.is_set or self.es_import_route_target.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.es_import_route_target.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "identifier"):
                            if (self.identifier is None):
                                self.identifier = Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment.Identifier()
                                self.identifier.parent = self
                                self._children_name_map["identifier"] = "identifier"
                            return self.identifier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "identifier" or name == "enable" or name == "es-import-route-target"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "es-import-route-target"):
                            self.es_import_route_target = value
                            self.es_import_route_target.value_namespace = name_space
                            self.es_import_route_target.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.neighbor.is_set or
                        self.pseudowire_id.is_set or
                        (self.evpn_virtual_access_pw_timers is not None and self.evpn_virtual_access_pw_timers.has_data()) or
                        (self.evpn_virtual_ethernet_segment is not None and self.evpn_virtual_ethernet_segment.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.neighbor.yfilter != YFilter.not_set or
                        self.pseudowire_id.yfilter != YFilter.not_set or
                        (self.evpn_virtual_access_pw_timers is not None and self.evpn_virtual_access_pw_timers.has_operation()) or
                        (self.evpn_virtual_ethernet_segment is not None and self.evpn_virtual_ethernet_segment.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpn-virtual-access-pw" + "[neighbor='" + self.neighbor.get() + "']" + "[pseudowire-id='" + self.pseudowire_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpn-virtual-access-pws/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor.get_name_leafdata())
                    if (self.pseudowire_id.is_set or self.pseudowire_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pseudowire_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "evpn-virtual-access-pw-timers"):
                        if (self.evpn_virtual_access_pw_timers is None):
                            self.evpn_virtual_access_pw_timers = Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualAccessPwTimers()
                            self.evpn_virtual_access_pw_timers.parent = self
                            self._children_name_map["evpn_virtual_access_pw_timers"] = "evpn-virtual-access-pw-timers"
                        return self.evpn_virtual_access_pw_timers

                    if (child_yang_name == "evpn-virtual-ethernet-segment"):
                        if (self.evpn_virtual_ethernet_segment is None):
                            self.evpn_virtual_ethernet_segment = Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw.EvpnVirtualEthernetSegment()
                            self.evpn_virtual_ethernet_segment.parent = self
                            self._children_name_map["evpn_virtual_ethernet_segment"] = "evpn-virtual-ethernet-segment"
                        return self.evpn_virtual_ethernet_segment

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evpn-virtual-access-pw-timers" or name == "evpn-virtual-ethernet-segment" or name == "neighbor" or name == "pseudowire-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "neighbor"):
                        self.neighbor = value
                        self.neighbor.value_namespace = name_space
                        self.neighbor.value_namespace_prefix = name_space_prefix
                    if(value_path == "pseudowire-id"):
                        self.pseudowire_id = value
                        self.pseudowire_id.value_namespace = name_space
                        self.pseudowire_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.evpn_virtual_access_pw:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.evpn_virtual_access_pw:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-virtual-access-pws" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpn-virtual-access-pw"):
                    for c in self.evpn_virtual_access_pw:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Evpn.EvpnTables.EvpnVirtualAccessPws.EvpnVirtualAccessPw()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.evpn_virtual_access_pw.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpn-virtual-access-pw"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class EvpnEthernetSegment(Entity):
            """
            EVPN Global Ethernet Segment submode
            
            .. attribute:: enable
            
            	Enable EVPN Global Ethernet Segment submode
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: evpn_esi_types
            
            	EVPN ESI type table
            	**type**\:   :py:class:`EvpnEsiTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes>`
            
            

            """

            _prefix = 'l2vpn-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Evpn.EvpnTables.EvpnEthernetSegment, self).__init__()

                self.yang_name = "evpn-ethernet-segment"
                self.yang_parent_name = "evpn-tables"

                self.enable = YLeaf(YType.empty, "enable")

                self.evpn_esi_types = Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes()
                self.evpn_esi_types.parent = self
                self._children_name_map["evpn_esi_types"] = "evpn-esi-types"
                self._children_yang_names.add("evpn-esi-types")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Evpn.EvpnTables.EvpnEthernetSegment, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Evpn.EvpnTables.EvpnEthernetSegment, self).__setattr__(name, value)


            class EvpnEsiTypes(Entity):
                """
                EVPN ESI type table
                
                .. attribute:: evpn_esi_type
                
                	ESI type
                	**type**\: list of    :py:class:`EvpnEsiType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_l2vpn_cfg.Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes.EvpnEsiType>`
                
                

                """

                _prefix = 'l2vpn-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes, self).__init__()

                    self.yang_name = "evpn-esi-types"
                    self.yang_parent_name = "evpn-ethernet-segment"

                    self.evpn_esi_type = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes, self).__setattr__(name, value)


                class EvpnEsiType(Entity):
                    """
                    ESI type
                    
                    .. attribute:: esi_type  <key>
                    
                    	ESI type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: disable_auto_generation
                    
                    	Disable ESI Autogeneration
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'l2vpn-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes.EvpnEsiType, self).__init__()

                        self.yang_name = "evpn-esi-type"
                        self.yang_parent_name = "evpn-esi-types"

                        self.esi_type = YLeaf(YType.uint32, "esi-type")

                        self.disable_auto_generation = YLeaf(YType.empty, "disable-auto-generation")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("esi_type",
                                        "disable_auto_generation") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes.EvpnEsiType, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes.EvpnEsiType, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.esi_type.is_set or
                            self.disable_auto_generation.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.esi_type.yfilter != YFilter.not_set or
                            self.disable_auto_generation.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "evpn-esi-type" + "[esi-type='" + self.esi_type.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpn-ethernet-segment/evpn-esi-types/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.esi_type.is_set or self.esi_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.esi_type.get_name_leafdata())
                        if (self.disable_auto_generation.is_set or self.disable_auto_generation.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable_auto_generation.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "esi-type" or name == "disable-auto-generation"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "esi-type"):
                            self.esi_type = value
                            self.esi_type.value_namespace = name_space
                            self.esi_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "disable-auto-generation"):
                            self.disable_auto_generation = value
                            self.disable_auto_generation.value_namespace = name_space
                            self.disable_auto_generation.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.evpn_esi_type:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.evpn_esi_type:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "evpn-esi-types" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/evpn-ethernet-segment/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "evpn-esi-type"):
                        for c in self.evpn_esi_type:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes.EvpnEsiType()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.evpn_esi_type.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "evpn-esi-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.enable.is_set or
                    (self.evpn_esi_types is not None and self.evpn_esi_types.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    (self.evpn_esi_types is not None and self.evpn_esi_types.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "evpn-ethernet-segment" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/evpn-tables/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "evpn-esi-types"):
                    if (self.evpn_esi_types is None):
                        self.evpn_esi_types = Evpn.EvpnTables.EvpnEthernetSegment.EvpnEsiTypes()
                        self.evpn_esi_types.parent = self
                        self._children_name_map["evpn_esi_types"] = "evpn-esi-types"
                    return self.evpn_esi_types

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "evpn-esi-types" or name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                self.evpn_source_interface.is_set or
                (self.evpn_ethernet_segment is not None and self.evpn_ethernet_segment.has_data()) or
                (self.evpn_instances is not None and self.evpn_instances.has_data()) or
                (self.evpn_interfaces is not None and self.evpn_interfaces.has_data()) or
                (self.evpn_load_balancing is not None and self.evpn_load_balancing.has_data()) or
                (self.evpn_logging is not None and self.evpn_logging.has_data()) or
                (self.evpn_timers is not None and self.evpn_timers.has_data()) or
                (self.evpn_virtual_access_pws is not None and self.evpn_virtual_access_pws.has_data()) or
                (self.evpn_virtual_access_vfis is not None and self.evpn_virtual_access_vfis.has_data()) or
                (self.evpnbgp_auto_discovery is not None and self.evpnbgp_auto_discovery.has_data()) or
                (self.evpnevis is not None and self.evpnevis.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.evpn_source_interface.yfilter != YFilter.not_set or
                (self.evpn_ethernet_segment is not None and self.evpn_ethernet_segment.has_operation()) or
                (self.evpn_instances is not None and self.evpn_instances.has_operation()) or
                (self.evpn_interfaces is not None and self.evpn_interfaces.has_operation()) or
                (self.evpn_load_balancing is not None and self.evpn_load_balancing.has_operation()) or
                (self.evpn_logging is not None and self.evpn_logging.has_operation()) or
                (self.evpn_timers is not None and self.evpn_timers.has_operation()) or
                (self.evpn_virtual_access_pws is not None and self.evpn_virtual_access_pws.has_operation()) or
                (self.evpn_virtual_access_vfis is not None and self.evpn_virtual_access_vfis.has_operation()) or
                (self.evpnbgp_auto_discovery is not None and self.evpnbgp_auto_discovery.has_operation()) or
                (self.evpnevis is not None and self.evpnevis.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "evpn-tables" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.evpn_source_interface.is_set or self.evpn_source_interface.yfilter != YFilter.not_set):
                leaf_name_data.append(self.evpn_source_interface.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "evpn-ethernet-segment"):
                if (self.evpn_ethernet_segment is None):
                    self.evpn_ethernet_segment = Evpn.EvpnTables.EvpnEthernetSegment()
                    self.evpn_ethernet_segment.parent = self
                    self._children_name_map["evpn_ethernet_segment"] = "evpn-ethernet-segment"
                return self.evpn_ethernet_segment

            if (child_yang_name == "evpn-instances"):
                if (self.evpn_instances is None):
                    self.evpn_instances = Evpn.EvpnTables.EvpnInstances()
                    self.evpn_instances.parent = self
                    self._children_name_map["evpn_instances"] = "evpn-instances"
                return self.evpn_instances

            if (child_yang_name == "evpn-interfaces"):
                if (self.evpn_interfaces is None):
                    self.evpn_interfaces = Evpn.EvpnTables.EvpnInterfaces()
                    self.evpn_interfaces.parent = self
                    self._children_name_map["evpn_interfaces"] = "evpn-interfaces"
                return self.evpn_interfaces

            if (child_yang_name == "evpn-load-balancing"):
                if (self.evpn_load_balancing is None):
                    self.evpn_load_balancing = Evpn.EvpnTables.EvpnLoadBalancing()
                    self.evpn_load_balancing.parent = self
                    self._children_name_map["evpn_load_balancing"] = "evpn-load-balancing"
                return self.evpn_load_balancing

            if (child_yang_name == "evpn-logging"):
                if (self.evpn_logging is None):
                    self.evpn_logging = Evpn.EvpnTables.EvpnLogging()
                    self.evpn_logging.parent = self
                    self._children_name_map["evpn_logging"] = "evpn-logging"
                return self.evpn_logging

            if (child_yang_name == "evpn-timers"):
                if (self.evpn_timers is None):
                    self.evpn_timers = Evpn.EvpnTables.EvpnTimers()
                    self.evpn_timers.parent = self
                    self._children_name_map["evpn_timers"] = "evpn-timers"
                return self.evpn_timers

            if (child_yang_name == "evpn-virtual-access-pws"):
                if (self.evpn_virtual_access_pws is None):
                    self.evpn_virtual_access_pws = Evpn.EvpnTables.EvpnVirtualAccessPws()
                    self.evpn_virtual_access_pws.parent = self
                    self._children_name_map["evpn_virtual_access_pws"] = "evpn-virtual-access-pws"
                return self.evpn_virtual_access_pws

            if (child_yang_name == "evpn-virtual-access-vfis"):
                if (self.evpn_virtual_access_vfis is None):
                    self.evpn_virtual_access_vfis = Evpn.EvpnTables.EvpnVirtualAccessVfis()
                    self.evpn_virtual_access_vfis.parent = self
                    self._children_name_map["evpn_virtual_access_vfis"] = "evpn-virtual-access-vfis"
                return self.evpn_virtual_access_vfis

            if (child_yang_name == "evpnbgp-auto-discovery"):
                if (self.evpnbgp_auto_discovery is None):
                    self.evpnbgp_auto_discovery = Evpn.EvpnTables.EvpnbgpAutoDiscovery()
                    self.evpnbgp_auto_discovery.parent = self
                    self._children_name_map["evpnbgp_auto_discovery"] = "evpnbgp-auto-discovery"
                return self.evpnbgp_auto_discovery

            if (child_yang_name == "evpnevis"):
                if (self.evpnevis is None):
                    self.evpnevis = Evpn.EvpnTables.Evpnevis()
                    self.evpnevis.parent = self
                    self._children_name_map["evpnevis"] = "evpnevis"
                return self.evpnevis

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "evpn-ethernet-segment" or name == "evpn-instances" or name == "evpn-interfaces" or name == "evpn-load-balancing" or name == "evpn-logging" or name == "evpn-timers" or name == "evpn-virtual-access-pws" or name == "evpn-virtual-access-vfis" or name == "evpnbgp-auto-discovery" or name == "evpnevis" or name == "evpn-source-interface"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "evpn-source-interface"):
                self.evpn_source_interface = value
                self.evpn_source_interface.value_namespace = name_space
                self.evpn_source_interface.value_namespace_prefix = name_space_prefix

    def has_data(self):
        return (
            self.enable.is_set or
            (self.evpn_tables is not None and self.evpn_tables.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            self.enable.yfilter != YFilter.not_set or
            (self.evpn_tables is not None and self.evpn_tables.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-l2vpn-cfg:evpn" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()
        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
            leaf_name_data.append(self.enable.get_name_leafdata())

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "evpn-tables"):
            if (self.evpn_tables is None):
                self.evpn_tables = Evpn.EvpnTables()
                self.evpn_tables.parent = self
                self._children_name_map["evpn_tables"] = "evpn-tables"
            return self.evpn_tables

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "evpn-tables" or name == "enable"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        if(value_path == "enable"):
            self.enable = value
            self.enable.value_namespace = name_space
            self.enable.value_namespace_prefix = name_space_prefix

    def clone_ptr(self):
        self._top_entity = Evpn()
        return self._top_entity

