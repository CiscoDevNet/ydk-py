""" openconfig_bgp 

This module describes a YANG model for BGP protocol
configuration.It is a limited subset of all of the configuration
parameters available in the variety of vendor implementations,
hence it is expected that it would be augmented with vendor\-
specific configuration data as needed. Additional modules or
submodules to handle other aspects of BGP configuration,
including policy, VRFs, VPNs, and additional address families
are also expected.
This model supports the following BGP configuration level
hierarchy\:
 BGP
   \|
   +\-> [ global BGP configuration ]
     +\-> AFI / SAFI global
   +\-> peer group
     +\-> [ peer group config ]
     +\-> AFI / SAFI [ per\-AFI overrides ]
   +\-> neighbor
     +\-> [ neighbor config ]
     +\-> [ optional pointer to peer\-group ]
     +\-> AFI / SAFI [ per\-AFI overrides ]

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error



class Bgp(Entity):
    """
    Top\-level configuration and state for the BGP router
    
    .. attribute:: global_
    
    	Global configuration for the BGP router
    	**type**\:   :py:class:`Global_ <ydk.models.openconfig.openconfig_bgp.Bgp.Global_>`
    
    .. attribute:: neighbors
    
    	Configuration for BGP neighbors
    	**type**\:   :py:class:`Neighbors <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors>`
    
    .. attribute:: peer_groups
    
    	Configuration for BGP peer\-groups
    	**type**\:   :py:class:`PeerGroups <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups>`
    
    

    """

    _prefix = 'oc-bgp'
    _revision = '2016-06-21'

    def __init__(self):
        super(Bgp, self).__init__()
        self._top_entity = None

        self.yang_name = "bgp"
        self.yang_parent_name = "openconfig-bgp"

        self.global_ = Bgp.Global_()
        self.global_.parent = self
        self._children_name_map["global_"] = "global"
        self._children_yang_names.add("global")

        self.neighbors = Bgp.Neighbors()
        self.neighbors.parent = self
        self._children_name_map["neighbors"] = "neighbors"
        self._children_yang_names.add("neighbors")

        self.peer_groups = Bgp.PeerGroups()
        self.peer_groups.parent = self
        self._children_name_map["peer_groups"] = "peer-groups"
        self._children_yang_names.add("peer-groups")


    class Global_(Entity):
        """
        Global configuration for the BGP router
        
        .. attribute:: afi_safis
        
        	Address family specific configuration
        	**type**\:   :py:class:`AfiSafis <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis>`
        
        .. attribute:: apply_policy
        
        	Anchor point for routing policies in the model. Import and export policies are with respect to the local routing table, i.e., export (send) and import (receive), depending on the context
        	**type**\:   :py:class:`ApplyPolicy <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.ApplyPolicy>`
        
        .. attribute:: confederation
        
        	Parameters indicating whether the local system acts as part of a BGP confederation
        	**type**\:   :py:class:`Confederation <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.Confederation>`
        
        .. attribute:: config
        
        	Configuration parameters relating to the global BGP router
        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.Config>`
        
        .. attribute:: default_route_distance
        
        	Administrative distance (or preference) assigned to routes received from different sources (external, internal, and local)
        	**type**\:   :py:class:`DefaultRouteDistance <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.DefaultRouteDistance>`
        
        .. attribute:: graceful_restart
        
        	Parameters relating the graceful restart mechanism for BGP
        	**type**\:   :py:class:`GracefulRestart <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.GracefulRestart>`
        
        .. attribute:: route_selection_options
        
        	Parameters relating to options for route selection
        	**type**\:   :py:class:`RouteSelectionOptions <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.RouteSelectionOptions>`
        
        .. attribute:: state
        
        	State information relating to the global BGP router
        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.State>`
        
        .. attribute:: use_multiple_paths
        
        	Parameters related to the use of multiple paths for the same NLRI
        	**type**\:   :py:class:`UseMultiplePaths <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths>`
        
        

        """

        _prefix = 'oc-bgp'
        _revision = '2016-06-21'

        def __init__(self):
            super(Bgp.Global_, self).__init__()

            self.yang_name = "global"
            self.yang_parent_name = "bgp"

            self.afi_safis = Bgp.Global_.AfiSafis()
            self.afi_safis.parent = self
            self._children_name_map["afi_safis"] = "afi-safis"
            self._children_yang_names.add("afi-safis")

            self.apply_policy = Bgp.Global_.ApplyPolicy()
            self.apply_policy.parent = self
            self._children_name_map["apply_policy"] = "apply-policy"
            self._children_yang_names.add("apply-policy")

            self.confederation = Bgp.Global_.Confederation()
            self.confederation.parent = self
            self._children_name_map["confederation"] = "confederation"
            self._children_yang_names.add("confederation")

            self.config = Bgp.Global_.Config()
            self.config.parent = self
            self._children_name_map["config"] = "config"
            self._children_yang_names.add("config")

            self.default_route_distance = Bgp.Global_.DefaultRouteDistance()
            self.default_route_distance.parent = self
            self._children_name_map["default_route_distance"] = "default-route-distance"
            self._children_yang_names.add("default-route-distance")

            self.graceful_restart = Bgp.Global_.GracefulRestart()
            self.graceful_restart.parent = self
            self._children_name_map["graceful_restart"] = "graceful-restart"
            self._children_yang_names.add("graceful-restart")

            self.route_selection_options = Bgp.Global_.RouteSelectionOptions()
            self.route_selection_options.parent = self
            self._children_name_map["route_selection_options"] = "route-selection-options"
            self._children_yang_names.add("route-selection-options")

            self.state = Bgp.Global_.State()
            self.state.parent = self
            self._children_name_map["state"] = "state"
            self._children_yang_names.add("state")

            self.use_multiple_paths = Bgp.Global_.UseMultiplePaths()
            self.use_multiple_paths.parent = self
            self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
            self._children_yang_names.add("use-multiple-paths")


        class Confederation(Entity):
            """
            Parameters indicating whether the local system acts as part
            of a BGP confederation
            
            .. attribute:: config
            
            	Configuration parameters relating to BGP confederations
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.Confederation.Config>`
            
            .. attribute:: state
            
            	State information relating to the BGP confederations
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.Confederation.State>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.Confederation, self).__init__()

                self.yang_name = "confederation"
                self.yang_parent_name = "global"

                self.config = Bgp.Global_.Confederation.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Bgp.Global_.Confederation.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration parameters relating to BGP confederations
                
                .. attribute:: enabled
                
                	When this leaf is set to true it indicates that the local\-AS is part of a BGP confederation
                	**type**\:  bool
                
                .. attribute:: identifier
                
                	Confederation identifier for the autonomous system
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: member_as
                
                	Remote autonomous systems that are to be treated as part of the local confederation
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.Confederation.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "confederation"

                    self.enabled = YLeaf(YType.boolean, "enabled")

                    self.identifier = YLeaf(YType.uint32, "identifier")

                    self.member_as = YLeafList(YType.uint32, "member-as")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enabled",
                                    "identifier",
                                    "member_as") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.Confederation.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.Confederation.Config, self).__setattr__(name, value)

                def has_data(self):
                    for leaf in self.member_as.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.enabled.is_set or
                        self.identifier.is_set)

                def has_operation(self):
                    for leaf in self.member_as.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set or
                        self.identifier.yfilter != YFilter.not_set or
                        self.member_as.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/confederation/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())
                    if (self.identifier.is_set or self.identifier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.identifier.get_name_leafdata())

                    leaf_name_data.extend(self.member_as.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enabled" or name == "identifier" or name == "member-as"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "identifier"):
                        self.identifier = value
                        self.identifier.value_namespace = name_space
                        self.identifier.value_namespace_prefix = name_space_prefix
                    if(value_path == "member-as"):
                        self.member_as.append(value)


            class State(Entity):
                """
                State information relating to the BGP confederations
                
                .. attribute:: enabled
                
                	When this leaf is set to true it indicates that the local\-AS is part of a BGP confederation
                	**type**\:  bool
                
                .. attribute:: identifier
                
                	Confederation identifier for the autonomous system
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: member_as
                
                	Remote autonomous systems that are to be treated as part of the local confederation
                	**type**\:  list of int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.Confederation.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "confederation"

                    self.enabled = YLeaf(YType.boolean, "enabled")

                    self.identifier = YLeaf(YType.uint32, "identifier")

                    self.member_as = YLeafList(YType.uint32, "member-as")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enabled",
                                    "identifier",
                                    "member_as") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.Confederation.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.Confederation.State, self).__setattr__(name, value)

                def has_data(self):
                    for leaf in self.member_as.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.enabled.is_set or
                        self.identifier.is_set)

                def has_operation(self):
                    for leaf in self.member_as.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set or
                        self.identifier.yfilter != YFilter.not_set or
                        self.member_as.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/confederation/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())
                    if (self.identifier.is_set or self.identifier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.identifier.get_name_leafdata())

                    leaf_name_data.extend(self.member_as.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enabled" or name == "identifier" or name == "member-as"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "identifier"):
                        self.identifier = value
                        self.identifier.value_namespace = name_space
                        self.identifier.value_namespace_prefix = name_space_prefix
                    if(value_path == "member-as"):
                        self.member_as.append(value)

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "confederation" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.Global_.Confederation.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.Global_.Confederation.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class DefaultRouteDistance(Entity):
            """
            Administrative distance (or preference) assigned to
            routes received from different sources
            (external, internal, and local).
            
            .. attribute:: config
            
            	Configuration parameters relating to the default route distance
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.DefaultRouteDistance.Config>`
            
            .. attribute:: state
            
            	State information relating to the default route distance
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.DefaultRouteDistance.State>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.DefaultRouteDistance, self).__init__()

                self.yang_name = "default-route-distance"
                self.yang_parent_name = "global"

                self.config = Bgp.Global_.DefaultRouteDistance.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Bgp.Global_.DefaultRouteDistance.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration parameters relating to the default route
                distance
                
                .. attribute:: external_route_distance
                
                	Administrative distance for routes learned from external BGP (eBGP)
                	**type**\:  int
                
                	**range:** 1..255
                
                .. attribute:: internal_route_distance
                
                	Administrative distance for routes learned from internal BGP (iBGP)
                	**type**\:  int
                
                	**range:** 1..255
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.DefaultRouteDistance.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "default-route-distance"

                    self.external_route_distance = YLeaf(YType.uint8, "external-route-distance")

                    self.internal_route_distance = YLeaf(YType.uint8, "internal-route-distance")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("external_route_distance",
                                    "internal_route_distance") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.DefaultRouteDistance.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.DefaultRouteDistance.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.external_route_distance.is_set or
                        self.internal_route_distance.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.external_route_distance.yfilter != YFilter.not_set or
                        self.internal_route_distance.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/default-route-distance/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.external_route_distance.is_set or self.external_route_distance.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.external_route_distance.get_name_leafdata())
                    if (self.internal_route_distance.is_set or self.internal_route_distance.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_route_distance.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "external-route-distance" or name == "internal-route-distance"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "external-route-distance"):
                        self.external_route_distance = value
                        self.external_route_distance.value_namespace = name_space
                        self.external_route_distance.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-route-distance"):
                        self.internal_route_distance = value
                        self.internal_route_distance.value_namespace = name_space
                        self.internal_route_distance.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                State information relating to the default route distance
                
                .. attribute:: external_route_distance
                
                	Administrative distance for routes learned from external BGP (eBGP)
                	**type**\:  int
                
                	**range:** 1..255
                
                .. attribute:: internal_route_distance
                
                	Administrative distance for routes learned from internal BGP (iBGP)
                	**type**\:  int
                
                	**range:** 1..255
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.DefaultRouteDistance.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "default-route-distance"

                    self.external_route_distance = YLeaf(YType.uint8, "external-route-distance")

                    self.internal_route_distance = YLeaf(YType.uint8, "internal-route-distance")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("external_route_distance",
                                    "internal_route_distance") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.DefaultRouteDistance.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.DefaultRouteDistance.State, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.external_route_distance.is_set or
                        self.internal_route_distance.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.external_route_distance.yfilter != YFilter.not_set or
                        self.internal_route_distance.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/default-route-distance/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.external_route_distance.is_set or self.external_route_distance.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.external_route_distance.get_name_leafdata())
                    if (self.internal_route_distance.is_set or self.internal_route_distance.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_route_distance.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "external-route-distance" or name == "internal-route-distance"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "external-route-distance"):
                        self.external_route_distance = value
                        self.external_route_distance.value_namespace = name_space
                        self.external_route_distance.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-route-distance"):
                        self.internal_route_distance = value
                        self.internal_route_distance.value_namespace = name_space
                        self.internal_route_distance.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "default-route-distance" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.Global_.DefaultRouteDistance.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.Global_.DefaultRouteDistance.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class GracefulRestart(Entity):
            """
            Parameters relating the graceful restart mechanism for BGP
            
            .. attribute:: config
            
            	Configuration parameters relating to graceful\-restart
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.GracefulRestart.Config>`
            
            .. attribute:: state
            
            	State information associated with graceful\-restart
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.GracefulRestart.State>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.GracefulRestart, self).__init__()

                self.yang_name = "graceful-restart"
                self.yang_parent_name = "global"

                self.config = Bgp.Global_.GracefulRestart.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Bgp.Global_.GracefulRestart.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration parameters relating to graceful\-restart
                
                .. attribute:: enabled
                
                	Enable or disable the graceful\-restart capability
                	**type**\:  bool
                
                .. attribute:: helper_only
                
                	Enable graceful\-restart in helper mode only. When this leaf is set, the local system does not retain forwarding its own state during a restart, but supports procedures for the receiving speaker, as defined in RFC4724
                	**type**\:  bool
                
                .. attribute:: restart_time
                
                	Estimated time (in seconds) for the local BGP speaker to restart a session. This value is advertise in the graceful restart BGP capability.  This is a 12\-bit value, referred to as Restart Time in RFC4724.  Per RFC4724, the suggested default value is <= the hold\-time value
                	**type**\:  int
                
                	**range:** 0..4096
                
                .. attribute:: stale_routes_time
                
                	An upper\-bound on the time thate stale routes will be retained by a router after a session is restarted. If an End\-of\-RIB (EOR) marker is received prior to this timer expiring stale\-routes will be flushed upon its receipt \- if no EOR is received, then when this timer expires stale paths will be purged. This timer is referred to as the Selection\_Deferral\_Timer in RFC4724
                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                
                	**range:** \-92233720368547758.08..92233720368547758.07
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.GracefulRestart.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "graceful-restart"

                    self.enabled = YLeaf(YType.boolean, "enabled")

                    self.helper_only = YLeaf(YType.boolean, "helper-only")

                    self.restart_time = YLeaf(YType.uint16, "restart-time")

                    self.stale_routes_time = YLeaf(YType.str, "stale-routes-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enabled",
                                    "helper_only",
                                    "restart_time",
                                    "stale_routes_time") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.GracefulRestart.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.GracefulRestart.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.enabled.is_set or
                        self.helper_only.is_set or
                        self.restart_time.is_set or
                        self.stale_routes_time.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set or
                        self.helper_only.yfilter != YFilter.not_set or
                        self.restart_time.yfilter != YFilter.not_set or
                        self.stale_routes_time.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/graceful-restart/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())
                    if (self.helper_only.is_set or self.helper_only.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.helper_only.get_name_leafdata())
                    if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.restart_time.get_name_leafdata())
                    if (self.stale_routes_time.is_set or self.stale_routes_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stale_routes_time.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enabled" or name == "helper-only" or name == "restart-time" or name == "stale-routes-time"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "helper-only"):
                        self.helper_only = value
                        self.helper_only.value_namespace = name_space
                        self.helper_only.value_namespace_prefix = name_space_prefix
                    if(value_path == "restart-time"):
                        self.restart_time = value
                        self.restart_time.value_namespace = name_space
                        self.restart_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "stale-routes-time"):
                        self.stale_routes_time = value
                        self.stale_routes_time.value_namespace = name_space
                        self.stale_routes_time.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                State information associated with graceful\-restart
                
                .. attribute:: enabled
                
                	Enable or disable the graceful\-restart capability
                	**type**\:  bool
                
                .. attribute:: helper_only
                
                	Enable graceful\-restart in helper mode only. When this leaf is set, the local system does not retain forwarding its own state during a restart, but supports procedures for the receiving speaker, as defined in RFC4724
                	**type**\:  bool
                
                .. attribute:: restart_time
                
                	Estimated time (in seconds) for the local BGP speaker to restart a session. This value is advertise in the graceful restart BGP capability.  This is a 12\-bit value, referred to as Restart Time in RFC4724.  Per RFC4724, the suggested default value is <= the hold\-time value
                	**type**\:  int
                
                	**range:** 0..4096
                
                .. attribute:: stale_routes_time
                
                	An upper\-bound on the time thate stale routes will be retained by a router after a session is restarted. If an End\-of\-RIB (EOR) marker is received prior to this timer expiring stale\-routes will be flushed upon its receipt \- if no EOR is received, then when this timer expires stale paths will be purged. This timer is referred to as the Selection\_Deferral\_Timer in RFC4724
                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                
                	**range:** \-92233720368547758.08..92233720368547758.07
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.GracefulRestart.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "graceful-restart"

                    self.enabled = YLeaf(YType.boolean, "enabled")

                    self.helper_only = YLeaf(YType.boolean, "helper-only")

                    self.restart_time = YLeaf(YType.uint16, "restart-time")

                    self.stale_routes_time = YLeaf(YType.str, "stale-routes-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enabled",
                                    "helper_only",
                                    "restart_time",
                                    "stale_routes_time") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.GracefulRestart.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.GracefulRestart.State, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.enabled.is_set or
                        self.helper_only.is_set or
                        self.restart_time.is_set or
                        self.stale_routes_time.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set or
                        self.helper_only.yfilter != YFilter.not_set or
                        self.restart_time.yfilter != YFilter.not_set or
                        self.stale_routes_time.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/graceful-restart/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())
                    if (self.helper_only.is_set or self.helper_only.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.helper_only.get_name_leafdata())
                    if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.restart_time.get_name_leafdata())
                    if (self.stale_routes_time.is_set or self.stale_routes_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stale_routes_time.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enabled" or name == "helper-only" or name == "restart-time" or name == "stale-routes-time"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "helper-only"):
                        self.helper_only = value
                        self.helper_only.value_namespace = name_space
                        self.helper_only.value_namespace_prefix = name_space_prefix
                    if(value_path == "restart-time"):
                        self.restart_time = value
                        self.restart_time.value_namespace = name_space
                        self.restart_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "stale-routes-time"):
                        self.stale_routes_time = value
                        self.stale_routes_time.value_namespace = name_space
                        self.stale_routes_time.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "graceful-restart" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.Global_.GracefulRestart.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.Global_.GracefulRestart.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Config(Entity):
            """
            Configuration parameters relating to the global BGP router
            
            .. attribute:: as_
            
            	Local autonomous system number of the router.  Uses the 32\-bit as\-number type from the model in RFC 6991
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**mandatory**\: True
            
            .. attribute:: router_id
            
            	Router id of the router \- an unsigned 32\-bit integer expressed in dotted quad notation
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.Config, self).__init__()

                self.yang_name = "config"
                self.yang_parent_name = "global"

                self.as_ = YLeaf(YType.uint32, "as")

                self.router_id = YLeaf(YType.str, "router-id")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("as_",
                                "router_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bgp.Global_.Config, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bgp.Global_.Config, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.as_.is_set or
                    self.router_id.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.as_.yfilter != YFilter.not_set or
                    self.router_id.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "config" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.as_.get_name_leafdata())
                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.router_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "as" or name == "router-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "as"):
                    self.as_ = value
                    self.as_.value_namespace = name_space
                    self.as_.value_namespace_prefix = name_space_prefix
                if(value_path == "router-id"):
                    self.router_id = value
                    self.router_id.value_namespace = name_space
                    self.router_id.value_namespace_prefix = name_space_prefix


        class UseMultiplePaths(Entity):
            """
            Parameters related to the use of multiple paths for the
            same NLRI
            
            .. attribute:: config
            
            	Configuration parameters relating to multipath
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.Config>`
            
            .. attribute:: ebgp
            
            	Multipath parameters for eBGP
            	**type**\:   :py:class:`Ebgp <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.Ebgp>`
            
            .. attribute:: ibgp
            
            	Multipath parameters for iBGP
            	**type**\:   :py:class:`Ibgp <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.Ibgp>`
            
            .. attribute:: state
            
            	State parameters relating to multipath
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.State>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.UseMultiplePaths, self).__init__()

                self.yang_name = "use-multiple-paths"
                self.yang_parent_name = "global"

                self.config = Bgp.Global_.UseMultiplePaths.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.ebgp = Bgp.Global_.UseMultiplePaths.Ebgp()
                self.ebgp.parent = self
                self._children_name_map["ebgp"] = "ebgp"
                self._children_yang_names.add("ebgp")

                self.ibgp = Bgp.Global_.UseMultiplePaths.Ibgp()
                self.ibgp.parent = self
                self._children_name_map["ibgp"] = "ibgp"
                self._children_yang_names.add("ibgp")

                self.state = Bgp.Global_.UseMultiplePaths.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Ebgp(Entity):
                """
                Multipath parameters for eBGP
                
                .. attribute:: config
                
                	Configuration parameters relating to eBGP multipath
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.Ebgp.Config>`
                
                .. attribute:: state
                
                	State information relating to eBGP multipath
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.Ebgp.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.UseMultiplePaths.Ebgp, self).__init__()

                    self.yang_name = "ebgp"
                    self.yang_parent_name = "use-multiple-paths"

                    self.config = Bgp.Global_.UseMultiplePaths.Ebgp.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Global_.UseMultiplePaths.Ebgp.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to eBGP multipath
                    
                    .. attribute:: allow_multiple_as
                    
                    	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: maximum_paths
                    
                    	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 1
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.UseMultiplePaths.Ebgp.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "ebgp"

                        self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                        self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_multiple_as",
                                        "maximum_paths") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Global_.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Global_.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_multiple_as.is_set or
                            self.maximum_paths.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_multiple_as.yfilter != YFilter.not_set or
                            self.maximum_paths.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/ebgp/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                        if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-multiple-as" or name == "maximum-paths"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-multiple-as"):
                            self.allow_multiple_as = value
                            self.allow_multiple_as.value_namespace = name_space
                            self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum-paths"):
                            self.maximum_paths = value
                            self.maximum_paths.value_namespace = name_space
                            self.maximum_paths.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to eBGP multipath
                    
                    .. attribute:: allow_multiple_as
                    
                    	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: maximum_paths
                    
                    	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 1
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.UseMultiplePaths.Ebgp.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "ebgp"

                        self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                        self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_multiple_as",
                                        "maximum_paths") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Global_.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Global_.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_multiple_as.is_set or
                            self.maximum_paths.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_multiple_as.yfilter != YFilter.not_set or
                            self.maximum_paths.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/ebgp/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                        if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-multiple-as" or name == "maximum-paths"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-multiple-as"):
                            self.allow_multiple_as = value
                            self.allow_multiple_as.value_namespace = name_space
                            self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum-paths"):
                            self.maximum_paths = value
                            self.maximum_paths.value_namespace = name_space
                            self.maximum_paths.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ebgp" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Global_.UseMultiplePaths.Ebgp.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Global_.UseMultiplePaths.Ebgp.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Ibgp(Entity):
                """
                Multipath parameters for iBGP
                
                .. attribute:: config
                
                	Configuration parameters relating to iBGP multipath
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.Ibgp.Config>`
                
                .. attribute:: state
                
                	State information relating to iBGP multipath
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.UseMultiplePaths.Ibgp.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.UseMultiplePaths.Ibgp, self).__init__()

                    self.yang_name = "ibgp"
                    self.yang_parent_name = "use-multiple-paths"

                    self.config = Bgp.Global_.UseMultiplePaths.Ibgp.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Global_.UseMultiplePaths.Ibgp.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to iBGP multipath
                    
                    .. attribute:: maximum_paths
                    
                    	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 1
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.UseMultiplePaths.Ibgp.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "ibgp"

                        self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_paths") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Global_.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Global_.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.maximum_paths.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_paths.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/ibgp/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-paths"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-paths"):
                            self.maximum_paths = value
                            self.maximum_paths.value_namespace = name_space
                            self.maximum_paths.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to iBGP multipath
                    
                    .. attribute:: maximum_paths
                    
                    	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**default value**\: 1
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.UseMultiplePaths.Ibgp.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "ibgp"

                        self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum_paths") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Global_.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Global_.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.maximum_paths.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum_paths.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/ibgp/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum-paths"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum-paths"):
                            self.maximum_paths = value
                            self.maximum_paths.value_namespace = name_space
                            self.maximum_paths.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ibgp" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Global_.UseMultiplePaths.Ibgp.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Global_.UseMultiplePaths.Ibgp.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class State(Entity):
                """
                State parameters relating to multipath
                
                .. attribute:: enabled
                
                	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                	**type**\:  bool
                
                	**default value**\: false
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.UseMultiplePaths.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "use-multiple-paths"

                    self.enabled = YLeaf(YType.boolean, "enabled")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enabled") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.UseMultiplePaths.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.UseMultiplePaths.State, self).__setattr__(name, value)

                def has_data(self):
                    return self.enabled.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enabled"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix


            class Config(Entity):
                """
                Configuration parameters relating to multipath
                
                .. attribute:: enabled
                
                	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                	**type**\:  bool
                
                	**default value**\: false
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.UseMultiplePaths.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "use-multiple-paths"

                    self.enabled = YLeaf(YType.boolean, "enabled")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enabled") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.UseMultiplePaths.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.UseMultiplePaths.Config, self).__setattr__(name, value)

                def has_data(self):
                    return self.enabled.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/use-multiple-paths/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "enabled"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.ebgp is not None and self.ebgp.has_data()) or
                    (self.ibgp is not None and self.ibgp.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.ebgp is not None and self.ebgp.has_operation()) or
                    (self.ibgp is not None and self.ibgp.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "use-multiple-paths" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.Global_.UseMultiplePaths.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "ebgp"):
                    if (self.ebgp is None):
                        self.ebgp = Bgp.Global_.UseMultiplePaths.Ebgp()
                        self.ebgp.parent = self
                        self._children_name_map["ebgp"] = "ebgp"
                    return self.ebgp

                if (child_yang_name == "ibgp"):
                    if (self.ibgp is None):
                        self.ibgp = Bgp.Global_.UseMultiplePaths.Ibgp()
                        self.ibgp.parent = self
                        self._children_name_map["ibgp"] = "ibgp"
                    return self.ibgp

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.Global_.UseMultiplePaths.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "ebgp" or name == "ibgp" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class State(Entity):
            """
            State information relating to the global BGP router
            
            .. attribute:: as_
            
            	Local autonomous system number of the router.  Uses the 32\-bit as\-number type from the model in RFC 6991
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**mandatory**\: True
            
            .. attribute:: router_id
            
            	Router id of the router \- an unsigned 32\-bit integer expressed in dotted quad notation
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
            
            .. attribute:: total_paths
            
            	Total number of BGP paths within the context
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_prefixes
            
            	Total number of BGP prefixes received within the context
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.State, self).__init__()

                self.yang_name = "state"
                self.yang_parent_name = "global"

                self.as_ = YLeaf(YType.uint32, "as")

                self.router_id = YLeaf(YType.str, "router-id")

                self.total_paths = YLeaf(YType.uint32, "total-paths")

                self.total_prefixes = YLeaf(YType.uint32, "total-prefixes")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("as_",
                                "router_id",
                                "total_paths",
                                "total_prefixes") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bgp.Global_.State, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bgp.Global_.State, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.as_.is_set or
                    self.router_id.is_set or
                    self.total_paths.is_set or
                    self.total_prefixes.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.as_.yfilter != YFilter.not_set or
                    self.router_id.yfilter != YFilter.not_set or
                    self.total_paths.yfilter != YFilter.not_set or
                    self.total_prefixes.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.as_.is_set or self.as_.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.as_.get_name_leafdata())
                if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.router_id.get_name_leafdata())
                if (self.total_paths.is_set or self.total_paths.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_paths.get_name_leafdata())
                if (self.total_prefixes.is_set or self.total_prefixes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_prefixes.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "as" or name == "router-id" or name == "total-paths" or name == "total-prefixes"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "as"):
                    self.as_ = value
                    self.as_.value_namespace = name_space
                    self.as_.value_namespace_prefix = name_space_prefix
                if(value_path == "router-id"):
                    self.router_id = value
                    self.router_id.value_namespace = name_space
                    self.router_id.value_namespace_prefix = name_space_prefix
                if(value_path == "total-paths"):
                    self.total_paths = value
                    self.total_paths.value_namespace = name_space
                    self.total_paths.value_namespace_prefix = name_space_prefix
                if(value_path == "total-prefixes"):
                    self.total_prefixes = value
                    self.total_prefixes.value_namespace = name_space
                    self.total_prefixes.value_namespace_prefix = name_space_prefix


        class RouteSelectionOptions(Entity):
            """
            Parameters relating to options for route selection
            
            .. attribute:: config
            
            	Configuration parameters relating to route selection options
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.RouteSelectionOptions.Config>`
            
            .. attribute:: state
            
            	State information for the route selection options
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.RouteSelectionOptions.State>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.RouteSelectionOptions, self).__init__()

                self.yang_name = "route-selection-options"
                self.yang_parent_name = "global"

                self.config = Bgp.Global_.RouteSelectionOptions.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Bgp.Global_.RouteSelectionOptions.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration parameters relating to route selection
                options
                
                .. attribute:: advertise_inactive_routes
                
                	Advertise inactive routes to external peers.  The default is to only advertise active routes
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: always_compare_med
                
                	Compare multi\-exit discriminator (MED) value from different ASes when selecting the best route.  The default behavior is to only compare MEDs for paths received from the same AS
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: enable_aigp
                
                	Flag to enable sending / receiving accumulated IGP attribute in routing updates
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: external_compare_router_id
                
                	When comparing similar routes received from external BGP peers, use the router\-id as a criterion to select the active path
                	**type**\:  bool
                
                	**default value**\: true
                
                .. attribute:: ignore_as_path_length
                
                	Ignore the AS path length when selecting the best path. The default is to use the AS path length and prefer paths with shorter length
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: ignore_next_hop_igp_metric
                
                	Ignore the IGP metric to the next\-hop when calculating BGP best\-path. The default is to select the route for which the metric to the next\-hop is lowest
                	**type**\:  bool
                
                	**default value**\: false
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.RouteSelectionOptions.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "route-selection-options"

                    self.advertise_inactive_routes = YLeaf(YType.boolean, "advertise-inactive-routes")

                    self.always_compare_med = YLeaf(YType.boolean, "always-compare-med")

                    self.enable_aigp = YLeaf(YType.boolean, "enable-aigp")

                    self.external_compare_router_id = YLeaf(YType.boolean, "external-compare-router-id")

                    self.ignore_as_path_length = YLeaf(YType.boolean, "ignore-as-path-length")

                    self.ignore_next_hop_igp_metric = YLeaf(YType.boolean, "ignore-next-hop-igp-metric")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("advertise_inactive_routes",
                                    "always_compare_med",
                                    "enable_aigp",
                                    "external_compare_router_id",
                                    "ignore_as_path_length",
                                    "ignore_next_hop_igp_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.RouteSelectionOptions.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.RouteSelectionOptions.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.advertise_inactive_routes.is_set or
                        self.always_compare_med.is_set or
                        self.enable_aigp.is_set or
                        self.external_compare_router_id.is_set or
                        self.ignore_as_path_length.is_set or
                        self.ignore_next_hop_igp_metric.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.advertise_inactive_routes.yfilter != YFilter.not_set or
                        self.always_compare_med.yfilter != YFilter.not_set or
                        self.enable_aigp.yfilter != YFilter.not_set or
                        self.external_compare_router_id.yfilter != YFilter.not_set or
                        self.ignore_as_path_length.yfilter != YFilter.not_set or
                        self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/route-selection-options/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.advertise_inactive_routes.is_set or self.advertise_inactive_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.advertise_inactive_routes.get_name_leafdata())
                    if (self.always_compare_med.is_set or self.always_compare_med.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.always_compare_med.get_name_leafdata())
                    if (self.enable_aigp.is_set or self.enable_aigp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable_aigp.get_name_leafdata())
                    if (self.external_compare_router_id.is_set or self.external_compare_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.external_compare_router_id.get_name_leafdata())
                    if (self.ignore_as_path_length.is_set or self.ignore_as_path_length.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ignore_as_path_length.get_name_leafdata())
                    if (self.ignore_next_hop_igp_metric.is_set or self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ignore_next_hop_igp_metric.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "advertise-inactive-routes" or name == "always-compare-med" or name == "enable-aigp" or name == "external-compare-router-id" or name == "ignore-as-path-length" or name == "ignore-next-hop-igp-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "advertise-inactive-routes"):
                        self.advertise_inactive_routes = value
                        self.advertise_inactive_routes.value_namespace = name_space
                        self.advertise_inactive_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "always-compare-med"):
                        self.always_compare_med = value
                        self.always_compare_med.value_namespace = name_space
                        self.always_compare_med.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable-aigp"):
                        self.enable_aigp = value
                        self.enable_aigp.value_namespace = name_space
                        self.enable_aigp.value_namespace_prefix = name_space_prefix
                    if(value_path == "external-compare-router-id"):
                        self.external_compare_router_id = value
                        self.external_compare_router_id.value_namespace = name_space
                        self.external_compare_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ignore-as-path-length"):
                        self.ignore_as_path_length = value
                        self.ignore_as_path_length.value_namespace = name_space
                        self.ignore_as_path_length.value_namespace_prefix = name_space_prefix
                    if(value_path == "ignore-next-hop-igp-metric"):
                        self.ignore_next_hop_igp_metric = value
                        self.ignore_next_hop_igp_metric.value_namespace = name_space
                        self.ignore_next_hop_igp_metric.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                State information for the route selection options
                
                .. attribute:: advertise_inactive_routes
                
                	Advertise inactive routes to external peers.  The default is to only advertise active routes
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: always_compare_med
                
                	Compare multi\-exit discriminator (MED) value from different ASes when selecting the best route.  The default behavior is to only compare MEDs for paths received from the same AS
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: enable_aigp
                
                	Flag to enable sending / receiving accumulated IGP attribute in routing updates
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: external_compare_router_id
                
                	When comparing similar routes received from external BGP peers, use the router\-id as a criterion to select the active path
                	**type**\:  bool
                
                	**default value**\: true
                
                .. attribute:: ignore_as_path_length
                
                	Ignore the AS path length when selecting the best path. The default is to use the AS path length and prefer paths with shorter length
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: ignore_next_hop_igp_metric
                
                	Ignore the IGP metric to the next\-hop when calculating BGP best\-path. The default is to select the route for which the metric to the next\-hop is lowest
                	**type**\:  bool
                
                	**default value**\: false
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.RouteSelectionOptions.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "route-selection-options"

                    self.advertise_inactive_routes = YLeaf(YType.boolean, "advertise-inactive-routes")

                    self.always_compare_med = YLeaf(YType.boolean, "always-compare-med")

                    self.enable_aigp = YLeaf(YType.boolean, "enable-aigp")

                    self.external_compare_router_id = YLeaf(YType.boolean, "external-compare-router-id")

                    self.ignore_as_path_length = YLeaf(YType.boolean, "ignore-as-path-length")

                    self.ignore_next_hop_igp_metric = YLeaf(YType.boolean, "ignore-next-hop-igp-metric")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("advertise_inactive_routes",
                                    "always_compare_med",
                                    "enable_aigp",
                                    "external_compare_router_id",
                                    "ignore_as_path_length",
                                    "ignore_next_hop_igp_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.RouteSelectionOptions.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.RouteSelectionOptions.State, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.advertise_inactive_routes.is_set or
                        self.always_compare_med.is_set or
                        self.enable_aigp.is_set or
                        self.external_compare_router_id.is_set or
                        self.ignore_as_path_length.is_set or
                        self.ignore_next_hop_igp_metric.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.advertise_inactive_routes.yfilter != YFilter.not_set or
                        self.always_compare_med.yfilter != YFilter.not_set or
                        self.enable_aigp.yfilter != YFilter.not_set or
                        self.external_compare_router_id.yfilter != YFilter.not_set or
                        self.ignore_as_path_length.yfilter != YFilter.not_set or
                        self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/route-selection-options/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.advertise_inactive_routes.is_set or self.advertise_inactive_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.advertise_inactive_routes.get_name_leafdata())
                    if (self.always_compare_med.is_set or self.always_compare_med.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.always_compare_med.get_name_leafdata())
                    if (self.enable_aigp.is_set or self.enable_aigp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable_aigp.get_name_leafdata())
                    if (self.external_compare_router_id.is_set or self.external_compare_router_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.external_compare_router_id.get_name_leafdata())
                    if (self.ignore_as_path_length.is_set or self.ignore_as_path_length.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ignore_as_path_length.get_name_leafdata())
                    if (self.ignore_next_hop_igp_metric.is_set or self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ignore_next_hop_igp_metric.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "advertise-inactive-routes" or name == "always-compare-med" or name == "enable-aigp" or name == "external-compare-router-id" or name == "ignore-as-path-length" or name == "ignore-next-hop-igp-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "advertise-inactive-routes"):
                        self.advertise_inactive_routes = value
                        self.advertise_inactive_routes.value_namespace = name_space
                        self.advertise_inactive_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "always-compare-med"):
                        self.always_compare_med = value
                        self.always_compare_med.value_namespace = name_space
                        self.always_compare_med.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable-aigp"):
                        self.enable_aigp = value
                        self.enable_aigp.value_namespace = name_space
                        self.enable_aigp.value_namespace_prefix = name_space_prefix
                    if(value_path == "external-compare-router-id"):
                        self.external_compare_router_id = value
                        self.external_compare_router_id.value_namespace = name_space
                        self.external_compare_router_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "ignore-as-path-length"):
                        self.ignore_as_path_length = value
                        self.ignore_as_path_length.value_namespace = name_space
                        self.ignore_as_path_length.value_namespace_prefix = name_space_prefix
                    if(value_path == "ignore-next-hop-igp-metric"):
                        self.ignore_next_hop_igp_metric = value
                        self.ignore_next_hop_igp_metric.value_namespace = name_space
                        self.ignore_next_hop_igp_metric.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "route-selection-options" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.Global_.RouteSelectionOptions.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.Global_.RouteSelectionOptions.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class AfiSafis(Entity):
            """
            Address family specific configuration
            
            .. attribute:: afi_safi
            
            	AFI,SAFI configuration available for the neighbour or group
            	**type**\: list of    :py:class:`AfiSafi <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.AfiSafis, self).__init__()

                self.yang_name = "afi-safis"
                self.yang_parent_name = "global"

                self.afi_safi = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bgp.Global_.AfiSafis, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bgp.Global_.AfiSafis, self).__setattr__(name, value)


            class AfiSafi(Entity):
                """
                AFI,SAFI configuration available for the
                neighbour or group
                
                .. attribute:: afi_safi_name  <key>
                
                	Reference to the AFI\-SAFI name used as a key for the AFI\-SAFI list
                	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                
                .. attribute:: apply_policy
                
                	Anchor point for routing policies in the model. Import and export policies are with respect to the local routing table, i.e., export (send) and import (receive), depending on the context
                	**type**\:   :py:class:`ApplyPolicy <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy>`
                
                .. attribute:: config
                
                	Configuration parameters for the AFI\-SAFI
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Config>`
                
                .. attribute:: graceful_restart
                
                	Parameters relating to BGP graceful\-restart
                	**type**\:   :py:class:`GracefulRestart <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart>`
                
                .. attribute:: ipv4_labeled_unicast
                
                	IPv4 Labeled Unicast configuration options
                	**type**\:   :py:class:`Ipv4LabeledUnicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast>`
                
                .. attribute:: ipv4_unicast
                
                	IPv4 unicast configuration options
                	**type**\:   :py:class:`Ipv4Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast>`
                
                .. attribute:: ipv6_labeled_unicast
                
                	IPv6 Labeled Unicast configuration options
                	**type**\:   :py:class:`Ipv6LabeledUnicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast>`
                
                .. attribute:: ipv6_unicast
                
                	IPv6 unicast configuration options
                	**type**\:   :py:class:`Ipv6Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast>`
                
                .. attribute:: l2vpn_evpn
                
                	BGP EVPN configuration options
                	**type**\:   :py:class:`L2VpnEvpn <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn>`
                
                .. attribute:: l2vpn_vpls
                
                	BGP\-signalled VPLS configuration options
                	**type**\:   :py:class:`L2VpnVpls <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls>`
                
                .. attribute:: l3vpn_ipv4_multicast
                
                	Multicast IPv4 L3VPN configuration options
                	**type**\:   :py:class:`L3VpnIpv4Multicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast>`
                
                .. attribute:: l3vpn_ipv4_unicast
                
                	Unicast IPv4 L3VPN configuration options
                	**type**\:   :py:class:`L3VpnIpv4Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast>`
                
                .. attribute:: l3vpn_ipv6_multicast
                
                	Multicast IPv6 L3VPN configuration options
                	**type**\:   :py:class:`L3VpnIpv6Multicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast>`
                
                .. attribute:: l3vpn_ipv6_unicast
                
                	Unicast IPv6 L3VPN configuration options
                	**type**\:   :py:class:`L3VpnIpv6Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast>`
                
                .. attribute:: route_selection_options
                
                	Parameters relating to options for route selection
                	**type**\:   :py:class:`RouteSelectionOptions <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions>`
                
                .. attribute:: state
                
                	State information relating to the AFI\-SAFI
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.State>`
                
                .. attribute:: use_multiple_paths
                
                	Parameters related to the use of multiple paths for the same NLRI
                	**type**\:   :py:class:`UseMultiplePaths <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.AfiSafis.AfiSafi, self).__init__()

                    self.yang_name = "afi-safi"
                    self.yang_parent_name = "afi-safis"

                    self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                    self.apply_policy = Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy()
                    self.apply_policy.parent = self
                    self._children_name_map["apply_policy"] = "apply-policy"
                    self._children_yang_names.add("apply-policy")

                    self.config = Bgp.Global_.AfiSafis.AfiSafi.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.graceful_restart = Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart()
                    self.graceful_restart.parent = self
                    self._children_name_map["graceful_restart"] = "graceful-restart"
                    self._children_yang_names.add("graceful-restart")

                    self.ipv4_labeled_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast()
                    self.ipv4_labeled_unicast.parent = self
                    self._children_name_map["ipv4_labeled_unicast"] = "ipv4-labeled-unicast"
                    self._children_yang_names.add("ipv4-labeled-unicast")

                    self.ipv4_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast()
                    self.ipv4_unicast.parent = self
                    self._children_name_map["ipv4_unicast"] = "ipv4-unicast"
                    self._children_yang_names.add("ipv4-unicast")

                    self.ipv6_labeled_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast()
                    self.ipv6_labeled_unicast.parent = self
                    self._children_name_map["ipv6_labeled_unicast"] = "ipv6-labeled-unicast"
                    self._children_yang_names.add("ipv6-labeled-unicast")

                    self.ipv6_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast()
                    self.ipv6_unicast.parent = self
                    self._children_name_map["ipv6_unicast"] = "ipv6-unicast"
                    self._children_yang_names.add("ipv6-unicast")

                    self.l2vpn_evpn = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn()
                    self.l2vpn_evpn.parent = self
                    self._children_name_map["l2vpn_evpn"] = "l2vpn-evpn"
                    self._children_yang_names.add("l2vpn-evpn")

                    self.l2vpn_vpls = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls()
                    self.l2vpn_vpls.parent = self
                    self._children_name_map["l2vpn_vpls"] = "l2vpn-vpls"
                    self._children_yang_names.add("l2vpn-vpls")

                    self.l3vpn_ipv4_multicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast()
                    self.l3vpn_ipv4_multicast.parent = self
                    self._children_name_map["l3vpn_ipv4_multicast"] = "l3vpn-ipv4-multicast"
                    self._children_yang_names.add("l3vpn-ipv4-multicast")

                    self.l3vpn_ipv4_unicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast()
                    self.l3vpn_ipv4_unicast.parent = self
                    self._children_name_map["l3vpn_ipv4_unicast"] = "l3vpn-ipv4-unicast"
                    self._children_yang_names.add("l3vpn-ipv4-unicast")

                    self.l3vpn_ipv6_multicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast()
                    self.l3vpn_ipv6_multicast.parent = self
                    self._children_name_map["l3vpn_ipv6_multicast"] = "l3vpn-ipv6-multicast"
                    self._children_yang_names.add("l3vpn-ipv6-multicast")

                    self.l3vpn_ipv6_unicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast()
                    self.l3vpn_ipv6_unicast.parent = self
                    self._children_name_map["l3vpn_ipv6_unicast"] = "l3vpn-ipv6-unicast"
                    self._children_yang_names.add("l3vpn-ipv6-unicast")

                    self.route_selection_options = Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions()
                    self.route_selection_options.parent = self
                    self._children_name_map["route_selection_options"] = "route-selection-options"
                    self._children_yang_names.add("route-selection-options")

                    self.state = Bgp.Global_.AfiSafis.AfiSafi.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                    self.use_multiple_paths = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths()
                    self.use_multiple_paths.parent = self
                    self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                    self._children_yang_names.add("use-multiple-paths")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("afi_safi_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.AfiSafis.AfiSafi, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.AfiSafis.AfiSafi, self).__setattr__(name, value)


                class State(Entity):
                    """
                    State information relating to the AFI\-SAFI
                    
                    .. attribute:: afi_safi_name
                    
                    	AFI,SAFI
                    	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                    
                    .. attribute:: enabled
                    
                    	This leaf indicates whether the IPv4 Unicast AFI,SAFI is enabled for the neighbour or group
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: total_paths
                    
                    	Total number of BGP paths within the context
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_prefixes
                    
                    	Total number of BGP prefixes received within the context
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "afi-safi"

                        self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.total_paths = YLeaf(YType.uint32, "total-paths")

                        self.total_prefixes = YLeaf(YType.uint32, "total-prefixes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi_safi_name",
                                        "enabled",
                                        "total_paths",
                                        "total_prefixes") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Global_.AfiSafis.AfiSafi.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Global_.AfiSafis.AfiSafi.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi_safi_name.is_set or
                            self.enabled.is_set or
                            self.total_paths.is_set or
                            self.total_prefixes.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi_safi_name.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.total_paths.yfilter != YFilter.not_set or
                            self.total_prefixes.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi_safi_name.get_name_leafdata())
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.total_paths.is_set or self.total_paths.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_paths.get_name_leafdata())
                        if (self.total_prefixes.is_set or self.total_prefixes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_prefixes.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi-safi-name" or name == "enabled" or name == "total-paths" or name == "total-prefixes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi-safi-name"):
                            self.afi_safi_name = value
                            self.afi_safi_name.value_namespace = name_space
                            self.afi_safi_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-paths"):
                            self.total_paths = value
                            self.total_paths.value_namespace = name_space
                            self.total_paths.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-prefixes"):
                            self.total_prefixes = value
                            self.total_prefixes.value_namespace = name_space
                            self.total_prefixes.value_namespace_prefix = name_space_prefix


                class L2VpnEvpn(Entity):
                    """
                    BGP EVPN configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn, self).__init__()

                        self.yang_name = "l2vpn-evpn"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "l2vpn-evpn"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "l2vpn-evpn" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ipv4Unicast(Entity):
                    """
                    IPv4 unicast configuration options
                    
                    .. attribute:: config
                    
                    	Configuration parameters for common IPv4 and IPv6 unicast AFI\-SAFI options
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.Config>`
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit>`
                    
                    .. attribute:: state
                    
                    	State information for common IPv4 and IPv6 unicast parameters
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast, self).__init__()

                        self.yang_name = "ipv4-unicast"
                        self.yang_parent_name = "afi-safi"

                        self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")

                        self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "ipv4-unicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Config(Entity):
                        """
                        Configuration parameters for common IPv4 and IPv6 unicast
                        AFI\-SAFI options
                        
                        .. attribute:: send_default_route
                        
                        	If set to true, send the default\-route to the neighbour(s)
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "ipv4-unicast"

                            self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("send_default_route") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.send_default_route.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.send_default_route.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_default_route.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "send-default-route"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "send-default-route"):
                                self.send_default_route = value
                                self.send_default_route.value_namespace = name_space
                                self.send_default_route.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information for common IPv4 and IPv6 unicast
                        parameters
                        
                        .. attribute:: send_default_route
                        
                        	If set to true, send the default\-route to the neighbour(s)
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "ipv4-unicast"

                            self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("send_default_route") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.send_default_route.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.send_default_route.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_default_route.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "send-default-route"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "send-default-route"):
                                self.send_default_route = value
                                self.send_default_route.value_namespace = name_space
                                self.send_default_route.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.prefix_limit is not None and self.prefix_limit.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipv4-unicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "prefix-limit" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class L3VpnIpv4Unicast(Entity):
                    """
                    Unicast IPv4 L3VPN configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast, self).__init__()

                        self.yang_name = "l3vpn-ipv4-unicast"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "l3vpn-ipv4-unicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "l3vpn-ipv4-unicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ipv6Unicast(Entity):
                    """
                    IPv6 unicast configuration options
                    
                    .. attribute:: config
                    
                    	Configuration parameters for common IPv4 and IPv6 unicast AFI\-SAFI options
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.Config>`
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit>`
                    
                    .. attribute:: state
                    
                    	State information for common IPv4 and IPv6 unicast parameters
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast, self).__init__()

                        self.yang_name = "ipv6-unicast"
                        self.yang_parent_name = "afi-safi"

                        self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")

                        self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "ipv6-unicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Config(Entity):
                        """
                        Configuration parameters for common IPv4 and IPv6 unicast
                        AFI\-SAFI options
                        
                        .. attribute:: send_default_route
                        
                        	If set to true, send the default\-route to the neighbour(s)
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "ipv6-unicast"

                            self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("send_default_route") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.send_default_route.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.send_default_route.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_default_route.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "send-default-route"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "send-default-route"):
                                self.send_default_route = value
                                self.send_default_route.value_namespace = name_space
                                self.send_default_route.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information for common IPv4 and IPv6 unicast
                        parameters
                        
                        .. attribute:: send_default_route
                        
                        	If set to true, send the default\-route to the neighbour(s)
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "ipv6-unicast"

                            self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("send_default_route") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.send_default_route.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.send_default_route.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.send_default_route.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "send-default-route"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "send-default-route"):
                                self.send_default_route = value
                                self.send_default_route.value_namespace = name_space
                                self.send_default_route.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.prefix_limit is not None and self.prefix_limit.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipv6-unicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "prefix-limit" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class ApplyPolicy(Entity):
                    """
                    Anchor point for routing policies in the model.
                    Import and export policies are with respect to the local
                    routing table, i.e., export (send) and import (receive),
                    depending on the context.
                    
                    .. attribute:: config
                    
                    	Policy configuration data
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.Config>`
                    
                    .. attribute:: state
                    
                    	Operational state for routing policy
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy, self).__init__()

                        self.yang_name = "apply-policy"
                        self.yang_parent_name = "afi-safi"

                        self.config = Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Policy configuration data.
                        
                        .. attribute:: default_export_policy
                        
                        	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                        	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                        
                        	**default value**\: REJECT_ROUTE
                        
                        .. attribute:: default_import_policy
                        
                        	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                        	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                        
                        	**default value**\: REJECT_ROUTE
                        
                        .. attribute:: export_policy
                        
                        	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                        	**type**\:  list of str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                        
                        .. attribute:: import_policy
                        
                        	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                        	**type**\:  list of str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "apply-policy"

                            self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                            self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                            self.export_policy = YLeafList(YType.str, "export-policy")

                            self.import_policy = YLeafList(YType.str, "import-policy")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("default_export_policy",
                                            "default_import_policy",
                                            "export_policy",
                                            "import_policy") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.export_policy.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.import_policy.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.default_export_policy.is_set or
                                self.default_import_policy.is_set)

                        def has_operation(self):
                            for leaf in self.export_policy.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.import_policy.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.default_export_policy.yfilter != YFilter.not_set or
                                self.default_import_policy.yfilter != YFilter.not_set or
                                self.export_policy.yfilter != YFilter.not_set or
                                self.import_policy.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                            if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                            leaf_name_data.extend(self.export_policy.get_name_leafdata())

                            leaf_name_data.extend(self.import_policy.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "default-export-policy"):
                                self.default_export_policy = value
                                self.default_export_policy.value_namespace = name_space
                                self.default_export_policy.value_namespace_prefix = name_space_prefix
                            if(value_path == "default-import-policy"):
                                self.default_import_policy = value
                                self.default_import_policy.value_namespace = name_space
                                self.default_import_policy.value_namespace_prefix = name_space_prefix
                            if(value_path == "export-policy"):
                                self.export_policy.append(value)
                            if(value_path == "import-policy"):
                                self.import_policy.append(value)


                    class State(Entity):
                        """
                        Operational state for routing policy
                        
                        .. attribute:: default_export_policy
                        
                        	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                        	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                        
                        	**default value**\: REJECT_ROUTE
                        
                        .. attribute:: default_import_policy
                        
                        	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                        	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                        
                        	**default value**\: REJECT_ROUTE
                        
                        .. attribute:: export_policy
                        
                        	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                        	**type**\:  list of str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                        
                        .. attribute:: import_policy
                        
                        	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                        	**type**\:  list of str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "apply-policy"

                            self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                            self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                            self.export_policy = YLeafList(YType.str, "export-policy")

                            self.import_policy = YLeafList(YType.str, "import-policy")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("default_export_policy",
                                            "default_import_policy",
                                            "export_policy",
                                            "import_policy") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.State, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.export_policy.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.import_policy.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.default_export_policy.is_set or
                                self.default_import_policy.is_set)

                        def has_operation(self):
                            for leaf in self.export_policy.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.import_policy.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.default_export_policy.yfilter != YFilter.not_set or
                                self.default_import_policy.yfilter != YFilter.not_set or
                                self.export_policy.yfilter != YFilter.not_set or
                                self.import_policy.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                            if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                            leaf_name_data.extend(self.export_policy.get_name_leafdata())

                            leaf_name_data.extend(self.import_policy.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "default-export-policy"):
                                self.default_export_policy = value
                                self.default_export_policy.value_namespace = name_space
                                self.default_export_policy.value_namespace_prefix = name_space_prefix
                            if(value_path == "default-import-policy"):
                                self.default_import_policy = value
                                self.default_import_policy.value_namespace = name_space
                                self.default_import_policy.value_namespace_prefix = name_space_prefix
                            if(value_path == "export-policy"):
                                self.export_policy.append(value)
                            if(value_path == "import-policy"):
                                self.import_policy.append(value)

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "apply-policy" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class RouteSelectionOptions(Entity):
                    """
                    Parameters relating to options for route selection
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to route selection options
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.Config>`
                    
                    .. attribute:: state
                    
                    	State information for the route selection options
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions, self).__init__()

                        self.yang_name = "route-selection-options"
                        self.yang_parent_name = "afi-safi"

                        self.config = Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to route selection
                        options
                        
                        .. attribute:: advertise_inactive_routes
                        
                        	Advertise inactive routes to external peers.  The default is to only advertise active routes
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: always_compare_med
                        
                        	Compare multi\-exit discriminator (MED) value from different ASes when selecting the best route.  The default behavior is to only compare MEDs for paths received from the same AS
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: enable_aigp
                        
                        	Flag to enable sending / receiving accumulated IGP attribute in routing updates
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: external_compare_router_id
                        
                        	When comparing similar routes received from external BGP peers, use the router\-id as a criterion to select the active path
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        .. attribute:: ignore_as_path_length
                        
                        	Ignore the AS path length when selecting the best path. The default is to use the AS path length and prefer paths with shorter length
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: ignore_next_hop_igp_metric
                        
                        	Ignore the IGP metric to the next\-hop when calculating BGP best\-path. The default is to select the route for which the metric to the next\-hop is lowest
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "route-selection-options"

                            self.advertise_inactive_routes = YLeaf(YType.boolean, "advertise-inactive-routes")

                            self.always_compare_med = YLeaf(YType.boolean, "always-compare-med")

                            self.enable_aigp = YLeaf(YType.boolean, "enable-aigp")

                            self.external_compare_router_id = YLeaf(YType.boolean, "external-compare-router-id")

                            self.ignore_as_path_length = YLeaf(YType.boolean, "ignore-as-path-length")

                            self.ignore_next_hop_igp_metric = YLeaf(YType.boolean, "ignore-next-hop-igp-metric")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("advertise_inactive_routes",
                                            "always_compare_med",
                                            "enable_aigp",
                                            "external_compare_router_id",
                                            "ignore_as_path_length",
                                            "ignore_next_hop_igp_metric") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.advertise_inactive_routes.is_set or
                                self.always_compare_med.is_set or
                                self.enable_aigp.is_set or
                                self.external_compare_router_id.is_set or
                                self.ignore_as_path_length.is_set or
                                self.ignore_next_hop_igp_metric.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.advertise_inactive_routes.yfilter != YFilter.not_set or
                                self.always_compare_med.yfilter != YFilter.not_set or
                                self.enable_aigp.yfilter != YFilter.not_set or
                                self.external_compare_router_id.yfilter != YFilter.not_set or
                                self.ignore_as_path_length.yfilter != YFilter.not_set or
                                self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.advertise_inactive_routes.is_set or self.advertise_inactive_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_inactive_routes.get_name_leafdata())
                            if (self.always_compare_med.is_set or self.always_compare_med.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.always_compare_med.get_name_leafdata())
                            if (self.enable_aigp.is_set or self.enable_aigp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable_aigp.get_name_leafdata())
                            if (self.external_compare_router_id.is_set or self.external_compare_router_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.external_compare_router_id.get_name_leafdata())
                            if (self.ignore_as_path_length.is_set or self.ignore_as_path_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignore_as_path_length.get_name_leafdata())
                            if (self.ignore_next_hop_igp_metric.is_set or self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignore_next_hop_igp_metric.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "advertise-inactive-routes" or name == "always-compare-med" or name == "enable-aigp" or name == "external-compare-router-id" or name == "ignore-as-path-length" or name == "ignore-next-hop-igp-metric"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "advertise-inactive-routes"):
                                self.advertise_inactive_routes = value
                                self.advertise_inactive_routes.value_namespace = name_space
                                self.advertise_inactive_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "always-compare-med"):
                                self.always_compare_med = value
                                self.always_compare_med.value_namespace = name_space
                                self.always_compare_med.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable-aigp"):
                                self.enable_aigp = value
                                self.enable_aigp.value_namespace = name_space
                                self.enable_aigp.value_namespace_prefix = name_space_prefix
                            if(value_path == "external-compare-router-id"):
                                self.external_compare_router_id = value
                                self.external_compare_router_id.value_namespace = name_space
                                self.external_compare_router_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignore-as-path-length"):
                                self.ignore_as_path_length = value
                                self.ignore_as_path_length.value_namespace = name_space
                                self.ignore_as_path_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignore-next-hop-igp-metric"):
                                self.ignore_next_hop_igp_metric = value
                                self.ignore_next_hop_igp_metric.value_namespace = name_space
                                self.ignore_next_hop_igp_metric.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information for the route selection options
                        
                        .. attribute:: advertise_inactive_routes
                        
                        	Advertise inactive routes to external peers.  The default is to only advertise active routes
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: always_compare_med
                        
                        	Compare multi\-exit discriminator (MED) value from different ASes when selecting the best route.  The default behavior is to only compare MEDs for paths received from the same AS
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: enable_aigp
                        
                        	Flag to enable sending / receiving accumulated IGP attribute in routing updates
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: external_compare_router_id
                        
                        	When comparing similar routes received from external BGP peers, use the router\-id as a criterion to select the active path
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        .. attribute:: ignore_as_path_length
                        
                        	Ignore the AS path length when selecting the best path. The default is to use the AS path length and prefer paths with shorter length
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: ignore_next_hop_igp_metric
                        
                        	Ignore the IGP metric to the next\-hop when calculating BGP best\-path. The default is to select the route for which the metric to the next\-hop is lowest
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "route-selection-options"

                            self.advertise_inactive_routes = YLeaf(YType.boolean, "advertise-inactive-routes")

                            self.always_compare_med = YLeaf(YType.boolean, "always-compare-med")

                            self.enable_aigp = YLeaf(YType.boolean, "enable-aigp")

                            self.external_compare_router_id = YLeaf(YType.boolean, "external-compare-router-id")

                            self.ignore_as_path_length = YLeaf(YType.boolean, "ignore-as-path-length")

                            self.ignore_next_hop_igp_metric = YLeaf(YType.boolean, "ignore-next-hop-igp-metric")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("advertise_inactive_routes",
                                            "always_compare_med",
                                            "enable_aigp",
                                            "external_compare_router_id",
                                            "ignore_as_path_length",
                                            "ignore_next_hop_igp_metric") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.advertise_inactive_routes.is_set or
                                self.always_compare_med.is_set or
                                self.enable_aigp.is_set or
                                self.external_compare_router_id.is_set or
                                self.ignore_as_path_length.is_set or
                                self.ignore_next_hop_igp_metric.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.advertise_inactive_routes.yfilter != YFilter.not_set or
                                self.always_compare_med.yfilter != YFilter.not_set or
                                self.enable_aigp.yfilter != YFilter.not_set or
                                self.external_compare_router_id.yfilter != YFilter.not_set or
                                self.ignore_as_path_length.yfilter != YFilter.not_set or
                                self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.advertise_inactive_routes.is_set or self.advertise_inactive_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_inactive_routes.get_name_leafdata())
                            if (self.always_compare_med.is_set or self.always_compare_med.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.always_compare_med.get_name_leafdata())
                            if (self.enable_aigp.is_set or self.enable_aigp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable_aigp.get_name_leafdata())
                            if (self.external_compare_router_id.is_set or self.external_compare_router_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.external_compare_router_id.get_name_leafdata())
                            if (self.ignore_as_path_length.is_set or self.ignore_as_path_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignore_as_path_length.get_name_leafdata())
                            if (self.ignore_next_hop_igp_metric.is_set or self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignore_next_hop_igp_metric.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "advertise-inactive-routes" or name == "always-compare-med" or name == "enable-aigp" or name == "external-compare-router-id" or name == "ignore-as-path-length" or name == "ignore-next-hop-igp-metric"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "advertise-inactive-routes"):
                                self.advertise_inactive_routes = value
                                self.advertise_inactive_routes.value_namespace = name_space
                                self.advertise_inactive_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "always-compare-med"):
                                self.always_compare_med = value
                                self.always_compare_med.value_namespace = name_space
                                self.always_compare_med.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable-aigp"):
                                self.enable_aigp = value
                                self.enable_aigp.value_namespace = name_space
                                self.enable_aigp.value_namespace_prefix = name_space_prefix
                            if(value_path == "external-compare-router-id"):
                                self.external_compare_router_id = value
                                self.external_compare_router_id.value_namespace = name_space
                                self.external_compare_router_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignore-as-path-length"):
                                self.ignore_as_path_length = value
                                self.ignore_as_path_length.value_namespace = name_space
                                self.ignore_as_path_length.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignore-next-hop-igp-metric"):
                                self.ignore_next_hop_igp_metric = value
                                self.ignore_next_hop_igp_metric.value_namespace = name_space
                                self.ignore_next_hop_igp_metric.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "route-selection-options" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ipv4LabeledUnicast(Entity):
                    """
                    IPv4 Labeled Unicast configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast, self).__init__()

                        self.yang_name = "ipv4-labeled-unicast"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "ipv4-labeled-unicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipv4-labeled-unicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ipv6LabeledUnicast(Entity):
                    """
                    IPv6 Labeled Unicast configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast, self).__init__()

                        self.yang_name = "ipv6-labeled-unicast"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "ipv6-labeled-unicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipv6-labeled-unicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class L3VpnIpv4Multicast(Entity):
                    """
                    Multicast IPv4 L3VPN configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast, self).__init__()

                        self.yang_name = "l3vpn-ipv4-multicast"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "l3vpn-ipv4-multicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "l3vpn-ipv4-multicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class L2VpnVpls(Entity):
                    """
                    BGP\-signalled VPLS configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls, self).__init__()

                        self.yang_name = "l2vpn-vpls"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "l2vpn-vpls"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "l2vpn-vpls" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Config(Entity):
                    """
                    Configuration parameters for the AFI\-SAFI
                    
                    .. attribute:: afi_safi_name
                    
                    	AFI,SAFI
                    	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                    
                    .. attribute:: enabled
                    
                    	This leaf indicates whether the IPv4 Unicast AFI,SAFI is enabled for the neighbour or group
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "afi-safi"

                        self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                        self.enabled = YLeaf(YType.boolean, "enabled")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi_safi_name",
                                        "enabled") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Global_.AfiSafis.AfiSafi.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Global_.AfiSafis.AfiSafi.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi_safi_name.is_set or
                            self.enabled.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi_safi_name.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi_safi_name.get_name_leafdata())
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi-safi-name" or name == "enabled"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi-safi-name"):
                            self.afi_safi_name = value
                            self.afi_safi_name.value_namespace = name_space
                            self.afi_safi_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix


                class GracefulRestart(Entity):
                    """
                    Parameters relating to BGP graceful\-restart
                    
                    .. attribute:: config
                    
                    	Configuration options for BGP graceful\-restart
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.Config>`
                    
                    .. attribute:: state
                    
                    	State information for BGP graceful\-restart
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart, self).__init__()

                        self.yang_name = "graceful-restart"
                        self.yang_parent_name = "afi-safi"

                        self.config = Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration options for BGP graceful\-restart
                        
                        .. attribute:: enabled
                        
                        	This leaf indicates whether graceful\-restart is enabled for this AFI\-SAFI
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "graceful-restart"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information for BGP graceful\-restart
                        
                        .. attribute:: enabled
                        
                        	This leaf indicates whether graceful\-restart is enabled for this AFI\-SAFI
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "graceful-restart"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "graceful-restart" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class UseMultiplePaths(Entity):
                    """
                    Parameters related to the use of multiple paths for the
                    same NLRI
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to multipath
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Config>`
                    
                    .. attribute:: ebgp
                    
                    	Multipath parameters for eBGP
                    	**type**\:   :py:class:`Ebgp <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp>`
                    
                    .. attribute:: ibgp
                    
                    	Multipath parameters for iBGP
                    	**type**\:   :py:class:`Ibgp <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp>`
                    
                    .. attribute:: state
                    
                    	State parameters relating to multipath
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths, self).__init__()

                        self.yang_name = "use-multiple-paths"
                        self.yang_parent_name = "afi-safi"

                        self.config = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.ebgp = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp()
                        self.ebgp.parent = self
                        self._children_name_map["ebgp"] = "ebgp"
                        self._children_yang_names.add("ebgp")

                        self.ibgp = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp()
                        self.ibgp.parent = self
                        self._children_name_map["ibgp"] = "ibgp"
                        self._children_yang_names.add("ibgp")

                        self.state = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to multipath
                        
                        .. attribute:: enabled
                        
                        	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "use-multiple-paths"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class Ebgp(Entity):
                        """
                        Multipath parameters for eBGP
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to eBGP multipath
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to eBGP multipath
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp, self).__init__()

                            self.yang_name = "ebgp"
                            self.yang_parent_name = "use-multiple-paths"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to eBGP multipath
                            
                            .. attribute:: allow_multiple_as
                            
                            	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: maximum_paths
                            
                            	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**default value**\: 1
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "ebgp"

                                self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                                self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("allow_multiple_as",
                                                "maximum_paths") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.allow_multiple_as.is_set or
                                    self.maximum_paths.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.allow_multiple_as.yfilter != YFilter.not_set or
                                    self.maximum_paths.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                                if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "allow-multiple-as" or name == "maximum-paths"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "allow-multiple-as"):
                                    self.allow_multiple_as = value
                                    self.allow_multiple_as.value_namespace = name_space
                                    self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-paths"):
                                    self.maximum_paths = value
                                    self.maximum_paths.value_namespace = name_space
                                    self.maximum_paths.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to eBGP multipath
                            
                            .. attribute:: allow_multiple_as
                            
                            	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: maximum_paths
                            
                            	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**default value**\: 1
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "ebgp"

                                self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                                self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("allow_multiple_as",
                                                "maximum_paths") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.allow_multiple_as.is_set or
                                    self.maximum_paths.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.allow_multiple_as.yfilter != YFilter.not_set or
                                    self.maximum_paths.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                                if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "allow-multiple-as" or name == "maximum-paths"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "allow-multiple-as"):
                                    self.allow_multiple_as = value
                                    self.allow_multiple_as.value_namespace = name_space
                                    self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-paths"):
                                    self.maximum_paths = value
                                    self.maximum_paths.value_namespace = name_space
                                    self.maximum_paths.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ebgp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ibgp(Entity):
                        """
                        Multipath parameters for iBGP
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to iBGP multipath
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to iBGP multipath
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp, self).__init__()

                            self.yang_name = "ibgp"
                            self.yang_parent_name = "use-multiple-paths"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to iBGP multipath
                            
                            .. attribute:: maximum_paths
                            
                            	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**default value**\: 1
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "ibgp"

                                self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("maximum_paths") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.maximum_paths.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.maximum_paths.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "maximum-paths"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "maximum-paths"):
                                    self.maximum_paths = value
                                    self.maximum_paths.value_namespace = name_space
                                    self.maximum_paths.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to iBGP multipath
                            
                            .. attribute:: maximum_paths
                            
                            	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**default value**\: 1
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "ibgp"

                                self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("maximum_paths") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.maximum_paths.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.maximum_paths.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "maximum-paths"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "maximum-paths"):
                                    self.maximum_paths = value
                                    self.maximum_paths.value_namespace = name_space
                                    self.maximum_paths.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ibgp" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class State(Entity):
                        """
                        State parameters relating to multipath
                        
                        .. attribute:: enabled
                        
                        	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "use-multiple-paths"

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enabled.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.ebgp is not None and self.ebgp.has_data()) or
                            (self.ibgp is not None and self.ibgp.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.ebgp is not None and self.ebgp.has_operation()) or
                            (self.ibgp is not None and self.ibgp.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "use-multiple-paths" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "ebgp"):
                            if (self.ebgp is None):
                                self.ebgp = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp()
                                self.ebgp.parent = self
                                self._children_name_map["ebgp"] = "ebgp"
                            return self.ebgp

                        if (child_yang_name == "ibgp"):
                            if (self.ibgp is None):
                                self.ibgp = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp()
                                self.ibgp.parent = self
                                self._children_name_map["ibgp"] = "ibgp"
                            return self.ibgp

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "ebgp" or name == "ibgp" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class L3VpnIpv6Unicast(Entity):
                    """
                    Unicast IPv6 L3VPN configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast, self).__init__()

                        self.yang_name = "l3vpn-ipv6-unicast"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "l3vpn-ipv6-unicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "l3vpn-ipv6-unicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class L3VpnIpv6Multicast(Entity):
                    """
                    Multicast IPv6 L3VPN configuration options
                    
                    .. attribute:: prefix_limit
                    
                    	Configure the maximum number of prefixes that will be accepted from a peer
                    	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast, self).__init__()

                        self.yang_name = "l3vpn-ipv6-multicast"
                        self.yang_parent_name = "afi-safi"

                        self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit()
                        self.prefix_limit.parent = self
                        self._children_name_map["prefix_limit"] = "prefix-limit"
                        self._children_yang_names.add("prefix-limit")


                    class PrefixLimit(Entity):
                        """
                        Configure the maximum number of prefixes that will be
                        accepted from a peer
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config>`
                        
                        .. attribute:: state
                        
                        	State information relating to the prefix\-limit for the AFI\-SAFI
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit, self).__init__()

                            self.yang_name = "prefix-limit"
                            self.yang_parent_name = "l3vpn-ipv6-multicast"

                            self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to the prefix
                            limit for the AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information relating to the prefix\-limit for the
                            AFI\-SAFI
                            
                            .. attribute:: max_prefixes
                            
                            	Maximum number of prefixes that will be accepted from the neighbour
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: restart_timer
                            
                            	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                            	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                            
                            	**range:** \-92233720368547758.08..92233720368547758.07
                            
                            	**units**\: seconds
                            
                            .. attribute:: shutdown_threshold_pct
                            
                            	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "prefix-limit"

                                self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                self.restart_timer = YLeaf(YType.str, "restart-timer")

                                self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_prefixes",
                                                "restart_timer",
                                                "shutdown_threshold_pct") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.max_prefixes.is_set or
                                    self.restart_timer.is_set or
                                    self.shutdown_threshold_pct.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_prefixes.yfilter != YFilter.not_set or
                                    self.restart_timer.yfilter != YFilter.not_set or
                                    self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-prefixes"):
                                    self.max_prefixes = value
                                    self.max_prefixes.value_namespace = name_space
                                    self.max_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-timer"):
                                    self.restart_timer = value
                                    self.restart_timer.value_namespace = name_space
                                    self.restart_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "shutdown-threshold-pct"):
                                    self.shutdown_threshold_pct = value
                                    self.shutdown_threshold_pct.value_namespace = name_space
                                    self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-limit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.prefix_limit is not None and self.prefix_limit.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "l3vpn-ipv6-multicast" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-limit"):
                            if (self.prefix_limit is None):
                                self.prefix_limit = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit()
                                self.prefix_limit.parent = self
                                self._children_name_map["prefix_limit"] = "prefix-limit"
                            return self.prefix_limit

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.afi_safi_name.is_set or
                        (self.apply_policy is not None and self.apply_policy.has_data()) or
                        (self.config is not None and self.config.has_data()) or
                        (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                        (self.ipv4_labeled_unicast is not None and self.ipv4_labeled_unicast.has_data()) or
                        (self.ipv4_unicast is not None and self.ipv4_unicast.has_data()) or
                        (self.ipv6_labeled_unicast is not None and self.ipv6_labeled_unicast.has_data()) or
                        (self.ipv6_unicast is not None and self.ipv6_unicast.has_data()) or
                        (self.l2vpn_evpn is not None and self.l2vpn_evpn.has_data()) or
                        (self.l2vpn_vpls is not None and self.l2vpn_vpls.has_data()) or
                        (self.l3vpn_ipv4_multicast is not None and self.l3vpn_ipv4_multicast.has_data()) or
                        (self.l3vpn_ipv4_unicast is not None and self.l3vpn_ipv4_unicast.has_data()) or
                        (self.l3vpn_ipv6_multicast is not None and self.l3vpn_ipv6_multicast.has_data()) or
                        (self.l3vpn_ipv6_unicast is not None and self.l3vpn_ipv6_unicast.has_data()) or
                        (self.route_selection_options is not None and self.route_selection_options.has_data()) or
                        (self.state is not None and self.state.has_data()) or
                        (self.use_multiple_paths is not None and self.use_multiple_paths.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.afi_safi_name.yfilter != YFilter.not_set or
                        (self.apply_policy is not None and self.apply_policy.has_operation()) or
                        (self.config is not None and self.config.has_operation()) or
                        (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                        (self.ipv4_labeled_unicast is not None and self.ipv4_labeled_unicast.has_operation()) or
                        (self.ipv4_unicast is not None and self.ipv4_unicast.has_operation()) or
                        (self.ipv6_labeled_unicast is not None and self.ipv6_labeled_unicast.has_operation()) or
                        (self.ipv6_unicast is not None and self.ipv6_unicast.has_operation()) or
                        (self.l2vpn_evpn is not None and self.l2vpn_evpn.has_operation()) or
                        (self.l2vpn_vpls is not None and self.l2vpn_vpls.has_operation()) or
                        (self.l3vpn_ipv4_multicast is not None and self.l3vpn_ipv4_multicast.has_operation()) or
                        (self.l3vpn_ipv4_unicast is not None and self.l3vpn_ipv4_unicast.has_operation()) or
                        (self.l3vpn_ipv6_multicast is not None and self.l3vpn_ipv6_multicast.has_operation()) or
                        (self.l3vpn_ipv6_unicast is not None and self.l3vpn_ipv6_unicast.has_operation()) or
                        (self.route_selection_options is not None and self.route_selection_options.has_operation()) or
                        (self.state is not None and self.state.has_operation()) or
                        (self.use_multiple_paths is not None and self.use_multiple_paths.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "afi-safi" + "[afi-safi-name='" + self.afi_safi_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/afi-safis/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.afi_safi_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "apply-policy"):
                        if (self.apply_policy is None):
                            self.apply_policy = Bgp.Global_.AfiSafis.AfiSafi.ApplyPolicy()
                            self.apply_policy.parent = self
                            self._children_name_map["apply_policy"] = "apply-policy"
                        return self.apply_policy

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Global_.AfiSafis.AfiSafi.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "graceful-restart"):
                        if (self.graceful_restart is None):
                            self.graceful_restart = Bgp.Global_.AfiSafis.AfiSafi.GracefulRestart()
                            self.graceful_restart.parent = self
                            self._children_name_map["graceful_restart"] = "graceful-restart"
                        return self.graceful_restart

                    if (child_yang_name == "ipv4-labeled-unicast"):
                        if (self.ipv4_labeled_unicast is None):
                            self.ipv4_labeled_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv4LabeledUnicast()
                            self.ipv4_labeled_unicast.parent = self
                            self._children_name_map["ipv4_labeled_unicast"] = "ipv4-labeled-unicast"
                        return self.ipv4_labeled_unicast

                    if (child_yang_name == "ipv4-unicast"):
                        if (self.ipv4_unicast is None):
                            self.ipv4_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv4Unicast()
                            self.ipv4_unicast.parent = self
                            self._children_name_map["ipv4_unicast"] = "ipv4-unicast"
                        return self.ipv4_unicast

                    if (child_yang_name == "ipv6-labeled-unicast"):
                        if (self.ipv6_labeled_unicast is None):
                            self.ipv6_labeled_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv6LabeledUnicast()
                            self.ipv6_labeled_unicast.parent = self
                            self._children_name_map["ipv6_labeled_unicast"] = "ipv6-labeled-unicast"
                        return self.ipv6_labeled_unicast

                    if (child_yang_name == "ipv6-unicast"):
                        if (self.ipv6_unicast is None):
                            self.ipv6_unicast = Bgp.Global_.AfiSafis.AfiSafi.Ipv6Unicast()
                            self.ipv6_unicast.parent = self
                            self._children_name_map["ipv6_unicast"] = "ipv6-unicast"
                        return self.ipv6_unicast

                    if (child_yang_name == "l2vpn-evpn"):
                        if (self.l2vpn_evpn is None):
                            self.l2vpn_evpn = Bgp.Global_.AfiSafis.AfiSafi.L2VpnEvpn()
                            self.l2vpn_evpn.parent = self
                            self._children_name_map["l2vpn_evpn"] = "l2vpn-evpn"
                        return self.l2vpn_evpn

                    if (child_yang_name == "l2vpn-vpls"):
                        if (self.l2vpn_vpls is None):
                            self.l2vpn_vpls = Bgp.Global_.AfiSafis.AfiSafi.L2VpnVpls()
                            self.l2vpn_vpls.parent = self
                            self._children_name_map["l2vpn_vpls"] = "l2vpn-vpls"
                        return self.l2vpn_vpls

                    if (child_yang_name == "l3vpn-ipv4-multicast"):
                        if (self.l3vpn_ipv4_multicast is None):
                            self.l3vpn_ipv4_multicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Multicast()
                            self.l3vpn_ipv4_multicast.parent = self
                            self._children_name_map["l3vpn_ipv4_multicast"] = "l3vpn-ipv4-multicast"
                        return self.l3vpn_ipv4_multicast

                    if (child_yang_name == "l3vpn-ipv4-unicast"):
                        if (self.l3vpn_ipv4_unicast is None):
                            self.l3vpn_ipv4_unicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv4Unicast()
                            self.l3vpn_ipv4_unicast.parent = self
                            self._children_name_map["l3vpn_ipv4_unicast"] = "l3vpn-ipv4-unicast"
                        return self.l3vpn_ipv4_unicast

                    if (child_yang_name == "l3vpn-ipv6-multicast"):
                        if (self.l3vpn_ipv6_multicast is None):
                            self.l3vpn_ipv6_multicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Multicast()
                            self.l3vpn_ipv6_multicast.parent = self
                            self._children_name_map["l3vpn_ipv6_multicast"] = "l3vpn-ipv6-multicast"
                        return self.l3vpn_ipv6_multicast

                    if (child_yang_name == "l3vpn-ipv6-unicast"):
                        if (self.l3vpn_ipv6_unicast is None):
                            self.l3vpn_ipv6_unicast = Bgp.Global_.AfiSafis.AfiSafi.L3VpnIpv6Unicast()
                            self.l3vpn_ipv6_unicast.parent = self
                            self._children_name_map["l3vpn_ipv6_unicast"] = "l3vpn-ipv6-unicast"
                        return self.l3vpn_ipv6_unicast

                    if (child_yang_name == "route-selection-options"):
                        if (self.route_selection_options is None):
                            self.route_selection_options = Bgp.Global_.AfiSafis.AfiSafi.RouteSelectionOptions()
                            self.route_selection_options.parent = self
                            self._children_name_map["route_selection_options"] = "route-selection-options"
                        return self.route_selection_options

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Global_.AfiSafis.AfiSafi.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    if (child_yang_name == "use-multiple-paths"):
                        if (self.use_multiple_paths is None):
                            self.use_multiple_paths = Bgp.Global_.AfiSafis.AfiSafi.UseMultiplePaths()
                            self.use_multiple_paths.parent = self
                            self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                        return self.use_multiple_paths

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "apply-policy" or name == "config" or name == "graceful-restart" or name == "ipv4-labeled-unicast" or name == "ipv4-unicast" or name == "ipv6-labeled-unicast" or name == "ipv6-unicast" or name == "l2vpn-evpn" or name == "l2vpn-vpls" or name == "l3vpn-ipv4-multicast" or name == "l3vpn-ipv4-unicast" or name == "l3vpn-ipv6-multicast" or name == "l3vpn-ipv6-unicast" or name == "route-selection-options" or name == "state" or name == "use-multiple-paths" or name == "afi-safi-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "afi-safi-name"):
                        self.afi_safi_name = value
                        self.afi_safi_name.value_namespace = name_space
                        self.afi_safi_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.afi_safi:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.afi_safi:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "afi-safis" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "afi-safi"):
                    for c in self.afi_safi:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bgp.Global_.AfiSafis.AfiSafi()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.afi_safi.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "afi-safi"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class ApplyPolicy(Entity):
            """
            Anchor point for routing policies in the model.
            Import and export policies are with respect to the local
            routing table, i.e., export (send) and import (receive),
            depending on the context.
            
            .. attribute:: config
            
            	Policy configuration data
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.ApplyPolicy.Config>`
            
            .. attribute:: state
            
            	Operational state for routing policy
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Global_.ApplyPolicy.State>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Global_.ApplyPolicy, self).__init__()

                self.yang_name = "apply-policy"
                self.yang_parent_name = "global"

                self.config = Bgp.Global_.ApplyPolicy.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Bgp.Global_.ApplyPolicy.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Policy configuration data.
                
                .. attribute:: default_export_policy
                
                	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                
                	**default value**\: REJECT_ROUTE
                
                .. attribute:: default_import_policy
                
                	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                
                	**default value**\: REJECT_ROUTE
                
                .. attribute:: export_policy
                
                	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                	**type**\:  list of str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                
                .. attribute:: import_policy
                
                	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                	**type**\:  list of str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.ApplyPolicy.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "apply-policy"

                    self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                    self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                    self.export_policy = YLeafList(YType.str, "export-policy")

                    self.import_policy = YLeafList(YType.str, "import-policy")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("default_export_policy",
                                    "default_import_policy",
                                    "export_policy",
                                    "import_policy") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.ApplyPolicy.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.ApplyPolicy.Config, self).__setattr__(name, value)

                def has_data(self):
                    for leaf in self.export_policy.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.import_policy.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.default_export_policy.is_set or
                        self.default_import_policy.is_set)

                def has_operation(self):
                    for leaf in self.export_policy.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.import_policy.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.default_export_policy.yfilter != YFilter.not_set or
                        self.default_import_policy.yfilter != YFilter.not_set or
                        self.export_policy.yfilter != YFilter.not_set or
                        self.import_policy.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/apply-policy/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                    if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                    leaf_name_data.extend(self.export_policy.get_name_leafdata())

                    leaf_name_data.extend(self.import_policy.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "default-export-policy"):
                        self.default_export_policy = value
                        self.default_export_policy.value_namespace = name_space
                        self.default_export_policy.value_namespace_prefix = name_space_prefix
                    if(value_path == "default-import-policy"):
                        self.default_import_policy = value
                        self.default_import_policy.value_namespace = name_space
                        self.default_import_policy.value_namespace_prefix = name_space_prefix
                    if(value_path == "export-policy"):
                        self.export_policy.append(value)
                    if(value_path == "import-policy"):
                        self.import_policy.append(value)


            class State(Entity):
                """
                Operational state for routing policy
                
                .. attribute:: default_export_policy
                
                	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                
                	**default value**\: REJECT_ROUTE
                
                .. attribute:: default_import_policy
                
                	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                
                	**default value**\: REJECT_ROUTE
                
                .. attribute:: export_policy
                
                	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                	**type**\:  list of str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                
                .. attribute:: import_policy
                
                	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                	**type**\:  list of str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Global_.ApplyPolicy.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "apply-policy"

                    self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                    self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                    self.export_policy = YLeafList(YType.str, "export-policy")

                    self.import_policy = YLeafList(YType.str, "import-policy")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("default_export_policy",
                                    "default_import_policy",
                                    "export_policy",
                                    "import_policy") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Global_.ApplyPolicy.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Global_.ApplyPolicy.State, self).__setattr__(name, value)

                def has_data(self):
                    for leaf in self.export_policy.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.import_policy.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.default_export_policy.is_set or
                        self.default_import_policy.is_set)

                def has_operation(self):
                    for leaf in self.export_policy.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.import_policy.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.default_export_policy.yfilter != YFilter.not_set or
                        self.default_import_policy.yfilter != YFilter.not_set or
                        self.export_policy.yfilter != YFilter.not_set or
                        self.import_policy.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-bgp:bgp/global/apply-policy/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                    if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                    leaf_name_data.extend(self.export_policy.get_name_leafdata())

                    leaf_name_data.extend(self.import_policy.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "default-export-policy"):
                        self.default_export_policy = value
                        self.default_export_policy.value_namespace = name_space
                        self.default_export_policy.value_namespace_prefix = name_space_prefix
                    if(value_path == "default-import-policy"):
                        self.default_import_policy = value
                        self.default_import_policy.value_namespace = name_space
                        self.default_import_policy.value_namespace_prefix = name_space_prefix
                    if(value_path == "export-policy"):
                        self.export_policy.append(value)
                    if(value_path == "import-policy"):
                        self.import_policy.append(value)

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "apply-policy" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.Global_.ApplyPolicy.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.Global_.ApplyPolicy.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.afi_safis is not None and self.afi_safis.has_data()) or
                (self.apply_policy is not None and self.apply_policy.has_data()) or
                (self.confederation is not None and self.confederation.has_data()) or
                (self.config is not None and self.config.has_data()) or
                (self.default_route_distance is not None and self.default_route_distance.has_data()) or
                (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                (self.route_selection_options is not None and self.route_selection_options.has_data()) or
                (self.state is not None and self.state.has_data()) or
                (self.use_multiple_paths is not None and self.use_multiple_paths.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.afi_safis is not None and self.afi_safis.has_operation()) or
                (self.apply_policy is not None and self.apply_policy.has_operation()) or
                (self.confederation is not None and self.confederation.has_operation()) or
                (self.config is not None and self.config.has_operation()) or
                (self.default_route_distance is not None and self.default_route_distance.has_operation()) or
                (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                (self.route_selection_options is not None and self.route_selection_options.has_operation()) or
                (self.state is not None and self.state.has_operation()) or
                (self.use_multiple_paths is not None and self.use_multiple_paths.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "global" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-bgp:bgp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "afi-safis"):
                if (self.afi_safis is None):
                    self.afi_safis = Bgp.Global_.AfiSafis()
                    self.afi_safis.parent = self
                    self._children_name_map["afi_safis"] = "afi-safis"
                return self.afi_safis

            if (child_yang_name == "apply-policy"):
                if (self.apply_policy is None):
                    self.apply_policy = Bgp.Global_.ApplyPolicy()
                    self.apply_policy.parent = self
                    self._children_name_map["apply_policy"] = "apply-policy"
                return self.apply_policy

            if (child_yang_name == "confederation"):
                if (self.confederation is None):
                    self.confederation = Bgp.Global_.Confederation()
                    self.confederation.parent = self
                    self._children_name_map["confederation"] = "confederation"
                return self.confederation

            if (child_yang_name == "config"):
                if (self.config is None):
                    self.config = Bgp.Global_.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                return self.config

            if (child_yang_name == "default-route-distance"):
                if (self.default_route_distance is None):
                    self.default_route_distance = Bgp.Global_.DefaultRouteDistance()
                    self.default_route_distance.parent = self
                    self._children_name_map["default_route_distance"] = "default-route-distance"
                return self.default_route_distance

            if (child_yang_name == "graceful-restart"):
                if (self.graceful_restart is None):
                    self.graceful_restart = Bgp.Global_.GracefulRestart()
                    self.graceful_restart.parent = self
                    self._children_name_map["graceful_restart"] = "graceful-restart"
                return self.graceful_restart

            if (child_yang_name == "route-selection-options"):
                if (self.route_selection_options is None):
                    self.route_selection_options = Bgp.Global_.RouteSelectionOptions()
                    self.route_selection_options.parent = self
                    self._children_name_map["route_selection_options"] = "route-selection-options"
                return self.route_selection_options

            if (child_yang_name == "state"):
                if (self.state is None):
                    self.state = Bgp.Global_.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                return self.state

            if (child_yang_name == "use-multiple-paths"):
                if (self.use_multiple_paths is None):
                    self.use_multiple_paths = Bgp.Global_.UseMultiplePaths()
                    self.use_multiple_paths.parent = self
                    self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                return self.use_multiple_paths

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "afi-safis" or name == "apply-policy" or name == "confederation" or name == "config" or name == "default-route-distance" or name == "graceful-restart" or name == "route-selection-options" or name == "state" or name == "use-multiple-paths"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Neighbors(Entity):
        """
        Configuration for BGP neighbors
        
        .. attribute:: neighbor
        
        	List of BGP neighbors configured on the local system, uniquely identified by peer IPv[46] address
        	**type**\: list of    :py:class:`Neighbor <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor>`
        
        

        """

        _prefix = 'oc-bgp'
        _revision = '2016-06-21'

        def __init__(self):
            super(Bgp.Neighbors, self).__init__()

            self.yang_name = "neighbors"
            self.yang_parent_name = "bgp"

            self.neighbor = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bgp.Neighbors, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bgp.Neighbors, self).__setattr__(name, value)


        class Neighbor(Entity):
            """
            List of BGP neighbors configured on the local system,
            uniquely identified by peer IPv[46] address
            
            .. attribute:: neighbor_address  <key>
            
            	Reference to the address of the BGP neighbor used as a key in the neighbor list
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: add_paths
            
            	Parameters relating to the advertisement and receipt of multiple paths for a single NLRI (add\-paths)
            	**type**\:   :py:class:`AddPaths <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AddPaths>`
            
            .. attribute:: afi_safis
            
            	Per\-address\-family configuration parameters associated with the neighbor
            	**type**\:   :py:class:`AfiSafis <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis>`
            
            .. attribute:: apply_policy
            
            	Anchor point for routing policies in the model. Import and export policies are with respect to the local routing table, i.e., export (send) and import (receive), depending on the context
            	**type**\:   :py:class:`ApplyPolicy <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.ApplyPolicy>`
            
            .. attribute:: as_path_options
            
            	AS\_PATH manipulation parameters for the BGP neighbor or group
            	**type**\:   :py:class:`AsPathOptions <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AsPathOptions>`
            
            .. attribute:: config
            
            	Configuration parameters relating to the BGP neighbor or group
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.Config>`
            
            .. attribute:: ebgp_multihop
            
            	eBGP multi\-hop parameters for the BGPgroup
            	**type**\:   :py:class:`EbgpMultihop <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.EbgpMultihop>`
            
            .. attribute:: error_handling
            
            	Error handling parameters used for the BGP neighbor or group
            	**type**\:   :py:class:`ErrorHandling <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.ErrorHandling>`
            
            .. attribute:: graceful_restart
            
            	Parameters relating the graceful restart mechanism for BGP
            	**type**\:   :py:class:`GracefulRestart <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.GracefulRestart>`
            
            .. attribute:: logging_options
            
            	Logging options for events related to the BGP neighbor or group
            	**type**\:   :py:class:`LoggingOptions <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.LoggingOptions>`
            
            .. attribute:: route_reflector
            
            	Route reflector parameters for the BGPgroup
            	**type**\:   :py:class:`RouteReflector <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.RouteReflector>`
            
            .. attribute:: state
            
            	State information relating to the BGP neighbor
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.State>`
            
            .. attribute:: timers
            
            	Timers related to a BGP neighbor
            	**type**\:   :py:class:`Timers <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.Timers>`
            
            .. attribute:: transport
            
            	Transport session parameters for the BGP neighbor
            	**type**\:   :py:class:`Transport <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.Transport>`
            
            .. attribute:: use_multiple_paths
            
            	Parameters related to the use of multiple\-paths for the same NLRI when they are received only from this neighbor
            	**type**\:   :py:class:`UseMultiplePaths <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.UseMultiplePaths>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.Neighbors.Neighbor, self).__init__()

                self.yang_name = "neighbor"
                self.yang_parent_name = "neighbors"

                self.neighbor_address = YLeaf(YType.str, "neighbor-address")

                self.add_paths = Bgp.Neighbors.Neighbor.AddPaths()
                self.add_paths.parent = self
                self._children_name_map["add_paths"] = "add-paths"
                self._children_yang_names.add("add-paths")

                self.afi_safis = Bgp.Neighbors.Neighbor.AfiSafis()
                self.afi_safis.parent = self
                self._children_name_map["afi_safis"] = "afi-safis"
                self._children_yang_names.add("afi-safis")

                self.apply_policy = Bgp.Neighbors.Neighbor.ApplyPolicy()
                self.apply_policy.parent = self
                self._children_name_map["apply_policy"] = "apply-policy"
                self._children_yang_names.add("apply-policy")

                self.as_path_options = Bgp.Neighbors.Neighbor.AsPathOptions()
                self.as_path_options.parent = self
                self._children_name_map["as_path_options"] = "as-path-options"
                self._children_yang_names.add("as-path-options")

                self.config = Bgp.Neighbors.Neighbor.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.ebgp_multihop = Bgp.Neighbors.Neighbor.EbgpMultihop()
                self.ebgp_multihop.parent = self
                self._children_name_map["ebgp_multihop"] = "ebgp-multihop"
                self._children_yang_names.add("ebgp-multihop")

                self.error_handling = Bgp.Neighbors.Neighbor.ErrorHandling()
                self.error_handling.parent = self
                self._children_name_map["error_handling"] = "error-handling"
                self._children_yang_names.add("error-handling")

                self.graceful_restart = Bgp.Neighbors.Neighbor.GracefulRestart()
                self.graceful_restart.parent = self
                self._children_name_map["graceful_restart"] = "graceful-restart"
                self._children_yang_names.add("graceful-restart")

                self.logging_options = Bgp.Neighbors.Neighbor.LoggingOptions()
                self.logging_options.parent = self
                self._children_name_map["logging_options"] = "logging-options"
                self._children_yang_names.add("logging-options")

                self.route_reflector = Bgp.Neighbors.Neighbor.RouteReflector()
                self.route_reflector.parent = self
                self._children_name_map["route_reflector"] = "route-reflector"
                self._children_yang_names.add("route-reflector")

                self.state = Bgp.Neighbors.Neighbor.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")

                self.timers = Bgp.Neighbors.Neighbor.Timers()
                self.timers.parent = self
                self._children_name_map["timers"] = "timers"
                self._children_yang_names.add("timers")

                self.transport = Bgp.Neighbors.Neighbor.Transport()
                self.transport.parent = self
                self._children_name_map["transport"] = "transport"
                self._children_yang_names.add("transport")

                self.use_multiple_paths = Bgp.Neighbors.Neighbor.UseMultiplePaths()
                self.use_multiple_paths.parent = self
                self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                self._children_yang_names.add("use-multiple-paths")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("neighbor_address") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bgp.Neighbors.Neighbor, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bgp.Neighbors.Neighbor, self).__setattr__(name, value)


            class Config(Entity):
                """
                Configuration parameters relating to the BGP neighbor or
                group
                
                .. attribute:: auth_password
                
                	Configures an MD5 authentication password for use with neighboring devices
                	**type**\:  str
                
                .. attribute:: description
                
                	An optional textual description (intended primarily for use with a peer or group
                	**type**\:  str
                
                .. attribute:: enabled
                
                	Whether the BGP peer is enabled. In cases where the enabled leaf is set to false, the local system should not initiate connections to the neighbor, and should not respond to TCP connections attempts from the neighbor. If the state of the BGP session is ESTABLISHED at the time that this leaf is set to false, the BGP session should be ceased
                	**type**\:  bool
                
                	**default value**\: true
                
                .. attribute:: local_as
                
                	The local autonomous system number that is to be used when establishing sessions with the remote peer or peer group, if this differs from the global BGP router autonomous system number
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: neighbor_address
                
                	Address of the BGP peer, either in IPv4 or IPv6
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: peer_as
                
                	AS number of the peer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_group
                
                	The peer\-group with which this neighbor is associated
                	**type**\:  str
                
                	**refers to**\:  :py:class:`peer_group_name <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup>`
                
                .. attribute:: peer_type
                
                	Explicitly designate the peer or peer group as internal (iBGP) or external (eBGP)
                	**type**\:   :py:class:`PeerType <ydk.models.openconfig.openconfig_bgp_types.PeerType>`
                
                .. attribute:: remove_private_as
                
                	Remove private AS numbers from updates sent to peers \- when this leaf is not specified, the AS\_PATH attribute should be sent to the peer unchanged
                	**type**\:   :py:class:`Remove_Private_As_Option <ydk.models.openconfig.openconfig_bgp_types.Remove_Private_As_Option>`
                
                .. attribute:: route_flap_damping
                
                	Enable route flap damping
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: send_community
                
                	Specify which types of community should be sent to the neighbor or group. The default is to not send the community attribute
                	**type**\:   :py:class:`CommunityType <ydk.models.openconfig.openconfig_bgp_types.CommunityType>`
                
                	**default value**\: NONE
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "neighbor"

                    self.auth_password = YLeaf(YType.str, "auth-password")

                    self.description = YLeaf(YType.str, "description")

                    self.enabled = YLeaf(YType.boolean, "enabled")

                    self.local_as = YLeaf(YType.uint32, "local-as")

                    self.neighbor_address = YLeaf(YType.str, "neighbor-address")

                    self.peer_as = YLeaf(YType.uint32, "peer-as")

                    self.peer_group = YLeaf(YType.str, "peer-group")

                    self.peer_type = YLeaf(YType.enumeration, "peer-type")

                    self.remove_private_as = YLeaf(YType.identityref, "remove-private-as")

                    self.route_flap_damping = YLeaf(YType.boolean, "route-flap-damping")

                    self.send_community = YLeaf(YType.enumeration, "send-community")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("auth_password",
                                    "description",
                                    "enabled",
                                    "local_as",
                                    "neighbor_address",
                                    "peer_as",
                                    "peer_group",
                                    "peer_type",
                                    "remove_private_as",
                                    "route_flap_damping",
                                    "send_community") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Neighbors.Neighbor.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Neighbors.Neighbor.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.auth_password.is_set or
                        self.description.is_set or
                        self.enabled.is_set or
                        self.local_as.is_set or
                        self.neighbor_address.is_set or
                        self.peer_as.is_set or
                        self.peer_group.is_set or
                        self.peer_type.is_set or
                        self.remove_private_as.is_set or
                        self.route_flap_damping.is_set or
                        self.send_community.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.auth_password.yfilter != YFilter.not_set or
                        self.description.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set or
                        self.local_as.yfilter != YFilter.not_set or
                        self.neighbor_address.yfilter != YFilter.not_set or
                        self.peer_as.yfilter != YFilter.not_set or
                        self.peer_group.yfilter != YFilter.not_set or
                        self.peer_type.yfilter != YFilter.not_set or
                        self.remove_private_as.yfilter != YFilter.not_set or
                        self.route_flap_damping.yfilter != YFilter.not_set or
                        self.send_community.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.auth_password.is_set or self.auth_password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.auth_password.get_name_leafdata())
                    if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.description.get_name_leafdata())
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())
                    if (self.local_as.is_set or self.local_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_as.get_name_leafdata())
                    if (self.neighbor_address.is_set or self.neighbor_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_address.get_name_leafdata())
                    if (self.peer_as.is_set or self.peer_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_as.get_name_leafdata())
                    if (self.peer_group.is_set or self.peer_group.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_group.get_name_leafdata())
                    if (self.peer_type.is_set or self.peer_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_type.get_name_leafdata())
                    if (self.remove_private_as.is_set or self.remove_private_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remove_private_as.get_name_leafdata())
                    if (self.route_flap_damping.is_set or self.route_flap_damping.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_flap_damping.get_name_leafdata())
                    if (self.send_community.is_set or self.send_community.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.send_community.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "auth-password" or name == "description" or name == "enabled" or name == "local-as" or name == "neighbor-address" or name == "peer-as" or name == "peer-group" or name == "peer-type" or name == "remove-private-as" or name == "route-flap-damping" or name == "send-community"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "auth-password"):
                        self.auth_password = value
                        self.auth_password.value_namespace = name_space
                        self.auth_password.value_namespace_prefix = name_space_prefix
                    if(value_path == "description"):
                        self.description = value
                        self.description.value_namespace = name_space
                        self.description.value_namespace_prefix = name_space_prefix
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-as"):
                        self.local_as = value
                        self.local_as.value_namespace = name_space
                        self.local_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-address"):
                        self.neighbor_address = value
                        self.neighbor_address.value_namespace = name_space
                        self.neighbor_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-as"):
                        self.peer_as = value
                        self.peer_as.value_namespace = name_space
                        self.peer_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-group"):
                        self.peer_group = value
                        self.peer_group.value_namespace = name_space
                        self.peer_group.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-type"):
                        self.peer_type = value
                        self.peer_type.value_namespace = name_space
                        self.peer_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "remove-private-as"):
                        self.remove_private_as = value
                        self.remove_private_as.value_namespace = name_space
                        self.remove_private_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "route-flap-damping"):
                        self.route_flap_damping = value
                        self.route_flap_damping.value_namespace = name_space
                        self.route_flap_damping.value_namespace_prefix = name_space_prefix
                    if(value_path == "send-community"):
                        self.send_community = value
                        self.send_community.value_namespace = name_space
                        self.send_community.value_namespace_prefix = name_space_prefix


            class EbgpMultihop(Entity):
                """
                eBGP multi\-hop parameters for the BGPgroup
                
                .. attribute:: config
                
                	Configuration parameters relating to eBGP multihop for the BGP group
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.EbgpMultihop.Config>`
                
                .. attribute:: state
                
                	State information for eBGP multihop, for the BGP neighbor or group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.EbgpMultihop.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.EbgpMultihop, self).__init__()

                    self.yang_name = "ebgp-multihop"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.EbgpMultihop.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.EbgpMultihop.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to eBGP multihop for the
                    BGP group
                    
                    .. attribute:: enabled
                    
                    	When enabled the referenced group or neighbors are permitted to be indirectly connected \- including cases where the TTL can be decremented between the BGP peers
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: multihop_ttl
                    
                    	Time\-to\-live value to use when packets are sent to the referenced group or neighbors and ebgp\-multihop is enabled
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.EbgpMultihop.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "ebgp-multihop"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.multihop_ttl = YLeaf(YType.uint8, "multihop-ttl")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "multihop_ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.EbgpMultihop.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.EbgpMultihop.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.multihop_ttl.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.multihop_ttl.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.multihop_ttl.is_set or self.multihop_ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multihop_ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "multihop-ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "multihop-ttl"):
                            self.multihop_ttl = value
                            self.multihop_ttl.value_namespace = name_space
                            self.multihop_ttl.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information for eBGP multihop, for the BGP neighbor
                    or group
                    
                    .. attribute:: enabled
                    
                    	When enabled the referenced group or neighbors are permitted to be indirectly connected \- including cases where the TTL can be decremented between the BGP peers
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: multihop_ttl
                    
                    	Time\-to\-live value to use when packets are sent to the referenced group or neighbors and ebgp\-multihop is enabled
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.EbgpMultihop.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "ebgp-multihop"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.multihop_ttl = YLeaf(YType.uint8, "multihop-ttl")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "multihop_ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.EbgpMultihop.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.EbgpMultihop.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.multihop_ttl.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.multihop_ttl.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.multihop_ttl.is_set or self.multihop_ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multihop_ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "multihop-ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "multihop-ttl"):
                            self.multihop_ttl = value
                            self.multihop_ttl.value_namespace = name_space
                            self.multihop_ttl.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ebgp-multihop" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.EbgpMultihop.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.EbgpMultihop.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class ErrorHandling(Entity):
                """
                Error handling parameters used for the BGP neighbor or
                group
                
                .. attribute:: config
                
                	Configuration parameters enabling or modifying the behavior or enhanced error handling mechanisms for the BGP neighbor
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.ErrorHandling.Config>`
                
                .. attribute:: state
                
                	State information relating to enhanced error handling mechanisms for the BGP neighbor
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.ErrorHandling.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.ErrorHandling, self).__init__()

                    self.yang_name = "error-handling"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.ErrorHandling.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.ErrorHandling.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters enabling or modifying the
                    behavior or enhanced error handling mechanisms for the BGP
                    neighbor
                    
                    .. attribute:: treat_as_withdraw
                    
                    	Specify whether erroneous UPDATE messages for which the NLRI can be extracted are reated as though the NLRI is withdrawn \- avoiding session reset
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.ErrorHandling.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "error-handling"

                        self.treat_as_withdraw = YLeaf(YType.boolean, "treat-as-withdraw")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("treat_as_withdraw") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.ErrorHandling.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.ErrorHandling.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.treat_as_withdraw.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.treat_as_withdraw.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.treat_as_withdraw.is_set or self.treat_as_withdraw.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.treat_as_withdraw.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "treat-as-withdraw"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "treat-as-withdraw"):
                            self.treat_as_withdraw = value
                            self.treat_as_withdraw.value_namespace = name_space
                            self.treat_as_withdraw.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to enhanced error handling
                    mechanisms for the BGP neighbor
                    
                    .. attribute:: erroneous_update_messages
                    
                    	The number of BGP UPDATE messages for which the treat\-as\-withdraw mechanism has been applied based on erroneous message contents
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: treat_as_withdraw
                    
                    	Specify whether erroneous UPDATE messages for which the NLRI can be extracted are reated as though the NLRI is withdrawn \- avoiding session reset
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.ErrorHandling.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "error-handling"

                        self.erroneous_update_messages = YLeaf(YType.uint32, "erroneous-update-messages")

                        self.treat_as_withdraw = YLeaf(YType.boolean, "treat-as-withdraw")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("erroneous_update_messages",
                                        "treat_as_withdraw") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.ErrorHandling.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.ErrorHandling.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.erroneous_update_messages.is_set or
                            self.treat_as_withdraw.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.erroneous_update_messages.yfilter != YFilter.not_set or
                            self.treat_as_withdraw.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.erroneous_update_messages.is_set or self.erroneous_update_messages.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.erroneous_update_messages.get_name_leafdata())
                        if (self.treat_as_withdraw.is_set or self.treat_as_withdraw.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.treat_as_withdraw.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "erroneous-update-messages" or name == "treat-as-withdraw"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "erroneous-update-messages"):
                            self.erroneous_update_messages = value
                            self.erroneous_update_messages.value_namespace = name_space
                            self.erroneous_update_messages.value_namespace_prefix = name_space_prefix
                        if(value_path == "treat-as-withdraw"):
                            self.treat_as_withdraw = value
                            self.treat_as_withdraw.value_namespace = name_space
                            self.treat_as_withdraw.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "error-handling" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.ErrorHandling.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.ErrorHandling.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LoggingOptions(Entity):
                """
                Logging options for events related to the BGP neighbor or
                group
                
                .. attribute:: config
                
                	Configuration parameters enabling or modifying logging for events relating to the BGPgroup
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.LoggingOptions.Config>`
                
                .. attribute:: state
                
                	State information relating to logging for the BGP neighbor or group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.LoggingOptions.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.LoggingOptions, self).__init__()

                    self.yang_name = "logging-options"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.LoggingOptions.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.LoggingOptions.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters enabling or modifying logging
                    for events relating to the BGPgroup
                    
                    .. attribute:: log_neighbor_state_changes
                    
                    	Configure logging of peer state changes.  Default is to enable logging of peer state changes
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.LoggingOptions.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "logging-options"

                        self.log_neighbor_state_changes = YLeaf(YType.boolean, "log-neighbor-state-changes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("log_neighbor_state_changes") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.LoggingOptions.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.LoggingOptions.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.log_neighbor_state_changes.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.log_neighbor_state_changes.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.log_neighbor_state_changes.is_set or self.log_neighbor_state_changes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.log_neighbor_state_changes.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "log-neighbor-state-changes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "log-neighbor-state-changes"):
                            self.log_neighbor_state_changes = value
                            self.log_neighbor_state_changes.value_namespace = name_space
                            self.log_neighbor_state_changes.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to logging for the BGP neighbor
                    or group
                    
                    .. attribute:: log_neighbor_state_changes
                    
                    	Configure logging of peer state changes.  Default is to enable logging of peer state changes
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.LoggingOptions.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "logging-options"

                        self.log_neighbor_state_changes = YLeaf(YType.boolean, "log-neighbor-state-changes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("log_neighbor_state_changes") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.LoggingOptions.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.LoggingOptions.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.log_neighbor_state_changes.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.log_neighbor_state_changes.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.log_neighbor_state_changes.is_set or self.log_neighbor_state_changes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.log_neighbor_state_changes.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "log-neighbor-state-changes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "log-neighbor-state-changes"):
                            self.log_neighbor_state_changes = value
                            self.log_neighbor_state_changes.value_namespace = name_space
                            self.log_neighbor_state_changes.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "logging-options" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.LoggingOptions.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.LoggingOptions.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AddPaths(Entity):
                """
                Parameters relating to the advertisement and receipt of
                multiple paths for a single NLRI (add\-paths)
                
                .. attribute:: config
                
                	Configuration parameters relating to ADD\_PATHS
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AddPaths.Config>`
                
                .. attribute:: state
                
                	State information associated with ADD\_PATHS
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AddPaths.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.AddPaths, self).__init__()

                    self.yang_name = "add-paths"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.AddPaths.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.AddPaths.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to ADD\_PATHS
                    
                    .. attribute:: eligible_prefix_policy
                    
                    	A reference to a routing policy which can be used to restrict the prefixes for which add\-paths is enabled
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: receive
                    
                    	Enable ability to receive multiple path advertisements for an NLRI from the neighbor or group
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: send_max
                    
                    	The maximum number of paths to advertise to neighbors for a single NLRI
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.AddPaths.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "add-paths"

                        self.eligible_prefix_policy = YLeaf(YType.str, "eligible-prefix-policy")

                        self.receive = YLeaf(YType.boolean, "receive")

                        self.send_max = YLeaf(YType.uint8, "send-max")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("eligible_prefix_policy",
                                        "receive",
                                        "send_max") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.AddPaths.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.AddPaths.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.eligible_prefix_policy.is_set or
                            self.receive.is_set or
                            self.send_max.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.eligible_prefix_policy.yfilter != YFilter.not_set or
                            self.receive.yfilter != YFilter.not_set or
                            self.send_max.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.eligible_prefix_policy.is_set or self.eligible_prefix_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eligible_prefix_policy.get_name_leafdata())
                        if (self.receive.is_set or self.receive.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive.get_name_leafdata())
                        if (self.send_max.is_set or self.send_max.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_max.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "eligible-prefix-policy" or name == "receive" or name == "send-max"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "eligible-prefix-policy"):
                            self.eligible_prefix_policy = value
                            self.eligible_prefix_policy.value_namespace = name_space
                            self.eligible_prefix_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive"):
                            self.receive = value
                            self.receive.value_namespace = name_space
                            self.receive.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-max"):
                            self.send_max = value
                            self.send_max.value_namespace = name_space
                            self.send_max.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information associated with ADD\_PATHS
                    
                    .. attribute:: eligible_prefix_policy
                    
                    	A reference to a routing policy which can be used to restrict the prefixes for which add\-paths is enabled
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: receive
                    
                    	Enable ability to receive multiple path advertisements for an NLRI from the neighbor or group
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: send_max
                    
                    	The maximum number of paths to advertise to neighbors for a single NLRI
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.AddPaths.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "add-paths"

                        self.eligible_prefix_policy = YLeaf(YType.str, "eligible-prefix-policy")

                        self.receive = YLeaf(YType.boolean, "receive")

                        self.send_max = YLeaf(YType.uint8, "send-max")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("eligible_prefix_policy",
                                        "receive",
                                        "send_max") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.AddPaths.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.AddPaths.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.eligible_prefix_policy.is_set or
                            self.receive.is_set or
                            self.send_max.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.eligible_prefix_policy.yfilter != YFilter.not_set or
                            self.receive.yfilter != YFilter.not_set or
                            self.send_max.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.eligible_prefix_policy.is_set or self.eligible_prefix_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eligible_prefix_policy.get_name_leafdata())
                        if (self.receive.is_set or self.receive.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive.get_name_leafdata())
                        if (self.send_max.is_set or self.send_max.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_max.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "eligible-prefix-policy" or name == "receive" or name == "send-max"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "eligible-prefix-policy"):
                            self.eligible_prefix_policy = value
                            self.eligible_prefix_policy.value_namespace = name_space
                            self.eligible_prefix_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive"):
                            self.receive = value
                            self.receive.value_namespace = name_space
                            self.receive.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-max"):
                            self.send_max = value
                            self.send_max.value_namespace = name_space
                            self.send_max.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "add-paths" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.AddPaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.AddPaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AfiSafis(Entity):
                """
                Per\-address\-family configuration parameters associated with
                the neighbor
                
                .. attribute:: afi_safi
                
                	AFI,SAFI configuration available for the neighbour or group
                	**type**\: list of    :py:class:`AfiSafi <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.AfiSafis, self).__init__()

                    self.yang_name = "afi-safis"
                    self.yang_parent_name = "neighbor"

                    self.afi_safi = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Neighbors.Neighbor.AfiSafis, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Neighbors.Neighbor.AfiSafis, self).__setattr__(name, value)


                class AfiSafi(Entity):
                    """
                    AFI,SAFI configuration available for the
                    neighbour or group
                    
                    .. attribute:: afi_safi_name  <key>
                    
                    	Reference to the AFI\-SAFI name used as a key for the AFI\-SAFI list
                    	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                    
                    .. attribute:: apply_policy
                    
                    	Anchor point for routing policies in the model. Import and export policies are with respect to the local routing table, i.e., export (send) and import (receive), depending on the context
                    	**type**\:   :py:class:`ApplyPolicy <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy>`
                    
                    .. attribute:: config
                    
                    	Configuration parameters for the AFI\-SAFI
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Config>`
                    
                    .. attribute:: graceful_restart
                    
                    	Parameters relating to BGP graceful\-restart
                    	**type**\:   :py:class:`GracefulRestart <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart>`
                    
                    .. attribute:: ipv4_labeled_unicast
                    
                    	IPv4 Labeled Unicast configuration options
                    	**type**\:   :py:class:`Ipv4LabeledUnicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast>`
                    
                    .. attribute:: ipv4_unicast
                    
                    	IPv4 unicast configuration options
                    	**type**\:   :py:class:`Ipv4Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast>`
                    
                    .. attribute:: ipv6_labeled_unicast
                    
                    	IPv6 Labeled Unicast configuration options
                    	**type**\:   :py:class:`Ipv6LabeledUnicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast>`
                    
                    .. attribute:: ipv6_unicast
                    
                    	IPv6 unicast configuration options
                    	**type**\:   :py:class:`Ipv6Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast>`
                    
                    .. attribute:: l2vpn_evpn
                    
                    	BGP EVPN configuration options
                    	**type**\:   :py:class:`L2VpnEvpn <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn>`
                    
                    .. attribute:: l2vpn_vpls
                    
                    	BGP\-signalled VPLS configuration options
                    	**type**\:   :py:class:`L2VpnVpls <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls>`
                    
                    .. attribute:: l3vpn_ipv4_multicast
                    
                    	Multicast IPv4 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv4Multicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast>`
                    
                    .. attribute:: l3vpn_ipv4_unicast
                    
                    	Unicast IPv4 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv4Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast>`
                    
                    .. attribute:: l3vpn_ipv6_multicast
                    
                    	Multicast IPv6 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv6Multicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast>`
                    
                    .. attribute:: l3vpn_ipv6_unicast
                    
                    	Unicast IPv6 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv6Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast>`
                    
                    .. attribute:: state
                    
                    	State information relating to the AFI\-SAFI
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State>`
                    
                    .. attribute:: use_multiple_paths
                    
                    	Parameters related to the use of multiple\-paths for the same NLRI when they are received only from this neighbor
                    	**type**\:   :py:class:`UseMultiplePaths <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi, self).__init__()

                        self.yang_name = "afi-safi"
                        self.yang_parent_name = "afi-safis"

                        self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                        self.apply_policy = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy()
                        self.apply_policy.parent = self
                        self._children_name_map["apply_policy"] = "apply-policy"
                        self._children_yang_names.add("apply-policy")

                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.graceful_restart = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart()
                        self.graceful_restart.parent = self
                        self._children_name_map["graceful_restart"] = "graceful-restart"
                        self._children_yang_names.add("graceful-restart")

                        self.ipv4_labeled_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast()
                        self.ipv4_labeled_unicast.parent = self
                        self._children_name_map["ipv4_labeled_unicast"] = "ipv4-labeled-unicast"
                        self._children_yang_names.add("ipv4-labeled-unicast")

                        self.ipv4_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast()
                        self.ipv4_unicast.parent = self
                        self._children_name_map["ipv4_unicast"] = "ipv4-unicast"
                        self._children_yang_names.add("ipv4-unicast")

                        self.ipv6_labeled_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast()
                        self.ipv6_labeled_unicast.parent = self
                        self._children_name_map["ipv6_labeled_unicast"] = "ipv6-labeled-unicast"
                        self._children_yang_names.add("ipv6-labeled-unicast")

                        self.ipv6_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast()
                        self.ipv6_unicast.parent = self
                        self._children_name_map["ipv6_unicast"] = "ipv6-unicast"
                        self._children_yang_names.add("ipv6-unicast")

                        self.l2vpn_evpn = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn()
                        self.l2vpn_evpn.parent = self
                        self._children_name_map["l2vpn_evpn"] = "l2vpn-evpn"
                        self._children_yang_names.add("l2vpn-evpn")

                        self.l2vpn_vpls = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls()
                        self.l2vpn_vpls.parent = self
                        self._children_name_map["l2vpn_vpls"] = "l2vpn-vpls"
                        self._children_yang_names.add("l2vpn-vpls")

                        self.l3vpn_ipv4_multicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast()
                        self.l3vpn_ipv4_multicast.parent = self
                        self._children_name_map["l3vpn_ipv4_multicast"] = "l3vpn-ipv4-multicast"
                        self._children_yang_names.add("l3vpn-ipv4-multicast")

                        self.l3vpn_ipv4_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast()
                        self.l3vpn_ipv4_unicast.parent = self
                        self._children_name_map["l3vpn_ipv4_unicast"] = "l3vpn-ipv4-unicast"
                        self._children_yang_names.add("l3vpn-ipv4-unicast")

                        self.l3vpn_ipv6_multicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast()
                        self.l3vpn_ipv6_multicast.parent = self
                        self._children_name_map["l3vpn_ipv6_multicast"] = "l3vpn-ipv6-multicast"
                        self._children_yang_names.add("l3vpn-ipv6-multicast")

                        self.l3vpn_ipv6_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast()
                        self.l3vpn_ipv6_unicast.parent = self
                        self._children_name_map["l3vpn_ipv6_unicast"] = "l3vpn-ipv6-unicast"
                        self._children_yang_names.add("l3vpn-ipv6-unicast")

                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")

                        self.use_multiple_paths = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths()
                        self.use_multiple_paths.parent = self
                        self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                        self._children_yang_names.add("use-multiple-paths")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi_safi_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi, self).__setattr__(name, value)


                    class L3VpnIpv4Multicast(Entity):
                        """
                        Multicast IPv4 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast, self).__init__()

                            self.yang_name = "l3vpn-ipv4-multicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv4-multicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv4-multicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L2VpnVpls(Entity):
                        """
                        BGP\-signalled VPLS configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls, self).__init__()

                            self.yang_name = "l2vpn-vpls"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l2vpn-vpls"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l2vpn-vpls" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class State(Entity):
                        """
                        State information relating to the AFI\-SAFI
                        
                        .. attribute:: active
                        
                        	This value indicates whether a particular AFI\-SAFI has been succesfully negotiated with the peer. An AFI\-SAFI may be enabled in the current running configuration, but a session restart may be required in order to negotiate the new capability
                        	**type**\:  bool
                        
                        .. attribute:: afi_safi_name
                        
                        	AFI,SAFI
                        	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                        
                        .. attribute:: enabled
                        
                        	This leaf indicates whether the IPv4 Unicast AFI,SAFI is enabled for the neighbour or group
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: prefixes
                        
                        	Prefix counters for the BGP session
                        	**type**\:   :py:class:`Prefixes <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State.Prefixes>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "afi-safi"

                            self.active = YLeaf(YType.boolean, "active")

                            self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                            self.enabled = YLeaf(YType.boolean, "enabled")

                            self.prefixes = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State.Prefixes()
                            self.prefixes.parent = self
                            self._children_name_map["prefixes"] = "prefixes"
                            self._children_yang_names.add("prefixes")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("active",
                                            "afi_safi_name",
                                            "enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State, self).__setattr__(name, value)


                        class Prefixes(Entity):
                            """
                            Prefix counters for the BGP session
                            
                            .. attribute:: installed
                            
                            	The number of advertised prefixes installed in the Loc\-RIB
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: received
                            
                            	The number of prefixes received from the neighbor
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sent
                            
                            	The number of prefixes advertised to the neighbor
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State.Prefixes, self).__init__()

                                self.yang_name = "prefixes"
                                self.yang_parent_name = "state"

                                self.installed = YLeaf(YType.uint32, "installed")

                                self.received = YLeaf(YType.uint32, "received")

                                self.sent = YLeaf(YType.uint32, "sent")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("installed",
                                                "received",
                                                "sent") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State.Prefixes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State.Prefixes, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.installed.is_set or
                                    self.received.is_set or
                                    self.sent.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.installed.yfilter != YFilter.not_set or
                                    self.received.yfilter != YFilter.not_set or
                                    self.sent.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefixes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.installed.is_set or self.installed.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.installed.get_name_leafdata())
                                if (self.received.is_set or self.received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.received.get_name_leafdata())
                                if (self.sent.is_set or self.sent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sent.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "installed" or name == "received" or name == "sent"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "installed"):
                                    self.installed = value
                                    self.installed.value_namespace = name_space
                                    self.installed.value_namespace_prefix = name_space_prefix
                                if(value_path == "received"):
                                    self.received = value
                                    self.received.value_namespace = name_space
                                    self.received.value_namespace_prefix = name_space_prefix
                                if(value_path == "sent"):
                                    self.sent = value
                                    self.sent.value_namespace = name_space
                                    self.sent.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.active.is_set or
                                self.afi_safi_name.is_set or
                                self.enabled.is_set or
                                (self.prefixes is not None and self.prefixes.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.active.yfilter != YFilter.not_set or
                                self.afi_safi_name.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set or
                                (self.prefixes is not None and self.prefixes.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.active.get_name_leafdata())
                            if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi_safi_name.get_name_leafdata())
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefixes"):
                                if (self.prefixes is None):
                                    self.prefixes = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State.Prefixes()
                                    self.prefixes.parent = self
                                    self._children_name_map["prefixes"] = "prefixes"
                                return self.prefixes

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefixes" or name == "active" or name == "afi-safi-name" or name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "active"):
                                self.active = value
                                self.active.value_namespace = name_space
                                self.active.value_namespace_prefix = name_space_prefix
                            if(value_path == "afi-safi-name"):
                                self.afi_safi_name = value
                                self.afi_safi_name.value_namespace = name_space
                                self.afi_safi_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class Ipv4Unicast(Entity):
                        """
                        IPv4 unicast configuration options
                        
                        .. attribute:: config
                        
                        	Configuration parameters for common IPv4 and IPv6 unicast AFI\-SAFI options
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.Config>`
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit>`
                        
                        .. attribute:: state
                        
                        	State information for common IPv4 and IPv6 unicast parameters
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast, self).__init__()

                            self.yang_name = "ipv4-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")

                            self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv4-unicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Config(Entity):
                            """
                            Configuration parameters for common IPv4 and IPv6 unicast
                            AFI\-SAFI options
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "ipv4-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information for common IPv4 and IPv6 unicast
                            parameters
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "ipv4-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv4-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "prefix-limit" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class UseMultiplePaths(Entity):
                        """
                        Parameters related to the use of multiple\-paths for the same
                        NLRI when they are received only from this neighbor
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to multipath
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Config>`
                        
                        .. attribute:: ebgp
                        
                        	Multipath configuration for eBGP
                        	**type**\:   :py:class:`Ebgp <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp>`
                        
                        .. attribute:: state
                        
                        	State parameters relating to multipath
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths, self).__init__()

                            self.yang_name = "use-multiple-paths"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.ebgp = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp()
                            self.ebgp.parent = self
                            self._children_name_map["ebgp"] = "ebgp"
                            self._children_yang_names.add("ebgp")

                            self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Ebgp(Entity):
                            """
                            Multipath configuration for eBGP
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to eBGP multipath
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to eBGP multipath
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp, self).__init__()

                                self.yang_name = "ebgp"
                                self.yang_parent_name = "use-multiple-paths"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to eBGP multipath
                                
                                .. attribute:: allow_multiple_as
                                
                                	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "ebgp"

                                    self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("allow_multiple_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.allow_multiple_as.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.allow_multiple_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "allow-multiple-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "allow-multiple-as"):
                                        self.allow_multiple_as = value
                                        self.allow_multiple_as.value_namespace = name_space
                                        self.allow_multiple_as.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to eBGP multipath
                                
                                .. attribute:: allow_multiple_as
                                
                                	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "ebgp"

                                    self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("allow_multiple_as") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.allow_multiple_as.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.allow_multiple_as.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "allow-multiple-as"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "allow-multiple-as"):
                                        self.allow_multiple_as = value
                                        self.allow_multiple_as.value_namespace = name_space
                                        self.allow_multiple_as.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ebgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class State(Entity):
                            """
                            State parameters relating to multipath
                            
                            .. attribute:: enabled
                            
                            	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "use-multiple-paths"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class Config(Entity):
                            """
                            Configuration parameters relating to multipath
                            
                            .. attribute:: enabled
                            
                            	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "use-multiple-paths"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.ebgp is not None and self.ebgp.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.ebgp is not None and self.ebgp.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "use-multiple-paths" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "ebgp"):
                                if (self.ebgp is None):
                                    self.ebgp = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp()
                                    self.ebgp.parent = self
                                    self._children_name_map["ebgp"] = "ebgp"
                                return self.ebgp

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "ebgp" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Config(Entity):
                        """
                        Configuration parameters for the AFI\-SAFI
                        
                        .. attribute:: afi_safi_name
                        
                        	AFI,SAFI
                        	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                        
                        .. attribute:: enabled
                        
                        	This leaf indicates whether the IPv4 Unicast AFI,SAFI is enabled for the neighbour or group
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "afi-safi"

                            self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi_safi_name",
                                            "enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi_safi_name.is_set or
                                self.enabled.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi_safi_name.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi_safi_name.get_name_leafdata())
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi-safi-name" or name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi-safi-name"):
                                self.afi_safi_name = value
                                self.afi_safi_name.value_namespace = name_space
                                self.afi_safi_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class Ipv6LabeledUnicast(Entity):
                        """
                        IPv6 Labeled Unicast configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast, self).__init__()

                            self.yang_name = "ipv6-labeled-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv6-labeled-unicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv6-labeled-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L3VpnIpv6Unicast(Entity):
                        """
                        Unicast IPv6 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast, self).__init__()

                            self.yang_name = "l3vpn-ipv6-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv6-unicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv6-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class ApplyPolicy(Entity):
                        """
                        Anchor point for routing policies in the model.
                        Import and export policies are with respect to the local
                        routing table, i.e., export (send) and import (receive),
                        depending on the context.
                        
                        .. attribute:: config
                        
                        	Policy configuration data
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.Config>`
                        
                        .. attribute:: state
                        
                        	Operational state for routing policy
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy, self).__init__()

                            self.yang_name = "apply-policy"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Policy configuration data.
                            
                            .. attribute:: default_export_policy
                            
                            	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: default_import_policy
                            
                            	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: export_policy
                            
                            	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            .. attribute:: import_policy
                            
                            	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "apply-policy"

                                self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                                self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                                self.export_policy = YLeafList(YType.str, "export-policy")

                                self.import_policy = YLeafList(YType.str, "import-policy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_export_policy",
                                                "default_import_policy",
                                                "export_policy",
                                                "import_policy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__setattr__(name, value)

                            def has_data(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return (
                                    self.default_export_policy.is_set or
                                    self.default_import_policy.is_set)

                            def has_operation(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_export_policy.yfilter != YFilter.not_set or
                                    self.default_import_policy.yfilter != YFilter.not_set or
                                    self.export_policy.yfilter != YFilter.not_set or
                                    self.import_policy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                                if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                                leaf_name_data.extend(self.export_policy.get_name_leafdata())

                                leaf_name_data.extend(self.import_policy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-export-policy"):
                                    self.default_export_policy = value
                                    self.default_export_policy.value_namespace = name_space
                                    self.default_export_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-import-policy"):
                                    self.default_import_policy = value
                                    self.default_import_policy.value_namespace = name_space
                                    self.default_import_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "export-policy"):
                                    self.export_policy.append(value)
                                if(value_path == "import-policy"):
                                    self.import_policy.append(value)


                        class State(Entity):
                            """
                            Operational state for routing policy
                            
                            .. attribute:: default_export_policy
                            
                            	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: default_import_policy
                            
                            	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: export_policy
                            
                            	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            .. attribute:: import_policy
                            
                            	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "apply-policy"

                                self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                                self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                                self.export_policy = YLeafList(YType.str, "export-policy")

                                self.import_policy = YLeafList(YType.str, "import-policy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_export_policy",
                                                "default_import_policy",
                                                "export_policy",
                                                "import_policy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.State, self).__setattr__(name, value)

                            def has_data(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return (
                                    self.default_export_policy.is_set or
                                    self.default_import_policy.is_set)

                            def has_operation(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_export_policy.yfilter != YFilter.not_set or
                                    self.default_import_policy.yfilter != YFilter.not_set or
                                    self.export_policy.yfilter != YFilter.not_set or
                                    self.import_policy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                                if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                                leaf_name_data.extend(self.export_policy.get_name_leafdata())

                                leaf_name_data.extend(self.import_policy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-export-policy"):
                                    self.default_export_policy = value
                                    self.default_export_policy.value_namespace = name_space
                                    self.default_export_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-import-policy"):
                                    self.default_import_policy = value
                                    self.default_import_policy.value_namespace = name_space
                                    self.default_import_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "export-policy"):
                                    self.export_policy.append(value)
                                if(value_path == "import-policy"):
                                    self.import_policy.append(value)

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "apply-policy" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ipv6Unicast(Entity):
                        """
                        IPv6 unicast configuration options
                        
                        .. attribute:: config
                        
                        	Configuration parameters for common IPv4 and IPv6 unicast AFI\-SAFI options
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.Config>`
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit>`
                        
                        .. attribute:: state
                        
                        	State information for common IPv4 and IPv6 unicast parameters
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast, self).__init__()

                            self.yang_name = "ipv6-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")

                            self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv6-unicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Config(Entity):
                            """
                            Configuration parameters for common IPv4 and IPv6 unicast
                            AFI\-SAFI options
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "ipv6-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information for common IPv4 and IPv6 unicast
                            parameters
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "ipv6-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv6-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "prefix-limit" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L3VpnIpv6Multicast(Entity):
                        """
                        Multicast IPv6 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast, self).__init__()

                            self.yang_name = "l3vpn-ipv6-multicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv6-multicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv6-multicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class GracefulRestart(Entity):
                        """
                        Parameters relating to BGP graceful\-restart
                        
                        .. attribute:: config
                        
                        	Configuration options for BGP graceful\-restart
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.Config>`
                        
                        .. attribute:: state
                        
                        	State information for BGP graceful\-restart
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart, self).__init__()

                            self.yang_name = "graceful-restart"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration options for BGP graceful\-restart
                            
                            .. attribute:: enabled
                            
                            	This leaf indicates whether graceful\-restart is enabled for this AFI\-SAFI
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "graceful-restart"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information for BGP graceful\-restart
                            
                            .. attribute:: advertised
                            
                            	This leaf indicates whether the ability to support graceful\-restart has been advertised to the peer
                            	**type**\:  bool
                            
                            .. attribute:: enabled
                            
                            	This leaf indicates whether graceful\-restart is enabled for this AFI\-SAFI
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: received
                            
                            	This leaf indicates whether the neighbor advertised the ability to support graceful\-restart for this AFI\-SAFI
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "graceful-restart"

                                self.advertised = YLeaf(YType.boolean, "advertised")

                                self.enabled = YLeaf(YType.boolean, "enabled")

                                self.received = YLeaf(YType.boolean, "received")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("advertised",
                                                "enabled",
                                                "received") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.advertised.is_set or
                                    self.enabled.is_set or
                                    self.received.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.advertised.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set or
                                    self.received.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.advertised.is_set or self.advertised.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advertised.get_name_leafdata())
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())
                                if (self.received.is_set or self.received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.received.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "advertised" or name == "enabled" or name == "received"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "advertised"):
                                    self.advertised = value
                                    self.advertised.value_namespace = name_space
                                    self.advertised.value_namespace_prefix = name_space_prefix
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix
                                if(value_path == "received"):
                                    self.received = value
                                    self.received.value_namespace = name_space
                                    self.received.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "graceful-restart" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L2VpnEvpn(Entity):
                        """
                        BGP EVPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn, self).__init__()

                            self.yang_name = "l2vpn-evpn"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l2vpn-evpn"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l2vpn-evpn" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L3VpnIpv4Unicast(Entity):
                        """
                        Unicast IPv4 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast, self).__init__()

                            self.yang_name = "l3vpn-ipv4-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv4-unicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv4-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ipv4LabeledUnicast(Entity):
                        """
                        IPv4 Labeled Unicast configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast, self).__init__()

                            self.yang_name = "ipv4-labeled-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv4-labeled-unicast"

                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv4-labeled-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.afi_safi_name.is_set or
                            (self.apply_policy is not None and self.apply_policy.has_data()) or
                            (self.config is not None and self.config.has_data()) or
                            (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                            (self.ipv4_labeled_unicast is not None and self.ipv4_labeled_unicast.has_data()) or
                            (self.ipv4_unicast is not None and self.ipv4_unicast.has_data()) or
                            (self.ipv6_labeled_unicast is not None and self.ipv6_labeled_unicast.has_data()) or
                            (self.ipv6_unicast is not None and self.ipv6_unicast.has_data()) or
                            (self.l2vpn_evpn is not None and self.l2vpn_evpn.has_data()) or
                            (self.l2vpn_vpls is not None and self.l2vpn_vpls.has_data()) or
                            (self.l3vpn_ipv4_multicast is not None and self.l3vpn_ipv4_multicast.has_data()) or
                            (self.l3vpn_ipv4_unicast is not None and self.l3vpn_ipv4_unicast.has_data()) or
                            (self.l3vpn_ipv6_multicast is not None and self.l3vpn_ipv6_multicast.has_data()) or
                            (self.l3vpn_ipv6_unicast is not None and self.l3vpn_ipv6_unicast.has_data()) or
                            (self.state is not None and self.state.has_data()) or
                            (self.use_multiple_paths is not None and self.use_multiple_paths.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi_safi_name.yfilter != YFilter.not_set or
                            (self.apply_policy is not None and self.apply_policy.has_operation()) or
                            (self.config is not None and self.config.has_operation()) or
                            (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                            (self.ipv4_labeled_unicast is not None and self.ipv4_labeled_unicast.has_operation()) or
                            (self.ipv4_unicast is not None and self.ipv4_unicast.has_operation()) or
                            (self.ipv6_labeled_unicast is not None and self.ipv6_labeled_unicast.has_operation()) or
                            (self.ipv6_unicast is not None and self.ipv6_unicast.has_operation()) or
                            (self.l2vpn_evpn is not None and self.l2vpn_evpn.has_operation()) or
                            (self.l2vpn_vpls is not None and self.l2vpn_vpls.has_operation()) or
                            (self.l3vpn_ipv4_multicast is not None and self.l3vpn_ipv4_multicast.has_operation()) or
                            (self.l3vpn_ipv4_unicast is not None and self.l3vpn_ipv4_unicast.has_operation()) or
                            (self.l3vpn_ipv6_multicast is not None and self.l3vpn_ipv6_multicast.has_operation()) or
                            (self.l3vpn_ipv6_unicast is not None and self.l3vpn_ipv6_unicast.has_operation()) or
                            (self.state is not None and self.state.has_operation()) or
                            (self.use_multiple_paths is not None and self.use_multiple_paths.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "afi-safi" + "[afi-safi-name='" + self.afi_safi_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi_safi_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "apply-policy"):
                            if (self.apply_policy is None):
                                self.apply_policy = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.ApplyPolicy()
                                self.apply_policy.parent = self
                                self._children_name_map["apply_policy"] = "apply-policy"
                            return self.apply_policy

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "graceful-restart"):
                            if (self.graceful_restart is None):
                                self.graceful_restart = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.GracefulRestart()
                                self.graceful_restart.parent = self
                                self._children_name_map["graceful_restart"] = "graceful-restart"
                            return self.graceful_restart

                        if (child_yang_name == "ipv4-labeled-unicast"):
                            if (self.ipv4_labeled_unicast is None):
                                self.ipv4_labeled_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4LabeledUnicast()
                                self.ipv4_labeled_unicast.parent = self
                                self._children_name_map["ipv4_labeled_unicast"] = "ipv4-labeled-unicast"
                            return self.ipv4_labeled_unicast

                        if (child_yang_name == "ipv4-unicast"):
                            if (self.ipv4_unicast is None):
                                self.ipv4_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv4Unicast()
                                self.ipv4_unicast.parent = self
                                self._children_name_map["ipv4_unicast"] = "ipv4-unicast"
                            return self.ipv4_unicast

                        if (child_yang_name == "ipv6-labeled-unicast"):
                            if (self.ipv6_labeled_unicast is None):
                                self.ipv6_labeled_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6LabeledUnicast()
                                self.ipv6_labeled_unicast.parent = self
                                self._children_name_map["ipv6_labeled_unicast"] = "ipv6-labeled-unicast"
                            return self.ipv6_labeled_unicast

                        if (child_yang_name == "ipv6-unicast"):
                            if (self.ipv6_unicast is None):
                                self.ipv6_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.Ipv6Unicast()
                                self.ipv6_unicast.parent = self
                                self._children_name_map["ipv6_unicast"] = "ipv6-unicast"
                            return self.ipv6_unicast

                        if (child_yang_name == "l2vpn-evpn"):
                            if (self.l2vpn_evpn is None):
                                self.l2vpn_evpn = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnEvpn()
                                self.l2vpn_evpn.parent = self
                                self._children_name_map["l2vpn_evpn"] = "l2vpn-evpn"
                            return self.l2vpn_evpn

                        if (child_yang_name == "l2vpn-vpls"):
                            if (self.l2vpn_vpls is None):
                                self.l2vpn_vpls = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L2VpnVpls()
                                self.l2vpn_vpls.parent = self
                                self._children_name_map["l2vpn_vpls"] = "l2vpn-vpls"
                            return self.l2vpn_vpls

                        if (child_yang_name == "l3vpn-ipv4-multicast"):
                            if (self.l3vpn_ipv4_multicast is None):
                                self.l3vpn_ipv4_multicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Multicast()
                                self.l3vpn_ipv4_multicast.parent = self
                                self._children_name_map["l3vpn_ipv4_multicast"] = "l3vpn-ipv4-multicast"
                            return self.l3vpn_ipv4_multicast

                        if (child_yang_name == "l3vpn-ipv4-unicast"):
                            if (self.l3vpn_ipv4_unicast is None):
                                self.l3vpn_ipv4_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv4Unicast()
                                self.l3vpn_ipv4_unicast.parent = self
                                self._children_name_map["l3vpn_ipv4_unicast"] = "l3vpn-ipv4-unicast"
                            return self.l3vpn_ipv4_unicast

                        if (child_yang_name == "l3vpn-ipv6-multicast"):
                            if (self.l3vpn_ipv6_multicast is None):
                                self.l3vpn_ipv6_multicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Multicast()
                                self.l3vpn_ipv6_multicast.parent = self
                                self._children_name_map["l3vpn_ipv6_multicast"] = "l3vpn-ipv6-multicast"
                            return self.l3vpn_ipv6_multicast

                        if (child_yang_name == "l3vpn-ipv6-unicast"):
                            if (self.l3vpn_ipv6_unicast is None):
                                self.l3vpn_ipv6_unicast = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.L3VpnIpv6Unicast()
                                self.l3vpn_ipv6_unicast.parent = self
                                self._children_name_map["l3vpn_ipv6_unicast"] = "l3vpn-ipv6-unicast"
                            return self.l3vpn_ipv6_unicast

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        if (child_yang_name == "use-multiple-paths"):
                            if (self.use_multiple_paths is None):
                                self.use_multiple_paths = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi.UseMultiplePaths()
                                self.use_multiple_paths.parent = self
                                self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                            return self.use_multiple_paths

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "apply-policy" or name == "config" or name == "graceful-restart" or name == "ipv4-labeled-unicast" or name == "ipv4-unicast" or name == "ipv6-labeled-unicast" or name == "ipv6-unicast" or name == "l2vpn-evpn" or name == "l2vpn-vpls" or name == "l3vpn-ipv4-multicast" or name == "l3vpn-ipv4-unicast" or name == "l3vpn-ipv6-multicast" or name == "l3vpn-ipv6-unicast" or name == "state" or name == "use-multiple-paths" or name == "afi-safi-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi-safi-name"):
                            self.afi_safi_name = value
                            self.afi_safi_name.value_namespace = name_space
                            self.afi_safi_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.afi_safi:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.afi_safi:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "afi-safis" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "afi-safi"):
                        for c in self.afi_safi:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bgp.Neighbors.Neighbor.AfiSafis.AfiSafi()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.afi_safi.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "afi-safi"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class GracefulRestart(Entity):
                """
                Parameters relating the graceful restart mechanism for BGP
                
                .. attribute:: config
                
                	Configuration parameters relating to graceful\-restart
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.GracefulRestart.Config>`
                
                .. attribute:: state
                
                	State information associated with graceful\-restart
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.GracefulRestart.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.GracefulRestart, self).__init__()

                    self.yang_name = "graceful-restart"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.GracefulRestart.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.GracefulRestart.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to graceful\-restart
                    
                    .. attribute:: enabled
                    
                    	Enable or disable the graceful\-restart capability
                    	**type**\:  bool
                    
                    .. attribute:: helper_only
                    
                    	Enable graceful\-restart in helper mode only. When this leaf is set, the local system does not retain forwarding its own state during a restart, but supports procedures for the receiving speaker, as defined in RFC4724
                    	**type**\:  bool
                    
                    .. attribute:: restart_time
                    
                    	Estimated time (in seconds) for the local BGP speaker to restart a session. This value is advertise in the graceful restart BGP capability.  This is a 12\-bit value, referred to as Restart Time in RFC4724.  Per RFC4724, the suggested default value is <= the hold\-time value
                    	**type**\:  int
                    
                    	**range:** 0..4096
                    
                    .. attribute:: stale_routes_time
                    
                    	An upper\-bound on the time thate stale routes will be retained by a router after a session is restarted. If an End\-of\-RIB (EOR) marker is received prior to this timer expiring stale\-routes will be flushed upon its receipt \- if no EOR is received, then when this timer expires stale paths will be purged. This timer is referred to as the Selection\_Deferral\_Timer in RFC4724
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.GracefulRestart.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "graceful-restart"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.helper_only = YLeaf(YType.boolean, "helper-only")

                        self.restart_time = YLeaf(YType.uint16, "restart-time")

                        self.stale_routes_time = YLeaf(YType.str, "stale-routes-time")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "helper_only",
                                        "restart_time",
                                        "stale_routes_time") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.GracefulRestart.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.GracefulRestart.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.helper_only.is_set or
                            self.restart_time.is_set or
                            self.stale_routes_time.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.helper_only.yfilter != YFilter.not_set or
                            self.restart_time.yfilter != YFilter.not_set or
                            self.stale_routes_time.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.helper_only.is_set or self.helper_only.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.helper_only.get_name_leafdata())
                        if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.restart_time.get_name_leafdata())
                        if (self.stale_routes_time.is_set or self.stale_routes_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stale_routes_time.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "helper-only" or name == "restart-time" or name == "stale-routes-time"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "helper-only"):
                            self.helper_only = value
                            self.helper_only.value_namespace = name_space
                            self.helper_only.value_namespace_prefix = name_space_prefix
                        if(value_path == "restart-time"):
                            self.restart_time = value
                            self.restart_time.value_namespace = name_space
                            self.restart_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "stale-routes-time"):
                            self.stale_routes_time = value
                            self.stale_routes_time.value_namespace = name_space
                            self.stale_routes_time.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information associated with graceful\-restart
                    
                    .. attribute:: enabled
                    
                    	Enable or disable the graceful\-restart capability
                    	**type**\:  bool
                    
                    .. attribute:: helper_only
                    
                    	Enable graceful\-restart in helper mode only. When this leaf is set, the local system does not retain forwarding its own state during a restart, but supports procedures for the receiving speaker, as defined in RFC4724
                    	**type**\:  bool
                    
                    .. attribute:: local_restarting
                    
                    	This flag indicates whether the local neighbor is currently restarting. The flag is unset after all NLRI have been advertised to the peer, and the End\-of\-RIB (EOR) marker has been unset
                    	**type**\:  bool
                    
                    .. attribute:: mode
                    
                    	Ths leaf indicates the mode of operation of BGP graceful restart with the peer
                    	**type**\:   :py:class:`Mode <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.GracefulRestart.State.Mode>`
                    
                    .. attribute:: peer_restart_time
                    
                    	The period of time (advertised by the peer) that the peer expects a restart of a BGP session to take
                    	**type**\:  int
                    
                    	**range:** 0..4096
                    
                    .. attribute:: peer_restarting
                    
                    	This flag indicates whether the remote neighbor is currently in the process of restarting, and hence received routes are currently stale
                    	**type**\:  bool
                    
                    .. attribute:: restart_time
                    
                    	Estimated time (in seconds) for the local BGP speaker to restart a session. This value is advertise in the graceful restart BGP capability.  This is a 12\-bit value, referred to as Restart Time in RFC4724.  Per RFC4724, the suggested default value is <= the hold\-time value
                    	**type**\:  int
                    
                    	**range:** 0..4096
                    
                    .. attribute:: stale_routes_time
                    
                    	An upper\-bound on the time thate stale routes will be retained by a router after a session is restarted. If an End\-of\-RIB (EOR) marker is received prior to this timer expiring stale\-routes will be flushed upon its receipt \- if no EOR is received, then when this timer expires stale paths will be purged. This timer is referred to as the Selection\_Deferral\_Timer in RFC4724
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.GracefulRestart.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "graceful-restart"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.helper_only = YLeaf(YType.boolean, "helper-only")

                        self.local_restarting = YLeaf(YType.boolean, "local-restarting")

                        self.mode = YLeaf(YType.enumeration, "mode")

                        self.peer_restart_time = YLeaf(YType.uint16, "peer-restart-time")

                        self.peer_restarting = YLeaf(YType.boolean, "peer-restarting")

                        self.restart_time = YLeaf(YType.uint16, "restart-time")

                        self.stale_routes_time = YLeaf(YType.str, "stale-routes-time")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "helper_only",
                                        "local_restarting",
                                        "mode",
                                        "peer_restart_time",
                                        "peer_restarting",
                                        "restart_time",
                                        "stale_routes_time") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.GracefulRestart.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.GracefulRestart.State, self).__setattr__(name, value)

                    class Mode(Enum):
                        """
                        Mode

                        Ths leaf indicates the mode of operation of BGP graceful

                        restart with the peer

                        .. data:: HELPER_ONLY = 0

                        	The local router is operating in helper-only mode, and

                        	hence will not retain forwarding state during a local

                        	session restart, but will do so during a restart of the

                        	remote peer

                        .. data:: BILATERAL = 1

                        	The local router is operating in both helper mode, and

                        	hence retains forwarding state during a remote restart,

                        	and also maintains forwarding state during local session

                        	restart

                        .. data:: REMOTE_HELPER = 2

                        	The local system is able to retain routes during restart

                        	but the remote system is only able to act as a helper

                        """

                        HELPER_ONLY = Enum.YLeaf(0, "HELPER_ONLY")

                        BILATERAL = Enum.YLeaf(1, "BILATERAL")

                        REMOTE_HELPER = Enum.YLeaf(2, "REMOTE_HELPER")


                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.helper_only.is_set or
                            self.local_restarting.is_set or
                            self.mode.is_set or
                            self.peer_restart_time.is_set or
                            self.peer_restarting.is_set or
                            self.restart_time.is_set or
                            self.stale_routes_time.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.helper_only.yfilter != YFilter.not_set or
                            self.local_restarting.yfilter != YFilter.not_set or
                            self.mode.yfilter != YFilter.not_set or
                            self.peer_restart_time.yfilter != YFilter.not_set or
                            self.peer_restarting.yfilter != YFilter.not_set or
                            self.restart_time.yfilter != YFilter.not_set or
                            self.stale_routes_time.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.helper_only.is_set or self.helper_only.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.helper_only.get_name_leafdata())
                        if (self.local_restarting.is_set or self.local_restarting.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_restarting.get_name_leafdata())
                        if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mode.get_name_leafdata())
                        if (self.peer_restart_time.is_set or self.peer_restart_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_restart_time.get_name_leafdata())
                        if (self.peer_restarting.is_set or self.peer_restarting.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_restarting.get_name_leafdata())
                        if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.restart_time.get_name_leafdata())
                        if (self.stale_routes_time.is_set or self.stale_routes_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stale_routes_time.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "helper-only" or name == "local-restarting" or name == "mode" or name == "peer-restart-time" or name == "peer-restarting" or name == "restart-time" or name == "stale-routes-time"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "helper-only"):
                            self.helper_only = value
                            self.helper_only.value_namespace = name_space
                            self.helper_only.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-restarting"):
                            self.local_restarting = value
                            self.local_restarting.value_namespace = name_space
                            self.local_restarting.value_namespace_prefix = name_space_prefix
                        if(value_path == "mode"):
                            self.mode = value
                            self.mode.value_namespace = name_space
                            self.mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-restart-time"):
                            self.peer_restart_time = value
                            self.peer_restart_time.value_namespace = name_space
                            self.peer_restart_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-restarting"):
                            self.peer_restarting = value
                            self.peer_restarting.value_namespace = name_space
                            self.peer_restarting.value_namespace_prefix = name_space_prefix
                        if(value_path == "restart-time"):
                            self.restart_time = value
                            self.restart_time.value_namespace = name_space
                            self.restart_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "stale-routes-time"):
                            self.stale_routes_time = value
                            self.stale_routes_time.value_namespace = name_space
                            self.stale_routes_time.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "graceful-restart" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.GracefulRestart.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.GracefulRestart.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class State(Entity):
                """
                State information relating to the BGP neighbor
                
                .. attribute:: auth_password
                
                	Configures an MD5 authentication password for use with neighboring devices
                	**type**\:  str
                
                .. attribute:: description
                
                	An optional textual description (intended primarily for use with a peer or group
                	**type**\:  str
                
                .. attribute:: enabled
                
                	Whether the BGP peer is enabled. In cases where the enabled leaf is set to false, the local system should not initiate connections to the neighbor, and should not respond to TCP connections attempts from the neighbor. If the state of the BGP session is ESTABLISHED at the time that this leaf is set to false, the BGP session should be ceased
                	**type**\:  bool
                
                	**default value**\: true
                
                .. attribute:: established_transitions
                
                	Number of transitions to the Established state for the neighbor session.  This value is analogous to the bgpPeerFsmEstablishedTransitions object from the standard BGP\-4 MIB
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: last_established
                
                	This timestamp indicates the time that the BGP session last transitioned in or out of the Established state.  The value is the timestamp in seconds relative to the Unix Epoch (Jan 1, 1970 00\:00\:00 UTC). The BGP session uptime can be computed by clients as the difference between this value and the current time in UTC (assuming the session is in the ESTABLISHED state, per the session\-state leaf)
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: local_as
                
                	The local autonomous system number that is to be used when establishing sessions with the remote peer or peer group, if this differs from the global BGP router autonomous system number
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: messages
                
                	Counters for BGP messages sent and received from the neighbor
                	**type**\:   :py:class:`Messages <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.State.Messages>`
                
                .. attribute:: neighbor_address
                
                	Address of the BGP peer, either in IPv4 or IPv6
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: peer_as
                
                	AS number of the peer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_group
                
                	The peer\-group with which this neighbor is associated
                	**type**\:  str
                
                	**refers to**\:  :py:class:`peer_group_name <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup>`
                
                .. attribute:: peer_type
                
                	Explicitly designate the peer or peer group as internal (iBGP) or external (eBGP)
                	**type**\:   :py:class:`PeerType <ydk.models.openconfig.openconfig_bgp_types.PeerType>`
                
                .. attribute:: queues
                
                	Counters related to queued messages associated with the BGP neighbor
                	**type**\:   :py:class:`Queues <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.State.Queues>`
                
                .. attribute:: remove_private_as
                
                	Remove private AS numbers from updates sent to peers \- when this leaf is not specified, the AS\_PATH attribute should be sent to the peer unchanged
                	**type**\:   :py:class:`Remove_Private_As_Option <ydk.models.openconfig.openconfig_bgp_types.Remove_Private_As_Option>`
                
                .. attribute:: route_flap_damping
                
                	Enable route flap damping
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: send_community
                
                	Specify which types of community should be sent to the neighbor or group. The default is to not send the community attribute
                	**type**\:   :py:class:`CommunityType <ydk.models.openconfig.openconfig_bgp_types.CommunityType>`
                
                	**default value**\: NONE
                
                .. attribute:: session_state
                
                	Operational state of the BGP peer
                	**type**\:   :py:class:`SessionState <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.State.SessionState>`
                
                .. attribute:: supported_capabilities
                
                	BGP capabilities negotiated as supported with the peer
                	**type**\:  
                		list of  
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "neighbor"

                    self.auth_password = YLeaf(YType.str, "auth-password")

                    self.description = YLeaf(YType.str, "description")

                    self.enabled = YLeaf(YType.boolean, "enabled")

                    self.established_transitions = YLeaf(YType.uint64, "established-transitions")

                    self.last_established = YLeaf(YType.uint64, "last-established")

                    self.local_as = YLeaf(YType.uint32, "local-as")

                    self.neighbor_address = YLeaf(YType.str, "neighbor-address")

                    self.peer_as = YLeaf(YType.uint32, "peer-as")

                    self.peer_group = YLeaf(YType.str, "peer-group")

                    self.peer_type = YLeaf(YType.enumeration, "peer-type")

                    self.remove_private_as = YLeaf(YType.identityref, "remove-private-as")

                    self.route_flap_damping = YLeaf(YType.boolean, "route-flap-damping")

                    self.send_community = YLeaf(YType.enumeration, "send-community")

                    self.session_state = YLeaf(YType.enumeration, "session-state")

                    self.supported_capabilities = YLeafList(YType.identityref, "supported-capabilities")

                    self.messages = Bgp.Neighbors.Neighbor.State.Messages()
                    self.messages.parent = self
                    self._children_name_map["messages"] = "messages"
                    self._children_yang_names.add("messages")

                    self.queues = Bgp.Neighbors.Neighbor.State.Queues()
                    self.queues.parent = self
                    self._children_name_map["queues"] = "queues"
                    self._children_yang_names.add("queues")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("auth_password",
                                    "description",
                                    "enabled",
                                    "established_transitions",
                                    "last_established",
                                    "local_as",
                                    "neighbor_address",
                                    "peer_as",
                                    "peer_group",
                                    "peer_type",
                                    "remove_private_as",
                                    "route_flap_damping",
                                    "send_community",
                                    "session_state",
                                    "supported_capabilities") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.Neighbors.Neighbor.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.Neighbors.Neighbor.State, self).__setattr__(name, value)

                class SessionState(Enum):
                    """
                    SessionState

                    Operational state of the BGP peer

                    .. data:: IDLE = 0

                    	neighbor is down, and in the Idle state of the

                    	FSM

                    .. data:: CONNECT = 1

                    	neighbor is down, and the session is waiting for

                    	the underlying transport session to be established

                    .. data:: ACTIVE = 2

                    	neighbor is down, and the local system is awaiting

                    	a conncetion from the remote peer

                    .. data:: OPENSENT = 3

                    	neighbor is in the process of being established.

                    	The local system has sent an OPEN message

                    .. data:: OPENCONFIRM = 4

                    	neighbor is in the process of being established.

                    	The local system is awaiting a NOTIFICATION or

                    	KEEPALIVE message

                    .. data:: ESTABLISHED = 5

                    	neighbor is up - the BGP session with the peer is

                    	established

                    """

                    IDLE = Enum.YLeaf(0, "IDLE")

                    CONNECT = Enum.YLeaf(1, "CONNECT")

                    ACTIVE = Enum.YLeaf(2, "ACTIVE")

                    OPENSENT = Enum.YLeaf(3, "OPENSENT")

                    OPENCONFIRM = Enum.YLeaf(4, "OPENCONFIRM")

                    ESTABLISHED = Enum.YLeaf(5, "ESTABLISHED")



                class Messages(Entity):
                    """
                    Counters for BGP messages sent and received from the
                    neighbor
                    
                    .. attribute:: received
                    
                    	Counters for BGP messages received from the neighbor
                    	**type**\:   :py:class:`Received <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.State.Messages.Received>`
                    
                    .. attribute:: sent
                    
                    	Counters relating to BGP messages sent to the neighbor
                    	**type**\:   :py:class:`Sent <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.State.Messages.Sent>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.State.Messages, self).__init__()

                        self.yang_name = "messages"
                        self.yang_parent_name = "state"

                        self.received = Bgp.Neighbors.Neighbor.State.Messages.Received()
                        self.received.parent = self
                        self._children_name_map["received"] = "received"
                        self._children_yang_names.add("received")

                        self.sent = Bgp.Neighbors.Neighbor.State.Messages.Sent()
                        self.sent.parent = self
                        self._children_name_map["sent"] = "sent"
                        self._children_yang_names.add("sent")


                    class Sent(Entity):
                        """
                        Counters relating to BGP messages sent to the neighbor
                        
                        .. attribute:: notification
                        
                        	Number of BGP NOTIFICATION messages indicating an error condition has occurred exchanged
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: update
                        
                        	Number of BGP UPDATE messages announcing, withdrawing or modifying paths exchanged
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.State.Messages.Sent, self).__init__()

                            self.yang_name = "sent"
                            self.yang_parent_name = "messages"

                            self.notification = YLeaf(YType.uint64, "NOTIFICATION")

                            self.update = YLeaf(YType.uint64, "UPDATE")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("notification",
                                            "update") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Neighbors.Neighbor.State.Messages.Sent, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Neighbors.Neighbor.State.Messages.Sent, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.notification.is_set or
                                self.update.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.notification.yfilter != YFilter.not_set or
                                self.update.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sent" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.notification.is_set or self.notification.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.notification.get_name_leafdata())
                            if (self.update.is_set or self.update.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.update.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "NOTIFICATION" or name == "UPDATE"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "NOTIFICATION"):
                                self.notification = value
                                self.notification.value_namespace = name_space
                                self.notification.value_namespace_prefix = name_space_prefix
                            if(value_path == "UPDATE"):
                                self.update = value
                                self.update.value_namespace = name_space
                                self.update.value_namespace_prefix = name_space_prefix


                    class Received(Entity):
                        """
                        Counters for BGP messages received from the neighbor
                        
                        .. attribute:: notification
                        
                        	Number of BGP NOTIFICATION messages indicating an error condition has occurred exchanged
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: update
                        
                        	Number of BGP UPDATE messages announcing, withdrawing or modifying paths exchanged
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.State.Messages.Received, self).__init__()

                            self.yang_name = "received"
                            self.yang_parent_name = "messages"

                            self.notification = YLeaf(YType.uint64, "NOTIFICATION")

                            self.update = YLeaf(YType.uint64, "UPDATE")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("notification",
                                            "update") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Neighbors.Neighbor.State.Messages.Received, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Neighbors.Neighbor.State.Messages.Received, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.notification.is_set or
                                self.update.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.notification.yfilter != YFilter.not_set or
                                self.update.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "received" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.notification.is_set or self.notification.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.notification.get_name_leafdata())
                            if (self.update.is_set or self.update.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.update.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "NOTIFICATION" or name == "UPDATE"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "NOTIFICATION"):
                                self.notification = value
                                self.notification.value_namespace = name_space
                                self.notification.value_namespace_prefix = name_space_prefix
                            if(value_path == "UPDATE"):
                                self.update = value
                                self.update.value_namespace = name_space
                                self.update.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.received is not None and self.received.has_data()) or
                            (self.sent is not None and self.sent.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.received is not None and self.received.has_operation()) or
                            (self.sent is not None and self.sent.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "messages" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "received"):
                            if (self.received is None):
                                self.received = Bgp.Neighbors.Neighbor.State.Messages.Received()
                                self.received.parent = self
                                self._children_name_map["received"] = "received"
                            return self.received

                        if (child_yang_name == "sent"):
                            if (self.sent is None):
                                self.sent = Bgp.Neighbors.Neighbor.State.Messages.Sent()
                                self.sent.parent = self
                                self._children_name_map["sent"] = "sent"
                            return self.sent

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "received" or name == "sent"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Queues(Entity):
                    """
                    Counters related to queued messages associated with the
                    BGP neighbor
                    
                    .. attribute:: input
                    
                    	The number of messages received from the peer currently queued
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output
                    
                    	The number of messages queued to be sent to the peer
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.State.Queues, self).__init__()

                        self.yang_name = "queues"
                        self.yang_parent_name = "state"

                        self.input = YLeaf(YType.uint32, "input")

                        self.output = YLeaf(YType.uint32, "output")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("input",
                                        "output") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.State.Queues, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.State.Queues, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.input.is_set or
                            self.output.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.input.yfilter != YFilter.not_set or
                            self.output.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "queues" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.input.is_set or self.input.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input.get_name_leafdata())
                        if (self.output.is_set or self.output.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "input" or name == "output"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "input"):
                            self.input = value
                            self.input.value_namespace = name_space
                            self.input.value_namespace_prefix = name_space_prefix
                        if(value_path == "output"):
                            self.output = value
                            self.output.value_namespace = name_space
                            self.output.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for leaf in self.supported_capabilities.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.auth_password.is_set or
                        self.description.is_set or
                        self.enabled.is_set or
                        self.established_transitions.is_set or
                        self.last_established.is_set or
                        self.local_as.is_set or
                        self.neighbor_address.is_set or
                        self.peer_as.is_set or
                        self.peer_group.is_set or
                        self.peer_type.is_set or
                        self.remove_private_as.is_set or
                        self.route_flap_damping.is_set or
                        self.send_community.is_set or
                        self.session_state.is_set or
                        (self.messages is not None and self.messages.has_data()) or
                        (self.queues is not None and self.queues.has_data()))

                def has_operation(self):
                    for leaf in self.supported_capabilities.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.auth_password.yfilter != YFilter.not_set or
                        self.description.yfilter != YFilter.not_set or
                        self.enabled.yfilter != YFilter.not_set or
                        self.established_transitions.yfilter != YFilter.not_set or
                        self.last_established.yfilter != YFilter.not_set or
                        self.local_as.yfilter != YFilter.not_set or
                        self.neighbor_address.yfilter != YFilter.not_set or
                        self.peer_as.yfilter != YFilter.not_set or
                        self.peer_group.yfilter != YFilter.not_set or
                        self.peer_type.yfilter != YFilter.not_set or
                        self.remove_private_as.yfilter != YFilter.not_set or
                        self.route_flap_damping.yfilter != YFilter.not_set or
                        self.send_community.yfilter != YFilter.not_set or
                        self.session_state.yfilter != YFilter.not_set or
                        self.supported_capabilities.yfilter != YFilter.not_set or
                        (self.messages is not None and self.messages.has_operation()) or
                        (self.queues is not None and self.queues.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.auth_password.is_set or self.auth_password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.auth_password.get_name_leafdata())
                    if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.description.get_name_leafdata())
                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enabled.get_name_leafdata())
                    if (self.established_transitions.is_set or self.established_transitions.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.established_transitions.get_name_leafdata())
                    if (self.last_established.is_set or self.last_established.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.last_established.get_name_leafdata())
                    if (self.local_as.is_set or self.local_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_as.get_name_leafdata())
                    if (self.neighbor_address.is_set or self.neighbor_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.neighbor_address.get_name_leafdata())
                    if (self.peer_as.is_set or self.peer_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_as.get_name_leafdata())
                    if (self.peer_group.is_set or self.peer_group.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_group.get_name_leafdata())
                    if (self.peer_type.is_set or self.peer_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_type.get_name_leafdata())
                    if (self.remove_private_as.is_set or self.remove_private_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remove_private_as.get_name_leafdata())
                    if (self.route_flap_damping.is_set or self.route_flap_damping.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_flap_damping.get_name_leafdata())
                    if (self.send_community.is_set or self.send_community.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.send_community.get_name_leafdata())
                    if (self.session_state.is_set or self.session_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_state.get_name_leafdata())

                    leaf_name_data.extend(self.supported_capabilities.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "messages"):
                        if (self.messages is None):
                            self.messages = Bgp.Neighbors.Neighbor.State.Messages()
                            self.messages.parent = self
                            self._children_name_map["messages"] = "messages"
                        return self.messages

                    if (child_yang_name == "queues"):
                        if (self.queues is None):
                            self.queues = Bgp.Neighbors.Neighbor.State.Queues()
                            self.queues.parent = self
                            self._children_name_map["queues"] = "queues"
                        return self.queues

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "messages" or name == "queues" or name == "auth-password" or name == "description" or name == "enabled" or name == "established-transitions" or name == "last-established" or name == "local-as" or name == "neighbor-address" or name == "peer-as" or name == "peer-group" or name == "peer-type" or name == "remove-private-as" or name == "route-flap-damping" or name == "send-community" or name == "session-state" or name == "supported-capabilities"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "auth-password"):
                        self.auth_password = value
                        self.auth_password.value_namespace = name_space
                        self.auth_password.value_namespace_prefix = name_space_prefix
                    if(value_path == "description"):
                        self.description = value
                        self.description.value_namespace = name_space
                        self.description.value_namespace_prefix = name_space_prefix
                    if(value_path == "enabled"):
                        self.enabled = value
                        self.enabled.value_namespace = name_space
                        self.enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "established-transitions"):
                        self.established_transitions = value
                        self.established_transitions.value_namespace = name_space
                        self.established_transitions.value_namespace_prefix = name_space_prefix
                    if(value_path == "last-established"):
                        self.last_established = value
                        self.last_established.value_namespace = name_space
                        self.last_established.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-as"):
                        self.local_as = value
                        self.local_as.value_namespace = name_space
                        self.local_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "neighbor-address"):
                        self.neighbor_address = value
                        self.neighbor_address.value_namespace = name_space
                        self.neighbor_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-as"):
                        self.peer_as = value
                        self.peer_as.value_namespace = name_space
                        self.peer_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-group"):
                        self.peer_group = value
                        self.peer_group.value_namespace = name_space
                        self.peer_group.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-type"):
                        self.peer_type = value
                        self.peer_type.value_namespace = name_space
                        self.peer_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "remove-private-as"):
                        self.remove_private_as = value
                        self.remove_private_as.value_namespace = name_space
                        self.remove_private_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "route-flap-damping"):
                        self.route_flap_damping = value
                        self.route_flap_damping.value_namespace = name_space
                        self.route_flap_damping.value_namespace_prefix = name_space_prefix
                    if(value_path == "send-community"):
                        self.send_community = value
                        self.send_community.value_namespace = name_space
                        self.send_community.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-state"):
                        self.session_state = value
                        self.session_state.value_namespace = name_space
                        self.session_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "supported-capabilities"):
                        identity = Identity(name_space, name_space_prefix, value)
                        self.supported_capabilities.append(identity)


            class Timers(Entity):
                """
                Timers related to a BGP neighbor
                
                .. attribute:: config
                
                	Configuration parameters relating to timers used for the BGP neighbor
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.Timers.Config>`
                
                .. attribute:: state
                
                	State information relating to the timers used for the BGP neighbor
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.Timers.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.Timers, self).__init__()

                    self.yang_name = "timers"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.Timers.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.Timers.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to timers used for the
                    BGP neighbor
                    
                    .. attribute:: connect_retry
                    
                    	Time interval in seconds between attempts to establish a session with the peer
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: hold_time
                    
                    	Time interval in seconds that a BGP session will be considered active in the absence of keepalive or other messages from the peer.  The hold\-time is typically set to 3x the keepalive\-interval
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 90
                    
                    .. attribute:: keepalive_interval
                    
                    	Time interval in seconds between transmission of keepalive messages to the neighbor.  Typically set to 1/3 the hold\-time
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: minimum_advertisement_interval
                    
                    	Minimum time which must elapse between subsequent UPDATE messages relating to a common set of NLRI being transmitted to a peer. This timer is referred to as MinRouteAdvertisementIntervalTimer by RFC 4721 and serves to reduce the number of UPDATE messages transmitted when a particular set of NLRI exhibit instability
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.Timers.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "timers"

                        self.connect_retry = YLeaf(YType.str, "connect-retry")

                        self.hold_time = YLeaf(YType.str, "hold-time")

                        self.keepalive_interval = YLeaf(YType.str, "keepalive-interval")

                        self.minimum_advertisement_interval = YLeaf(YType.str, "minimum-advertisement-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("connect_retry",
                                        "hold_time",
                                        "keepalive_interval",
                                        "minimum_advertisement_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.Timers.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.Timers.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.connect_retry.is_set or
                            self.hold_time.is_set or
                            self.keepalive_interval.is_set or
                            self.minimum_advertisement_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.connect_retry.yfilter != YFilter.not_set or
                            self.hold_time.yfilter != YFilter.not_set or
                            self.keepalive_interval.yfilter != YFilter.not_set or
                            self.minimum_advertisement_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.connect_retry.is_set or self.connect_retry.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connect_retry.get_name_leafdata())
                        if (self.hold_time.is_set or self.hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_time.get_name_leafdata())
                        if (self.keepalive_interval.is_set or self.keepalive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_interval.get_name_leafdata())
                        if (self.minimum_advertisement_interval.is_set or self.minimum_advertisement_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum_advertisement_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "connect-retry" or name == "hold-time" or name == "keepalive-interval" or name == "minimum-advertisement-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "connect-retry"):
                            self.connect_retry = value
                            self.connect_retry.value_namespace = name_space
                            self.connect_retry.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-time"):
                            self.hold_time = value
                            self.hold_time.value_namespace = name_space
                            self.hold_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-interval"):
                            self.keepalive_interval = value
                            self.keepalive_interval.value_namespace = name_space
                            self.keepalive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum-advertisement-interval"):
                            self.minimum_advertisement_interval = value
                            self.minimum_advertisement_interval.value_namespace = name_space
                            self.minimum_advertisement_interval.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to the timers used for the BGP
                    neighbor
                    
                    .. attribute:: connect_retry
                    
                    	Time interval in seconds between attempts to establish a session with the peer
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: hold_time
                    
                    	Time interval in seconds that a BGP session will be considered active in the absence of keepalive or other messages from the peer.  The hold\-time is typically set to 3x the keepalive\-interval
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 90
                    
                    .. attribute:: keepalive_interval
                    
                    	Time interval in seconds between transmission of keepalive messages to the neighbor.  Typically set to 1/3 the hold\-time
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: minimum_advertisement_interval
                    
                    	Minimum time which must elapse between subsequent UPDATE messages relating to a common set of NLRI being transmitted to a peer. This timer is referred to as MinRouteAdvertisementIntervalTimer by RFC 4721 and serves to reduce the number of UPDATE messages transmitted when a particular set of NLRI exhibit instability
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: negotiated_hold_time
                    
                    	The negotiated hold\-time for the BGP session
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.Timers.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "timers"

                        self.connect_retry = YLeaf(YType.str, "connect-retry")

                        self.hold_time = YLeaf(YType.str, "hold-time")

                        self.keepalive_interval = YLeaf(YType.str, "keepalive-interval")

                        self.minimum_advertisement_interval = YLeaf(YType.str, "minimum-advertisement-interval")

                        self.negotiated_hold_time = YLeaf(YType.str, "negotiated-hold-time")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("connect_retry",
                                        "hold_time",
                                        "keepalive_interval",
                                        "minimum_advertisement_interval",
                                        "negotiated_hold_time") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.Timers.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.Timers.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.connect_retry.is_set or
                            self.hold_time.is_set or
                            self.keepalive_interval.is_set or
                            self.minimum_advertisement_interval.is_set or
                            self.negotiated_hold_time.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.connect_retry.yfilter != YFilter.not_set or
                            self.hold_time.yfilter != YFilter.not_set or
                            self.keepalive_interval.yfilter != YFilter.not_set or
                            self.minimum_advertisement_interval.yfilter != YFilter.not_set or
                            self.negotiated_hold_time.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.connect_retry.is_set or self.connect_retry.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connect_retry.get_name_leafdata())
                        if (self.hold_time.is_set or self.hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_time.get_name_leafdata())
                        if (self.keepalive_interval.is_set or self.keepalive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_interval.get_name_leafdata())
                        if (self.minimum_advertisement_interval.is_set or self.minimum_advertisement_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum_advertisement_interval.get_name_leafdata())
                        if (self.negotiated_hold_time.is_set or self.negotiated_hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_hold_time.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "connect-retry" or name == "hold-time" or name == "keepalive-interval" or name == "minimum-advertisement-interval" or name == "negotiated-hold-time"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "connect-retry"):
                            self.connect_retry = value
                            self.connect_retry.value_namespace = name_space
                            self.connect_retry.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-time"):
                            self.hold_time = value
                            self.hold_time.value_namespace = name_space
                            self.hold_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-interval"):
                            self.keepalive_interval = value
                            self.keepalive_interval.value_namespace = name_space
                            self.keepalive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum-advertisement-interval"):
                            self.minimum_advertisement_interval = value
                            self.minimum_advertisement_interval.value_namespace = name_space
                            self.minimum_advertisement_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-hold-time"):
                            self.negotiated_hold_time = value
                            self.negotiated_hold_time.value_namespace = name_space
                            self.negotiated_hold_time.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "timers" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.Timers.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.Timers.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class ApplyPolicy(Entity):
                """
                Anchor point for routing policies in the model.
                Import and export policies are with respect to the local
                routing table, i.e., export (send) and import (receive),
                depending on the context.
                
                .. attribute:: config
                
                	Policy configuration data
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.ApplyPolicy.Config>`
                
                .. attribute:: state
                
                	Operational state for routing policy
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.ApplyPolicy.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.ApplyPolicy, self).__init__()

                    self.yang_name = "apply-policy"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.ApplyPolicy.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.ApplyPolicy.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Policy configuration data.
                    
                    .. attribute:: default_export_policy
                    
                    	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: default_import_policy
                    
                    	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: export_policy
                    
                    	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: import_policy
                    
                    	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.ApplyPolicy.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "apply-policy"

                        self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                        self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                        self.export_policy = YLeafList(YType.str, "export-policy")

                        self.import_policy = YLeafList(YType.str, "import-policy")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("default_export_policy",
                                        "default_import_policy",
                                        "export_policy",
                                        "import_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.ApplyPolicy.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.ApplyPolicy.Config, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.default_export_policy.is_set or
                            self.default_import_policy.is_set)

                    def has_operation(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.default_export_policy.yfilter != YFilter.not_set or
                            self.default_import_policy.yfilter != YFilter.not_set or
                            self.export_policy.yfilter != YFilter.not_set or
                            self.import_policy.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                        if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                        leaf_name_data.extend(self.export_policy.get_name_leafdata())

                        leaf_name_data.extend(self.import_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "default-export-policy"):
                            self.default_export_policy = value
                            self.default_export_policy.value_namespace = name_space
                            self.default_export_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "default-import-policy"):
                            self.default_import_policy = value
                            self.default_import_policy.value_namespace = name_space
                            self.default_import_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "export-policy"):
                            self.export_policy.append(value)
                        if(value_path == "import-policy"):
                            self.import_policy.append(value)


                class State(Entity):
                    """
                    Operational state for routing policy
                    
                    .. attribute:: default_export_policy
                    
                    	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: default_import_policy
                    
                    	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: export_policy
                    
                    	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: import_policy
                    
                    	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.ApplyPolicy.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "apply-policy"

                        self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                        self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                        self.export_policy = YLeafList(YType.str, "export-policy")

                        self.import_policy = YLeafList(YType.str, "import-policy")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("default_export_policy",
                                        "default_import_policy",
                                        "export_policy",
                                        "import_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.ApplyPolicy.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.ApplyPolicy.State, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.default_export_policy.is_set or
                            self.default_import_policy.is_set)

                    def has_operation(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.default_export_policy.yfilter != YFilter.not_set or
                            self.default_import_policy.yfilter != YFilter.not_set or
                            self.export_policy.yfilter != YFilter.not_set or
                            self.import_policy.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                        if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                        leaf_name_data.extend(self.export_policy.get_name_leafdata())

                        leaf_name_data.extend(self.import_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "default-export-policy"):
                            self.default_export_policy = value
                            self.default_export_policy.value_namespace = name_space
                            self.default_export_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "default-import-policy"):
                            self.default_import_policy = value
                            self.default_import_policy.value_namespace = name_space
                            self.default_import_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "export-policy"):
                            self.export_policy.append(value)
                        if(value_path == "import-policy"):
                            self.import_policy.append(value)

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "apply-policy" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.ApplyPolicy.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.ApplyPolicy.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Transport(Entity):
                """
                Transport session parameters for the BGP neighbor
                
                .. attribute:: config
                
                	Configuration parameters relating to the transport session(s) used for the BGP neighbor
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.Transport.Config>`
                
                .. attribute:: state
                
                	State information relating to the transport session(s) used for the BGP neighbor
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.Transport.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.Transport, self).__init__()

                    self.yang_name = "transport"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.Transport.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.Transport.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to the transport
                    session(s) used for the BGP neighbor
                    
                    .. attribute:: local_address
                    
                    	Set the local IP (either IPv4 or IPv6) address to use for the session when sending BGP update messages.  This may be expressed as either an IP address or reference to the name of an interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    
                    ----
                    	**type**\:  str
                    
                    
                    ----
                    .. attribute:: mtu_discovery
                    
                    	Turns path mtu discovery for BGP TCP sessions on (true) or off (false)
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: passive_mode
                    
                    	Wait for peers to issue requests to open a BGP session, rather than initiating sessions from the local router
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: tcp_mss
                    
                    	Sets the max segment size for BGP TCP sessions
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.Transport.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "transport"

                        self.local_address = YLeaf(YType.str, "local-address")

                        self.mtu_discovery = YLeaf(YType.boolean, "mtu-discovery")

                        self.passive_mode = YLeaf(YType.boolean, "passive-mode")

                        self.tcp_mss = YLeaf(YType.uint16, "tcp-mss")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("local_address",
                                        "mtu_discovery",
                                        "passive_mode",
                                        "tcp_mss") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.Transport.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.Transport.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.local_address.is_set or
                            self.mtu_discovery.is_set or
                            self.passive_mode.is_set or
                            self.tcp_mss.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.local_address.yfilter != YFilter.not_set or
                            self.mtu_discovery.yfilter != YFilter.not_set or
                            self.passive_mode.yfilter != YFilter.not_set or
                            self.tcp_mss.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_address.get_name_leafdata())
                        if (self.mtu_discovery.is_set or self.mtu_discovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu_discovery.get_name_leafdata())
                        if (self.passive_mode.is_set or self.passive_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.passive_mode.get_name_leafdata())
                        if (self.tcp_mss.is_set or self.tcp_mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_mss.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "local-address" or name == "mtu-discovery" or name == "passive-mode" or name == "tcp-mss"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "local-address"):
                            self.local_address = value
                            self.local_address.value_namespace = name_space
                            self.local_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu-discovery"):
                            self.mtu_discovery = value
                            self.mtu_discovery.value_namespace = name_space
                            self.mtu_discovery.value_namespace_prefix = name_space_prefix
                        if(value_path == "passive-mode"):
                            self.passive_mode = value
                            self.passive_mode.value_namespace = name_space
                            self.passive_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-mss"):
                            self.tcp_mss = value
                            self.tcp_mss.value_namespace = name_space
                            self.tcp_mss.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to the transport session(s)
                    used for the BGP neighbor
                    
                    .. attribute:: local_address
                    
                    	Set the local IP (either IPv4 or IPv6) address to use for the session when sending BGP update messages.  This may be expressed as either an IP address or reference to the name of an interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    
                    ----
                    	**type**\:  str
                    
                    
                    ----
                    .. attribute:: local_port
                    
                    	Local TCP port being used for the TCP session supporting the BGP session
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: mtu_discovery
                    
                    	Turns path mtu discovery for BGP TCP sessions on (true) or off (false)
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: passive_mode
                    
                    	Wait for peers to issue requests to open a BGP session, rather than initiating sessions from the local router
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: remote_address
                    
                    	Remote address to which the BGP session has been established
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: remote_port
                    
                    	Remote port being used by the peer for the TCP session supporting the BGP session
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: tcp_mss
                    
                    	Sets the max segment size for BGP TCP sessions
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.Transport.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "transport"

                        self.local_address = YLeaf(YType.str, "local-address")

                        self.local_port = YLeaf(YType.uint16, "local-port")

                        self.mtu_discovery = YLeaf(YType.boolean, "mtu-discovery")

                        self.passive_mode = YLeaf(YType.boolean, "passive-mode")

                        self.remote_address = YLeaf(YType.str, "remote-address")

                        self.remote_port = YLeaf(YType.uint16, "remote-port")

                        self.tcp_mss = YLeaf(YType.uint16, "tcp-mss")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("local_address",
                                        "local_port",
                                        "mtu_discovery",
                                        "passive_mode",
                                        "remote_address",
                                        "remote_port",
                                        "tcp_mss") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.Transport.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.Transport.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.local_address.is_set or
                            self.local_port.is_set or
                            self.mtu_discovery.is_set or
                            self.passive_mode.is_set or
                            self.remote_address.is_set or
                            self.remote_port.is_set or
                            self.tcp_mss.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.local_address.yfilter != YFilter.not_set or
                            self.local_port.yfilter != YFilter.not_set or
                            self.mtu_discovery.yfilter != YFilter.not_set or
                            self.passive_mode.yfilter != YFilter.not_set or
                            self.remote_address.yfilter != YFilter.not_set or
                            self.remote_port.yfilter != YFilter.not_set or
                            self.tcp_mss.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_address.get_name_leafdata())
                        if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_port.get_name_leafdata())
                        if (self.mtu_discovery.is_set or self.mtu_discovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu_discovery.get_name_leafdata())
                        if (self.passive_mode.is_set or self.passive_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.passive_mode.get_name_leafdata())
                        if (self.remote_address.is_set or self.remote_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_address.get_name_leafdata())
                        if (self.remote_port.is_set or self.remote_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_port.get_name_leafdata())
                        if (self.tcp_mss.is_set or self.tcp_mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_mss.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "local-address" or name == "local-port" or name == "mtu-discovery" or name == "passive-mode" or name == "remote-address" or name == "remote-port" or name == "tcp-mss"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "local-address"):
                            self.local_address = value
                            self.local_address.value_namespace = name_space
                            self.local_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-port"):
                            self.local_port = value
                            self.local_port.value_namespace = name_space
                            self.local_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu-discovery"):
                            self.mtu_discovery = value
                            self.mtu_discovery.value_namespace = name_space
                            self.mtu_discovery.value_namespace_prefix = name_space_prefix
                        if(value_path == "passive-mode"):
                            self.passive_mode = value
                            self.passive_mode.value_namespace = name_space
                            self.passive_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-address"):
                            self.remote_address = value
                            self.remote_address.value_namespace = name_space
                            self.remote_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-port"):
                            self.remote_port = value
                            self.remote_port.value_namespace = name_space
                            self.remote_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-mss"):
                            self.tcp_mss = value
                            self.tcp_mss.value_namespace = name_space
                            self.tcp_mss.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "transport" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.Transport.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.Transport.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class UseMultiplePaths(Entity):
                """
                Parameters related to the use of multiple\-paths for the same
                NLRI when they are received only from this neighbor
                
                .. attribute:: config
                
                	Configuration parameters relating to multipath
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.UseMultiplePaths.Config>`
                
                .. attribute:: ebgp
                
                	Multipath configuration for eBGP
                	**type**\:   :py:class:`Ebgp <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp>`
                
                .. attribute:: state
                
                	State parameters relating to multipath
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.UseMultiplePaths.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.UseMultiplePaths, self).__init__()

                    self.yang_name = "use-multiple-paths"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.UseMultiplePaths.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.ebgp = Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp()
                    self.ebgp.parent = self
                    self._children_name_map["ebgp"] = "ebgp"
                    self._children_yang_names.add("ebgp")

                    self.state = Bgp.Neighbors.Neighbor.UseMultiplePaths.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to multipath
                    
                    .. attribute:: enabled
                    
                    	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "use-multiple-paths"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.enabled.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State parameters relating to multipath
                    
                    .. attribute:: enabled
                    
                    	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.UseMultiplePaths.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "use-multiple-paths"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.UseMultiplePaths.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.UseMultiplePaths.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.enabled.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix


                class Ebgp(Entity):
                    """
                    Multipath configuration for eBGP
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to eBGP multipath
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.Config>`
                    
                    .. attribute:: state
                    
                    	State information relating to eBGP multipath
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp, self).__init__()

                        self.yang_name = "ebgp"
                        self.yang_parent_name = "use-multiple-paths"

                        self.config = Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to eBGP multipath
                        
                        .. attribute:: allow_multiple_as
                        
                        	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "ebgp"

                            self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("allow_multiple_as") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.allow_multiple_as.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.allow_multiple_as.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "allow-multiple-as"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "allow-multiple-as"):
                                self.allow_multiple_as = value
                                self.allow_multiple_as.value_namespace = name_space
                                self.allow_multiple_as.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information relating to eBGP multipath
                        
                        .. attribute:: allow_multiple_as
                        
                        	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "ebgp"

                            self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("allow_multiple_as") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.allow_multiple_as.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.allow_multiple_as.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "allow-multiple-as"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "allow-multiple-as"):
                                self.allow_multiple_as = value
                                self.allow_multiple_as.value_namespace = name_space
                                self.allow_multiple_as.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ebgp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.ebgp is not None and self.ebgp.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.ebgp is not None and self.ebgp.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "use-multiple-paths" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.UseMultiplePaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "ebgp"):
                        if (self.ebgp is None):
                            self.ebgp = Bgp.Neighbors.Neighbor.UseMultiplePaths.Ebgp()
                            self.ebgp.parent = self
                            self._children_name_map["ebgp"] = "ebgp"
                        return self.ebgp

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.UseMultiplePaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "ebgp" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class RouteReflector(Entity):
                """
                Route reflector parameters for the BGPgroup
                
                .. attribute:: config
                
                	Configuraton parameters relating to route reflection for the BGPgroup
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.RouteReflector.Config>`
                
                .. attribute:: state
                
                	State information relating to route reflection for the BGPgroup
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.RouteReflector.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.RouteReflector, self).__init__()

                    self.yang_name = "route-reflector"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.RouteReflector.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.RouteReflector.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuraton parameters relating to route reflection
                    for the BGPgroup
                    
                    .. attribute:: route_reflector_client
                    
                    	Configure the neighbor as a route reflector client
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: route_reflector_cluster_id
                    
                    	route\-reflector cluster id to use when local router is configured as a route reflector.  Commonly set at the group level, but allows a different cluster id to be set for each neighbor
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.RouteReflector.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "route-reflector"

                        self.route_reflector_client = YLeaf(YType.boolean, "route-reflector-client")

                        self.route_reflector_cluster_id = YLeaf(YType.str, "route-reflector-cluster-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("route_reflector_client",
                                        "route_reflector_cluster_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.RouteReflector.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.RouteReflector.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.route_reflector_client.is_set or
                            self.route_reflector_cluster_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.route_reflector_client.yfilter != YFilter.not_set or
                            self.route_reflector_cluster_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.route_reflector_client.is_set or self.route_reflector_client.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_client.get_name_leafdata())
                        if (self.route_reflector_cluster_id.is_set or self.route_reflector_cluster_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_cluster_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-reflector-client" or name == "route-reflector-cluster-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "route-reflector-client"):
                            self.route_reflector_client = value
                            self.route_reflector_client.value_namespace = name_space
                            self.route_reflector_client.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-reflector-cluster-id"):
                            self.route_reflector_cluster_id = value
                            self.route_reflector_cluster_id.value_namespace = name_space
                            self.route_reflector_cluster_id.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to route reflection for the
                    BGPgroup
                    
                    .. attribute:: route_reflector_client
                    
                    	Configure the neighbor as a route reflector client
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: route_reflector_cluster_id
                    
                    	route\-reflector cluster id to use when local router is configured as a route reflector.  Commonly set at the group level, but allows a different cluster id to be set for each neighbor
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.RouteReflector.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "route-reflector"

                        self.route_reflector_client = YLeaf(YType.boolean, "route-reflector-client")

                        self.route_reflector_cluster_id = YLeaf(YType.str, "route-reflector-cluster-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("route_reflector_client",
                                        "route_reflector_cluster_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.RouteReflector.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.RouteReflector.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.route_reflector_client.is_set or
                            self.route_reflector_cluster_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.route_reflector_client.yfilter != YFilter.not_set or
                            self.route_reflector_cluster_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.route_reflector_client.is_set or self.route_reflector_client.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_client.get_name_leafdata())
                        if (self.route_reflector_cluster_id.is_set or self.route_reflector_cluster_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_cluster_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-reflector-client" or name == "route-reflector-cluster-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "route-reflector-client"):
                            self.route_reflector_client = value
                            self.route_reflector_client.value_namespace = name_space
                            self.route_reflector_client.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-reflector-cluster-id"):
                            self.route_reflector_cluster_id = value
                            self.route_reflector_cluster_id.value_namespace = name_space
                            self.route_reflector_cluster_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "route-reflector" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.RouteReflector.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.RouteReflector.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AsPathOptions(Entity):
                """
                AS\_PATH manipulation parameters for the BGP neighbor or
                group
                
                .. attribute:: config
                
                	Configuration parameters relating to AS\_PATH manipulation for the BGP peer or group
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AsPathOptions.Config>`
                
                .. attribute:: state
                
                	State information relating to the AS\_PATH manipulation mechanisms for the BGP peer or group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.Neighbors.Neighbor.AsPathOptions.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.Neighbors.Neighbor.AsPathOptions, self).__init__()

                    self.yang_name = "as-path-options"
                    self.yang_parent_name = "neighbor"

                    self.config = Bgp.Neighbors.Neighbor.AsPathOptions.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.Neighbors.Neighbor.AsPathOptions.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to AS\_PATH manipulation
                    for the BGP peer or group
                    
                    .. attribute:: allow_own_as
                    
                    	Specify the number of occurrences of the local BGP speaker's AS that can occur within the AS\_PATH before it is rejected
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**default value**\: 0
                    
                    .. attribute:: replace_peer_as
                    
                    	Replace occurrences of the peer's AS in the AS\_PATH with the local autonomous system number
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.AsPathOptions.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "as-path-options"

                        self.allow_own_as = YLeaf(YType.uint8, "allow-own-as")

                        self.replace_peer_as = YLeaf(YType.boolean, "replace-peer-as")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_own_as",
                                        "replace_peer_as") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.AsPathOptions.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.AsPathOptions.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_own_as.is_set or
                            self.replace_peer_as.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_own_as.yfilter != YFilter.not_set or
                            self.replace_peer_as.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_own_as.is_set or self.allow_own_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_own_as.get_name_leafdata())
                        if (self.replace_peer_as.is_set or self.replace_peer_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.replace_peer_as.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-own-as" or name == "replace-peer-as"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-own-as"):
                            self.allow_own_as = value
                            self.allow_own_as.value_namespace = name_space
                            self.allow_own_as.value_namespace_prefix = name_space_prefix
                        if(value_path == "replace-peer-as"):
                            self.replace_peer_as = value
                            self.replace_peer_as.value_namespace = name_space
                            self.replace_peer_as.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to the AS\_PATH manipulation
                    mechanisms for the BGP peer or group
                    
                    .. attribute:: allow_own_as
                    
                    	Specify the number of occurrences of the local BGP speaker's AS that can occur within the AS\_PATH before it is rejected
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**default value**\: 0
                    
                    .. attribute:: replace_peer_as
                    
                    	Replace occurrences of the peer's AS in the AS\_PATH with the local autonomous system number
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.Neighbors.Neighbor.AsPathOptions.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "as-path-options"

                        self.allow_own_as = YLeaf(YType.uint8, "allow-own-as")

                        self.replace_peer_as = YLeaf(YType.boolean, "replace-peer-as")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_own_as",
                                        "replace_peer_as") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.Neighbors.Neighbor.AsPathOptions.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.Neighbors.Neighbor.AsPathOptions.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_own_as.is_set or
                            self.replace_peer_as.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_own_as.yfilter != YFilter.not_set or
                            self.replace_peer_as.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_own_as.is_set or self.allow_own_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_own_as.get_name_leafdata())
                        if (self.replace_peer_as.is_set or self.replace_peer_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.replace_peer_as.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-own-as" or name == "replace-peer-as"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-own-as"):
                            self.allow_own_as = value
                            self.allow_own_as.value_namespace = name_space
                            self.allow_own_as.value_namespace_prefix = name_space_prefix
                        if(value_path == "replace-peer-as"):
                            self.replace_peer_as = value
                            self.replace_peer_as.value_namespace = name_space
                            self.replace_peer_as.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "as-path-options" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.Neighbors.Neighbor.AsPathOptions.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.Neighbors.Neighbor.AsPathOptions.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.neighbor_address.is_set or
                    (self.add_paths is not None and self.add_paths.has_data()) or
                    (self.afi_safis is not None and self.afi_safis.has_data()) or
                    (self.apply_policy is not None and self.apply_policy.has_data()) or
                    (self.as_path_options is not None and self.as_path_options.has_data()) or
                    (self.config is not None and self.config.has_data()) or
                    (self.ebgp_multihop is not None and self.ebgp_multihop.has_data()) or
                    (self.error_handling is not None and self.error_handling.has_data()) or
                    (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                    (self.logging_options is not None and self.logging_options.has_data()) or
                    (self.route_reflector is not None and self.route_reflector.has_data()) or
                    (self.state is not None and self.state.has_data()) or
                    (self.timers is not None and self.timers.has_data()) or
                    (self.transport is not None and self.transport.has_data()) or
                    (self.use_multiple_paths is not None and self.use_multiple_paths.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.neighbor_address.yfilter != YFilter.not_set or
                    (self.add_paths is not None and self.add_paths.has_operation()) or
                    (self.afi_safis is not None and self.afi_safis.has_operation()) or
                    (self.apply_policy is not None and self.apply_policy.has_operation()) or
                    (self.as_path_options is not None and self.as_path_options.has_operation()) or
                    (self.config is not None and self.config.has_operation()) or
                    (self.ebgp_multihop is not None and self.ebgp_multihop.has_operation()) or
                    (self.error_handling is not None and self.error_handling.has_operation()) or
                    (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                    (self.logging_options is not None and self.logging_options.has_operation()) or
                    (self.route_reflector is not None and self.route_reflector.has_operation()) or
                    (self.state is not None and self.state.has_operation()) or
                    (self.timers is not None and self.timers.has_operation()) or
                    (self.transport is not None and self.transport.has_operation()) or
                    (self.use_multiple_paths is not None and self.use_multiple_paths.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "neighbor" + "[neighbor-address='" + self.neighbor_address.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/neighbors/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.neighbor_address.is_set or self.neighbor_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor_address.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "add-paths"):
                    if (self.add_paths is None):
                        self.add_paths = Bgp.Neighbors.Neighbor.AddPaths()
                        self.add_paths.parent = self
                        self._children_name_map["add_paths"] = "add-paths"
                    return self.add_paths

                if (child_yang_name == "afi-safis"):
                    if (self.afi_safis is None):
                        self.afi_safis = Bgp.Neighbors.Neighbor.AfiSafis()
                        self.afi_safis.parent = self
                        self._children_name_map["afi_safis"] = "afi-safis"
                    return self.afi_safis

                if (child_yang_name == "apply-policy"):
                    if (self.apply_policy is None):
                        self.apply_policy = Bgp.Neighbors.Neighbor.ApplyPolicy()
                        self.apply_policy.parent = self
                        self._children_name_map["apply_policy"] = "apply-policy"
                    return self.apply_policy

                if (child_yang_name == "as-path-options"):
                    if (self.as_path_options is None):
                        self.as_path_options = Bgp.Neighbors.Neighbor.AsPathOptions()
                        self.as_path_options.parent = self
                        self._children_name_map["as_path_options"] = "as-path-options"
                    return self.as_path_options

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.Neighbors.Neighbor.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "ebgp-multihop"):
                    if (self.ebgp_multihop is None):
                        self.ebgp_multihop = Bgp.Neighbors.Neighbor.EbgpMultihop()
                        self.ebgp_multihop.parent = self
                        self._children_name_map["ebgp_multihop"] = "ebgp-multihop"
                    return self.ebgp_multihop

                if (child_yang_name == "error-handling"):
                    if (self.error_handling is None):
                        self.error_handling = Bgp.Neighbors.Neighbor.ErrorHandling()
                        self.error_handling.parent = self
                        self._children_name_map["error_handling"] = "error-handling"
                    return self.error_handling

                if (child_yang_name == "graceful-restart"):
                    if (self.graceful_restart is None):
                        self.graceful_restart = Bgp.Neighbors.Neighbor.GracefulRestart()
                        self.graceful_restart.parent = self
                        self._children_name_map["graceful_restart"] = "graceful-restart"
                    return self.graceful_restart

                if (child_yang_name == "logging-options"):
                    if (self.logging_options is None):
                        self.logging_options = Bgp.Neighbors.Neighbor.LoggingOptions()
                        self.logging_options.parent = self
                        self._children_name_map["logging_options"] = "logging-options"
                    return self.logging_options

                if (child_yang_name == "route-reflector"):
                    if (self.route_reflector is None):
                        self.route_reflector = Bgp.Neighbors.Neighbor.RouteReflector()
                        self.route_reflector.parent = self
                        self._children_name_map["route_reflector"] = "route-reflector"
                    return self.route_reflector

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.Neighbors.Neighbor.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                if (child_yang_name == "timers"):
                    if (self.timers is None):
                        self.timers = Bgp.Neighbors.Neighbor.Timers()
                        self.timers.parent = self
                        self._children_name_map["timers"] = "timers"
                    return self.timers

                if (child_yang_name == "transport"):
                    if (self.transport is None):
                        self.transport = Bgp.Neighbors.Neighbor.Transport()
                        self.transport.parent = self
                        self._children_name_map["transport"] = "transport"
                    return self.transport

                if (child_yang_name == "use-multiple-paths"):
                    if (self.use_multiple_paths is None):
                        self.use_multiple_paths = Bgp.Neighbors.Neighbor.UseMultiplePaths()
                        self.use_multiple_paths.parent = self
                        self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                    return self.use_multiple_paths

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "add-paths" or name == "afi-safis" or name == "apply-policy" or name == "as-path-options" or name == "config" or name == "ebgp-multihop" or name == "error-handling" or name == "graceful-restart" or name == "logging-options" or name == "route-reflector" or name == "state" or name == "timers" or name == "transport" or name == "use-multiple-paths" or name == "neighbor-address"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "neighbor-address"):
                    self.neighbor_address = value
                    self.neighbor_address.value_namespace = name_space
                    self.neighbor_address.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.neighbor:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.neighbor:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "neighbors" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-bgp:bgp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "neighbor"):
                for c in self.neighbor:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bgp.Neighbors.Neighbor()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.neighbor.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "neighbor"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class PeerGroups(Entity):
        """
        Configuration for BGP peer\-groups
        
        .. attribute:: peer_group
        
        	List of BGP peer\-groups configured on the local system \- uniquely identified by peer\-group name
        	**type**\: list of    :py:class:`PeerGroup <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup>`
        
        

        """

        _prefix = 'oc-bgp'
        _revision = '2016-06-21'

        def __init__(self):
            super(Bgp.PeerGroups, self).__init__()

            self.yang_name = "peer-groups"
            self.yang_parent_name = "bgp"

            self.peer_group = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bgp.PeerGroups, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bgp.PeerGroups, self).__setattr__(name, value)


        class PeerGroup(Entity):
            """
            List of BGP peer\-groups configured on the local system \-
            uniquely identified by peer\-group name
            
            .. attribute:: peer_group_name  <key>
            
            	Reference to the name of the BGP peer\-group used as a key in the peer\-group list
            	**type**\:  str
            
            	**refers to**\:  :py:class:`peer_group_name <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Config>`
            
            .. attribute:: add_paths
            
            	Parameters relating to the advertisement and receipt of multiple paths for a single NLRI (add\-paths)
            	**type**\:   :py:class:`AddPaths <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AddPaths>`
            
            .. attribute:: afi_safis
            
            	Per\-address\-family configuration parameters associated with thegroup
            	**type**\:   :py:class:`AfiSafis <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis>`
            
            .. attribute:: apply_policy
            
            	Anchor point for routing policies in the model. Import and export policies are with respect to the local routing table, i.e., export (send) and import (receive), depending on the context
            	**type**\:   :py:class:`ApplyPolicy <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.ApplyPolicy>`
            
            .. attribute:: as_path_options
            
            	AS\_PATH manipulation parameters for the BGP neighbor or group
            	**type**\:   :py:class:`AsPathOptions <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AsPathOptions>`
            
            .. attribute:: config
            
            	Configuration parameters relating to the BGP neighbor or group
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Config>`
            
            .. attribute:: ebgp_multihop
            
            	eBGP multi\-hop parameters for the BGPgroup
            	**type**\:   :py:class:`EbgpMultihop <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.EbgpMultihop>`
            
            .. attribute:: error_handling
            
            	Error handling parameters used for the BGP peer\-group
            	**type**\:   :py:class:`ErrorHandling <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.ErrorHandling>`
            
            .. attribute:: graceful_restart
            
            	Parameters relating the graceful restart mechanism for BGP
            	**type**\:   :py:class:`GracefulRestart <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.GracefulRestart>`
            
            .. attribute:: logging_options
            
            	Logging options for events related to the BGP neighbor or group
            	**type**\:   :py:class:`LoggingOptions <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.LoggingOptions>`
            
            .. attribute:: route_reflector
            
            	Route reflector parameters for the BGPgroup
            	**type**\:   :py:class:`RouteReflector <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.RouteReflector>`
            
            .. attribute:: state
            
            	State information relating to the BGP peer\-group
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.State>`
            
            .. attribute:: timers
            
            	Timers related to a BGP peer\-group
            	**type**\:   :py:class:`Timers <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Timers>`
            
            .. attribute:: transport
            
            	Transport session parameters for the BGP peer\-group
            	**type**\:   :py:class:`Transport <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Transport>`
            
            .. attribute:: use_multiple_paths
            
            	Parameters related to the use of multiple paths for the same NLRI
            	**type**\:   :py:class:`UseMultiplePaths <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths>`
            
            

            """

            _prefix = 'oc-bgp'
            _revision = '2016-06-21'

            def __init__(self):
                super(Bgp.PeerGroups.PeerGroup, self).__init__()

                self.yang_name = "peer-group"
                self.yang_parent_name = "peer-groups"

                self.peer_group_name = YLeaf(YType.str, "peer-group-name")

                self.add_paths = Bgp.PeerGroups.PeerGroup.AddPaths()
                self.add_paths.parent = self
                self._children_name_map["add_paths"] = "add-paths"
                self._children_yang_names.add("add-paths")

                self.afi_safis = Bgp.PeerGroups.PeerGroup.AfiSafis()
                self.afi_safis.parent = self
                self._children_name_map["afi_safis"] = "afi-safis"
                self._children_yang_names.add("afi-safis")

                self.apply_policy = Bgp.PeerGroups.PeerGroup.ApplyPolicy()
                self.apply_policy.parent = self
                self._children_name_map["apply_policy"] = "apply-policy"
                self._children_yang_names.add("apply-policy")

                self.as_path_options = Bgp.PeerGroups.PeerGroup.AsPathOptions()
                self.as_path_options.parent = self
                self._children_name_map["as_path_options"] = "as-path-options"
                self._children_yang_names.add("as-path-options")

                self.config = Bgp.PeerGroups.PeerGroup.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.ebgp_multihop = Bgp.PeerGroups.PeerGroup.EbgpMultihop()
                self.ebgp_multihop.parent = self
                self._children_name_map["ebgp_multihop"] = "ebgp-multihop"
                self._children_yang_names.add("ebgp-multihop")

                self.error_handling = Bgp.PeerGroups.PeerGroup.ErrorHandling()
                self.error_handling.parent = self
                self._children_name_map["error_handling"] = "error-handling"
                self._children_yang_names.add("error-handling")

                self.graceful_restart = Bgp.PeerGroups.PeerGroup.GracefulRestart()
                self.graceful_restart.parent = self
                self._children_name_map["graceful_restart"] = "graceful-restart"
                self._children_yang_names.add("graceful-restart")

                self.logging_options = Bgp.PeerGroups.PeerGroup.LoggingOptions()
                self.logging_options.parent = self
                self._children_name_map["logging_options"] = "logging-options"
                self._children_yang_names.add("logging-options")

                self.route_reflector = Bgp.PeerGroups.PeerGroup.RouteReflector()
                self.route_reflector.parent = self
                self._children_name_map["route_reflector"] = "route-reflector"
                self._children_yang_names.add("route-reflector")

                self.state = Bgp.PeerGroups.PeerGroup.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")

                self.timers = Bgp.PeerGroups.PeerGroup.Timers()
                self.timers.parent = self
                self._children_name_map["timers"] = "timers"
                self._children_yang_names.add("timers")

                self.transport = Bgp.PeerGroups.PeerGroup.Transport()
                self.transport.parent = self
                self._children_name_map["transport"] = "transport"
                self._children_yang_names.add("transport")

                self.use_multiple_paths = Bgp.PeerGroups.PeerGroup.UseMultiplePaths()
                self.use_multiple_paths.parent = self
                self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                self._children_yang_names.add("use-multiple-paths")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("peer_group_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bgp.PeerGroups.PeerGroup, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bgp.PeerGroups.PeerGroup, self).__setattr__(name, value)


            class ErrorHandling(Entity):
                """
                Error handling parameters used for the BGP peer\-group
                
                .. attribute:: config
                
                	Configuration parameters enabling or modifying the behavior or enhanced error handling mechanisms for the BGP group
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.ErrorHandling.Config>`
                
                .. attribute:: state
                
                	State information relating to enhanced error handling mechanisms for the BGP group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.ErrorHandling.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.ErrorHandling, self).__init__()

                    self.yang_name = "error-handling"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.ErrorHandling.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.ErrorHandling.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters enabling or modifying the
                    behavior or enhanced error handling mechanisms for the BGP
                    group
                    
                    .. attribute:: treat_as_withdraw
                    
                    	Specify whether erroneous UPDATE messages for which the NLRI can be extracted are reated as though the NLRI is withdrawn \- avoiding session reset
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.ErrorHandling.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "error-handling"

                        self.treat_as_withdraw = YLeaf(YType.boolean, "treat-as-withdraw")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("treat_as_withdraw") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.ErrorHandling.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.ErrorHandling.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.treat_as_withdraw.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.treat_as_withdraw.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.treat_as_withdraw.is_set or self.treat_as_withdraw.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.treat_as_withdraw.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "treat-as-withdraw"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "treat-as-withdraw"):
                            self.treat_as_withdraw = value
                            self.treat_as_withdraw.value_namespace = name_space
                            self.treat_as_withdraw.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to enhanced error handling
                    mechanisms for the BGP group
                    
                    .. attribute:: treat_as_withdraw
                    
                    	Specify whether erroneous UPDATE messages for which the NLRI can be extracted are reated as though the NLRI is withdrawn \- avoiding session reset
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.ErrorHandling.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "error-handling"

                        self.treat_as_withdraw = YLeaf(YType.boolean, "treat-as-withdraw")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("treat_as_withdraw") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.ErrorHandling.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.ErrorHandling.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.treat_as_withdraw.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.treat_as_withdraw.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.treat_as_withdraw.is_set or self.treat_as_withdraw.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.treat_as_withdraw.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "treat-as-withdraw"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "treat-as-withdraw"):
                            self.treat_as_withdraw = value
                            self.treat_as_withdraw.value_namespace = name_space
                            self.treat_as_withdraw.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "error-handling" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.ErrorHandling.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.ErrorHandling.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class State(Entity):
                """
                State information relating to the BGP peer\-group
                
                .. attribute:: auth_password
                
                	Configures an MD5 authentication password for use with neighboring devices
                	**type**\:  str
                
                .. attribute:: description
                
                	An optional textual description (intended primarily for use with a peer or group
                	**type**\:  str
                
                .. attribute:: local_as
                
                	The local autonomous system number that is to be used when establishing sessions with the remote peer or peer group, if this differs from the global BGP router autonomous system number
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_as
                
                	AS number of the peer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_group_name
                
                	Name of the BGP peer\-group
                	**type**\:  str
                
                .. attribute:: peer_type
                
                	Explicitly designate the peer or peer group as internal (iBGP) or external (eBGP)
                	**type**\:   :py:class:`PeerType <ydk.models.openconfig.openconfig_bgp_types.PeerType>`
                
                .. attribute:: remove_private_as
                
                	Remove private AS numbers from updates sent to peers \- when this leaf is not specified, the AS\_PATH attribute should be sent to the peer unchanged
                	**type**\:   :py:class:`Remove_Private_As_Option <ydk.models.openconfig.openconfig_bgp_types.Remove_Private_As_Option>`
                
                .. attribute:: route_flap_damping
                
                	Enable route flap damping
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: send_community
                
                	Specify which types of community should be sent to the neighbor or group. The default is to not send the community attribute
                	**type**\:   :py:class:`CommunityType <ydk.models.openconfig.openconfig_bgp_types.CommunityType>`
                
                	**default value**\: NONE
                
                .. attribute:: total_paths
                
                	Total number of BGP paths within the context
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_prefixes
                
                	Total number of BGP prefixes received within the context
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "peer-group"

                    self.auth_password = YLeaf(YType.str, "auth-password")

                    self.description = YLeaf(YType.str, "description")

                    self.local_as = YLeaf(YType.uint32, "local-as")

                    self.peer_as = YLeaf(YType.uint32, "peer-as")

                    self.peer_group_name = YLeaf(YType.str, "peer-group-name")

                    self.peer_type = YLeaf(YType.enumeration, "peer-type")

                    self.remove_private_as = YLeaf(YType.identityref, "remove-private-as")

                    self.route_flap_damping = YLeaf(YType.boolean, "route-flap-damping")

                    self.send_community = YLeaf(YType.enumeration, "send-community")

                    self.total_paths = YLeaf(YType.uint32, "total-paths")

                    self.total_prefixes = YLeaf(YType.uint32, "total-prefixes")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("auth_password",
                                    "description",
                                    "local_as",
                                    "peer_as",
                                    "peer_group_name",
                                    "peer_type",
                                    "remove_private_as",
                                    "route_flap_damping",
                                    "send_community",
                                    "total_paths",
                                    "total_prefixes") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.PeerGroups.PeerGroup.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.PeerGroups.PeerGroup.State, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.auth_password.is_set or
                        self.description.is_set or
                        self.local_as.is_set or
                        self.peer_as.is_set or
                        self.peer_group_name.is_set or
                        self.peer_type.is_set or
                        self.remove_private_as.is_set or
                        self.route_flap_damping.is_set or
                        self.send_community.is_set or
                        self.total_paths.is_set or
                        self.total_prefixes.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.auth_password.yfilter != YFilter.not_set or
                        self.description.yfilter != YFilter.not_set or
                        self.local_as.yfilter != YFilter.not_set or
                        self.peer_as.yfilter != YFilter.not_set or
                        self.peer_group_name.yfilter != YFilter.not_set or
                        self.peer_type.yfilter != YFilter.not_set or
                        self.remove_private_as.yfilter != YFilter.not_set or
                        self.route_flap_damping.yfilter != YFilter.not_set or
                        self.send_community.yfilter != YFilter.not_set or
                        self.total_paths.yfilter != YFilter.not_set or
                        self.total_prefixes.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.auth_password.is_set or self.auth_password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.auth_password.get_name_leafdata())
                    if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.description.get_name_leafdata())
                    if (self.local_as.is_set or self.local_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_as.get_name_leafdata())
                    if (self.peer_as.is_set or self.peer_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_as.get_name_leafdata())
                    if (self.peer_group_name.is_set or self.peer_group_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_group_name.get_name_leafdata())
                    if (self.peer_type.is_set or self.peer_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_type.get_name_leafdata())
                    if (self.remove_private_as.is_set or self.remove_private_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remove_private_as.get_name_leafdata())
                    if (self.route_flap_damping.is_set or self.route_flap_damping.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_flap_damping.get_name_leafdata())
                    if (self.send_community.is_set or self.send_community.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.send_community.get_name_leafdata())
                    if (self.total_paths.is_set or self.total_paths.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_paths.get_name_leafdata())
                    if (self.total_prefixes.is_set or self.total_prefixes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_prefixes.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "auth-password" or name == "description" or name == "local-as" or name == "peer-as" or name == "peer-group-name" or name == "peer-type" or name == "remove-private-as" or name == "route-flap-damping" or name == "send-community" or name == "total-paths" or name == "total-prefixes"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "auth-password"):
                        self.auth_password = value
                        self.auth_password.value_namespace = name_space
                        self.auth_password.value_namespace_prefix = name_space_prefix
                    if(value_path == "description"):
                        self.description = value
                        self.description.value_namespace = name_space
                        self.description.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-as"):
                        self.local_as = value
                        self.local_as.value_namespace = name_space
                        self.local_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-as"):
                        self.peer_as = value
                        self.peer_as.value_namespace = name_space
                        self.peer_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-group-name"):
                        self.peer_group_name = value
                        self.peer_group_name.value_namespace = name_space
                        self.peer_group_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-type"):
                        self.peer_type = value
                        self.peer_type.value_namespace = name_space
                        self.peer_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "remove-private-as"):
                        self.remove_private_as = value
                        self.remove_private_as.value_namespace = name_space
                        self.remove_private_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "route-flap-damping"):
                        self.route_flap_damping = value
                        self.route_flap_damping.value_namespace = name_space
                        self.route_flap_damping.value_namespace_prefix = name_space_prefix
                    if(value_path == "send-community"):
                        self.send_community = value
                        self.send_community.value_namespace = name_space
                        self.send_community.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-paths"):
                        self.total_paths = value
                        self.total_paths.value_namespace = name_space
                        self.total_paths.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-prefixes"):
                        self.total_prefixes = value
                        self.total_prefixes.value_namespace = name_space
                        self.total_prefixes.value_namespace_prefix = name_space_prefix


            class AddPaths(Entity):
                """
                Parameters relating to the advertisement and receipt of
                multiple paths for a single NLRI (add\-paths)
                
                .. attribute:: config
                
                	Configuration parameters relating to ADD\_PATHS
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AddPaths.Config>`
                
                .. attribute:: state
                
                	State information associated with ADD\_PATHS
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AddPaths.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.AddPaths, self).__init__()

                    self.yang_name = "add-paths"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.AddPaths.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.AddPaths.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to ADD\_PATHS
                    
                    .. attribute:: eligible_prefix_policy
                    
                    	A reference to a routing policy which can be used to restrict the prefixes for which add\-paths is enabled
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: receive
                    
                    	Enable ability to receive multiple path advertisements for an NLRI from the neighbor or group
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: send_max
                    
                    	The maximum number of paths to advertise to neighbors for a single NLRI
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.AddPaths.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "add-paths"

                        self.eligible_prefix_policy = YLeaf(YType.str, "eligible-prefix-policy")

                        self.receive = YLeaf(YType.boolean, "receive")

                        self.send_max = YLeaf(YType.uint8, "send-max")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("eligible_prefix_policy",
                                        "receive",
                                        "send_max") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.AddPaths.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.AddPaths.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.eligible_prefix_policy.is_set or
                            self.receive.is_set or
                            self.send_max.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.eligible_prefix_policy.yfilter != YFilter.not_set or
                            self.receive.yfilter != YFilter.not_set or
                            self.send_max.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.eligible_prefix_policy.is_set or self.eligible_prefix_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eligible_prefix_policy.get_name_leafdata())
                        if (self.receive.is_set or self.receive.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive.get_name_leafdata())
                        if (self.send_max.is_set or self.send_max.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_max.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "eligible-prefix-policy" or name == "receive" or name == "send-max"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "eligible-prefix-policy"):
                            self.eligible_prefix_policy = value
                            self.eligible_prefix_policy.value_namespace = name_space
                            self.eligible_prefix_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive"):
                            self.receive = value
                            self.receive.value_namespace = name_space
                            self.receive.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-max"):
                            self.send_max = value
                            self.send_max.value_namespace = name_space
                            self.send_max.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information associated with ADD\_PATHS
                    
                    .. attribute:: eligible_prefix_policy
                    
                    	A reference to a routing policy which can be used to restrict the prefixes for which add\-paths is enabled
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: receive
                    
                    	Enable ability to receive multiple path advertisements for an NLRI from the neighbor or group
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: send_max
                    
                    	The maximum number of paths to advertise to neighbors for a single NLRI
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.AddPaths.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "add-paths"

                        self.eligible_prefix_policy = YLeaf(YType.str, "eligible-prefix-policy")

                        self.receive = YLeaf(YType.boolean, "receive")

                        self.send_max = YLeaf(YType.uint8, "send-max")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("eligible_prefix_policy",
                                        "receive",
                                        "send_max") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.AddPaths.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.AddPaths.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.eligible_prefix_policy.is_set or
                            self.receive.is_set or
                            self.send_max.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.eligible_prefix_policy.yfilter != YFilter.not_set or
                            self.receive.yfilter != YFilter.not_set or
                            self.send_max.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.eligible_prefix_policy.is_set or self.eligible_prefix_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.eligible_prefix_policy.get_name_leafdata())
                        if (self.receive.is_set or self.receive.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receive.get_name_leafdata())
                        if (self.send_max.is_set or self.send_max.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.send_max.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "eligible-prefix-policy" or name == "receive" or name == "send-max"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "eligible-prefix-policy"):
                            self.eligible_prefix_policy = value
                            self.eligible_prefix_policy.value_namespace = name_space
                            self.eligible_prefix_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "receive"):
                            self.receive = value
                            self.receive.value_namespace = name_space
                            self.receive.value_namespace_prefix = name_space_prefix
                        if(value_path == "send-max"):
                            self.send_max = value
                            self.send_max.value_namespace = name_space
                            self.send_max.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "add-paths" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.AddPaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.AddPaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class ApplyPolicy(Entity):
                """
                Anchor point for routing policies in the model.
                Import and export policies are with respect to the local
                routing table, i.e., export (send) and import (receive),
                depending on the context.
                
                .. attribute:: config
                
                	Policy configuration data
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.ApplyPolicy.Config>`
                
                .. attribute:: state
                
                	Operational state for routing policy
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.ApplyPolicy.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.ApplyPolicy, self).__init__()

                    self.yang_name = "apply-policy"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.ApplyPolicy.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.ApplyPolicy.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Policy configuration data.
                    
                    .. attribute:: default_export_policy
                    
                    	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: default_import_policy
                    
                    	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: export_policy
                    
                    	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: import_policy
                    
                    	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.ApplyPolicy.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "apply-policy"

                        self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                        self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                        self.export_policy = YLeafList(YType.str, "export-policy")

                        self.import_policy = YLeafList(YType.str, "import-policy")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("default_export_policy",
                                        "default_import_policy",
                                        "export_policy",
                                        "import_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.ApplyPolicy.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.ApplyPolicy.Config, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.default_export_policy.is_set or
                            self.default_import_policy.is_set)

                    def has_operation(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.default_export_policy.yfilter != YFilter.not_set or
                            self.default_import_policy.yfilter != YFilter.not_set or
                            self.export_policy.yfilter != YFilter.not_set or
                            self.import_policy.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                        if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                        leaf_name_data.extend(self.export_policy.get_name_leafdata())

                        leaf_name_data.extend(self.import_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "default-export-policy"):
                            self.default_export_policy = value
                            self.default_export_policy.value_namespace = name_space
                            self.default_export_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "default-import-policy"):
                            self.default_import_policy = value
                            self.default_import_policy.value_namespace = name_space
                            self.default_import_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "export-policy"):
                            self.export_policy.append(value)
                        if(value_path == "import-policy"):
                            self.import_policy.append(value)


                class State(Entity):
                    """
                    Operational state for routing policy
                    
                    .. attribute:: default_export_policy
                    
                    	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: default_import_policy
                    
                    	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                    	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                    
                    	**default value**\: REJECT_ROUTE
                    
                    .. attribute:: export_policy
                    
                    	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    .. attribute:: import_policy
                    
                    	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                    	**type**\:  list of str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.ApplyPolicy.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "apply-policy"

                        self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                        self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                        self.export_policy = YLeafList(YType.str, "export-policy")

                        self.import_policy = YLeafList(YType.str, "import-policy")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("default_export_policy",
                                        "default_import_policy",
                                        "export_policy",
                                        "import_policy") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.ApplyPolicy.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.ApplyPolicy.State, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.default_export_policy.is_set or
                            self.default_import_policy.is_set)

                    def has_operation(self):
                        for leaf in self.export_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.import_policy.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.default_export_policy.yfilter != YFilter.not_set or
                            self.default_import_policy.yfilter != YFilter.not_set or
                            self.export_policy.yfilter != YFilter.not_set or
                            self.import_policy.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                        if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                        leaf_name_data.extend(self.export_policy.get_name_leafdata())

                        leaf_name_data.extend(self.import_policy.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "default-export-policy"):
                            self.default_export_policy = value
                            self.default_export_policy.value_namespace = name_space
                            self.default_export_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "default-import-policy"):
                            self.default_import_policy = value
                            self.default_import_policy.value_namespace = name_space
                            self.default_import_policy.value_namespace_prefix = name_space_prefix
                        if(value_path == "export-policy"):
                            self.export_policy.append(value)
                        if(value_path == "import-policy"):
                            self.import_policy.append(value)

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "apply-policy" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.ApplyPolicy.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.ApplyPolicy.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class UseMultiplePaths(Entity):
                """
                Parameters related to the use of multiple paths for the
                same NLRI
                
                .. attribute:: config
                
                	Configuration parameters relating to multipath
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Config>`
                
                .. attribute:: ebgp
                
                	Multipath parameters for eBGP
                	**type**\:   :py:class:`Ebgp <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp>`
                
                .. attribute:: ibgp
                
                	Multipath parameters for iBGP
                	**type**\:   :py:class:`Ibgp <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp>`
                
                .. attribute:: state
                
                	State parameters relating to multipath
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths, self).__init__()

                    self.yang_name = "use-multiple-paths"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.ebgp = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp()
                    self.ebgp.parent = self
                    self._children_name_map["ebgp"] = "ebgp"
                    self._children_yang_names.add("ebgp")

                    self.ibgp = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp()
                    self.ibgp.parent = self
                    self._children_name_map["ibgp"] = "ibgp"
                    self._children_yang_names.add("ibgp")

                    self.state = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to multipath
                    
                    .. attribute:: enabled
                    
                    	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "use-multiple-paths"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.enabled.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State parameters relating to multipath
                    
                    .. attribute:: enabled
                    
                    	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "use-multiple-paths"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.enabled.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix


                class Ebgp(Entity):
                    """
                    Multipath parameters for eBGP
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to eBGP multipath
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.Config>`
                    
                    .. attribute:: state
                    
                    	State information relating to eBGP multipath
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp, self).__init__()

                        self.yang_name = "ebgp"
                        self.yang_parent_name = "use-multiple-paths"

                        self.config = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to eBGP multipath
                        
                        .. attribute:: allow_multiple_as
                        
                        	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: maximum_paths
                        
                        	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**default value**\: 1
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "ebgp"

                            self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                            self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("allow_multiple_as",
                                            "maximum_paths") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.allow_multiple_as.is_set or
                                self.maximum_paths.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.allow_multiple_as.yfilter != YFilter.not_set or
                                self.maximum_paths.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                            if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "allow-multiple-as" or name == "maximum-paths"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "allow-multiple-as"):
                                self.allow_multiple_as = value
                                self.allow_multiple_as.value_namespace = name_space
                                self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                            if(value_path == "maximum-paths"):
                                self.maximum_paths = value
                                self.maximum_paths.value_namespace = name_space
                                self.maximum_paths.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information relating to eBGP multipath
                        
                        .. attribute:: allow_multiple_as
                        
                        	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: maximum_paths
                        
                        	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**default value**\: 1
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "ebgp"

                            self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                            self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("allow_multiple_as",
                                            "maximum_paths") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.allow_multiple_as.is_set or
                                self.maximum_paths.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.allow_multiple_as.yfilter != YFilter.not_set or
                                self.maximum_paths.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                            if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "allow-multiple-as" or name == "maximum-paths"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "allow-multiple-as"):
                                self.allow_multiple_as = value
                                self.allow_multiple_as.value_namespace = name_space
                                self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                            if(value_path == "maximum-paths"):
                                self.maximum_paths = value
                                self.maximum_paths.value_namespace = name_space
                                self.maximum_paths.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ebgp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Ibgp(Entity):
                    """
                    Multipath parameters for iBGP
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to iBGP multipath
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.Config>`
                    
                    .. attribute:: state
                    
                    	State information relating to iBGP multipath
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.State>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp, self).__init__()

                        self.yang_name = "ibgp"
                        self.yang_parent_name = "use-multiple-paths"

                        self.config = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to iBGP multipath
                        
                        .. attribute:: maximum_paths
                        
                        	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**default value**\: 1
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "ibgp"

                            self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_paths") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.maximum_paths.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_paths.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-paths"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-paths"):
                                self.maximum_paths = value
                                self.maximum_paths.value_namespace = name_space
                                self.maximum_paths.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information relating to iBGP multipath
                        
                        .. attribute:: maximum_paths
                        
                        	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**default value**\: 1
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "ibgp"

                            self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("maximum_paths") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.maximum_paths.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.maximum_paths.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "maximum-paths"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "maximum-paths"):
                                self.maximum_paths = value
                                self.maximum_paths.value_namespace = name_space
                                self.maximum_paths.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ibgp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.ebgp is not None and self.ebgp.has_data()) or
                        (self.ibgp is not None and self.ibgp.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.ebgp is not None and self.ebgp.has_operation()) or
                        (self.ibgp is not None and self.ibgp.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "use-multiple-paths" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "ebgp"):
                        if (self.ebgp is None):
                            self.ebgp = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ebgp()
                            self.ebgp.parent = self
                            self._children_name_map["ebgp"] = "ebgp"
                        return self.ebgp

                    if (child_yang_name == "ibgp"):
                        if (self.ibgp is None):
                            self.ibgp = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.Ibgp()
                            self.ibgp.parent = self
                            self._children_name_map["ibgp"] = "ibgp"
                        return self.ibgp

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.UseMultiplePaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "ebgp" or name == "ibgp" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LoggingOptions(Entity):
                """
                Logging options for events related to the BGP neighbor or
                group
                
                .. attribute:: config
                
                	Configuration parameters enabling or modifying logging for events relating to the BGPgroup
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.LoggingOptions.Config>`
                
                .. attribute:: state
                
                	State information relating to logging for the BGP neighbor or group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.LoggingOptions.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.LoggingOptions, self).__init__()

                    self.yang_name = "logging-options"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.LoggingOptions.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.LoggingOptions.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters enabling or modifying logging
                    for events relating to the BGPgroup
                    
                    .. attribute:: log_neighbor_state_changes
                    
                    	Configure logging of peer state changes.  Default is to enable logging of peer state changes
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.LoggingOptions.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "logging-options"

                        self.log_neighbor_state_changes = YLeaf(YType.boolean, "log-neighbor-state-changes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("log_neighbor_state_changes") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.LoggingOptions.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.LoggingOptions.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.log_neighbor_state_changes.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.log_neighbor_state_changes.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.log_neighbor_state_changes.is_set or self.log_neighbor_state_changes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.log_neighbor_state_changes.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "log-neighbor-state-changes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "log-neighbor-state-changes"):
                            self.log_neighbor_state_changes = value
                            self.log_neighbor_state_changes.value_namespace = name_space
                            self.log_neighbor_state_changes.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to logging for the BGP neighbor
                    or group
                    
                    .. attribute:: log_neighbor_state_changes
                    
                    	Configure logging of peer state changes.  Default is to enable logging of peer state changes
                    	**type**\:  bool
                    
                    	**default value**\: true
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.LoggingOptions.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "logging-options"

                        self.log_neighbor_state_changes = YLeaf(YType.boolean, "log-neighbor-state-changes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("log_neighbor_state_changes") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.LoggingOptions.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.LoggingOptions.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.log_neighbor_state_changes.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.log_neighbor_state_changes.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.log_neighbor_state_changes.is_set or self.log_neighbor_state_changes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.log_neighbor_state_changes.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "log-neighbor-state-changes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "log-neighbor-state-changes"):
                            self.log_neighbor_state_changes = value
                            self.log_neighbor_state_changes.value_namespace = name_space
                            self.log_neighbor_state_changes.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "logging-options" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.LoggingOptions.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.LoggingOptions.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AfiSafis(Entity):
                """
                Per\-address\-family configuration parameters associated with
                thegroup
                
                .. attribute:: afi_safi
                
                	AFI,SAFI configuration available for the neighbour or group
                	**type**\: list of    :py:class:`AfiSafi <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.AfiSafis, self).__init__()

                    self.yang_name = "afi-safis"
                    self.yang_parent_name = "peer-group"

                    self.afi_safi = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis, self).__setattr__(name, value)


                class AfiSafi(Entity):
                    """
                    AFI,SAFI configuration available for the
                    neighbour or group
                    
                    .. attribute:: afi_safi_name  <key>
                    
                    	Reference to the AFI\-SAFI name used as a key for the AFI\-SAFI list
                    	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                    
                    .. attribute:: apply_policy
                    
                    	Anchor point for routing policies in the model. Import and export policies are with respect to the local routing table, i.e., export (send) and import (receive), depending on the context
                    	**type**\:   :py:class:`ApplyPolicy <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy>`
                    
                    .. attribute:: config
                    
                    	Configuration parameters for the AFI\-SAFI
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Config>`
                    
                    .. attribute:: graceful_restart
                    
                    	Parameters relating to BGP graceful\-restart
                    	**type**\:   :py:class:`GracefulRestart <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart>`
                    
                    .. attribute:: ipv4_labeled_unicast
                    
                    	IPv4 Labeled Unicast configuration options
                    	**type**\:   :py:class:`Ipv4LabeledUnicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast>`
                    
                    .. attribute:: ipv4_unicast
                    
                    	IPv4 unicast configuration options
                    	**type**\:   :py:class:`Ipv4Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast>`
                    
                    .. attribute:: ipv6_labeled_unicast
                    
                    	IPv6 Labeled Unicast configuration options
                    	**type**\:   :py:class:`Ipv6LabeledUnicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast>`
                    
                    .. attribute:: ipv6_unicast
                    
                    	IPv6 unicast configuration options
                    	**type**\:   :py:class:`Ipv6Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast>`
                    
                    .. attribute:: l2vpn_evpn
                    
                    	BGP EVPN configuration options
                    	**type**\:   :py:class:`L2VpnEvpn <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn>`
                    
                    .. attribute:: l2vpn_vpls
                    
                    	BGP\-signalled VPLS configuration options
                    	**type**\:   :py:class:`L2VpnVpls <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls>`
                    
                    .. attribute:: l3vpn_ipv4_multicast
                    
                    	Multicast IPv4 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv4Multicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast>`
                    
                    .. attribute:: l3vpn_ipv4_unicast
                    
                    	Unicast IPv4 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv4Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast>`
                    
                    .. attribute:: l3vpn_ipv6_multicast
                    
                    	Multicast IPv6 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv6Multicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast>`
                    
                    .. attribute:: l3vpn_ipv6_unicast
                    
                    	Unicast IPv6 L3VPN configuration options
                    	**type**\:   :py:class:`L3VpnIpv6Unicast <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast>`
                    
                    .. attribute:: route_selection_options
                    
                    	Parameters relating to options for route selection
                    	**type**\:   :py:class:`RouteSelectionOptions <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions>`
                    
                    .. attribute:: state
                    
                    	State information relating to the AFI\-SAFI
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.State>`
                    
                    .. attribute:: use_multiple_paths
                    
                    	Parameters related to the use of multiple paths for the same NLRI
                    	**type**\:   :py:class:`UseMultiplePaths <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths>`
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi, self).__init__()

                        self.yang_name = "afi-safi"
                        self.yang_parent_name = "afi-safis"

                        self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                        self.apply_policy = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy()
                        self.apply_policy.parent = self
                        self._children_name_map["apply_policy"] = "apply-policy"
                        self._children_yang_names.add("apply-policy")

                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.graceful_restart = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart()
                        self.graceful_restart.parent = self
                        self._children_name_map["graceful_restart"] = "graceful-restart"
                        self._children_yang_names.add("graceful-restart")

                        self.ipv4_labeled_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast()
                        self.ipv4_labeled_unicast.parent = self
                        self._children_name_map["ipv4_labeled_unicast"] = "ipv4-labeled-unicast"
                        self._children_yang_names.add("ipv4-labeled-unicast")

                        self.ipv4_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast()
                        self.ipv4_unicast.parent = self
                        self._children_name_map["ipv4_unicast"] = "ipv4-unicast"
                        self._children_yang_names.add("ipv4-unicast")

                        self.ipv6_labeled_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast()
                        self.ipv6_labeled_unicast.parent = self
                        self._children_name_map["ipv6_labeled_unicast"] = "ipv6-labeled-unicast"
                        self._children_yang_names.add("ipv6-labeled-unicast")

                        self.ipv6_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast()
                        self.ipv6_unicast.parent = self
                        self._children_name_map["ipv6_unicast"] = "ipv6-unicast"
                        self._children_yang_names.add("ipv6-unicast")

                        self.l2vpn_evpn = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn()
                        self.l2vpn_evpn.parent = self
                        self._children_name_map["l2vpn_evpn"] = "l2vpn-evpn"
                        self._children_yang_names.add("l2vpn-evpn")

                        self.l2vpn_vpls = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls()
                        self.l2vpn_vpls.parent = self
                        self._children_name_map["l2vpn_vpls"] = "l2vpn-vpls"
                        self._children_yang_names.add("l2vpn-vpls")

                        self.l3vpn_ipv4_multicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast()
                        self.l3vpn_ipv4_multicast.parent = self
                        self._children_name_map["l3vpn_ipv4_multicast"] = "l3vpn-ipv4-multicast"
                        self._children_yang_names.add("l3vpn-ipv4-multicast")

                        self.l3vpn_ipv4_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast()
                        self.l3vpn_ipv4_unicast.parent = self
                        self._children_name_map["l3vpn_ipv4_unicast"] = "l3vpn-ipv4-unicast"
                        self._children_yang_names.add("l3vpn-ipv4-unicast")

                        self.l3vpn_ipv6_multicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast()
                        self.l3vpn_ipv6_multicast.parent = self
                        self._children_name_map["l3vpn_ipv6_multicast"] = "l3vpn-ipv6-multicast"
                        self._children_yang_names.add("l3vpn-ipv6-multicast")

                        self.l3vpn_ipv6_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast()
                        self.l3vpn_ipv6_unicast.parent = self
                        self._children_name_map["l3vpn_ipv6_unicast"] = "l3vpn-ipv6-unicast"
                        self._children_yang_names.add("l3vpn-ipv6-unicast")

                        self.route_selection_options = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions()
                        self.route_selection_options.parent = self
                        self._children_name_map["route_selection_options"] = "route-selection-options"
                        self._children_yang_names.add("route-selection-options")

                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")

                        self.use_multiple_paths = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths()
                        self.use_multiple_paths.parent = self
                        self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                        self._children_yang_names.add("use-multiple-paths")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi_safi_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi, self).__setattr__(name, value)


                    class State(Entity):
                        """
                        State information relating to the AFI\-SAFI
                        
                        .. attribute:: afi_safi_name
                        
                        	AFI,SAFI
                        	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                        
                        .. attribute:: enabled
                        
                        	This leaf indicates whether the IPv4 Unicast AFI,SAFI is enabled for the neighbour or group
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "afi-safi"

                            self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi_safi_name",
                                            "enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi_safi_name.is_set or
                                self.enabled.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi_safi_name.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi_safi_name.get_name_leafdata())
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi-safi-name" or name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi-safi-name"):
                                self.afi_safi_name = value
                                self.afi_safi_name.value_namespace = name_space
                                self.afi_safi_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class L2VpnEvpn(Entity):
                        """
                        BGP EVPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn, self).__init__()

                            self.yang_name = "l2vpn-evpn"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l2vpn-evpn"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l2vpn-evpn" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ipv6Unicast(Entity):
                        """
                        IPv6 unicast configuration options
                        
                        .. attribute:: config
                        
                        	Configuration parameters for common IPv4 and IPv6 unicast AFI\-SAFI options
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.Config>`
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit>`
                        
                        .. attribute:: state
                        
                        	State information for common IPv4 and IPv6 unicast parameters
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast, self).__init__()

                            self.yang_name = "ipv6-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")

                            self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv6-unicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Config(Entity):
                            """
                            Configuration parameters for common IPv4 and IPv6 unicast
                            AFI\-SAFI options
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "ipv6-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information for common IPv4 and IPv6 unicast
                            parameters
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "ipv6-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv6-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "prefix-limit" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ipv4LabeledUnicast(Entity):
                        """
                        IPv4 Labeled Unicast configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast, self).__init__()

                            self.yang_name = "ipv4-labeled-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv4-labeled-unicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv4-labeled-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L3VpnIpv4Unicast(Entity):
                        """
                        Unicast IPv4 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast, self).__init__()

                            self.yang_name = "l3vpn-ipv4-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv4-unicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv4-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ipv6LabeledUnicast(Entity):
                        """
                        IPv6 Labeled Unicast configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast, self).__init__()

                            self.yang_name = "ipv6-labeled-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv6-labeled-unicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv6-labeled-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class ApplyPolicy(Entity):
                        """
                        Anchor point for routing policies in the model.
                        Import and export policies are with respect to the local
                        routing table, i.e., export (send) and import (receive),
                        depending on the context.
                        
                        .. attribute:: config
                        
                        	Policy configuration data
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.Config>`
                        
                        .. attribute:: state
                        
                        	Operational state for routing policy
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy, self).__init__()

                            self.yang_name = "apply-policy"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Policy configuration data.
                            
                            .. attribute:: default_export_policy
                            
                            	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: default_import_policy
                            
                            	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: export_policy
                            
                            	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            .. attribute:: import_policy
                            
                            	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "apply-policy"

                                self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                                self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                                self.export_policy = YLeafList(YType.str, "export-policy")

                                self.import_policy = YLeafList(YType.str, "import-policy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_export_policy",
                                                "default_import_policy",
                                                "export_policy",
                                                "import_policy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.Config, self).__setattr__(name, value)

                            def has_data(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return (
                                    self.default_export_policy.is_set or
                                    self.default_import_policy.is_set)

                            def has_operation(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_export_policy.yfilter != YFilter.not_set or
                                    self.default_import_policy.yfilter != YFilter.not_set or
                                    self.export_policy.yfilter != YFilter.not_set or
                                    self.import_policy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                                if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                                leaf_name_data.extend(self.export_policy.get_name_leafdata())

                                leaf_name_data.extend(self.import_policy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-export-policy"):
                                    self.default_export_policy = value
                                    self.default_export_policy.value_namespace = name_space
                                    self.default_export_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-import-policy"):
                                    self.default_import_policy = value
                                    self.default_import_policy.value_namespace = name_space
                                    self.default_import_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "export-policy"):
                                    self.export_policy.append(value)
                                if(value_path == "import-policy"):
                                    self.import_policy.append(value)


                        class State(Entity):
                            """
                            Operational state for routing policy
                            
                            .. attribute:: default_export_policy
                            
                            	explicitly set a default policy if no policy definition in the export policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: default_import_policy
                            
                            	explicitly set a default policy if no policy definition in the import policy chain is satisfied
                            	**type**\:   :py:class:`DefaultPolicyType <ydk.models.openconfig.openconfig_routing_policy.DefaultPolicyType>`
                            
                            	**default value**\: REJECT_ROUTE
                            
                            .. attribute:: export_policy
                            
                            	list of policy names in sequence to be applied on sending a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            .. attribute:: import_policy
                            
                            	list of policy names in sequence to be applied on receiving a routing update in the current context, e.g., for the current peer group, neighbor, address family, etc
                            	**type**\:  list of str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_routing_policy.RoutingPolicy.PolicyDefinitions.PolicyDefinition>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "apply-policy"

                                self.default_export_policy = YLeaf(YType.enumeration, "default-export-policy")

                                self.default_import_policy = YLeaf(YType.enumeration, "default-import-policy")

                                self.export_policy = YLeafList(YType.str, "export-policy")

                                self.import_policy = YLeafList(YType.str, "import-policy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_export_policy",
                                                "default_import_policy",
                                                "export_policy",
                                                "import_policy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.State, self).__setattr__(name, value)

                            def has_data(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return (
                                    self.default_export_policy.is_set or
                                    self.default_import_policy.is_set)

                            def has_operation(self):
                                for leaf in self.export_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                for leaf in self.import_policy.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_export_policy.yfilter != YFilter.not_set or
                                    self.default_import_policy.yfilter != YFilter.not_set or
                                    self.export_policy.yfilter != YFilter.not_set or
                                    self.import_policy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_export_policy.is_set or self.default_export_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_export_policy.get_name_leafdata())
                                if (self.default_import_policy.is_set or self.default_import_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_import_policy.get_name_leafdata())

                                leaf_name_data.extend(self.export_policy.get_name_leafdata())

                                leaf_name_data.extend(self.import_policy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-export-policy" or name == "default-import-policy" or name == "export-policy" or name == "import-policy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-export-policy"):
                                    self.default_export_policy = value
                                    self.default_export_policy.value_namespace = name_space
                                    self.default_export_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-import-policy"):
                                    self.default_import_policy = value
                                    self.default_import_policy.value_namespace = name_space
                                    self.default_import_policy.value_namespace_prefix = name_space_prefix
                                if(value_path == "export-policy"):
                                    self.export_policy.append(value)
                                if(value_path == "import-policy"):
                                    self.import_policy.append(value)

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "apply-policy" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class RouteSelectionOptions(Entity):
                        """
                        Parameters relating to options for route selection
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to route selection options
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.Config>`
                        
                        .. attribute:: state
                        
                        	State information for the route selection options
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions, self).__init__()

                            self.yang_name = "route-selection-options"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to route selection
                            options
                            
                            .. attribute:: advertise_inactive_routes
                            
                            	Advertise inactive routes to external peers.  The default is to only advertise active routes
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: always_compare_med
                            
                            	Compare multi\-exit discriminator (MED) value from different ASes when selecting the best route.  The default behavior is to only compare MEDs for paths received from the same AS
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: enable_aigp
                            
                            	Flag to enable sending / receiving accumulated IGP attribute in routing updates
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: external_compare_router_id
                            
                            	When comparing similar routes received from external BGP peers, use the router\-id as a criterion to select the active path
                            	**type**\:  bool
                            
                            	**default value**\: true
                            
                            .. attribute:: ignore_as_path_length
                            
                            	Ignore the AS path length when selecting the best path. The default is to use the AS path length and prefer paths with shorter length
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: ignore_next_hop_igp_metric
                            
                            	Ignore the IGP metric to the next\-hop when calculating BGP best\-path. The default is to select the route for which the metric to the next\-hop is lowest
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "route-selection-options"

                                self.advertise_inactive_routes = YLeaf(YType.boolean, "advertise-inactive-routes")

                                self.always_compare_med = YLeaf(YType.boolean, "always-compare-med")

                                self.enable_aigp = YLeaf(YType.boolean, "enable-aigp")

                                self.external_compare_router_id = YLeaf(YType.boolean, "external-compare-router-id")

                                self.ignore_as_path_length = YLeaf(YType.boolean, "ignore-as-path-length")

                                self.ignore_next_hop_igp_metric = YLeaf(YType.boolean, "ignore-next-hop-igp-metric")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("advertise_inactive_routes",
                                                "always_compare_med",
                                                "enable_aigp",
                                                "external_compare_router_id",
                                                "ignore_as_path_length",
                                                "ignore_next_hop_igp_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.advertise_inactive_routes.is_set or
                                    self.always_compare_med.is_set or
                                    self.enable_aigp.is_set or
                                    self.external_compare_router_id.is_set or
                                    self.ignore_as_path_length.is_set or
                                    self.ignore_next_hop_igp_metric.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.advertise_inactive_routes.yfilter != YFilter.not_set or
                                    self.always_compare_med.yfilter != YFilter.not_set or
                                    self.enable_aigp.yfilter != YFilter.not_set or
                                    self.external_compare_router_id.yfilter != YFilter.not_set or
                                    self.ignore_as_path_length.yfilter != YFilter.not_set or
                                    self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.advertise_inactive_routes.is_set or self.advertise_inactive_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advertise_inactive_routes.get_name_leafdata())
                                if (self.always_compare_med.is_set or self.always_compare_med.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.always_compare_med.get_name_leafdata())
                                if (self.enable_aigp.is_set or self.enable_aigp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable_aigp.get_name_leafdata())
                                if (self.external_compare_router_id.is_set or self.external_compare_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_compare_router_id.get_name_leafdata())
                                if (self.ignore_as_path_length.is_set or self.ignore_as_path_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ignore_as_path_length.get_name_leafdata())
                                if (self.ignore_next_hop_igp_metric.is_set or self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ignore_next_hop_igp_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "advertise-inactive-routes" or name == "always-compare-med" or name == "enable-aigp" or name == "external-compare-router-id" or name == "ignore-as-path-length" or name == "ignore-next-hop-igp-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "advertise-inactive-routes"):
                                    self.advertise_inactive_routes = value
                                    self.advertise_inactive_routes.value_namespace = name_space
                                    self.advertise_inactive_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "always-compare-med"):
                                    self.always_compare_med = value
                                    self.always_compare_med.value_namespace = name_space
                                    self.always_compare_med.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable-aigp"):
                                    self.enable_aigp = value
                                    self.enable_aigp.value_namespace = name_space
                                    self.enable_aigp.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-compare-router-id"):
                                    self.external_compare_router_id = value
                                    self.external_compare_router_id.value_namespace = name_space
                                    self.external_compare_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "ignore-as-path-length"):
                                    self.ignore_as_path_length = value
                                    self.ignore_as_path_length.value_namespace = name_space
                                    self.ignore_as_path_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "ignore-next-hop-igp-metric"):
                                    self.ignore_next_hop_igp_metric = value
                                    self.ignore_next_hop_igp_metric.value_namespace = name_space
                                    self.ignore_next_hop_igp_metric.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information for the route selection options
                            
                            .. attribute:: advertise_inactive_routes
                            
                            	Advertise inactive routes to external peers.  The default is to only advertise active routes
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: always_compare_med
                            
                            	Compare multi\-exit discriminator (MED) value from different ASes when selecting the best route.  The default behavior is to only compare MEDs for paths received from the same AS
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: enable_aigp
                            
                            	Flag to enable sending / receiving accumulated IGP attribute in routing updates
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: external_compare_router_id
                            
                            	When comparing similar routes received from external BGP peers, use the router\-id as a criterion to select the active path
                            	**type**\:  bool
                            
                            	**default value**\: true
                            
                            .. attribute:: ignore_as_path_length
                            
                            	Ignore the AS path length when selecting the best path. The default is to use the AS path length and prefer paths with shorter length
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: ignore_next_hop_igp_metric
                            
                            	Ignore the IGP metric to the next\-hop when calculating BGP best\-path. The default is to select the route for which the metric to the next\-hop is lowest
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "route-selection-options"

                                self.advertise_inactive_routes = YLeaf(YType.boolean, "advertise-inactive-routes")

                                self.always_compare_med = YLeaf(YType.boolean, "always-compare-med")

                                self.enable_aigp = YLeaf(YType.boolean, "enable-aigp")

                                self.external_compare_router_id = YLeaf(YType.boolean, "external-compare-router-id")

                                self.ignore_as_path_length = YLeaf(YType.boolean, "ignore-as-path-length")

                                self.ignore_next_hop_igp_metric = YLeaf(YType.boolean, "ignore-next-hop-igp-metric")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("advertise_inactive_routes",
                                                "always_compare_med",
                                                "enable_aigp",
                                                "external_compare_router_id",
                                                "ignore_as_path_length",
                                                "ignore_next_hop_igp_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.advertise_inactive_routes.is_set or
                                    self.always_compare_med.is_set or
                                    self.enable_aigp.is_set or
                                    self.external_compare_router_id.is_set or
                                    self.ignore_as_path_length.is_set or
                                    self.ignore_next_hop_igp_metric.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.advertise_inactive_routes.yfilter != YFilter.not_set or
                                    self.always_compare_med.yfilter != YFilter.not_set or
                                    self.enable_aigp.yfilter != YFilter.not_set or
                                    self.external_compare_router_id.yfilter != YFilter.not_set or
                                    self.ignore_as_path_length.yfilter != YFilter.not_set or
                                    self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.advertise_inactive_routes.is_set or self.advertise_inactive_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advertise_inactive_routes.get_name_leafdata())
                                if (self.always_compare_med.is_set or self.always_compare_med.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.always_compare_med.get_name_leafdata())
                                if (self.enable_aigp.is_set or self.enable_aigp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable_aigp.get_name_leafdata())
                                if (self.external_compare_router_id.is_set or self.external_compare_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_compare_router_id.get_name_leafdata())
                                if (self.ignore_as_path_length.is_set or self.ignore_as_path_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ignore_as_path_length.get_name_leafdata())
                                if (self.ignore_next_hop_igp_metric.is_set or self.ignore_next_hop_igp_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ignore_next_hop_igp_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "advertise-inactive-routes" or name == "always-compare-med" or name == "enable-aigp" or name == "external-compare-router-id" or name == "ignore-as-path-length" or name == "ignore-next-hop-igp-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "advertise-inactive-routes"):
                                    self.advertise_inactive_routes = value
                                    self.advertise_inactive_routes.value_namespace = name_space
                                    self.advertise_inactive_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "always-compare-med"):
                                    self.always_compare_med = value
                                    self.always_compare_med.value_namespace = name_space
                                    self.always_compare_med.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable-aigp"):
                                    self.enable_aigp = value
                                    self.enable_aigp.value_namespace = name_space
                                    self.enable_aigp.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-compare-router-id"):
                                    self.external_compare_router_id = value
                                    self.external_compare_router_id.value_namespace = name_space
                                    self.external_compare_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "ignore-as-path-length"):
                                    self.ignore_as_path_length = value
                                    self.ignore_as_path_length.value_namespace = name_space
                                    self.ignore_as_path_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "ignore-next-hop-igp-metric"):
                                    self.ignore_next_hop_igp_metric = value
                                    self.ignore_next_hop_igp_metric.value_namespace = name_space
                                    self.ignore_next_hop_igp_metric.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "route-selection-options" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L3VpnIpv4Multicast(Entity):
                        """
                        Multicast IPv4 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast, self).__init__()

                            self.yang_name = "l3vpn-ipv4-multicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv4-multicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv4-multicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L2VpnVpls(Entity):
                        """
                        BGP\-signalled VPLS configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls, self).__init__()

                            self.yang_name = "l2vpn-vpls"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l2vpn-vpls"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l2vpn-vpls" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Config(Entity):
                        """
                        Configuration parameters for the AFI\-SAFI
                        
                        .. attribute:: afi_safi_name
                        
                        	AFI,SAFI
                        	**type**\:   :py:class:`Afi_Safi_Type <ydk.models.openconfig.openconfig_bgp_types.Afi_Safi_Type>`
                        
                        .. attribute:: enabled
                        
                        	This leaf indicates whether the IPv4 Unicast AFI,SAFI is enabled for the neighbour or group
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "afi-safi"

                            self.afi_safi_name = YLeaf(YType.identityref, "afi-safi-name")

                            self.enabled = YLeaf(YType.boolean, "enabled")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi_safi_name",
                                            "enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi_safi_name.is_set or
                                self.enabled.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi_safi_name.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi_safi_name.get_name_leafdata())
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi-safi-name" or name == "enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi-safi-name"):
                                self.afi_safi_name = value
                                self.afi_safi_name.value_namespace = name_space
                                self.afi_safi_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix


                    class GracefulRestart(Entity):
                        """
                        Parameters relating to BGP graceful\-restart
                        
                        .. attribute:: config
                        
                        	Configuration options for BGP graceful\-restart
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.Config>`
                        
                        .. attribute:: state
                        
                        	State information for BGP graceful\-restart
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart, self).__init__()

                            self.yang_name = "graceful-restart"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration options for BGP graceful\-restart
                            
                            .. attribute:: enabled
                            
                            	This leaf indicates whether graceful\-restart is enabled for this AFI\-SAFI
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "graceful-restart"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information for BGP graceful\-restart
                            
                            .. attribute:: enabled
                            
                            	This leaf indicates whether graceful\-restart is enabled for this AFI\-SAFI
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "graceful-restart"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "graceful-restart" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ipv4Unicast(Entity):
                        """
                        IPv4 unicast configuration options
                        
                        .. attribute:: config
                        
                        	Configuration parameters for common IPv4 and IPv6 unicast AFI\-SAFI options
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.Config>`
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit>`
                        
                        .. attribute:: state
                        
                        	State information for common IPv4 and IPv6 unicast parameters
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast, self).__init__()

                            self.yang_name = "ipv4-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")

                            self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "ipv4-unicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Config(Entity):
                            """
                            Configuration parameters for common IPv4 and IPv6 unicast
                            AFI\-SAFI options
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "ipv4-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information for common IPv4 and IPv6 unicast
                            parameters
                            
                            .. attribute:: send_default_route
                            
                            	If set to true, send the default\-route to the neighbour(s)
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "ipv4-unicast"

                                self.send_default_route = YLeaf(YType.boolean, "send-default-route")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("send_default_route") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.send_default_route.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.send_default_route.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.send_default_route.is_set or self.send_default_route.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.send_default_route.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "send-default-route"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "send-default-route"):
                                    self.send_default_route = value
                                    self.send_default_route.value_namespace = name_space
                                    self.send_default_route.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv4-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "prefix-limit" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class UseMultiplePaths(Entity):
                        """
                        Parameters related to the use of multiple paths for the
                        same NLRI
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to multipath
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Config>`
                        
                        .. attribute:: ebgp
                        
                        	Multipath parameters for eBGP
                        	**type**\:   :py:class:`Ebgp <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp>`
                        
                        .. attribute:: ibgp
                        
                        	Multipath parameters for iBGP
                        	**type**\:   :py:class:`Ibgp <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp>`
                        
                        .. attribute:: state
                        
                        	State parameters relating to multipath
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.State>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths, self).__init__()

                            self.yang_name = "use-multiple-paths"
                            self.yang_parent_name = "afi-safi"

                            self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.ebgp = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp()
                            self.ebgp.parent = self
                            self._children_name_map["ebgp"] = "ebgp"
                            self._children_yang_names.add("ebgp")

                            self.ibgp = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp()
                            self.ibgp.parent = self
                            self._children_name_map["ibgp"] = "ibgp"
                            self._children_yang_names.add("ibgp")

                            self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Ebgp(Entity):
                            """
                            Multipath parameters for eBGP
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to eBGP multipath
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to eBGP multipath
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp, self).__init__()

                                self.yang_name = "ebgp"
                                self.yang_parent_name = "use-multiple-paths"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to eBGP multipath
                                
                                .. attribute:: allow_multiple_as
                                
                                	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: maximum_paths
                                
                                	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**default value**\: 1
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "ebgp"

                                    self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                                    self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("allow_multiple_as",
                                                    "maximum_paths") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.allow_multiple_as.is_set or
                                        self.maximum_paths.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.allow_multiple_as.yfilter != YFilter.not_set or
                                        self.maximum_paths.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                                    if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "allow-multiple-as" or name == "maximum-paths"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "allow-multiple-as"):
                                        self.allow_multiple_as = value
                                        self.allow_multiple_as.value_namespace = name_space
                                        self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "maximum-paths"):
                                        self.maximum_paths = value
                                        self.maximum_paths.value_namespace = name_space
                                        self.maximum_paths.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to eBGP multipath
                                
                                .. attribute:: allow_multiple_as
                                
                                	Allow multipath to use paths from different neighbouring ASes.  The default is to only consider multiple paths from the same neighbouring AS
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: maximum_paths
                                
                                	Maximum number of parallel paths to consider when using BGP multipath. The default is use a single path
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**default value**\: 1
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "ebgp"

                                    self.allow_multiple_as = YLeaf(YType.boolean, "allow-multiple-as")

                                    self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("allow_multiple_as",
                                                    "maximum_paths") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.allow_multiple_as.is_set or
                                        self.maximum_paths.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.allow_multiple_as.yfilter != YFilter.not_set or
                                        self.maximum_paths.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.allow_multiple_as.is_set or self.allow_multiple_as.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.allow_multiple_as.get_name_leafdata())
                                    if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "allow-multiple-as" or name == "maximum-paths"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "allow-multiple-as"):
                                        self.allow_multiple_as = value
                                        self.allow_multiple_as.value_namespace = name_space
                                        self.allow_multiple_as.value_namespace_prefix = name_space_prefix
                                    if(value_path == "maximum-paths"):
                                        self.maximum_paths = value
                                        self.maximum_paths.value_namespace = name_space
                                        self.maximum_paths.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ebgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class State(Entity):
                            """
                            State parameters relating to multipath
                            
                            .. attribute:: enabled
                            
                            	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "use-multiple-paths"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class Config(Entity):
                            """
                            Configuration parameters relating to multipath
                            
                            .. attribute:: enabled
                            
                            	Whether the use of multiple paths for the same NLRI is enabled for the neighbor. This value is overridden by any more specific configuration value
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "use-multiple-paths"

                                self.enabled = YLeaf(YType.boolean, "enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enabled.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix


                        class Ibgp(Entity):
                            """
                            Multipath parameters for iBGP
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to iBGP multipath
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to iBGP multipath
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp, self).__init__()

                                self.yang_name = "ibgp"
                                self.yang_parent_name = "use-multiple-paths"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to iBGP multipath
                                
                                .. attribute:: maximum_paths
                                
                                	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**default value**\: 1
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "ibgp"

                                    self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("maximum_paths") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.maximum_paths.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.maximum_paths.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "maximum-paths"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "maximum-paths"):
                                        self.maximum_paths = value
                                        self.maximum_paths.value_namespace = name_space
                                        self.maximum_paths.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to iBGP multipath
                                
                                .. attribute:: maximum_paths
                                
                                	Maximum number of parallel paths to consider when using iBGP multipath. The default is to use a single path
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**default value**\: 1
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "ibgp"

                                    self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("maximum_paths") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.maximum_paths.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.maximum_paths.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_paths.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "maximum-paths"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "maximum-paths"):
                                        self.maximum_paths = value
                                        self.maximum_paths.value_namespace = name_space
                                        self.maximum_paths.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ibgp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.ebgp is not None and self.ebgp.has_data()) or
                                (self.ibgp is not None and self.ibgp.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.ebgp is not None and self.ebgp.has_operation()) or
                                (self.ibgp is not None and self.ibgp.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "use-multiple-paths" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "ebgp"):
                                if (self.ebgp is None):
                                    self.ebgp = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ebgp()
                                    self.ebgp.parent = self
                                    self._children_name_map["ebgp"] = "ebgp"
                                return self.ebgp

                            if (child_yang_name == "ibgp"):
                                if (self.ibgp is None):
                                    self.ibgp = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.Ibgp()
                                    self.ibgp.parent = self
                                    self._children_name_map["ibgp"] = "ibgp"
                                return self.ibgp

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "ebgp" or name == "ibgp" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L3VpnIpv6Unicast(Entity):
                        """
                        Unicast IPv6 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast, self).__init__()

                            self.yang_name = "l3vpn-ipv6-unicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv6-unicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv6-unicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class L3VpnIpv6Multicast(Entity):
                        """
                        Multicast IPv6 L3VPN configuration options
                        
                        .. attribute:: prefix_limit
                        
                        	Configure the maximum number of prefixes that will be accepted from a peer
                        	**type**\:   :py:class:`PrefixLimit <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit>`
                        
                        

                        """

                        _prefix = 'oc-bgp'
                        _revision = '2016-06-21'

                        def __init__(self):
                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast, self).__init__()

                            self.yang_name = "l3vpn-ipv6-multicast"
                            self.yang_parent_name = "afi-safi"

                            self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit()
                            self.prefix_limit.parent = self
                            self._children_name_map["prefix_limit"] = "prefix-limit"
                            self._children_yang_names.add("prefix-limit")


                        class PrefixLimit(Entity):
                            """
                            Configure the maximum number of prefixes that will be
                            accepted from a peer
                            
                            .. attribute:: config
                            
                            	Configuration parameters relating to the prefix limit for the AFI\-SAFI
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config>`
                            
                            .. attribute:: state
                            
                            	State information relating to the prefix\-limit for the AFI\-SAFI
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State>`
                            
                            

                            """

                            _prefix = 'oc-bgp'
                            _revision = '2016-06-21'

                            def __init__(self):
                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit, self).__init__()

                                self.yang_name = "prefix-limit"
                                self.yang_parent_name = "l3vpn-ipv6-multicast"

                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration parameters relating to the prefix
                                limit for the AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information relating to the prefix\-limit for the
                                AFI\-SAFI
                                
                                .. attribute:: max_prefixes
                                
                                	Maximum number of prefixes that will be accepted from the neighbour
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: restart_timer
                                
                                	Time interval in seconds after which the BGP session is re\-established after being torn down due to exceeding the max\-prefix limit
                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                
                                	**range:** \-92233720368547758.08..92233720368547758.07
                                
                                	**units**\: seconds
                                
                                .. attribute:: shutdown_threshold_pct
                                
                                	Threshold on number of prefixes that can be received from a neighbour before generation of warning messages or log entries. Expressed as a percentage of max\-prefixes
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'oc-bgp'
                                _revision = '2016-06-21'

                                def __init__(self):
                                    super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "prefix-limit"

                                    self.max_prefixes = YLeaf(YType.uint32, "max-prefixes")

                                    self.restart_timer = YLeaf(YType.str, "restart-timer")

                                    self.shutdown_threshold_pct = YLeaf(YType.uint8, "shutdown-threshold-pct")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("max_prefixes",
                                                    "restart_timer",
                                                    "shutdown_threshold_pct") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.max_prefixes.is_set or
                                        self.restart_timer.is_set or
                                        self.shutdown_threshold_pct.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.max_prefixes.yfilter != YFilter.not_set or
                                        self.restart_timer.yfilter != YFilter.not_set or
                                        self.shutdown_threshold_pct.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.max_prefixes.is_set or self.max_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_prefixes.get_name_leafdata())
                                    if (self.restart_timer.is_set or self.restart_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.restart_timer.get_name_leafdata())
                                    if (self.shutdown_threshold_pct.is_set or self.shutdown_threshold_pct.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.shutdown_threshold_pct.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "max-prefixes" or name == "restart-timer" or name == "shutdown-threshold-pct"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "max-prefixes"):
                                        self.max_prefixes = value
                                        self.max_prefixes.value_namespace = name_space
                                        self.max_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "restart-timer"):
                                        self.restart_timer = value
                                        self.restart_timer.value_namespace = name_space
                                        self.restart_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "shutdown-threshold-pct"):
                                        self.shutdown_threshold_pct = value
                                        self.shutdown_threshold_pct.value_namespace = name_space
                                        self.shutdown_threshold_pct.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-limit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.prefix_limit is not None and self.prefix_limit.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.prefix_limit is not None and self.prefix_limit.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "l3vpn-ipv6-multicast" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-limit"):
                                if (self.prefix_limit is None):
                                    self.prefix_limit = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast.PrefixLimit()
                                    self.prefix_limit.parent = self
                                    self._children_name_map["prefix_limit"] = "prefix-limit"
                                return self.prefix_limit

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-limit"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.afi_safi_name.is_set or
                            (self.apply_policy is not None and self.apply_policy.has_data()) or
                            (self.config is not None and self.config.has_data()) or
                            (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                            (self.ipv4_labeled_unicast is not None and self.ipv4_labeled_unicast.has_data()) or
                            (self.ipv4_unicast is not None and self.ipv4_unicast.has_data()) or
                            (self.ipv6_labeled_unicast is not None and self.ipv6_labeled_unicast.has_data()) or
                            (self.ipv6_unicast is not None and self.ipv6_unicast.has_data()) or
                            (self.l2vpn_evpn is not None and self.l2vpn_evpn.has_data()) or
                            (self.l2vpn_vpls is not None and self.l2vpn_vpls.has_data()) or
                            (self.l3vpn_ipv4_multicast is not None and self.l3vpn_ipv4_multicast.has_data()) or
                            (self.l3vpn_ipv4_unicast is not None and self.l3vpn_ipv4_unicast.has_data()) or
                            (self.l3vpn_ipv6_multicast is not None and self.l3vpn_ipv6_multicast.has_data()) or
                            (self.l3vpn_ipv6_unicast is not None and self.l3vpn_ipv6_unicast.has_data()) or
                            (self.route_selection_options is not None and self.route_selection_options.has_data()) or
                            (self.state is not None and self.state.has_data()) or
                            (self.use_multiple_paths is not None and self.use_multiple_paths.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi_safi_name.yfilter != YFilter.not_set or
                            (self.apply_policy is not None and self.apply_policy.has_operation()) or
                            (self.config is not None and self.config.has_operation()) or
                            (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                            (self.ipv4_labeled_unicast is not None and self.ipv4_labeled_unicast.has_operation()) or
                            (self.ipv4_unicast is not None and self.ipv4_unicast.has_operation()) or
                            (self.ipv6_labeled_unicast is not None and self.ipv6_labeled_unicast.has_operation()) or
                            (self.ipv6_unicast is not None and self.ipv6_unicast.has_operation()) or
                            (self.l2vpn_evpn is not None and self.l2vpn_evpn.has_operation()) or
                            (self.l2vpn_vpls is not None and self.l2vpn_vpls.has_operation()) or
                            (self.l3vpn_ipv4_multicast is not None and self.l3vpn_ipv4_multicast.has_operation()) or
                            (self.l3vpn_ipv4_unicast is not None and self.l3vpn_ipv4_unicast.has_operation()) or
                            (self.l3vpn_ipv6_multicast is not None and self.l3vpn_ipv6_multicast.has_operation()) or
                            (self.l3vpn_ipv6_unicast is not None and self.l3vpn_ipv6_unicast.has_operation()) or
                            (self.route_selection_options is not None and self.route_selection_options.has_operation()) or
                            (self.state is not None and self.state.has_operation()) or
                            (self.use_multiple_paths is not None and self.use_multiple_paths.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "afi-safi" + "[afi-safi-name='" + self.afi_safi_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi_safi_name.is_set or self.afi_safi_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi_safi_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "apply-policy"):
                            if (self.apply_policy is None):
                                self.apply_policy = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.ApplyPolicy()
                                self.apply_policy.parent = self
                                self._children_name_map["apply_policy"] = "apply-policy"
                            return self.apply_policy

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "graceful-restart"):
                            if (self.graceful_restart is None):
                                self.graceful_restart = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.GracefulRestart()
                                self.graceful_restart.parent = self
                                self._children_name_map["graceful_restart"] = "graceful-restart"
                            return self.graceful_restart

                        if (child_yang_name == "ipv4-labeled-unicast"):
                            if (self.ipv4_labeled_unicast is None):
                                self.ipv4_labeled_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4LabeledUnicast()
                                self.ipv4_labeled_unicast.parent = self
                                self._children_name_map["ipv4_labeled_unicast"] = "ipv4-labeled-unicast"
                            return self.ipv4_labeled_unicast

                        if (child_yang_name == "ipv4-unicast"):
                            if (self.ipv4_unicast is None):
                                self.ipv4_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv4Unicast()
                                self.ipv4_unicast.parent = self
                                self._children_name_map["ipv4_unicast"] = "ipv4-unicast"
                            return self.ipv4_unicast

                        if (child_yang_name == "ipv6-labeled-unicast"):
                            if (self.ipv6_labeled_unicast is None):
                                self.ipv6_labeled_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6LabeledUnicast()
                                self.ipv6_labeled_unicast.parent = self
                                self._children_name_map["ipv6_labeled_unicast"] = "ipv6-labeled-unicast"
                            return self.ipv6_labeled_unicast

                        if (child_yang_name == "ipv6-unicast"):
                            if (self.ipv6_unicast is None):
                                self.ipv6_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.Ipv6Unicast()
                                self.ipv6_unicast.parent = self
                                self._children_name_map["ipv6_unicast"] = "ipv6-unicast"
                            return self.ipv6_unicast

                        if (child_yang_name == "l2vpn-evpn"):
                            if (self.l2vpn_evpn is None):
                                self.l2vpn_evpn = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnEvpn()
                                self.l2vpn_evpn.parent = self
                                self._children_name_map["l2vpn_evpn"] = "l2vpn-evpn"
                            return self.l2vpn_evpn

                        if (child_yang_name == "l2vpn-vpls"):
                            if (self.l2vpn_vpls is None):
                                self.l2vpn_vpls = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L2VpnVpls()
                                self.l2vpn_vpls.parent = self
                                self._children_name_map["l2vpn_vpls"] = "l2vpn-vpls"
                            return self.l2vpn_vpls

                        if (child_yang_name == "l3vpn-ipv4-multicast"):
                            if (self.l3vpn_ipv4_multicast is None):
                                self.l3vpn_ipv4_multicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Multicast()
                                self.l3vpn_ipv4_multicast.parent = self
                                self._children_name_map["l3vpn_ipv4_multicast"] = "l3vpn-ipv4-multicast"
                            return self.l3vpn_ipv4_multicast

                        if (child_yang_name == "l3vpn-ipv4-unicast"):
                            if (self.l3vpn_ipv4_unicast is None):
                                self.l3vpn_ipv4_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv4Unicast()
                                self.l3vpn_ipv4_unicast.parent = self
                                self._children_name_map["l3vpn_ipv4_unicast"] = "l3vpn-ipv4-unicast"
                            return self.l3vpn_ipv4_unicast

                        if (child_yang_name == "l3vpn-ipv6-multicast"):
                            if (self.l3vpn_ipv6_multicast is None):
                                self.l3vpn_ipv6_multicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Multicast()
                                self.l3vpn_ipv6_multicast.parent = self
                                self._children_name_map["l3vpn_ipv6_multicast"] = "l3vpn-ipv6-multicast"
                            return self.l3vpn_ipv6_multicast

                        if (child_yang_name == "l3vpn-ipv6-unicast"):
                            if (self.l3vpn_ipv6_unicast is None):
                                self.l3vpn_ipv6_unicast = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.L3VpnIpv6Unicast()
                                self.l3vpn_ipv6_unicast.parent = self
                                self._children_name_map["l3vpn_ipv6_unicast"] = "l3vpn-ipv6-unicast"
                            return self.l3vpn_ipv6_unicast

                        if (child_yang_name == "route-selection-options"):
                            if (self.route_selection_options is None):
                                self.route_selection_options = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.RouteSelectionOptions()
                                self.route_selection_options.parent = self
                                self._children_name_map["route_selection_options"] = "route-selection-options"
                            return self.route_selection_options

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        if (child_yang_name == "use-multiple-paths"):
                            if (self.use_multiple_paths is None):
                                self.use_multiple_paths = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi.UseMultiplePaths()
                                self.use_multiple_paths.parent = self
                                self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                            return self.use_multiple_paths

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "apply-policy" or name == "config" or name == "graceful-restart" or name == "ipv4-labeled-unicast" or name == "ipv4-unicast" or name == "ipv6-labeled-unicast" or name == "ipv6-unicast" or name == "l2vpn-evpn" or name == "l2vpn-vpls" or name == "l3vpn-ipv4-multicast" or name == "l3vpn-ipv4-unicast" or name == "l3vpn-ipv6-multicast" or name == "l3vpn-ipv6-unicast" or name == "route-selection-options" or name == "state" or name == "use-multiple-paths" or name == "afi-safi-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi-safi-name"):
                            self.afi_safi_name = value
                            self.afi_safi_name.value_namespace = name_space
                            self.afi_safi_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.afi_safi:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.afi_safi:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "afi-safis" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "afi-safi"):
                        for c in self.afi_safi:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bgp.PeerGroups.PeerGroup.AfiSafis.AfiSafi()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.afi_safi.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "afi-safi"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Config(Entity):
                """
                Configuration parameters relating to the BGP neighbor or
                group
                
                .. attribute:: auth_password
                
                	Configures an MD5 authentication password for use with neighboring devices
                	**type**\:  str
                
                .. attribute:: description
                
                	An optional textual description (intended primarily for use with a peer or group
                	**type**\:  str
                
                .. attribute:: local_as
                
                	The local autonomous system number that is to be used when establishing sessions with the remote peer or peer group, if this differs from the global BGP router autonomous system number
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_as
                
                	AS number of the peer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_group_name
                
                	Name of the BGP peer\-group
                	**type**\:  str
                
                .. attribute:: peer_type
                
                	Explicitly designate the peer or peer group as internal (iBGP) or external (eBGP)
                	**type**\:   :py:class:`PeerType <ydk.models.openconfig.openconfig_bgp_types.PeerType>`
                
                .. attribute:: remove_private_as
                
                	Remove private AS numbers from updates sent to peers \- when this leaf is not specified, the AS\_PATH attribute should be sent to the peer unchanged
                	**type**\:   :py:class:`Remove_Private_As_Option <ydk.models.openconfig.openconfig_bgp_types.Remove_Private_As_Option>`
                
                .. attribute:: route_flap_damping
                
                	Enable route flap damping
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: send_community
                
                	Specify which types of community should be sent to the neighbor or group. The default is to not send the community attribute
                	**type**\:   :py:class:`CommunityType <ydk.models.openconfig.openconfig_bgp_types.CommunityType>`
                
                	**default value**\: NONE
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "peer-group"

                    self.auth_password = YLeaf(YType.str, "auth-password")

                    self.description = YLeaf(YType.str, "description")

                    self.local_as = YLeaf(YType.uint32, "local-as")

                    self.peer_as = YLeaf(YType.uint32, "peer-as")

                    self.peer_group_name = YLeaf(YType.str, "peer-group-name")

                    self.peer_type = YLeaf(YType.enumeration, "peer-type")

                    self.remove_private_as = YLeaf(YType.identityref, "remove-private-as")

                    self.route_flap_damping = YLeaf(YType.boolean, "route-flap-damping")

                    self.send_community = YLeaf(YType.enumeration, "send-community")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("auth_password",
                                    "description",
                                    "local_as",
                                    "peer_as",
                                    "peer_group_name",
                                    "peer_type",
                                    "remove_private_as",
                                    "route_flap_damping",
                                    "send_community") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bgp.PeerGroups.PeerGroup.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bgp.PeerGroups.PeerGroup.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.auth_password.is_set or
                        self.description.is_set or
                        self.local_as.is_set or
                        self.peer_as.is_set or
                        self.peer_group_name.is_set or
                        self.peer_type.is_set or
                        self.remove_private_as.is_set or
                        self.route_flap_damping.is_set or
                        self.send_community.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.auth_password.yfilter != YFilter.not_set or
                        self.description.yfilter != YFilter.not_set or
                        self.local_as.yfilter != YFilter.not_set or
                        self.peer_as.yfilter != YFilter.not_set or
                        self.peer_group_name.yfilter != YFilter.not_set or
                        self.peer_type.yfilter != YFilter.not_set or
                        self.remove_private_as.yfilter != YFilter.not_set or
                        self.route_flap_damping.yfilter != YFilter.not_set or
                        self.send_community.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.auth_password.is_set or self.auth_password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.auth_password.get_name_leafdata())
                    if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.description.get_name_leafdata())
                    if (self.local_as.is_set or self.local_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_as.get_name_leafdata())
                    if (self.peer_as.is_set or self.peer_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_as.get_name_leafdata())
                    if (self.peer_group_name.is_set or self.peer_group_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_group_name.get_name_leafdata())
                    if (self.peer_type.is_set or self.peer_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_type.get_name_leafdata())
                    if (self.remove_private_as.is_set or self.remove_private_as.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remove_private_as.get_name_leafdata())
                    if (self.route_flap_damping.is_set or self.route_flap_damping.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.route_flap_damping.get_name_leafdata())
                    if (self.send_community.is_set or self.send_community.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.send_community.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "auth-password" or name == "description" or name == "local-as" or name == "peer-as" or name == "peer-group-name" or name == "peer-type" or name == "remove-private-as" or name == "route-flap-damping" or name == "send-community"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "auth-password"):
                        self.auth_password = value
                        self.auth_password.value_namespace = name_space
                        self.auth_password.value_namespace_prefix = name_space_prefix
                    if(value_path == "description"):
                        self.description = value
                        self.description.value_namespace = name_space
                        self.description.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-as"):
                        self.local_as = value
                        self.local_as.value_namespace = name_space
                        self.local_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-as"):
                        self.peer_as = value
                        self.peer_as.value_namespace = name_space
                        self.peer_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-group-name"):
                        self.peer_group_name = value
                        self.peer_group_name.value_namespace = name_space
                        self.peer_group_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-type"):
                        self.peer_type = value
                        self.peer_type.value_namespace = name_space
                        self.peer_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "remove-private-as"):
                        self.remove_private_as = value
                        self.remove_private_as.value_namespace = name_space
                        self.remove_private_as.value_namespace_prefix = name_space_prefix
                    if(value_path == "route-flap-damping"):
                        self.route_flap_damping = value
                        self.route_flap_damping.value_namespace = name_space
                        self.route_flap_damping.value_namespace_prefix = name_space_prefix
                    if(value_path == "send-community"):
                        self.send_community = value
                        self.send_community.value_namespace = name_space
                        self.send_community.value_namespace_prefix = name_space_prefix


            class GracefulRestart(Entity):
                """
                Parameters relating the graceful restart mechanism for BGP
                
                .. attribute:: config
                
                	Configuration parameters relating to graceful\-restart
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.GracefulRestart.Config>`
                
                .. attribute:: state
                
                	State information associated with graceful\-restart
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.GracefulRestart.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.GracefulRestart, self).__init__()

                    self.yang_name = "graceful-restart"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.GracefulRestart.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.GracefulRestart.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to graceful\-restart
                    
                    .. attribute:: enabled
                    
                    	Enable or disable the graceful\-restart capability
                    	**type**\:  bool
                    
                    .. attribute:: helper_only
                    
                    	Enable graceful\-restart in helper mode only. When this leaf is set, the local system does not retain forwarding its own state during a restart, but supports procedures for the receiving speaker, as defined in RFC4724
                    	**type**\:  bool
                    
                    .. attribute:: restart_time
                    
                    	Estimated time (in seconds) for the local BGP speaker to restart a session. This value is advertise in the graceful restart BGP capability.  This is a 12\-bit value, referred to as Restart Time in RFC4724.  Per RFC4724, the suggested default value is <= the hold\-time value
                    	**type**\:  int
                    
                    	**range:** 0..4096
                    
                    .. attribute:: stale_routes_time
                    
                    	An upper\-bound on the time thate stale routes will be retained by a router after a session is restarted. If an End\-of\-RIB (EOR) marker is received prior to this timer expiring stale\-routes will be flushed upon its receipt \- if no EOR is received, then when this timer expires stale paths will be purged. This timer is referred to as the Selection\_Deferral\_Timer in RFC4724
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.GracefulRestart.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "graceful-restart"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.helper_only = YLeaf(YType.boolean, "helper-only")

                        self.restart_time = YLeaf(YType.uint16, "restart-time")

                        self.stale_routes_time = YLeaf(YType.str, "stale-routes-time")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "helper_only",
                                        "restart_time",
                                        "stale_routes_time") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.GracefulRestart.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.GracefulRestart.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.helper_only.is_set or
                            self.restart_time.is_set or
                            self.stale_routes_time.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.helper_only.yfilter != YFilter.not_set or
                            self.restart_time.yfilter != YFilter.not_set or
                            self.stale_routes_time.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.helper_only.is_set or self.helper_only.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.helper_only.get_name_leafdata())
                        if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.restart_time.get_name_leafdata())
                        if (self.stale_routes_time.is_set or self.stale_routes_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stale_routes_time.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "helper-only" or name == "restart-time" or name == "stale-routes-time"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "helper-only"):
                            self.helper_only = value
                            self.helper_only.value_namespace = name_space
                            self.helper_only.value_namespace_prefix = name_space_prefix
                        if(value_path == "restart-time"):
                            self.restart_time = value
                            self.restart_time.value_namespace = name_space
                            self.restart_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "stale-routes-time"):
                            self.stale_routes_time = value
                            self.stale_routes_time.value_namespace = name_space
                            self.stale_routes_time.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information associated with graceful\-restart
                    
                    .. attribute:: enabled
                    
                    	Enable or disable the graceful\-restart capability
                    	**type**\:  bool
                    
                    .. attribute:: helper_only
                    
                    	Enable graceful\-restart in helper mode only. When this leaf is set, the local system does not retain forwarding its own state during a restart, but supports procedures for the receiving speaker, as defined in RFC4724
                    	**type**\:  bool
                    
                    .. attribute:: restart_time
                    
                    	Estimated time (in seconds) for the local BGP speaker to restart a session. This value is advertise in the graceful restart BGP capability.  This is a 12\-bit value, referred to as Restart Time in RFC4724.  Per RFC4724, the suggested default value is <= the hold\-time value
                    	**type**\:  int
                    
                    	**range:** 0..4096
                    
                    .. attribute:: stale_routes_time
                    
                    	An upper\-bound on the time thate stale routes will be retained by a router after a session is restarted. If an End\-of\-RIB (EOR) marker is received prior to this timer expiring stale\-routes will be flushed upon its receipt \- if no EOR is received, then when this timer expires stale paths will be purged. This timer is referred to as the Selection\_Deferral\_Timer in RFC4724
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.GracefulRestart.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "graceful-restart"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.helper_only = YLeaf(YType.boolean, "helper-only")

                        self.restart_time = YLeaf(YType.uint16, "restart-time")

                        self.stale_routes_time = YLeaf(YType.str, "stale-routes-time")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "helper_only",
                                        "restart_time",
                                        "stale_routes_time") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.GracefulRestart.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.GracefulRestart.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.helper_only.is_set or
                            self.restart_time.is_set or
                            self.stale_routes_time.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.helper_only.yfilter != YFilter.not_set or
                            self.restart_time.yfilter != YFilter.not_set or
                            self.stale_routes_time.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.helper_only.is_set or self.helper_only.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.helper_only.get_name_leafdata())
                        if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.restart_time.get_name_leafdata())
                        if (self.stale_routes_time.is_set or self.stale_routes_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stale_routes_time.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "helper-only" or name == "restart-time" or name == "stale-routes-time"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "helper-only"):
                            self.helper_only = value
                            self.helper_only.value_namespace = name_space
                            self.helper_only.value_namespace_prefix = name_space_prefix
                        if(value_path == "restart-time"):
                            self.restart_time = value
                            self.restart_time.value_namespace = name_space
                            self.restart_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "stale-routes-time"):
                            self.stale_routes_time = value
                            self.stale_routes_time.value_namespace = name_space
                            self.stale_routes_time.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "graceful-restart" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.GracefulRestart.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.GracefulRestart.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class RouteReflector(Entity):
                """
                Route reflector parameters for the BGPgroup
                
                .. attribute:: config
                
                	Configuraton parameters relating to route reflection for the BGPgroup
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.RouteReflector.Config>`
                
                .. attribute:: state
                
                	State information relating to route reflection for the BGPgroup
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.RouteReflector.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.RouteReflector, self).__init__()

                    self.yang_name = "route-reflector"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.RouteReflector.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.RouteReflector.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuraton parameters relating to route reflection
                    for the BGPgroup
                    
                    .. attribute:: route_reflector_client
                    
                    	Configure the neighbor as a route reflector client
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: route_reflector_cluster_id
                    
                    	route\-reflector cluster id to use when local router is configured as a route reflector.  Commonly set at the group level, but allows a different cluster id to be set for each neighbor
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.RouteReflector.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "route-reflector"

                        self.route_reflector_client = YLeaf(YType.boolean, "route-reflector-client")

                        self.route_reflector_cluster_id = YLeaf(YType.str, "route-reflector-cluster-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("route_reflector_client",
                                        "route_reflector_cluster_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.RouteReflector.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.RouteReflector.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.route_reflector_client.is_set or
                            self.route_reflector_cluster_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.route_reflector_client.yfilter != YFilter.not_set or
                            self.route_reflector_cluster_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.route_reflector_client.is_set or self.route_reflector_client.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_client.get_name_leafdata())
                        if (self.route_reflector_cluster_id.is_set or self.route_reflector_cluster_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_cluster_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-reflector-client" or name == "route-reflector-cluster-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "route-reflector-client"):
                            self.route_reflector_client = value
                            self.route_reflector_client.value_namespace = name_space
                            self.route_reflector_client.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-reflector-cluster-id"):
                            self.route_reflector_cluster_id = value
                            self.route_reflector_cluster_id.value_namespace = name_space
                            self.route_reflector_cluster_id.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to route reflection for the
                    BGPgroup
                    
                    .. attribute:: route_reflector_client
                    
                    	Configure the neighbor as a route reflector client
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: route_reflector_cluster_id
                    
                    	route\-reflector cluster id to use when local router is configured as a route reflector.  Commonly set at the group level, but allows a different cluster id to be set for each neighbor
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.RouteReflector.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "route-reflector"

                        self.route_reflector_client = YLeaf(YType.boolean, "route-reflector-client")

                        self.route_reflector_cluster_id = YLeaf(YType.str, "route-reflector-cluster-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("route_reflector_client",
                                        "route_reflector_cluster_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.RouteReflector.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.RouteReflector.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.route_reflector_client.is_set or
                            self.route_reflector_cluster_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.route_reflector_client.yfilter != YFilter.not_set or
                            self.route_reflector_cluster_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.route_reflector_client.is_set or self.route_reflector_client.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_client.get_name_leafdata())
                        if (self.route_reflector_cluster_id.is_set or self.route_reflector_cluster_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_reflector_cluster_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route-reflector-client" or name == "route-reflector-cluster-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "route-reflector-client"):
                            self.route_reflector_client = value
                            self.route_reflector_client.value_namespace = name_space
                            self.route_reflector_client.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-reflector-cluster-id"):
                            self.route_reflector_cluster_id = value
                            self.route_reflector_cluster_id.value_namespace = name_space
                            self.route_reflector_cluster_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "route-reflector" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.RouteReflector.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.RouteReflector.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AsPathOptions(Entity):
                """
                AS\_PATH manipulation parameters for the BGP neighbor or
                group
                
                .. attribute:: config
                
                	Configuration parameters relating to AS\_PATH manipulation for the BGP peer or group
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AsPathOptions.Config>`
                
                .. attribute:: state
                
                	State information relating to the AS\_PATH manipulation mechanisms for the BGP peer or group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.AsPathOptions.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.AsPathOptions, self).__init__()

                    self.yang_name = "as-path-options"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.AsPathOptions.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.AsPathOptions.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to AS\_PATH manipulation
                    for the BGP peer or group
                    
                    .. attribute:: allow_own_as
                    
                    	Specify the number of occurrences of the local BGP speaker's AS that can occur within the AS\_PATH before it is rejected
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**default value**\: 0
                    
                    .. attribute:: replace_peer_as
                    
                    	Replace occurrences of the peer's AS in the AS\_PATH with the local autonomous system number
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.AsPathOptions.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "as-path-options"

                        self.allow_own_as = YLeaf(YType.uint8, "allow-own-as")

                        self.replace_peer_as = YLeaf(YType.boolean, "replace-peer-as")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_own_as",
                                        "replace_peer_as") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.AsPathOptions.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.AsPathOptions.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_own_as.is_set or
                            self.replace_peer_as.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_own_as.yfilter != YFilter.not_set or
                            self.replace_peer_as.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_own_as.is_set or self.allow_own_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_own_as.get_name_leafdata())
                        if (self.replace_peer_as.is_set or self.replace_peer_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.replace_peer_as.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-own-as" or name == "replace-peer-as"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-own-as"):
                            self.allow_own_as = value
                            self.allow_own_as.value_namespace = name_space
                            self.allow_own_as.value_namespace_prefix = name_space_prefix
                        if(value_path == "replace-peer-as"):
                            self.replace_peer_as = value
                            self.replace_peer_as.value_namespace = name_space
                            self.replace_peer_as.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to the AS\_PATH manipulation
                    mechanisms for the BGP peer or group
                    
                    .. attribute:: allow_own_as
                    
                    	Specify the number of occurrences of the local BGP speaker's AS that can occur within the AS\_PATH before it is rejected
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**default value**\: 0
                    
                    .. attribute:: replace_peer_as
                    
                    	Replace occurrences of the peer's AS in the AS\_PATH with the local autonomous system number
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.AsPathOptions.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "as-path-options"

                        self.allow_own_as = YLeaf(YType.uint8, "allow-own-as")

                        self.replace_peer_as = YLeaf(YType.boolean, "replace-peer-as")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("allow_own_as",
                                        "replace_peer_as") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.AsPathOptions.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.AsPathOptions.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.allow_own_as.is_set or
                            self.replace_peer_as.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.allow_own_as.yfilter != YFilter.not_set or
                            self.replace_peer_as.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.allow_own_as.is_set or self.allow_own_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.allow_own_as.get_name_leafdata())
                        if (self.replace_peer_as.is_set or self.replace_peer_as.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.replace_peer_as.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "allow-own-as" or name == "replace-peer-as"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "allow-own-as"):
                            self.allow_own_as = value
                            self.allow_own_as.value_namespace = name_space
                            self.allow_own_as.value_namespace_prefix = name_space_prefix
                        if(value_path == "replace-peer-as"):
                            self.replace_peer_as = value
                            self.replace_peer_as.value_namespace = name_space
                            self.replace_peer_as.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "as-path-options" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.AsPathOptions.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.AsPathOptions.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Timers(Entity):
                """
                Timers related to a BGP peer\-group
                
                .. attribute:: config
                
                	Configuration parameters relating to timers used for the BGP neighbor or peer group
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Timers.Config>`
                
                .. attribute:: state
                
                	State information relating to the timers used for the BGP group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Timers.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.Timers, self).__init__()

                    self.yang_name = "timers"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.Timers.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.Timers.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to timers used for the
                    BGP neighbor or peer group
                    
                    .. attribute:: connect_retry
                    
                    	Time interval in seconds between attempts to establish a session with the peer
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: hold_time
                    
                    	Time interval in seconds that a BGP session will be considered active in the absence of keepalive or other messages from the peer.  The hold\-time is typically set to 3x the keepalive\-interval
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 90
                    
                    .. attribute:: keepalive_interval
                    
                    	Time interval in seconds between transmission of keepalive messages to the neighbor.  Typically set to 1/3 the hold\-time
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: minimum_advertisement_interval
                    
                    	Minimum time which must elapse between subsequent UPDATE messages relating to a common set of NLRI being transmitted to a peer. This timer is referred to as MinRouteAdvertisementIntervalTimer by RFC 4721 and serves to reduce the number of UPDATE messages transmitted when a particular set of NLRI exhibit instability
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.Timers.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "timers"

                        self.connect_retry = YLeaf(YType.str, "connect-retry")

                        self.hold_time = YLeaf(YType.str, "hold-time")

                        self.keepalive_interval = YLeaf(YType.str, "keepalive-interval")

                        self.minimum_advertisement_interval = YLeaf(YType.str, "minimum-advertisement-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("connect_retry",
                                        "hold_time",
                                        "keepalive_interval",
                                        "minimum_advertisement_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.Timers.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.Timers.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.connect_retry.is_set or
                            self.hold_time.is_set or
                            self.keepalive_interval.is_set or
                            self.minimum_advertisement_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.connect_retry.yfilter != YFilter.not_set or
                            self.hold_time.yfilter != YFilter.not_set or
                            self.keepalive_interval.yfilter != YFilter.not_set or
                            self.minimum_advertisement_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.connect_retry.is_set or self.connect_retry.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connect_retry.get_name_leafdata())
                        if (self.hold_time.is_set or self.hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_time.get_name_leafdata())
                        if (self.keepalive_interval.is_set or self.keepalive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_interval.get_name_leafdata())
                        if (self.minimum_advertisement_interval.is_set or self.minimum_advertisement_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum_advertisement_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "connect-retry" or name == "hold-time" or name == "keepalive-interval" or name == "minimum-advertisement-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "connect-retry"):
                            self.connect_retry = value
                            self.connect_retry.value_namespace = name_space
                            self.connect_retry.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-time"):
                            self.hold_time = value
                            self.hold_time.value_namespace = name_space
                            self.hold_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-interval"):
                            self.keepalive_interval = value
                            self.keepalive_interval.value_namespace = name_space
                            self.keepalive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum-advertisement-interval"):
                            self.minimum_advertisement_interval = value
                            self.minimum_advertisement_interval.value_namespace = name_space
                            self.minimum_advertisement_interval.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to the timers used for the BGP
                    group
                    
                    .. attribute:: connect_retry
                    
                    	Time interval in seconds between attempts to establish a session with the peer
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: hold_time
                    
                    	Time interval in seconds that a BGP session will be considered active in the absence of keepalive or other messages from the peer.  The hold\-time is typically set to 3x the keepalive\-interval
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 90
                    
                    .. attribute:: keepalive_interval
                    
                    	Time interval in seconds between transmission of keepalive messages to the neighbor.  Typically set to 1/3 the hold\-time
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    .. attribute:: minimum_advertisement_interval
                    
                    	Minimum time which must elapse between subsequent UPDATE messages relating to a common set of NLRI being transmitted to a peer. This timer is referred to as MinRouteAdvertisementIntervalTimer by RFC 4721 and serves to reduce the number of UPDATE messages transmitted when a particular set of NLRI exhibit instability
                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                    
                    	**range:** \-92233720368547758.08..92233720368547758.07
                    
                    	**default value**\: 30
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.Timers.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "timers"

                        self.connect_retry = YLeaf(YType.str, "connect-retry")

                        self.hold_time = YLeaf(YType.str, "hold-time")

                        self.keepalive_interval = YLeaf(YType.str, "keepalive-interval")

                        self.minimum_advertisement_interval = YLeaf(YType.str, "minimum-advertisement-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("connect_retry",
                                        "hold_time",
                                        "keepalive_interval",
                                        "minimum_advertisement_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.Timers.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.Timers.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.connect_retry.is_set or
                            self.hold_time.is_set or
                            self.keepalive_interval.is_set or
                            self.minimum_advertisement_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.connect_retry.yfilter != YFilter.not_set or
                            self.hold_time.yfilter != YFilter.not_set or
                            self.keepalive_interval.yfilter != YFilter.not_set or
                            self.minimum_advertisement_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.connect_retry.is_set or self.connect_retry.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.connect_retry.get_name_leafdata())
                        if (self.hold_time.is_set or self.hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_time.get_name_leafdata())
                        if (self.keepalive_interval.is_set or self.keepalive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_interval.get_name_leafdata())
                        if (self.minimum_advertisement_interval.is_set or self.minimum_advertisement_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum_advertisement_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "connect-retry" or name == "hold-time" or name == "keepalive-interval" or name == "minimum-advertisement-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "connect-retry"):
                            self.connect_retry = value
                            self.connect_retry.value_namespace = name_space
                            self.connect_retry.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-time"):
                            self.hold_time = value
                            self.hold_time.value_namespace = name_space
                            self.hold_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-interval"):
                            self.keepalive_interval = value
                            self.keepalive_interval.value_namespace = name_space
                            self.keepalive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum-advertisement-interval"):
                            self.minimum_advertisement_interval = value
                            self.minimum_advertisement_interval.value_namespace = name_space
                            self.minimum_advertisement_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "timers" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.Timers.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.Timers.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Transport(Entity):
                """
                Transport session parameters for the BGP peer\-group
                
                .. attribute:: config
                
                	Configuration parameters relating to the transport session(s) used for the BGP neighbor or group
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Transport.Config>`
                
                .. attribute:: state
                
                	State information relating to the transport session(s) used for the BGP neighbor or group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.Transport.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.Transport, self).__init__()

                    self.yang_name = "transport"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.Transport.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.Transport.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to the transport
                    session(s) used for the BGP neighbor or group
                    
                    .. attribute:: local_address
                    
                    	Set the local IP (either IPv4 or IPv6) address to use for the session when sending BGP update messages.  This may be expressed as either an IP address or reference to the name of an interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    
                    ----
                    	**type**\:  str
                    
                    
                    ----
                    .. attribute:: mtu_discovery
                    
                    	Turns path mtu discovery for BGP TCP sessions on (true) or off (false)
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: passive_mode
                    
                    	Wait for peers to issue requests to open a BGP session, rather than initiating sessions from the local router
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: tcp_mss
                    
                    	Sets the max segment size for BGP TCP sessions
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.Transport.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "transport"

                        self.local_address = YLeaf(YType.str, "local-address")

                        self.mtu_discovery = YLeaf(YType.boolean, "mtu-discovery")

                        self.passive_mode = YLeaf(YType.boolean, "passive-mode")

                        self.tcp_mss = YLeaf(YType.uint16, "tcp-mss")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("local_address",
                                        "mtu_discovery",
                                        "passive_mode",
                                        "tcp_mss") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.Transport.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.Transport.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.local_address.is_set or
                            self.mtu_discovery.is_set or
                            self.passive_mode.is_set or
                            self.tcp_mss.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.local_address.yfilter != YFilter.not_set or
                            self.mtu_discovery.yfilter != YFilter.not_set or
                            self.passive_mode.yfilter != YFilter.not_set or
                            self.tcp_mss.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_address.get_name_leafdata())
                        if (self.mtu_discovery.is_set or self.mtu_discovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu_discovery.get_name_leafdata())
                        if (self.passive_mode.is_set or self.passive_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.passive_mode.get_name_leafdata())
                        if (self.tcp_mss.is_set or self.tcp_mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_mss.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "local-address" or name == "mtu-discovery" or name == "passive-mode" or name == "tcp-mss"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "local-address"):
                            self.local_address = value
                            self.local_address.value_namespace = name_space
                            self.local_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu-discovery"):
                            self.mtu_discovery = value
                            self.mtu_discovery.value_namespace = name_space
                            self.mtu_discovery.value_namespace_prefix = name_space_prefix
                        if(value_path == "passive-mode"):
                            self.passive_mode = value
                            self.passive_mode.value_namespace = name_space
                            self.passive_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-mss"):
                            self.tcp_mss = value
                            self.tcp_mss.value_namespace = name_space
                            self.tcp_mss.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information relating to the transport session(s)
                    used for the BGP neighbor or group
                    
                    .. attribute:: local_address
                    
                    	Set the local IP (either IPv4 or IPv6) address to use for the session when sending BGP update messages.  This may be expressed as either an IP address or reference to the name of an interface
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    
                    ----
                    	**type**\:  str
                    
                    
                    ----
                    .. attribute:: mtu_discovery
                    
                    	Turns path mtu discovery for BGP TCP sessions on (true) or off (false)
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: passive_mode
                    
                    	Wait for peers to issue requests to open a BGP session, rather than initiating sessions from the local router
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: tcp_mss
                    
                    	Sets the max segment size for BGP TCP sessions
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.Transport.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "transport"

                        self.local_address = YLeaf(YType.str, "local-address")

                        self.mtu_discovery = YLeaf(YType.boolean, "mtu-discovery")

                        self.passive_mode = YLeaf(YType.boolean, "passive-mode")

                        self.tcp_mss = YLeaf(YType.uint16, "tcp-mss")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("local_address",
                                        "mtu_discovery",
                                        "passive_mode",
                                        "tcp_mss") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.Transport.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.Transport.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.local_address.is_set or
                            self.mtu_discovery.is_set or
                            self.passive_mode.is_set or
                            self.tcp_mss.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.local_address.yfilter != YFilter.not_set or
                            self.mtu_discovery.yfilter != YFilter.not_set or
                            self.passive_mode.yfilter != YFilter.not_set or
                            self.tcp_mss.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_address.get_name_leafdata())
                        if (self.mtu_discovery.is_set or self.mtu_discovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu_discovery.get_name_leafdata())
                        if (self.passive_mode.is_set or self.passive_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.passive_mode.get_name_leafdata())
                        if (self.tcp_mss.is_set or self.tcp_mss.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tcp_mss.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "local-address" or name == "mtu-discovery" or name == "passive-mode" or name == "tcp-mss"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "local-address"):
                            self.local_address = value
                            self.local_address.value_namespace = name_space
                            self.local_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu-discovery"):
                            self.mtu_discovery = value
                            self.mtu_discovery.value_namespace = name_space
                            self.mtu_discovery.value_namespace_prefix = name_space_prefix
                        if(value_path == "passive-mode"):
                            self.passive_mode = value
                            self.passive_mode.value_namespace = name_space
                            self.passive_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "tcp-mss"):
                            self.tcp_mss = value
                            self.tcp_mss.value_namespace = name_space
                            self.tcp_mss.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "transport" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.Transport.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.Transport.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class EbgpMultihop(Entity):
                """
                eBGP multi\-hop parameters for the BGPgroup
                
                .. attribute:: config
                
                	Configuration parameters relating to eBGP multihop for the BGP group
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.EbgpMultihop.Config>`
                
                .. attribute:: state
                
                	State information for eBGP multihop, for the BGP neighbor or group
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_bgp.Bgp.PeerGroups.PeerGroup.EbgpMultihop.State>`
                
                

                """

                _prefix = 'oc-bgp'
                _revision = '2016-06-21'

                def __init__(self):
                    super(Bgp.PeerGroups.PeerGroup.EbgpMultihop, self).__init__()

                    self.yang_name = "ebgp-multihop"
                    self.yang_parent_name = "peer-group"

                    self.config = Bgp.PeerGroups.PeerGroup.EbgpMultihop.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Bgp.PeerGroups.PeerGroup.EbgpMultihop.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters relating to eBGP multihop for the
                    BGP group
                    
                    .. attribute:: enabled
                    
                    	When enabled the referenced group or neighbors are permitted to be indirectly connected \- including cases where the TTL can be decremented between the BGP peers
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: multihop_ttl
                    
                    	Time\-to\-live value to use when packets are sent to the referenced group or neighbors and ebgp\-multihop is enabled
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.EbgpMultihop.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "ebgp-multihop"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.multihop_ttl = YLeaf(YType.uint8, "multihop-ttl")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "multihop_ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.EbgpMultihop.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.EbgpMultihop.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.multihop_ttl.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.multihop_ttl.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.multihop_ttl.is_set or self.multihop_ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multihop_ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "multihop-ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "multihop-ttl"):
                            self.multihop_ttl = value
                            self.multihop_ttl.value_namespace = name_space
                            self.multihop_ttl.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State information for eBGP multihop, for the BGP neighbor
                    or group
                    
                    .. attribute:: enabled
                    
                    	When enabled the referenced group or neighbors are permitted to be indirectly connected \- including cases where the TTL can be decremented between the BGP peers
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: multihop_ttl
                    
                    	Time\-to\-live value to use when packets are sent to the referenced group or neighbors and ebgp\-multihop is enabled
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'oc-bgp'
                    _revision = '2016-06-21'

                    def __init__(self):
                        super(Bgp.PeerGroups.PeerGroup.EbgpMultihop.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "ebgp-multihop"

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.multihop_ttl = YLeaf(YType.uint8, "multihop-ttl")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enabled",
                                        "multihop_ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bgp.PeerGroups.PeerGroup.EbgpMultihop.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bgp.PeerGroups.PeerGroup.EbgpMultihop.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enabled.is_set or
                            self.multihop_ttl.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.multihop_ttl.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.multihop_ttl.is_set or self.multihop_ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multihop_ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enabled" or name == "multihop-ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "multihop-ttl"):
                            self.multihop_ttl = value
                            self.multihop_ttl.value_namespace = name_space
                            self.multihop_ttl.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ebgp-multihop" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Bgp.PeerGroups.PeerGroup.EbgpMultihop.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Bgp.PeerGroups.PeerGroup.EbgpMultihop.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.peer_group_name.is_set or
                    (self.add_paths is not None and self.add_paths.has_data()) or
                    (self.afi_safis is not None and self.afi_safis.has_data()) or
                    (self.apply_policy is not None and self.apply_policy.has_data()) or
                    (self.as_path_options is not None and self.as_path_options.has_data()) or
                    (self.config is not None and self.config.has_data()) or
                    (self.ebgp_multihop is not None and self.ebgp_multihop.has_data()) or
                    (self.error_handling is not None and self.error_handling.has_data()) or
                    (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                    (self.logging_options is not None and self.logging_options.has_data()) or
                    (self.route_reflector is not None and self.route_reflector.has_data()) or
                    (self.state is not None and self.state.has_data()) or
                    (self.timers is not None and self.timers.has_data()) or
                    (self.transport is not None and self.transport.has_data()) or
                    (self.use_multiple_paths is not None and self.use_multiple_paths.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.peer_group_name.yfilter != YFilter.not_set or
                    (self.add_paths is not None and self.add_paths.has_operation()) or
                    (self.afi_safis is not None and self.afi_safis.has_operation()) or
                    (self.apply_policy is not None and self.apply_policy.has_operation()) or
                    (self.as_path_options is not None and self.as_path_options.has_operation()) or
                    (self.config is not None and self.config.has_operation()) or
                    (self.ebgp_multihop is not None and self.ebgp_multihop.has_operation()) or
                    (self.error_handling is not None and self.error_handling.has_operation()) or
                    (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                    (self.logging_options is not None and self.logging_options.has_operation()) or
                    (self.route_reflector is not None and self.route_reflector.has_operation()) or
                    (self.state is not None and self.state.has_operation()) or
                    (self.timers is not None and self.timers.has_operation()) or
                    (self.transport is not None and self.transport.has_operation()) or
                    (self.use_multiple_paths is not None and self.use_multiple_paths.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-group" + "[peer-group-name='" + self.peer_group_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-bgp:bgp/peer-groups/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.peer_group_name.is_set or self.peer_group_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_group_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "add-paths"):
                    if (self.add_paths is None):
                        self.add_paths = Bgp.PeerGroups.PeerGroup.AddPaths()
                        self.add_paths.parent = self
                        self._children_name_map["add_paths"] = "add-paths"
                    return self.add_paths

                if (child_yang_name == "afi-safis"):
                    if (self.afi_safis is None):
                        self.afi_safis = Bgp.PeerGroups.PeerGroup.AfiSafis()
                        self.afi_safis.parent = self
                        self._children_name_map["afi_safis"] = "afi-safis"
                    return self.afi_safis

                if (child_yang_name == "apply-policy"):
                    if (self.apply_policy is None):
                        self.apply_policy = Bgp.PeerGroups.PeerGroup.ApplyPolicy()
                        self.apply_policy.parent = self
                        self._children_name_map["apply_policy"] = "apply-policy"
                    return self.apply_policy

                if (child_yang_name == "as-path-options"):
                    if (self.as_path_options is None):
                        self.as_path_options = Bgp.PeerGroups.PeerGroup.AsPathOptions()
                        self.as_path_options.parent = self
                        self._children_name_map["as_path_options"] = "as-path-options"
                    return self.as_path_options

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Bgp.PeerGroups.PeerGroup.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "ebgp-multihop"):
                    if (self.ebgp_multihop is None):
                        self.ebgp_multihop = Bgp.PeerGroups.PeerGroup.EbgpMultihop()
                        self.ebgp_multihop.parent = self
                        self._children_name_map["ebgp_multihop"] = "ebgp-multihop"
                    return self.ebgp_multihop

                if (child_yang_name == "error-handling"):
                    if (self.error_handling is None):
                        self.error_handling = Bgp.PeerGroups.PeerGroup.ErrorHandling()
                        self.error_handling.parent = self
                        self._children_name_map["error_handling"] = "error-handling"
                    return self.error_handling

                if (child_yang_name == "graceful-restart"):
                    if (self.graceful_restart is None):
                        self.graceful_restart = Bgp.PeerGroups.PeerGroup.GracefulRestart()
                        self.graceful_restart.parent = self
                        self._children_name_map["graceful_restart"] = "graceful-restart"
                    return self.graceful_restart

                if (child_yang_name == "logging-options"):
                    if (self.logging_options is None):
                        self.logging_options = Bgp.PeerGroups.PeerGroup.LoggingOptions()
                        self.logging_options.parent = self
                        self._children_name_map["logging_options"] = "logging-options"
                    return self.logging_options

                if (child_yang_name == "route-reflector"):
                    if (self.route_reflector is None):
                        self.route_reflector = Bgp.PeerGroups.PeerGroup.RouteReflector()
                        self.route_reflector.parent = self
                        self._children_name_map["route_reflector"] = "route-reflector"
                    return self.route_reflector

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Bgp.PeerGroups.PeerGroup.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                if (child_yang_name == "timers"):
                    if (self.timers is None):
                        self.timers = Bgp.PeerGroups.PeerGroup.Timers()
                        self.timers.parent = self
                        self._children_name_map["timers"] = "timers"
                    return self.timers

                if (child_yang_name == "transport"):
                    if (self.transport is None):
                        self.transport = Bgp.PeerGroups.PeerGroup.Transport()
                        self.transport.parent = self
                        self._children_name_map["transport"] = "transport"
                    return self.transport

                if (child_yang_name == "use-multiple-paths"):
                    if (self.use_multiple_paths is None):
                        self.use_multiple_paths = Bgp.PeerGroups.PeerGroup.UseMultiplePaths()
                        self.use_multiple_paths.parent = self
                        self._children_name_map["use_multiple_paths"] = "use-multiple-paths"
                    return self.use_multiple_paths

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "add-paths" or name == "afi-safis" or name == "apply-policy" or name == "as-path-options" or name == "config" or name == "ebgp-multihop" or name == "error-handling" or name == "graceful-restart" or name == "logging-options" or name == "route-reflector" or name == "state" or name == "timers" or name == "transport" or name == "use-multiple-paths" or name == "peer-group-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "peer-group-name"):
                    self.peer_group_name = value
                    self.peer_group_name.value_namespace = name_space
                    self.peer_group_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.peer_group:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.peer_group:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "peer-groups" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-bgp:bgp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "peer-group"):
                for c in self.peer_group:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bgp.PeerGroups.PeerGroup()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.peer_group.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "peer-group"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.global_ is not None and self.global_.has_data()) or
            (self.neighbors is not None and self.neighbors.has_data()) or
            (self.peer_groups is not None and self.peer_groups.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.global_ is not None and self.global_.has_operation()) or
            (self.neighbors is not None and self.neighbors.has_operation()) or
            (self.peer_groups is not None and self.peer_groups.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "openconfig-bgp:bgp" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "global"):
            if (self.global_ is None):
                self.global_ = Bgp.Global_()
                self.global_.parent = self
                self._children_name_map["global_"] = "global"
            return self.global_

        if (child_yang_name == "neighbors"):
            if (self.neighbors is None):
                self.neighbors = Bgp.Neighbors()
                self.neighbors.parent = self
                self._children_name_map["neighbors"] = "neighbors"
            return self.neighbors

        if (child_yang_name == "peer-groups"):
            if (self.peer_groups is None):
                self.peer_groups = Bgp.PeerGroups()
                self.peer_groups.parent = self
                self._children_name_map["peer_groups"] = "peer-groups"
            return self.peer_groups

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "global" or name == "neighbors" or name == "peer-groups"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Bgp()
        return self._top_entity

