""" CISCO_SYSLOG_MIB 

The MIB module to describe and store the system
messages generated by the IOS and any other
OS which supports syslogs.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class Syslogseverity(Enum):
    """
    Syslogseverity

    The severity of a syslog message.  The enumeration

    values are equal to the values that syslog uses + 1.

    For example, with syslog, emergency=0.

     'emergency' \: system is unusable

     'alert'     \: action must be taken immediately

     'critical'  \: critical conditions

     'error'     \: error conditions

     'warning'   \: warning conditions

     'notice'    \: normal but significant condition

     'informational'\: informational messages 

     'debug'        \: debug\-level messages.

    .. data:: emergency = 1

    .. data:: alert = 2

    .. data:: critical = 3

    .. data:: error = 4

    .. data:: warning = 5

    .. data:: notice = 6

    .. data:: info = 7

    .. data:: debug = 8

    """

    emergency = Enum.YLeaf(1, "emergency")

    alert = Enum.YLeaf(2, "alert")

    critical = Enum.YLeaf(3, "critical")

    error = Enum.YLeaf(4, "error")

    warning = Enum.YLeaf(5, "warning")

    notice = Enum.YLeaf(6, "notice")

    info = Enum.YLeaf(7, "info")

    debug = Enum.YLeaf(8, "debug")



class CiscoSyslogMib(Entity):
    """
    
    
    .. attribute:: clogbasic
    
    	
    	**type**\:   :py:class:`Clogbasic <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Clogbasic>`
    
    .. attribute:: cloghistory
    
    	
    	**type**\:   :py:class:`Cloghistory <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Cloghistory>`
    
    .. attribute:: cloghistorytable
    
    	A table of syslog messages generated by this device. All 'interesting' syslog messages (i.e. severity <= clogMaxSeverity) are entered into this table
    	**type**\:   :py:class:`Cloghistorytable <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Cloghistorytable>`
    
    .. attribute:: clogserver
    
    	
    	**type**\:   :py:class:`Clogserver <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Clogserver>`
    
    .. attribute:: clogserverconfigtable
    
    	This table contains entries that allow application to configure syslog servers for the system.  The maximum number of entries that can be created for this table is limited by the object clogMaxServers
    	**type**\:   :py:class:`Clogserverconfigtable <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Clogserverconfigtable>`
    
    

    """

    _prefix = 'CISCO-SYSLOG-MIB'
    _revision = '2005-12-03'

    def __init__(self):
        super(CiscoSyslogMib, self).__init__()
        self._top_entity = None

        self.yang_name = "CISCO-SYSLOG-MIB"
        self.yang_parent_name = "CISCO-SYSLOG-MIB"

        self.clogbasic = CiscoSyslogMib.Clogbasic()
        self.clogbasic.parent = self
        self._children_name_map["clogbasic"] = "clogBasic"
        self._children_yang_names.add("clogBasic")

        self.cloghistory = CiscoSyslogMib.Cloghistory()
        self.cloghistory.parent = self
        self._children_name_map["cloghistory"] = "clogHistory"
        self._children_yang_names.add("clogHistory")

        self.cloghistorytable = CiscoSyslogMib.Cloghistorytable()
        self.cloghistorytable.parent = self
        self._children_name_map["cloghistorytable"] = "clogHistoryTable"
        self._children_yang_names.add("clogHistoryTable")

        self.clogserver = CiscoSyslogMib.Clogserver()
        self.clogserver.parent = self
        self._children_name_map["clogserver"] = "clogServer"
        self._children_yang_names.add("clogServer")

        self.clogserverconfigtable = CiscoSyslogMib.Clogserverconfigtable()
        self.clogserverconfigtable.parent = self
        self._children_name_map["clogserverconfigtable"] = "clogServerConfigTable"
        self._children_yang_names.add("clogServerConfigTable")


    class Clogbasic(Entity):
        """
        
        
        .. attribute:: clogmaxseverity
        
        	Indicates which syslog severity levels will be processed.  Any syslog message with a severity value greater than this value will be ignored by the agent. note\: severity numeric values increase as their severity decreases, e.g. 'error' is more severe than 'debug'
        	**type**\:   :py:class:`Syslogseverity <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.Syslogseverity>`
        
        .. attribute:: clogmsgdrops
        
        	The number of syslog messages which could not be processed due to lack of system resources. Most likely this will occur at the same time that syslog messages are generated to indicate this lack of resources.  Increases in this object's value may serve as an indication that system resource levels should be examined via other mib objects.  A message that is dropped will not appear in the history table and no notification will be sent for this message
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        	**units**\: messages
        
        .. attribute:: clogmsgignores
        
        	The number of syslog messages which were ignored.  A message will be ignored if it has a severity value greater than clogMaxSeverity
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        	**units**\: messages
        
        .. attribute:: clognotificationsenabled
        
        	Indicates whether clogMessageGenerated notifications will or will not be sent when a syslog message is generated by the device.  Disabling notifications does not prevent syslog messages from being added to the clogHistoryTable
        	**type**\:  bool
        
        .. attribute:: clognotificationssent
        
        	The number of clogMessageGenerated notifications that have been sent. This number may include notifications that were prevented from being transmitted due to reasons such as resource limitations and/or non\-connectivity.  If one is receiving notifications, one can periodically poll this object to determine if any notifications were missed.  If so, a poll of the clogHistoryTable might be appropriate
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        	**units**\: notifications
        
        .. attribute:: clogoriginid
        
        	This object is used for configuring the origin identifier for the syslog messages.  The origin identifier is useful for identifying  the source of system logging messages in cases  syslog messages from multiple devices are sent  to a single syslog host. The origin identifier is added to the beginning of all system logging (syslog) messages sent to remote  hosts.  The type of the identifier is specified by clogOriginIDType object.  This object can be written by the SNMP manager only when clogOriginIDType is set to 'userDefined'.  For following value(s) of clogOriginIDType, this object can not be set; the value of this object is derived by the system in these cases\:    'contextName'     'ipv4Address'    'hostName'    'other'         'none'       This object contains the context name of the device, when clogOriginIDType is  set to 'contextName'.  This object contains IPv4 address (in dotted decimal notation) of the sending  interface when clogOriginIDType is set to 'ipv4Address'.  This object contains hostname of the system when clogOriginIDType is set to 'hostName'.  This object will contain zero length octet string when clogOriginIDType is either 'none' or 'other'
        	**type**\:  str
        
        .. attribute:: clogoriginidtype
        
        	This object identifies the type of value that will be contained in clogOriginID object.  The possible value(s) are\:    'none'       \: do not send origin identifier in                    syslog messages.    'other'      \: type that is not identified by other                    values specified in this object.    'hostName'   \: Send hostname of the system in syslog                   messages.    'ipv4Address'\: Send IP address of the sending interface.    'contextName'\: Send context name of the security device.    'userDefined'\: Send user configured string in                   syslog message.     The value 'other' and 'none' can not be set but    can only be read
        	**type**\:   :py:class:`Clogoriginidtype <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Clogbasic.Clogoriginidtype>`
        
        

        """

        _prefix = 'CISCO-SYSLOG-MIB'
        _revision = '2005-12-03'

        def __init__(self):
            super(CiscoSyslogMib.Clogbasic, self).__init__()

            self.yang_name = "clogBasic"
            self.yang_parent_name = "CISCO-SYSLOG-MIB"

            self.clogmaxseverity = YLeaf(YType.enumeration, "clogMaxSeverity")

            self.clogmsgdrops = YLeaf(YType.uint32, "clogMsgDrops")

            self.clogmsgignores = YLeaf(YType.uint32, "clogMsgIgnores")

            self.clognotificationsenabled = YLeaf(YType.boolean, "clogNotificationsEnabled")

            self.clognotificationssent = YLeaf(YType.uint32, "clogNotificationsSent")

            self.clogoriginid = YLeaf(YType.str, "clogOriginID")

            self.clogoriginidtype = YLeaf(YType.enumeration, "clogOriginIDType")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("clogmaxseverity",
                            "clogmsgdrops",
                            "clogmsgignores",
                            "clognotificationsenabled",
                            "clognotificationssent",
                            "clogoriginid",
                            "clogoriginidtype") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoSyslogMib.Clogbasic, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoSyslogMib.Clogbasic, self).__setattr__(name, value)

        class Clogoriginidtype(Enum):
            """
            Clogoriginidtype

            This object identifies the type of value that

            will be contained in clogOriginID object.

            The possible value(s) are\:

               'none'       \: do not send origin identifier in 

                              syslog messages.

               'other'      \: type that is not identified by other 

                              values specified in this object.

               'hostName'   \: Send hostname of the system in syslog

                              messages.

               'ipv4Address'\: Send IP address of the sending interface.

               'contextName'\: Send context name of the security device.

               'userDefined'\: Send user configured string in

                              syslog message.

               The value 'other' and 'none' can not be set but

               can only be read.

            .. data:: none = 1

            .. data:: other = 2

            .. data:: hostName = 3

            .. data:: ipv4Address = 4

            .. data:: contextName = 5

            .. data:: userDefined = 6

            """

            none = Enum.YLeaf(1, "none")

            other = Enum.YLeaf(2, "other")

            hostName = Enum.YLeaf(3, "hostName")

            ipv4Address = Enum.YLeaf(4, "ipv4Address")

            contextName = Enum.YLeaf(5, "contextName")

            userDefined = Enum.YLeaf(6, "userDefined")


        def has_data(self):
            return (
                self.clogmaxseverity.is_set or
                self.clogmsgdrops.is_set or
                self.clogmsgignores.is_set or
                self.clognotificationsenabled.is_set or
                self.clognotificationssent.is_set or
                self.clogoriginid.is_set or
                self.clogoriginidtype.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.clogmaxseverity.yfilter != YFilter.not_set or
                self.clogmsgdrops.yfilter != YFilter.not_set or
                self.clogmsgignores.yfilter != YFilter.not_set or
                self.clognotificationsenabled.yfilter != YFilter.not_set or
                self.clognotificationssent.yfilter != YFilter.not_set or
                self.clogoriginid.yfilter != YFilter.not_set or
                self.clogoriginidtype.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "clogBasic" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.clogmaxseverity.is_set or self.clogmaxseverity.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clogmaxseverity.get_name_leafdata())
            if (self.clogmsgdrops.is_set or self.clogmsgdrops.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clogmsgdrops.get_name_leafdata())
            if (self.clogmsgignores.is_set or self.clogmsgignores.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clogmsgignores.get_name_leafdata())
            if (self.clognotificationsenabled.is_set or self.clognotificationsenabled.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clognotificationsenabled.get_name_leafdata())
            if (self.clognotificationssent.is_set or self.clognotificationssent.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clognotificationssent.get_name_leafdata())
            if (self.clogoriginid.is_set or self.clogoriginid.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clogoriginid.get_name_leafdata())
            if (self.clogoriginidtype.is_set or self.clogoriginidtype.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clogoriginidtype.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "clogMaxSeverity" or name == "clogMsgDrops" or name == "clogMsgIgnores" or name == "clogNotificationsEnabled" or name == "clogNotificationsSent" or name == "clogOriginID" or name == "clogOriginIDType"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "clogMaxSeverity"):
                self.clogmaxseverity = value
                self.clogmaxseverity.value_namespace = name_space
                self.clogmaxseverity.value_namespace_prefix = name_space_prefix
            if(value_path == "clogMsgDrops"):
                self.clogmsgdrops = value
                self.clogmsgdrops.value_namespace = name_space
                self.clogmsgdrops.value_namespace_prefix = name_space_prefix
            if(value_path == "clogMsgIgnores"):
                self.clogmsgignores = value
                self.clogmsgignores.value_namespace = name_space
                self.clogmsgignores.value_namespace_prefix = name_space_prefix
            if(value_path == "clogNotificationsEnabled"):
                self.clognotificationsenabled = value
                self.clognotificationsenabled.value_namespace = name_space
                self.clognotificationsenabled.value_namespace_prefix = name_space_prefix
            if(value_path == "clogNotificationsSent"):
                self.clognotificationssent = value
                self.clognotificationssent.value_namespace = name_space
                self.clognotificationssent.value_namespace_prefix = name_space_prefix
            if(value_path == "clogOriginID"):
                self.clogoriginid = value
                self.clogoriginid.value_namespace = name_space
                self.clogoriginid.value_namespace_prefix = name_space_prefix
            if(value_path == "clogOriginIDType"):
                self.clogoriginidtype = value
                self.clogoriginidtype.value_namespace = name_space
                self.clogoriginidtype.value_namespace_prefix = name_space_prefix


    class Cloghistory(Entity):
        """
        
        
        .. attribute:: cloghistmsgsflushed
        
        	The number of entries that have been removed from the clogHistoryTable in order to make room for new entries. This object can be utilized to determine whether your polling frequency on the history table is fast enough and/or the size of your history table is large enough such that you are not missing messages
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        	**units**\: messages
        
        .. attribute:: cloghisttablemaxlength
        
        	The upper limit on the number of entries that the clogHistoryTable may contain.  A value of 0 will prevent any history from being retained. When this table is full, the oldest entry will be deleted and a new one will be created
        	**type**\:  int
        
        	**range:** 0..500
        
        	**units**\: entries
        
        

        """

        _prefix = 'CISCO-SYSLOG-MIB'
        _revision = '2005-12-03'

        def __init__(self):
            super(CiscoSyslogMib.Cloghistory, self).__init__()

            self.yang_name = "clogHistory"
            self.yang_parent_name = "CISCO-SYSLOG-MIB"

            self.cloghistmsgsflushed = YLeaf(YType.uint32, "clogHistMsgsFlushed")

            self.cloghisttablemaxlength = YLeaf(YType.int32, "clogHistTableMaxLength")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("cloghistmsgsflushed",
                            "cloghisttablemaxlength") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoSyslogMib.Cloghistory, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoSyslogMib.Cloghistory, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.cloghistmsgsflushed.is_set or
                self.cloghisttablemaxlength.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.cloghistmsgsflushed.yfilter != YFilter.not_set or
                self.cloghisttablemaxlength.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "clogHistory" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.cloghistmsgsflushed.is_set or self.cloghistmsgsflushed.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cloghistmsgsflushed.get_name_leafdata())
            if (self.cloghisttablemaxlength.is_set or self.cloghisttablemaxlength.yfilter != YFilter.not_set):
                leaf_name_data.append(self.cloghisttablemaxlength.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "clogHistMsgsFlushed" or name == "clogHistTableMaxLength"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "clogHistMsgsFlushed"):
                self.cloghistmsgsflushed = value
                self.cloghistmsgsflushed.value_namespace = name_space
                self.cloghistmsgsflushed.value_namespace_prefix = name_space_prefix
            if(value_path == "clogHistTableMaxLength"):
                self.cloghisttablemaxlength = value
                self.cloghisttablemaxlength.value_namespace = name_space
                self.cloghisttablemaxlength.value_namespace_prefix = name_space_prefix


    class Clogserver(Entity):
        """
        
        
        .. attribute:: clogmaxservers
        
        	The maximum number of syslog servers that can be configured for the system in clogServerConfigTable.  A value of zero for this object indicates there is no specified limit for the system and is only dictated by system resources
        	**type**\:  int
        
        	**range:** 0..4294967295
        
        

        """

        _prefix = 'CISCO-SYSLOG-MIB'
        _revision = '2005-12-03'

        def __init__(self):
            super(CiscoSyslogMib.Clogserver, self).__init__()

            self.yang_name = "clogServer"
            self.yang_parent_name = "CISCO-SYSLOG-MIB"

            self.clogmaxservers = YLeaf(YType.uint32, "clogMaxServers")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("clogmaxservers") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoSyslogMib.Clogserver, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoSyslogMib.Clogserver, self).__setattr__(name, value)

        def has_data(self):
            return self.clogmaxservers.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.clogmaxservers.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "clogServer" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.clogmaxservers.is_set or self.clogmaxservers.yfilter != YFilter.not_set):
                leaf_name_data.append(self.clogmaxservers.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "clogMaxServers"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "clogMaxServers"):
                self.clogmaxservers = value
                self.clogmaxservers.value_namespace = name_space
                self.clogmaxservers.value_namespace_prefix = name_space_prefix


    class Cloghistorytable(Entity):
        """
        A table of syslog messages generated by this device.
        All 'interesting' syslog messages (i.e. severity <=
        clogMaxSeverity) are entered into this table.
        
        .. attribute:: cloghistoryentry
        
        	A syslog message that was previously generated by this device. Each entry is indexed by a message index
        	**type**\: list of    :py:class:`Cloghistoryentry <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Cloghistorytable.Cloghistoryentry>`
        
        

        """

        _prefix = 'CISCO-SYSLOG-MIB'
        _revision = '2005-12-03'

        def __init__(self):
            super(CiscoSyslogMib.Cloghistorytable, self).__init__()

            self.yang_name = "clogHistoryTable"
            self.yang_parent_name = "CISCO-SYSLOG-MIB"

            self.cloghistoryentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoSyslogMib.Cloghistorytable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoSyslogMib.Cloghistorytable, self).__setattr__(name, value)


        class Cloghistoryentry(Entity):
            """
            A syslog message that was previously generated by this
            device. Each entry is indexed by a message index.
            
            .. attribute:: cloghistindex  <key>
            
            	A monotonically increasing integer for the sole purpose of indexing messages.  When it reaches the maximum value the agent flushes the table and wraps the value back to 1
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            .. attribute:: cloghistfacility
            
            	Name of the facility that generated this message. For example\: 'SYS'
            	**type**\:  str
            
            	**length:** 1..20
            
            .. attribute:: cloghistmsgname
            
            	A textual identification for the message type. A facility name in conjunction with a message name uniquely identifies a message type
            	**type**\:  str
            
            	**length:** 1..30
            
            .. attribute:: cloghistmsgtext
            
            	The text of the message.  If the text of the message exceeds 255 bytes, the message will be truncated to 254 bytes and a '\*' character will be appended \- indicating that the message has been truncated
            	**type**\:  str
            
            	**length:** 1..255
            
            .. attribute:: cloghistseverity
            
            	The severity of the message
            	**type**\:   :py:class:`Syslogseverity <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.Syslogseverity>`
            
            .. attribute:: cloghisttimestamp
            
            	The value of sysUpTime when this message was generated
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'CISCO-SYSLOG-MIB'
            _revision = '2005-12-03'

            def __init__(self):
                super(CiscoSyslogMib.Cloghistorytable.Cloghistoryentry, self).__init__()

                self.yang_name = "clogHistoryEntry"
                self.yang_parent_name = "clogHistoryTable"

                self.cloghistindex = YLeaf(YType.int32, "clogHistIndex")

                self.cloghistfacility = YLeaf(YType.str, "clogHistFacility")

                self.cloghistmsgname = YLeaf(YType.str, "clogHistMsgName")

                self.cloghistmsgtext = YLeaf(YType.str, "clogHistMsgText")

                self.cloghistseverity = YLeaf(YType.enumeration, "clogHistSeverity")

                self.cloghisttimestamp = YLeaf(YType.uint32, "clogHistTimestamp")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cloghistindex",
                                "cloghistfacility",
                                "cloghistmsgname",
                                "cloghistmsgtext",
                                "cloghistseverity",
                                "cloghisttimestamp") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoSyslogMib.Cloghistorytable.Cloghistoryentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoSyslogMib.Cloghistorytable.Cloghistoryentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.cloghistindex.is_set or
                    self.cloghistfacility.is_set or
                    self.cloghistmsgname.is_set or
                    self.cloghistmsgtext.is_set or
                    self.cloghistseverity.is_set or
                    self.cloghisttimestamp.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cloghistindex.yfilter != YFilter.not_set or
                    self.cloghistfacility.yfilter != YFilter.not_set or
                    self.cloghistmsgname.yfilter != YFilter.not_set or
                    self.cloghistmsgtext.yfilter != YFilter.not_set or
                    self.cloghistseverity.yfilter != YFilter.not_set or
                    self.cloghisttimestamp.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "clogHistoryEntry" + "[clogHistIndex='" + self.cloghistindex.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB/clogHistoryTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cloghistindex.is_set or self.cloghistindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cloghistindex.get_name_leafdata())
                if (self.cloghistfacility.is_set or self.cloghistfacility.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cloghistfacility.get_name_leafdata())
                if (self.cloghistmsgname.is_set or self.cloghistmsgname.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cloghistmsgname.get_name_leafdata())
                if (self.cloghistmsgtext.is_set or self.cloghistmsgtext.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cloghistmsgtext.get_name_leafdata())
                if (self.cloghistseverity.is_set or self.cloghistseverity.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cloghistseverity.get_name_leafdata())
                if (self.cloghisttimestamp.is_set or self.cloghisttimestamp.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cloghisttimestamp.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "clogHistIndex" or name == "clogHistFacility" or name == "clogHistMsgName" or name == "clogHistMsgText" or name == "clogHistSeverity" or name == "clogHistTimestamp"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "clogHistIndex"):
                    self.cloghistindex = value
                    self.cloghistindex.value_namespace = name_space
                    self.cloghistindex.value_namespace_prefix = name_space_prefix
                if(value_path == "clogHistFacility"):
                    self.cloghistfacility = value
                    self.cloghistfacility.value_namespace = name_space
                    self.cloghistfacility.value_namespace_prefix = name_space_prefix
                if(value_path == "clogHistMsgName"):
                    self.cloghistmsgname = value
                    self.cloghistmsgname.value_namespace = name_space
                    self.cloghistmsgname.value_namespace_prefix = name_space_prefix
                if(value_path == "clogHistMsgText"):
                    self.cloghistmsgtext = value
                    self.cloghistmsgtext.value_namespace = name_space
                    self.cloghistmsgtext.value_namespace_prefix = name_space_prefix
                if(value_path == "clogHistSeverity"):
                    self.cloghistseverity = value
                    self.cloghistseverity.value_namespace = name_space
                    self.cloghistseverity.value_namespace_prefix = name_space_prefix
                if(value_path == "clogHistTimestamp"):
                    self.cloghisttimestamp = value
                    self.cloghisttimestamp.value_namespace = name_space
                    self.cloghisttimestamp.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.cloghistoryentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.cloghistoryentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "clogHistoryTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "clogHistoryEntry"):
                for c in self.cloghistoryentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoSyslogMib.Cloghistorytable.Cloghistoryentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.cloghistoryentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "clogHistoryEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Clogserverconfigtable(Entity):
        """
        This table contains entries that allow application
        to configure syslog servers for the system.
        
        The maximum number of entries that can be created
        for this table is limited by the object
        clogMaxServers.
        
        .. attribute:: clogserverconfigentry
        
        	An entry containing information about syslog servers configured for the system
        	**type**\: list of    :py:class:`Clogserverconfigentry <ydk.models.cisco_ios_xe.CISCO_SYSLOG_MIB.CiscoSyslogMib.Clogserverconfigtable.Clogserverconfigentry>`
        
        

        """

        _prefix = 'CISCO-SYSLOG-MIB'
        _revision = '2005-12-03'

        def __init__(self):
            super(CiscoSyslogMib.Clogserverconfigtable, self).__init__()

            self.yang_name = "clogServerConfigTable"
            self.yang_parent_name = "CISCO-SYSLOG-MIB"

            self.clogserverconfigentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoSyslogMib.Clogserverconfigtable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoSyslogMib.Clogserverconfigtable, self).__setattr__(name, value)


        class Clogserverconfigentry(Entity):
            """
            An entry containing information about syslog servers
            configured for the system.
            
            .. attribute:: clogserveraddrtype  <key>
            
            	The type of Internet address of this syslog server
            	**type**\:   :py:class:`Inetaddresstype <ydk.models.cisco_ios_xe.INET_ADDRESS_MIB.Inetaddresstype>`
            
            .. attribute:: clogserveraddr  <key>
            
            	The Internet address of this syslog server. The type of this address is determined by the value of the clogServerAddrType object
            	**type**\:  str
            
            	**length:** 0..64
            
            .. attribute:: clogserverstatus
            
            	The status object used to manage rows in this table.  A row may only be created by setting this object to 'createAndGo'.  A row may only be deleted by setting this object to 'destroy'
            	**type**\:   :py:class:`Rowstatus <ydk.models.cisco_ios_xe.SNMPv2_TC.Rowstatus>`
            
            

            """

            _prefix = 'CISCO-SYSLOG-MIB'
            _revision = '2005-12-03'

            def __init__(self):
                super(CiscoSyslogMib.Clogserverconfigtable.Clogserverconfigentry, self).__init__()

                self.yang_name = "clogServerConfigEntry"
                self.yang_parent_name = "clogServerConfigTable"

                self.clogserveraddrtype = YLeaf(YType.enumeration, "clogServerAddrType")

                self.clogserveraddr = YLeaf(YType.str, "clogServerAddr")

                self.clogserverstatus = YLeaf(YType.enumeration, "clogServerStatus")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("clogserveraddrtype",
                                "clogserveraddr",
                                "clogserverstatus") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoSyslogMib.Clogserverconfigtable.Clogserverconfigentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoSyslogMib.Clogserverconfigtable.Clogserverconfigentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.clogserveraddrtype.is_set or
                    self.clogserveraddr.is_set or
                    self.clogserverstatus.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.clogserveraddrtype.yfilter != YFilter.not_set or
                    self.clogserveraddr.yfilter != YFilter.not_set or
                    self.clogserverstatus.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "clogServerConfigEntry" + "[clogServerAddrType='" + self.clogserveraddrtype.get() + "']" + "[clogServerAddr='" + self.clogserveraddr.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB/clogServerConfigTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.clogserveraddrtype.is_set or self.clogserveraddrtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.clogserveraddrtype.get_name_leafdata())
                if (self.clogserveraddr.is_set or self.clogserveraddr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.clogserveraddr.get_name_leafdata())
                if (self.clogserverstatus.is_set or self.clogserverstatus.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.clogserverstatus.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "clogServerAddrType" or name == "clogServerAddr" or name == "clogServerStatus"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "clogServerAddrType"):
                    self.clogserveraddrtype = value
                    self.clogserveraddrtype.value_namespace = name_space
                    self.clogserveraddrtype.value_namespace_prefix = name_space_prefix
                if(value_path == "clogServerAddr"):
                    self.clogserveraddr = value
                    self.clogserveraddr.value_namespace = name_space
                    self.clogserveraddr.value_namespace_prefix = name_space_prefix
                if(value_path == "clogServerStatus"):
                    self.clogserverstatus = value
                    self.clogserverstatus.value_namespace = name_space
                    self.clogserverstatus.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.clogserverconfigentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.clogserverconfigentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "clogServerConfigTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "clogServerConfigEntry"):
                for c in self.clogserverconfigentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoSyslogMib.Clogserverconfigtable.Clogserverconfigentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.clogserverconfigentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "clogServerConfigEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.clogbasic is not None and self.clogbasic.has_data()) or
            (self.cloghistory is not None and self.cloghistory.has_data()) or
            (self.cloghistorytable is not None and self.cloghistorytable.has_data()) or
            (self.clogserver is not None and self.clogserver.has_data()) or
            (self.clogserverconfigtable is not None and self.clogserverconfigtable.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.clogbasic is not None and self.clogbasic.has_operation()) or
            (self.cloghistory is not None and self.cloghistory.has_operation()) or
            (self.cloghistorytable is not None and self.cloghistorytable.has_operation()) or
            (self.clogserver is not None and self.clogserver.has_operation()) or
            (self.clogserverconfigtable is not None and self.clogserverconfigtable.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "CISCO-SYSLOG-MIB:CISCO-SYSLOG-MIB" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "clogBasic"):
            if (self.clogbasic is None):
                self.clogbasic = CiscoSyslogMib.Clogbasic()
                self.clogbasic.parent = self
                self._children_name_map["clogbasic"] = "clogBasic"
            return self.clogbasic

        if (child_yang_name == "clogHistory"):
            if (self.cloghistory is None):
                self.cloghistory = CiscoSyslogMib.Cloghistory()
                self.cloghistory.parent = self
                self._children_name_map["cloghistory"] = "clogHistory"
            return self.cloghistory

        if (child_yang_name == "clogHistoryTable"):
            if (self.cloghistorytable is None):
                self.cloghistorytable = CiscoSyslogMib.Cloghistorytable()
                self.cloghistorytable.parent = self
                self._children_name_map["cloghistorytable"] = "clogHistoryTable"
            return self.cloghistorytable

        if (child_yang_name == "clogServer"):
            if (self.clogserver is None):
                self.clogserver = CiscoSyslogMib.Clogserver()
                self.clogserver.parent = self
                self._children_name_map["clogserver"] = "clogServer"
            return self.clogserver

        if (child_yang_name == "clogServerConfigTable"):
            if (self.clogserverconfigtable is None):
                self.clogserverconfigtable = CiscoSyslogMib.Clogserverconfigtable()
                self.clogserverconfigtable.parent = self
                self._children_name_map["clogserverconfigtable"] = "clogServerConfigTable"
            return self.clogserverconfigtable

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "clogBasic" or name == "clogHistory" or name == "clogHistoryTable" or name == "clogServer" or name == "clogServerConfigTable"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = CiscoSyslogMib()
        return self._top_entity

