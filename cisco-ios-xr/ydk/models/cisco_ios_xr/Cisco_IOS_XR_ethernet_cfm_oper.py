""" Cisco_IOS_XR_ethernet_cfm_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR ethernet\-cfm package operational data.

This module contains definitions
for the following management objects\:
  cfm\: CFM operational data

This YANG module augments the
  Cisco\-IOS\-XR\-infra\-sla\-oper
module with state data.

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class CfmAisDir(Enum):
    """
    CfmAisDir

    Cfm ais dir

    .. data:: up = 0

    	Packets sent inward

    .. data:: down = 1

    	Packets sent outward

    """

    up = Enum.YLeaf(0, "up")

    down = Enum.YLeaf(1, "down")


class CfmBagAisInterval(Enum):
    """
    CfmBagAisInterval

    CFM AIS intervals

    .. data:: ais_interval_none = 0

    	Invalid AIS interval

    .. data:: ais_interval1s = 4

    	Interval of 1s

    .. data:: ais_interval1m = 6

    	Interval of 1 min

    """

    ais_interval_none = Enum.YLeaf(0, "ais-interval-none")

    ais_interval1s = Enum.YLeaf(4, "ais-interval1s")

    ais_interval1m = Enum.YLeaf(6, "ais-interval1m")


class CfmBagBdidFmt(Enum):
    """
    CfmBagBdidFmt

    Bridge domain identifier format

    .. data:: invalid = 0

    	Invalid BDID identifier format

    .. data:: bd_id = 1

    	Identifier is a bridge domain ID

    .. data:: xc_p2p_id = 2

    	Identifier is a P2P cross-connect ID

    .. data:: xc_mp2mp_id = 3

    	Identifier is a MP2MP cross-connect ID

    .. data:: down_only = 4

    	Identifier is a maintenance association name

    """

    invalid = Enum.YLeaf(0, "invalid")

    bd_id = Enum.YLeaf(1, "bd-id")

    xc_p2p_id = Enum.YLeaf(2, "xc-p2p-id")

    xc_mp2mp_id = Enum.YLeaf(3, "xc-mp2mp-id")

    down_only = Enum.YLeaf(4, "down-only")


class CfmBagCcmInterval(Enum):
    """
    CfmBagCcmInterval

    CFM CCM intervals

    .. data:: interval_none = 0

    	Invalid CCM interval

    .. data:: interval3_3ms = 1

    	Interval of 3.3ms

    .. data:: interval10ms = 2

    	Interval of 10ms

    .. data:: interval100ms = 3

    	Interval of 100ms

    .. data:: interval1s = 4

    	Interval of 1s

    .. data:: interval10s = 5

    	Interval of 10s

    .. data:: interval1m = 6

    	Interval of 1 min

    .. data:: interval10m = 7

    	Interval of 10 mins

    """

    interval_none = Enum.YLeaf(0, "interval-none")

    interval3_3ms = Enum.YLeaf(1, "interval3-3ms")

    interval10ms = Enum.YLeaf(2, "interval10ms")

    interval100ms = Enum.YLeaf(3, "interval100ms")

    interval1s = Enum.YLeaf(4, "interval1s")

    interval10s = Enum.YLeaf(5, "interval10s")

    interval1m = Enum.YLeaf(6, "interval1m")

    interval10m = Enum.YLeaf(7, "interval10m")


class CfmBagCcmOffload(Enum):
    """
    CfmBagCcmOffload

    Offload status of CCM processing

    .. data:: offload_none = 0

    	CCM processing has not been offloaded

    .. data:: offload_software = 1

    	CCM processing has been offloaded to software

    .. data:: offload_hardware = 2

    	CCM processing has been offloaded to hardware

    """

    offload_none = Enum.YLeaf(0, "offload-none")

    offload_software = Enum.YLeaf(1, "offload-software")

    offload_hardware = Enum.YLeaf(2, "offload-hardware")


class CfmBagDirection(Enum):
    """
    CfmBagDirection

    MEP direction

    .. data:: direction_up = 0

    	Up

    .. data:: direction_down = 1

    	Down

    .. data:: direction_invalid = 2

    	Invalid direction

    """

    direction_up = Enum.YLeaf(0, "direction-up")

    direction_down = Enum.YLeaf(1, "direction-down")

    direction_invalid = Enum.YLeaf(2, "direction-invalid")


class CfmBagIssuRole(Enum):
    """
    CfmBagIssuRole

    CFM ISSU role

    .. data:: unknown = 0

    	Unknown

    .. data:: primary = 1

    	Primary

    .. data:: secondary = 2

    	Secondary

    """

    unknown = Enum.YLeaf(0, "unknown")

    primary = Enum.YLeaf(1, "primary")

    secondary = Enum.YLeaf(2, "secondary")


class CfmBagIwState(Enum):
    """
    CfmBagIwState

    CFM Interworking state

    .. data:: interworking_up = 0

    	Interface is UP

    .. data:: interworking_test = 1

    	Interface is in TEST mode

    """

    interworking_up = Enum.YLeaf(0, "interworking-up")

    interworking_test = Enum.YLeaf(1, "interworking-test")


class CfmBagMdLevel(Enum):
    """
    CfmBagMdLevel

    CFM level

    .. data:: level0 = 0

    	CFM level 0

    .. data:: level1 = 1

    	CFM level 1

    .. data:: level2 = 2

    	CFM level 2

    .. data:: level3 = 3

    	CFM level 3

    .. data:: level4 = 4

    	CFM level 4

    .. data:: level5 = 5

    	CFM level 5

    .. data:: level6 = 6

    	CFM level 6

    .. data:: level7 = 7

    	CFM level 7

    .. data:: level_invalid = 8

    	Invalid CFM level

    """

    level0 = Enum.YLeaf(0, "level0")

    level1 = Enum.YLeaf(1, "level1")

    level2 = Enum.YLeaf(2, "level2")

    level3 = Enum.YLeaf(3, "level3")

    level4 = Enum.YLeaf(4, "level4")

    level5 = Enum.YLeaf(5, "level5")

    level6 = Enum.YLeaf(6, "level6")

    level7 = Enum.YLeaf(7, "level7")

    level_invalid = Enum.YLeaf(8, "level-invalid")


class CfmBagMdidFmt(Enum):
    """
    CfmBagMdidFmt

    CFM MDID format

    .. data:: mdid_null = 1

    	MDID is explicity NULL

    .. data:: mdid_dns_like = 2

    	MDID is based on a DNS name

    .. data:: mdid_mac_address = 3

    	MDID is a (MAC address, integer) pair

    .. data:: mdid_string = 4

    	MDID is a character string

    .. data:: mdid_unknown = 5

    	Unknown MDID format

    """

    mdid_null = Enum.YLeaf(1, "mdid-null")

    mdid_dns_like = Enum.YLeaf(2, "mdid-dns-like")

    mdid_mac_address = Enum.YLeaf(3, "mdid-mac-address")

    mdid_string = Enum.YLeaf(4, "mdid-string")

    mdid_unknown = Enum.YLeaf(5, "mdid-unknown")


class CfmBagOpcode(Enum):
    """
    CfmBagOpcode

    CFM Opcode

    .. data:: reserved = 0

    	Reserved

    .. data:: ccm = 1

    	Continuity Check

    .. data:: lbr = 2

    	Loopback Reply

    .. data:: lbm = 3

    	Loopback Message

    .. data:: ltr = 4

    	Linktrace Reply

    .. data:: ltm = 5

    	Linktrace Message

    """

    reserved = Enum.YLeaf(0, "reserved")

    ccm = Enum.YLeaf(1, "ccm")

    lbr = Enum.YLeaf(2, "lbr")

    lbm = Enum.YLeaf(3, "lbm")

    ltr = Enum.YLeaf(4, "ltr")

    ltm = Enum.YLeaf(5, "ltm")


class CfmBagSmanFmt(Enum):
    """
    CfmBagSmanFmt

    Short MA Name format

    .. data:: sman_vlan_id = 1

    	Short MA Name is a 12-bit VLAN-ID

    .. data:: sman_string = 2

    	Short MA Name is a character string

    .. data:: sman_uint16 = 3

    	Short MA Name is a 16-bit unsigned integer

    .. data:: sman_vpn_id = 4

    	Short MA Name is a global VPN identifier

    .. data:: sman_icc = 32

    	Short MA Name uses the ICC-based format

    .. data:: sman_unknown = 33

    	Unknown Short MA Name format

    """

    sman_vlan_id = Enum.YLeaf(1, "sman-vlan-id")

    sman_string = Enum.YLeaf(2, "sman-string")

    sman_uint16 = Enum.YLeaf(3, "sman-uint16")

    sman_vpn_id = Enum.YLeaf(4, "sman-vpn-id")

    sman_icc = Enum.YLeaf(32, "sman-icc")

    sman_unknown = Enum.YLeaf(33, "sman-unknown")


class CfmBagStpState(Enum):
    """
    CfmBagStpState

    CFM STP state

    .. data:: stp_up = 0

    	Interface is UP

    .. data:: stp_blocked = 1

    	Interface is STP-blocked

    .. data:: stp_unknown = 2

    	Unknown Interface STP state

    """

    stp_up = Enum.YLeaf(0, "stp-up")

    stp_blocked = Enum.YLeaf(1, "stp-blocked")

    stp_unknown = Enum.YLeaf(2, "stp-unknown")


class CfmMaMpVariety(Enum):
    """
    CfmMaMpVariety

    CFM MA Maintenance Point varieties

    .. data:: mip = 0

    	MIP

    .. data:: up_mep = 1

    	Up MEP

    .. data:: downmep = 2

    	Down MEP

    .. data:: unknown_mep = 3

    	Unknown MEP

    """

    mip = Enum.YLeaf(0, "mip")

    up_mep = Enum.YLeaf(1, "up-mep")

    downmep = Enum.YLeaf(2, "downmep")

    unknown_mep = Enum.YLeaf(3, "unknown-mep")


class CfmPmAddlIntfStatus(Enum):
    """
    CfmPmAddlIntfStatus

    Additional interface status

    .. data:: unknown = 0

    	Additional interface status unknown

    .. data:: administratively_down = 1

    	Interface is explicitly shutdown in

    	configuration

    .. data:: remote_excessive_errors = 2

    	Remote interface has exceeded its 802.3 Link

    	OAM error threshold

    .. data:: local_excessive_errors = 3

    	Local interface has exceeded its 802.3 Link OAM

    	error threshold

    """

    unknown = Enum.YLeaf(0, "unknown")

    administratively_down = Enum.YLeaf(1, "administratively-down")

    remote_excessive_errors = Enum.YLeaf(2, "remote-excessive-errors")

    local_excessive_errors = Enum.YLeaf(3, "local-excessive-errors")


class CfmPmAisReceive(Enum):
    """
    CfmPmAisReceive

    Enumeration of how the MEP is receiving the

    signal, directly or via AIS or LCK messages.

    .. data:: receive_none = 0

    	No signal received

    .. data:: receive_ais = 1

    	Receiving AIS messages

    .. data:: receive_lck = 2

    	Receiving LCK messages

    .. data:: receive_direct = 3

    	Receiving AIS directly from another MEP on the

    	same interface

    """

    receive_none = Enum.YLeaf(0, "receive-none")

    receive_ais = Enum.YLeaf(1, "receive-ais")

    receive_lck = Enum.YLeaf(2, "receive-lck")

    receive_direct = Enum.YLeaf(3, "receive-direct")


class CfmPmAisTransmit(Enum):
    """
    CfmPmAisTransmit

    Enumeration of how the MEP is transmitting AIS,

    via a MIP or directly to a higher MEP

    .. data:: transmit_none = 0

    	AIS not transmitted

    .. data:: transmit_ais = 1

    	AIS transmitted via MIP

    .. data:: transmit_ais_direct = 2

    	AIS signal passed directly to a higher MEP

    """

    transmit_none = Enum.YLeaf(0, "transmit-none")

    transmit_ais = Enum.YLeaf(1, "transmit-ais")

    transmit_ais_direct = Enum.YLeaf(2, "transmit-ais-direct")


class CfmPmChassisIdFmt(Enum):
    """
    CfmPmChassisIdFmt

    Chassis ID type

    .. data:: chassis_id_chassis_component = 1

    	Chassis ID is a component name

    .. data:: chassis_id_interface_alias = 2

    	Chassis ID is an interface alias

    .. data:: chassis_id_port_component = 3

    	Chassis ID is a port component name

    .. data:: chassis_id_mac_address = 4

    	Chassis ID is a MAC address

    .. data:: chassis_id_network_address = 5

    	Chassis ID is a network address

    .. data:: chassis_id_interface_name = 6

    	Chassis ID is an interface name

    .. data:: chassis_id_local = 7

    	Chassis ID is a local name

    .. data:: chassis_id_unknown_type = 8

    	Unknown Chassis ID type

    """

    chassis_id_chassis_component = Enum.YLeaf(1, "chassis-id-chassis-component")

    chassis_id_interface_alias = Enum.YLeaf(2, "chassis-id-interface-alias")

    chassis_id_port_component = Enum.YLeaf(3, "chassis-id-port-component")

    chassis_id_mac_address = Enum.YLeaf(4, "chassis-id-mac-address")

    chassis_id_network_address = Enum.YLeaf(5, "chassis-id-network-address")

    chassis_id_interface_name = Enum.YLeaf(6, "chassis-id-interface-name")

    chassis_id_local = Enum.YLeaf(7, "chassis-id-local")

    chassis_id_unknown_type = Enum.YLeaf(8, "chassis-id-unknown-type")


class CfmPmEgressAction(Enum):
    """
    CfmPmEgressAction

    Egress action

    .. data:: egress_ok = 1

    	OK

    .. data:: egress_down = 2

    	Down

    .. data:: egress_blocked = 3

    	STP Blocked

    .. data:: egress_vid = 4

    	VID Blocked

    """

    egress_ok = Enum.YLeaf(1, "egress-ok")

    egress_down = Enum.YLeaf(2, "egress-down")

    egress_blocked = Enum.YLeaf(3, "egress-blocked")

    egress_vid = Enum.YLeaf(4, "egress-vid")


class CfmPmElmReplyFilter(Enum):
    """
    CfmPmElmReplyFilter

    Reply filter used for Exploratory Linktrace

    operations

    .. data:: reply_filter_not_present = 0

    	Reply Filter not present

    .. data:: reply_filter_default = 1

    	Reply from ports which are not MAC-pruned,

    	VID-pruned, or STP-blocked

    .. data:: reply_filter_vlan_topology = 2

    	Reply from ports which are not VID-pruned or

    	STP-blocked

    .. data:: reply_filter_spanning_tree = 3

    	Reply from ports which are not STP-blocked

    .. data:: reply_filter_all_ports = 4

    	Reply from all ports

    """

    reply_filter_not_present = Enum.YLeaf(0, "reply-filter-not-present")

    reply_filter_default = Enum.YLeaf(1, "reply-filter-default")

    reply_filter_vlan_topology = Enum.YLeaf(2, "reply-filter-vlan-topology")

    reply_filter_spanning_tree = Enum.YLeaf(3, "reply-filter-spanning-tree")

    reply_filter_all_ports = Enum.YLeaf(4, "reply-filter-all-ports")


class CfmPmElrEgressAction(Enum):
    """
    CfmPmElrEgressAction

    ELR Egress action

    .. data:: elr_egress_ok = 1

    	OK

    .. data:: elr_egress_down = 2

    	Down

    .. data:: elr_egress_blocked = 3

    	STP Blocked

    .. data:: elr_egress_vid = 4

    	VID Blocked

    .. data:: elr_egress_mac = 255

    	MAC Pruned

    """

    elr_egress_ok = Enum.YLeaf(1, "elr-egress-ok")

    elr_egress_down = Enum.YLeaf(2, "elr-egress-down")

    elr_egress_blocked = Enum.YLeaf(3, "elr-egress-blocked")

    elr_egress_vid = Enum.YLeaf(4, "elr-egress-vid")

    elr_egress_mac = Enum.YLeaf(255, "elr-egress-mac")


class CfmPmElrIngressAction(Enum):
    """
    CfmPmElrIngressAction

    ELR Ingress action

    .. data:: elr_ingress_ok = 1

    	OK

    .. data:: elr_ingress_down = 2

    	Down

    .. data:: elr_ingress_blocked = 3

    	STP Blocked

    .. data:: elr_ingress_vid = 4

    	VID Blocked

    """

    elr_ingress_ok = Enum.YLeaf(1, "elr-ingress-ok")

    elr_ingress_down = Enum.YLeaf(2, "elr-ingress-down")

    elr_ingress_blocked = Enum.YLeaf(3, "elr-ingress-blocked")

    elr_ingress_vid = Enum.YLeaf(4, "elr-ingress-vid")


class CfmPmElrRelayAction(Enum):
    """
    CfmPmElrRelayAction

    ELR relay action

    .. data:: elr_relay_hit = 1

    	Target Hit

    .. data:: elr_relay_fdb = 2

    	Filtering database

    .. data:: elr_relay_flood = 3

    	Flood forwarded

    .. data:: elr_relay_drop = 4

    	Dropped

    """

    elr_relay_hit = Enum.YLeaf(1, "elr-relay-hit")

    elr_relay_fdb = Enum.YLeaf(2, "elr-relay-fdb")

    elr_relay_flood = Enum.YLeaf(3, "elr-relay-flood")

    elr_relay_drop = Enum.YLeaf(4, "elr-relay-drop")


class CfmPmEltDelayModel(Enum):
    """
    CfmPmEltDelayModel

    Delay model used for Exploratory Linktrace

    operations

    .. data:: delay_model_invalid = 0

    	Not a valid delay model

    .. data:: delay_model_logarithmic = 1

    	Reply using logarithmic delay model

    .. data:: delay_model_constant = 2

    	Reply using constant delay model

    """

    delay_model_invalid = Enum.YLeaf(0, "delay-model-invalid")

    delay_model_logarithmic = Enum.YLeaf(1, "delay-model-logarithmic")

    delay_model_constant = Enum.YLeaf(2, "delay-model-constant")


class CfmPmIdFmt(Enum):
    """
    CfmPmIdFmt

    ID format

    .. data:: id_format_is_string = 0

    	ID format is a string

    .. data:: id_format_is_mac_address = 1

    	ID format is a MAC address

    .. data:: id_format_is_raw_hex = 2

    	ID format is raw hex

    """

    id_format_is_string = Enum.YLeaf(0, "id-format-is-string")

    id_format_is_mac_address = Enum.YLeaf(1, "id-format-is-mac-address")

    id_format_is_raw_hex = Enum.YLeaf(2, "id-format-is-raw-hex")


class CfmPmIngressAction(Enum):
    """
    CfmPmIngressAction

    Ingress action

    .. data:: ingress_ok = 1

    	OK

    .. data:: ingress_down = 2

    	Down

    .. data:: ingress_blocked = 3

    	STP Blocked

    .. data:: ingress_vid = 4

    	VID Blocked

    """

    ingress_ok = Enum.YLeaf(1, "ingress-ok")

    ingress_down = Enum.YLeaf(2, "ingress-down")

    ingress_blocked = Enum.YLeaf(3, "ingress-blocked")

    ingress_vid = Enum.YLeaf(4, "ingress-vid")


class CfmPmIntfStatus(Enum):
    """
    CfmPmIntfStatus

    Interface status

    .. data:: interface_status_up = 1

    	Interface is up

    .. data:: interface_status_down = 2

    	Interface is down

    .. data:: interface_status_testing = 3

    	Interface is in testing mode

    .. data:: interface_status_unknown = 4

    	Unknown interface status

    .. data:: interface_status_dormant = 5

    	Interface is dormant

    .. data:: interface_status_not_present = 6

    	Interface status not found

    .. data:: interface_status_lower_layer_down = 7

    	Lower layer is down

    """

    interface_status_up = Enum.YLeaf(1, "interface-status-up")

    interface_status_down = Enum.YLeaf(2, "interface-status-down")

    interface_status_testing = Enum.YLeaf(3, "interface-status-testing")

    interface_status_unknown = Enum.YLeaf(4, "interface-status-unknown")

    interface_status_dormant = Enum.YLeaf(5, "interface-status-dormant")

    interface_status_not_present = Enum.YLeaf(6, "interface-status-not-present")

    interface_status_lower_layer_down = Enum.YLeaf(7, "interface-status-lower-layer-down")


class CfmPmLastHopFmt(Enum):
    """
    CfmPmLastHopFmt

    Last hop identifier format

    .. data:: last_hop_none = 0

    	No last hop identifier

    .. data:: last_hop_host_name = 1

    	Last hop identifier is a hostname

    .. data:: last_hop_egress_id = 2

    	Last hop identifier is an egress ID

    """

    last_hop_none = Enum.YLeaf(0, "last-hop-none")

    last_hop_host_name = Enum.YLeaf(1, "last-hop-host-name")

    last_hop_egress_id = Enum.YLeaf(2, "last-hop-egress-id")


class CfmPmLtMode(Enum):
    """
    CfmPmLtMode

    Type of Linktrace operation

    .. data:: cfm_pm_lt_mode_basic = 1

    	Basic IEEE 802.1ag Linktrace

    .. data:: cfm_pm_lt_mode_exploratory = 2

    	Cisco Exploratory Linktrace

    """

    cfm_pm_lt_mode_basic = Enum.YLeaf(1, "cfm-pm-lt-mode-basic")

    cfm_pm_lt_mode_exploratory = Enum.YLeaf(2, "cfm-pm-lt-mode-exploratory")


class CfmPmMepDefect(Enum):
    """
    CfmPmMepDefect

    Defects that can be reported by a MEP

    .. data:: defect_none = 0

    	No defect reported

    .. data:: defect_rdi_ccm = 1

    	Some Peer MEP's CCM has the RDI bit set

    .. data:: defect_ma_cstatus = 2

    	A Peer MEP port or interface status error has

    	been reported

    .. data:: defect_remote_ccm = 3

    	Not receiving valid CCMs from at least one Peer

    	MEP

    .. data:: defect_error_ccm = 4

    	Currently receiving invalid CCMs from at least

    	one Peer MEP

    .. data:: defect_cross_connect_ccm = 5

    	Currently receiving CCMs from an incorrect

    	service (MA)

    """

    defect_none = Enum.YLeaf(0, "defect-none")

    defect_rdi_ccm = Enum.YLeaf(1, "defect-rdi-ccm")

    defect_ma_cstatus = Enum.YLeaf(2, "defect-ma-cstatus")

    defect_remote_ccm = Enum.YLeaf(3, "defect-remote-ccm")

    defect_error_ccm = Enum.YLeaf(4, "defect-error-ccm")

    defect_cross_connect_ccm = Enum.YLeaf(5, "defect-cross-connect-ccm")


class CfmPmMepFngState(Enum):
    """
    CfmPmMepFngState

    Fault Notification Generation state machine

    states

    .. data:: fng_reset = 1

    	FNG in reset state

    .. data:: fng_defect = 2

    	FNG has detected but not yet reported a defect

    .. data:: fng_report_defect = 3

    	FNG is in the process of reporting a defect

    .. data:: fng_defect_reported = 4

    	FNG has reported a defect

    .. data:: fng_defect_clearing = 5

    	No defect present, but the reset timer has not

    	yet expired

    """

    fng_reset = Enum.YLeaf(1, "fng-reset")

    fng_defect = Enum.YLeaf(2, "fng-defect")

    fng_report_defect = Enum.YLeaf(3, "fng-report-defect")

    fng_defect_reported = Enum.YLeaf(4, "fng-defect-reported")

    fng_defect_clearing = Enum.YLeaf(5, "fng-defect-clearing")


class CfmPmPktAction(Enum):
    """
    CfmPmPktAction

    Action taken for received packet

    .. data:: packet_processed = 0

    	Packet processed successfully

    .. data:: packet_forwarded = 1

    	Packet forwarded

    .. data:: unknown_opcode = 2

    	Packet dropped at a MEP due to unknown opcode

    .. data:: filter_level = 3

    	Packet dropped due to level/opcode filtering at

    	a MEP

    .. data:: filter_blocked = 4

    	Packet dropped because interface is STP blocked

    .. data:: filter_local_mac = 5

    	Packet dropped due to local destination MAC

    .. data:: malformed_ccm_size = 6

    	CCM too short or too long

    .. data:: malformed_ccm_mep_id = 7

    	Invalid MEP-ID

    .. data:: malformed_too_short = 8

    	Packet too short

    .. data:: malformed_destination_mac_unicast = 9

    	Destination MAC address does not match

    	interface

    .. data:: malformed_destination_mac_multicast = 10

    	Invalid multicast destination MAC address

    .. data:: malformed_tlv_offset = 11

    	TLV offset too short or beyond the end of the

    	packet

    .. data:: malformed_lbm_source_mac = 12

    	Invalid source MAC address for LBM

    .. data:: malformed_ltr_relay_action = 13

    	Unknown LTR relay action

    .. data:: malformed_ltr_reply_tlv = 14

    	LTR has neither reply-ingress or reply-egress

    .. data:: malformed_lt_origin = 15

    	Invalid Linktrace Message origin MAC address

    .. data:: malformed_ltm_target = 16

    	Invalid LTM target MAC address

    .. data:: malformed_source_mac = 17

    	Invalid source MAC address

    .. data:: malformed_header_too_short = 18

    	Packet too short for CFM header

    .. data:: malformed_tlv_header_overrun = 19

    	TLV header extends beyond the end of the packet

    .. data:: malformed_tlv_overrun = 20

    	TLV extends beyond the end of the packet

    .. data:: malformed_duplicate_sender_id = 21

    	Multiple Sender-ID TLVs found

    .. data:: malformed_duplicate_port_status = 22

    	Multiple Port-status TLVs found

    .. data:: malformed_duplicate_interface_status = 23

    	Multiple Interface-state TLVs found

    .. data:: malformed_wrong_tlv = 24

    	Invalid TLV for this type of packet found

    .. data:: malformed_duplicate_data = 25

    	Multiple Data TLVs found

    .. data:: malformed_duplicate_ltr_egress_id = 26

    	Multiple LTR-Egress-ID TLVs found

    .. data:: malformed_duplicate_reply_ingress = 27

    	Multiple Reply-ingress TLVs found

    .. data:: malformed_duplicate_reply_egress = 28

    	Multiple Reply-egress TLVs found

    .. data:: malformed_duplicate_ltm_egress_id = 29

    	Multiple LTM-Egress-ID TLVs found

    .. data:: malformed_sender_id_size = 30

    	Sender-ID TLV is too short

    .. data:: malformed_chassis_id_size = 31

    	Sender-ID TLV is too short to contain the

    	Chassis ID

    .. data:: malformed_mgmt_address_domain_size = 32

    	Sender-ID TLV is too short to contain the

    	management address domain

    .. data:: malformed_mgmt_address_size = 33

    	Sender-ID TLV is too short to contain the

    	management address

    .. data:: malformed_port_status_size = 34

    	Port-status TLV is too short

    .. data:: malformed_port_status = 35

    	Invalid Port status value

    .. data:: malformed_interface_status_size = 36

    	Interface-status TLV is too short

    .. data:: malformed_interface_status = 37

    	Invalid Interface status value

    .. data:: malformed_organization_specific_tlv_size = 38

    	Organization-specific TLV is too short

    .. data:: malformed_duplicate_mep_name = 39

    	Multiple MEP-name TLVs found

    .. data:: malformed_duplicate_additional_interface_status = 40

    	Multiple additional-interface-status TLVs found

    .. data:: malformed_ltr_egress_id_size = 41

    	LTR-Egress-ID TLV is too short

    .. data:: malformed_reply_ingress_size = 42

    	Reply-ingress TLV is too short

    .. data:: malformed_ingress_action = 43

    	Invalid ingress-action value

    .. data:: malformed_reply_ingress_mac = 44

    	Reply-ingress TLV has invalid MAC address

    .. data:: malformed_ingress_port_length_size = 45

    	Reply-ingress TLV is too short to contain the

    	Port ID type

    .. data:: malformed_ingress_port_id_length = 46

    	Reply-ingress TLV has a zero Port ID length

    .. data:: malformed_ingress_port_id_size = 47

    	Reply-ingress TLV is too short to contain the

    	Port ID

    .. data:: malformed_reply_egress_size = 48

    	Reply-egress TLV is too short

    .. data:: malformed_egress_action = 49

    	Invalid egress-action value

    .. data:: malformed_reply_egress_mac = 50

    	Reply-egress TLV has invalid MAC address

    .. data:: malformed_egress_port_length_size = 51

    	Reply-egress TLV is too short to contain the

    	Port ID type

    .. data:: malformed_egress_port_id_length = 52

    	Reply-egress TLV has a zero Port ID length

    .. data:: malformed_egress_port_id_size = 53

    	Reply-egress TLV is too short to contain the

    	Port ID

    .. data:: malformed_ltm_egress_id_size = 54

    	LTM-Egress_ID TLV is too short

    .. data:: malformed_mep_name_size = 55

    	MEP-name TLV is too short

    .. data:: malformed_mep_name_name_length = 56

    	MEP-name TLV is too short to contain a MEP name

    .. data:: malformed_additional_interface_status_size = 57

    	Additional-interface-status is too short

    .. data:: malformed_additional_interface_status = 58

    	Invalid additional interface status

    .. data:: malformed_ccm_interval = 59

    	CCM has a zero CCM interval

    .. data:: malformed_mdid_mac_address_length = 60

    	CCM has a MAC-address MDID but the MDID is the

    	wrong length

    .. data:: malformed_mdid_length = 61

    	CCM has an invalid MDID length

    .. data:: malformed_sman_length = 62

    	CCM has an invalid Short MA Name length

    .. data:: malformed_sman2_byte_length = 63

    	CCM has a VID or 16-bit Short MA Name but a

    	mismatched length

    .. data:: malformed_sman_vpn_id_length = 64

    	CCM has a VPNID Short MA Name but a mismatched

    	length

    .. data:: malformed_elr_no_reply_tlv = 65

    	ELR has no ELR Reply TLVs

    .. data:: malformed_separate_elr_reply_egress = 66

    	ELR Reply Egress TLVs not all adjacent

    .. data:: malformed_dcm_destination_multicast = 67

    	DCM has a multicast destination MAC

    .. data:: malformed_dcm_embed_length = 68

    	DCM is too short to contain an Embedded PDU

    .. data:: malformed_dcm_embed_level = 69

    	DCM Embedded PDU level does not match DCM level

    .. data:: malformed_dcm_embed_version = 70

    	DCM Embedded PDU version does not match DCM

    	version

    .. data:: malformed_elr_relay_action = 71

    	Unknown ELR relay action

    .. data:: malformed_elr_tt_ls = 73

    	Reply Ingress TTL is not one greater than Reply

    	Egress TTL

    .. data:: malformed_elr_ttl_ingress = 74

    	Reply Ingress TTL present without ELR Reply

    	Ingress TLV

    .. data:: malformed_elr_ttl_egress = 75

    	Reply Egress TTL present without ELR Reply

    	Egress TLV

    .. data:: malformed_elm_destination_unicast = 76

    	ELM Destination MAC must not be unicast

    .. data:: malformed_elm_egress_id = 77

    	ELM has no LTM Egress ID TLV

    .. data:: malformed_dcm_embed_oui = 78

    	Embedded DCM OUI unrecognized

    .. data:: malformed_dcm_embed_opcode = 79

    	Embedded DCM Opcode is not ELM

    .. data:: malformed_elm_constant_zero = 80

    	ELM Constant Factor is zero

    .. data:: malformed_elr_timeout_zero = 81

    	ELR Next-Hop Timeout is zero

    .. data:: malformed_duplicate_test = 82

    	Multiple Test TLVs found

    .. data:: malformed_dmm_source_mac = 83

    	Invalid source MAC address for DMM

    .. data:: malformed_test_size = 84

    	Test TLV is too short

    .. data:: malformed_dmr_time_stamps = 85

    	DMR has exactly one of its Rxf and Txb

    	timestamps unspecified

    .. data:: malformed_dm_time_stamp_fmt = 86

    	The format of one or more timestamps is invalid

    .. data:: malformed_ais_interval = 87

    	AIS/LCK has invalid interval value (not 1

    	second or 1 minute)

    .. data:: filter_interface_down = 88

    	Packet dropped due to interface being down

    .. data:: filter_forward_standby = 89

    	Packet dropped - not forwarded because

    	interface is in standby mode

    .. data:: malformed_sman_icc_based_length = 90

    	CCM has an ICC-based format Short MA Name but a

    	mismatched length

    .. data:: filter_foward_issu_secondary = 120

    	Packet dropped - not forwarded in secondary HA

    	role

    .. data:: filter_response_standby = 121

    	Packet dropped - not responded to because

    	interface is in standby mode

    .. data:: filter_response_issu_secondary = 122

    	Packet dropped - not responded to in secondary

    	HA role

    """

    packet_processed = Enum.YLeaf(0, "packet-processed")

    packet_forwarded = Enum.YLeaf(1, "packet-forwarded")

    unknown_opcode = Enum.YLeaf(2, "unknown-opcode")

    filter_level = Enum.YLeaf(3, "filter-level")

    filter_blocked = Enum.YLeaf(4, "filter-blocked")

    filter_local_mac = Enum.YLeaf(5, "filter-local-mac")

    malformed_ccm_size = Enum.YLeaf(6, "malformed-ccm-size")

    malformed_ccm_mep_id = Enum.YLeaf(7, "malformed-ccm-mep-id")

    malformed_too_short = Enum.YLeaf(8, "malformed-too-short")

    malformed_destination_mac_unicast = Enum.YLeaf(9, "malformed-destination-mac-unicast")

    malformed_destination_mac_multicast = Enum.YLeaf(10, "malformed-destination-mac-multicast")

    malformed_tlv_offset = Enum.YLeaf(11, "malformed-tlv-offset")

    malformed_lbm_source_mac = Enum.YLeaf(12, "malformed-lbm-source-mac")

    malformed_ltr_relay_action = Enum.YLeaf(13, "malformed-ltr-relay-action")

    malformed_ltr_reply_tlv = Enum.YLeaf(14, "malformed-ltr-reply-tlv")

    malformed_lt_origin = Enum.YLeaf(15, "malformed-lt-origin")

    malformed_ltm_target = Enum.YLeaf(16, "malformed-ltm-target")

    malformed_source_mac = Enum.YLeaf(17, "malformed-source-mac")

    malformed_header_too_short = Enum.YLeaf(18, "malformed-header-too-short")

    malformed_tlv_header_overrun = Enum.YLeaf(19, "malformed-tlv-header-overrun")

    malformed_tlv_overrun = Enum.YLeaf(20, "malformed-tlv-overrun")

    malformed_duplicate_sender_id = Enum.YLeaf(21, "malformed-duplicate-sender-id")

    malformed_duplicate_port_status = Enum.YLeaf(22, "malformed-duplicate-port-status")

    malformed_duplicate_interface_status = Enum.YLeaf(23, "malformed-duplicate-interface-status")

    malformed_wrong_tlv = Enum.YLeaf(24, "malformed-wrong-tlv")

    malformed_duplicate_data = Enum.YLeaf(25, "malformed-duplicate-data")

    malformed_duplicate_ltr_egress_id = Enum.YLeaf(26, "malformed-duplicate-ltr-egress-id")

    malformed_duplicate_reply_ingress = Enum.YLeaf(27, "malformed-duplicate-reply-ingress")

    malformed_duplicate_reply_egress = Enum.YLeaf(28, "malformed-duplicate-reply-egress")

    malformed_duplicate_ltm_egress_id = Enum.YLeaf(29, "malformed-duplicate-ltm-egress-id")

    malformed_sender_id_size = Enum.YLeaf(30, "malformed-sender-id-size")

    malformed_chassis_id_size = Enum.YLeaf(31, "malformed-chassis-id-size")

    malformed_mgmt_address_domain_size = Enum.YLeaf(32, "malformed-mgmt-address-domain-size")

    malformed_mgmt_address_size = Enum.YLeaf(33, "malformed-mgmt-address-size")

    malformed_port_status_size = Enum.YLeaf(34, "malformed-port-status-size")

    malformed_port_status = Enum.YLeaf(35, "malformed-port-status")

    malformed_interface_status_size = Enum.YLeaf(36, "malformed-interface-status-size")

    malformed_interface_status = Enum.YLeaf(37, "malformed-interface-status")

    malformed_organization_specific_tlv_size = Enum.YLeaf(38, "malformed-organization-specific-tlv-size")

    malformed_duplicate_mep_name = Enum.YLeaf(39, "malformed-duplicate-mep-name")

    malformed_duplicate_additional_interface_status = Enum.YLeaf(40, "malformed-duplicate-additional-interface-status")

    malformed_ltr_egress_id_size = Enum.YLeaf(41, "malformed-ltr-egress-id-size")

    malformed_reply_ingress_size = Enum.YLeaf(42, "malformed-reply-ingress-size")

    malformed_ingress_action = Enum.YLeaf(43, "malformed-ingress-action")

    malformed_reply_ingress_mac = Enum.YLeaf(44, "malformed-reply-ingress-mac")

    malformed_ingress_port_length_size = Enum.YLeaf(45, "malformed-ingress-port-length-size")

    malformed_ingress_port_id_length = Enum.YLeaf(46, "malformed-ingress-port-id-length")

    malformed_ingress_port_id_size = Enum.YLeaf(47, "malformed-ingress-port-id-size")

    malformed_reply_egress_size = Enum.YLeaf(48, "malformed-reply-egress-size")

    malformed_egress_action = Enum.YLeaf(49, "malformed-egress-action")

    malformed_reply_egress_mac = Enum.YLeaf(50, "malformed-reply-egress-mac")

    malformed_egress_port_length_size = Enum.YLeaf(51, "malformed-egress-port-length-size")

    malformed_egress_port_id_length = Enum.YLeaf(52, "malformed-egress-port-id-length")

    malformed_egress_port_id_size = Enum.YLeaf(53, "malformed-egress-port-id-size")

    malformed_ltm_egress_id_size = Enum.YLeaf(54, "malformed-ltm-egress-id-size")

    malformed_mep_name_size = Enum.YLeaf(55, "malformed-mep-name-size")

    malformed_mep_name_name_length = Enum.YLeaf(56, "malformed-mep-name-name-length")

    malformed_additional_interface_status_size = Enum.YLeaf(57, "malformed-additional-interface-status-size")

    malformed_additional_interface_status = Enum.YLeaf(58, "malformed-additional-interface-status")

    malformed_ccm_interval = Enum.YLeaf(59, "malformed-ccm-interval")

    malformed_mdid_mac_address_length = Enum.YLeaf(60, "malformed-mdid-mac-address-length")

    malformed_mdid_length = Enum.YLeaf(61, "malformed-mdid-length")

    malformed_sman_length = Enum.YLeaf(62, "malformed-sman-length")

    malformed_sman2_byte_length = Enum.YLeaf(63, "malformed-sman2-byte-length")

    malformed_sman_vpn_id_length = Enum.YLeaf(64, "malformed-sman-vpn-id-length")

    malformed_elr_no_reply_tlv = Enum.YLeaf(65, "malformed-elr-no-reply-tlv")

    malformed_separate_elr_reply_egress = Enum.YLeaf(66, "malformed-separate-elr-reply-egress")

    malformed_dcm_destination_multicast = Enum.YLeaf(67, "malformed-dcm-destination-multicast")

    malformed_dcm_embed_length = Enum.YLeaf(68, "malformed-dcm-embed-length")

    malformed_dcm_embed_level = Enum.YLeaf(69, "malformed-dcm-embed-level")

    malformed_dcm_embed_version = Enum.YLeaf(70, "malformed-dcm-embed-version")

    malformed_elr_relay_action = Enum.YLeaf(71, "malformed-elr-relay-action")

    malformed_elr_tt_ls = Enum.YLeaf(73, "malformed-elr-tt-ls")

    malformed_elr_ttl_ingress = Enum.YLeaf(74, "malformed-elr-ttl-ingress")

    malformed_elr_ttl_egress = Enum.YLeaf(75, "malformed-elr-ttl-egress")

    malformed_elm_destination_unicast = Enum.YLeaf(76, "malformed-elm-destination-unicast")

    malformed_elm_egress_id = Enum.YLeaf(77, "malformed-elm-egress-id")

    malformed_dcm_embed_oui = Enum.YLeaf(78, "malformed-dcm-embed-oui")

    malformed_dcm_embed_opcode = Enum.YLeaf(79, "malformed-dcm-embed-opcode")

    malformed_elm_constant_zero = Enum.YLeaf(80, "malformed-elm-constant-zero")

    malformed_elr_timeout_zero = Enum.YLeaf(81, "malformed-elr-timeout-zero")

    malformed_duplicate_test = Enum.YLeaf(82, "malformed-duplicate-test")

    malformed_dmm_source_mac = Enum.YLeaf(83, "malformed-dmm-source-mac")

    malformed_test_size = Enum.YLeaf(84, "malformed-test-size")

    malformed_dmr_time_stamps = Enum.YLeaf(85, "malformed-dmr-time-stamps")

    malformed_dm_time_stamp_fmt = Enum.YLeaf(86, "malformed-dm-time-stamp-fmt")

    malformed_ais_interval = Enum.YLeaf(87, "malformed-ais-interval")

    filter_interface_down = Enum.YLeaf(88, "filter-interface-down")

    filter_forward_standby = Enum.YLeaf(89, "filter-forward-standby")

    malformed_sman_icc_based_length = Enum.YLeaf(90, "malformed-sman-icc-based-length")

    filter_foward_issu_secondary = Enum.YLeaf(120, "filter-foward-issu-secondary")

    filter_response_standby = Enum.YLeaf(121, "filter-response-standby")

    filter_response_issu_secondary = Enum.YLeaf(122, "filter-response-issu-secondary")


class CfmPmPortIdFmt(Enum):
    """
    CfmPmPortIdFmt

    Port ID format

    .. data:: port_id_interface_alias = 1

    	Port ID is an interface alias

    .. data:: port_id_port_component = 2

    	Port ID is a component name

    .. data:: port_id_mac_address = 3

    	Port ID is a MAC address

    .. data:: port_id_network_address = 4

    	Port ID is a network address

    .. data:: port_id_interface_name = 5

    	Port ID is an interface name

    .. data:: port_id_agent_circuit_id = 6

    	Port ID is an agent name

    .. data:: port_id_local = 7

    	Port ID is a local name

    .. data:: port_id_unknown = 8

    	Port ID format unknown

    """

    port_id_interface_alias = Enum.YLeaf(1, "port-id-interface-alias")

    port_id_port_component = Enum.YLeaf(2, "port-id-port-component")

    port_id_mac_address = Enum.YLeaf(3, "port-id-mac-address")

    port_id_network_address = Enum.YLeaf(4, "port-id-network-address")

    port_id_interface_name = Enum.YLeaf(5, "port-id-interface-name")

    port_id_agent_circuit_id = Enum.YLeaf(6, "port-id-agent-circuit-id")

    port_id_local = Enum.YLeaf(7, "port-id-local")

    port_id_unknown = Enum.YLeaf(8, "port-id-unknown")


class CfmPmPortStatus(Enum):
    """
    CfmPmPortStatus

    Port status

    .. data:: port_status_blocked = 1

    	Port is STP blocked

    .. data:: port_status_up = 2

    	Port is up

    .. data:: port_status_unknown = 3

    	Unknown port status

    """

    port_status_blocked = Enum.YLeaf(1, "port-status-blocked")

    port_status_up = Enum.YLeaf(2, "port-status-up")

    port_status_unknown = Enum.YLeaf(3, "port-status-unknown")


class CfmPmRelayAction(Enum):
    """
    CfmPmRelayAction

    LTR relay action

    .. data:: relay_hit = 1

    	Target Hit

    .. data:: relay_fdb = 2

    	Filtering database

    .. data:: relay_mpdb = 3

    	CCM Learning database

    """

    relay_hit = Enum.YLeaf(1, "relay-hit")

    relay_fdb = Enum.YLeaf(2, "relay-fdb")

    relay_mpdb = Enum.YLeaf(3, "relay-mpdb")


class CfmPmRmepState(Enum):
    """
    CfmPmRmepState

    State of the Peer MEP state machine

    .. data:: peer_mep_idle = 1

    	Momentary state during reset

    .. data:: peer_mep_start = 2

    	Loss timer not expired since reset, but no

    	valid CCM received

    .. data:: peer_mep_failed = 3

    	Loss timer has expired

    .. data:: peer_mep_ok = 4

    	Loss timer has not expired since last valid CCM

    """

    peer_mep_idle = Enum.YLeaf(1, "peer-mep-idle")

    peer_mep_start = Enum.YLeaf(2, "peer-mep-start")

    peer_mep_failed = Enum.YLeaf(3, "peer-mep-failed")

    peer_mep_ok = Enum.YLeaf(4, "peer-mep-ok")


class CfmPmRmepXcState(Enum):
    """
    CfmPmRmepXcState

    Cross\-check state of a peer MEP

    .. data:: cross_check_ok = 0

    	Cross-check OK

    .. data:: cross_check_missing = 1

    	No CCMs received within loss time from peer MEP

    .. data:: cross_check_extra = 2

    	CCMs received from peer MEP not marked for

    	cross-check

    """

    cross_check_ok = Enum.YLeaf(0, "cross-check-ok")

    cross_check_missing = Enum.YLeaf(1, "cross-check-missing")

    cross_check_extra = Enum.YLeaf(2, "cross-check-extra")


class SlaBucketSize(Enum):
    """
    SlaBucketSize

    Type of configuration of a bucket size

    .. data:: buckets_per_probe = 0

    	Bucket size is configured as buckets per probe

    .. data:: probes_per_bucket = 1

    	Bucket size is configured as probes per bucket

    """

    buckets_per_probe = Enum.YLeaf(0, "buckets-per-probe")

    probes_per_bucket = Enum.YLeaf(1, "probes-per-bucket")


class SlaOperBucket(Enum):
    """
    SlaOperBucket

    Type of SLA metric bucket

    .. data:: bucket_type_bins = 0

    	SLA metric bin

    .. data:: bucket_type_samples = 1

    	SLA metric sample

    """

    bucket_type_bins = Enum.YLeaf(0, "bucket-type-bins")

    bucket_type_samples = Enum.YLeaf(1, "bucket-type-samples")


class SlaOperOperation(Enum):
    """
    SlaOperOperation

    Type of SLA operation

    .. data:: operation_type_configured = 0

    	Configured SLA operation

    .. data:: operation_type_ondemand = 1

    	On-demand SLA operation

    """

    operation_type_configured = Enum.YLeaf(0, "operation-type-configured")

    operation_type_ondemand = Enum.YLeaf(1, "operation-type-ondemand")


class SlaOperPacketPriority(Enum):
    """
    SlaOperPacketPriority

    Priority scheme for packet priority

    .. data:: priority_none = 0

    	Packet does not use any specified priority.

    .. data:: priority_cos = 1

    	Packet uses a specified 3-bit COS priority

    	value.

    """

    priority_none = Enum.YLeaf(0, "priority-none")

    priority_cos = Enum.YLeaf(1, "priority-cos")


class SlaOperTestPatternScheme(Enum):
    """
    SlaOperTestPatternScheme

    Test pattern scheme for packet padding

    .. data:: hex = 0

    	Packet is padded with a user-specified string

    .. data:: pseudo_random = 1

    	Packet is padded with a pseudo-random bit

    	sequence

    """

    hex = Enum.YLeaf(0, "hex")

    pseudo_random = Enum.YLeaf(1, "pseudo-random")


class SlaRecordableMetric(Enum):
    """
    SlaRecordableMetric

    Types of metrics that can be recorded by probes

    .. data:: metric_invalid = 0

    	Not a valid metric type

    .. data:: metric_round_trip_delay = 1

    	Round-trip Delay

    .. data:: metric_one_way_delay_sd = 2

    	One-way Delay (Source->Destination)

    .. data:: metric_one_way_delay_ds = 3

    	One-way Delay (Destination->Source)

    .. data:: metric_round_trip_jitter = 4

    	Round-trip Jitter

    .. data:: metric_one_way_jitter_sd = 5

    	One-way Jitter (Source->Destination)

    .. data:: metric_one_way_jitter_ds = 6

    	One-way Jitter (Destination->Source)

    .. data:: metric_one_way_flr_sd = 7

    	One-way Frame Loss Ratio (Source->Destination)

    .. data:: metric_one_way_flr_ds = 8

    	One-way Frame Loss Ratio (Destination->Source)

    """

    metric_invalid = Enum.YLeaf(0, "metric-invalid")

    metric_round_trip_delay = Enum.YLeaf(1, "metric-round-trip-delay")

    metric_one_way_delay_sd = Enum.YLeaf(2, "metric-one-way-delay-sd")

    metric_one_way_delay_ds = Enum.YLeaf(3, "metric-one-way-delay-ds")

    metric_round_trip_jitter = Enum.YLeaf(4, "metric-round-trip-jitter")

    metric_one_way_jitter_sd = Enum.YLeaf(5, "metric-one-way-jitter-sd")

    metric_one_way_jitter_ds = Enum.YLeaf(6, "metric-one-way-jitter-ds")

    metric_one_way_flr_sd = Enum.YLeaf(7, "metric-one-way-flr-sd")

    metric_one_way_flr_ds = Enum.YLeaf(8, "metric-one-way-flr-ds")



class Cfm(Entity):
    """
    CFM operational data
    
    .. attribute:: global_
    
    	Global operational data
    	**type**\:   :py:class:`Global_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_>`
    
    .. attribute:: nodes
    
    	Node table for node\-specific operational data
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes>`
    
    

    """

    _prefix = 'ethernet-cfm-oper'
    _revision = '2015-11-09'

    def __init__(self):
        super(Cfm, self).__init__()
        self._top_entity = None

        self.yang_name = "cfm"
        self.yang_parent_name = "Cisco-IOS-XR-ethernet-cfm-oper"

        self.global_ = Cfm.Global_()
        self.global_.parent = self
        self._children_name_map["global_"] = "global"
        self._children_yang_names.add("global")

        self.nodes = Cfm.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")


    class Nodes(Entity):
        """
        Node table for node\-specific operational data
        
        .. attribute:: node
        
        	Node\-specific data for a particular node
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node>`
        
        

        """

        _prefix = 'ethernet-cfm-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Cfm.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "cfm"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Cfm.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Cfm.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            Node\-specific data for a particular node
            
            .. attribute:: node  <key>
            
            	Node
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: ccm_learning_databases
            
            	CCMLearningDatabase table
            	**type**\:   :py:class:`CcmLearningDatabases <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.CcmLearningDatabases>`
            
            .. attribute:: interface_aises
            
            	Interface AIS table
            	**type**\:   :py:class:`InterfaceAises <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceAises>`
            
            .. attribute:: interface_statistics
            
            	Interface Statistics table
            	**type**\:   :py:class:`InterfaceStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceStatistics>`
            
            .. attribute:: summary
            
            	Summary
            	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.Summary>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.node = YLeaf(YType.str, "node")

                self.ccm_learning_databases = Cfm.Nodes.Node.CcmLearningDatabases()
                self.ccm_learning_databases.parent = self
                self._children_name_map["ccm_learning_databases"] = "ccm-learning-databases"
                self._children_yang_names.add("ccm-learning-databases")

                self.interface_aises = Cfm.Nodes.Node.InterfaceAises()
                self.interface_aises.parent = self
                self._children_name_map["interface_aises"] = "interface-aises"
                self._children_yang_names.add("interface-aises")

                self.interface_statistics = Cfm.Nodes.Node.InterfaceStatistics()
                self.interface_statistics.parent = self
                self._children_name_map["interface_statistics"] = "interface-statistics"
                self._children_yang_names.add("interface-statistics")

                self.summary = Cfm.Nodes.Node.Summary()
                self.summary.parent = self
                self._children_name_map["summary"] = "summary"
                self._children_yang_names.add("summary")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Nodes.Node, self).__setattr__(name, value)


            class InterfaceAises(Entity):
                """
                Interface AIS table
                
                .. attribute:: interface_ais
                
                	AIS statistics for a particular interface
                	**type**\: list of    :py:class:`InterfaceAis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceAises.InterfaceAis>`
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Nodes.Node.InterfaceAises, self).__init__()

                    self.yang_name = "interface-aises"
                    self.yang_parent_name = "node"

                    self.interface_ais = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Nodes.Node.InterfaceAises, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Nodes.Node.InterfaceAises, self).__setattr__(name, value)


                class InterfaceAis(Entity):
                    """
                    AIS statistics for a particular interface
                    
                    .. attribute:: interface_name  <key>
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: direction  <key>
                    
                    	AIS Direction
                    	**type**\:   :py:class:`CfmAisDir <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmAisDir>`
                    
                    .. attribute:: interface
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: interface_state
                    
                    	IM Interface state
                    	**type**\:  str
                    
                    .. attribute:: interworking_state
                    
                    	Interface interworking state
                    	**type**\:   :py:class:`CfmBagIwState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagIwState>`
                    
                    .. attribute:: statistics
                    
                    	AIS statistics
                    	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics>`
                    
                    .. attribute:: stp_state
                    
                    	STP state
                    	**type**\:   :py:class:`CfmBagStpState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagStpState>`
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis, self).__init__()

                        self.yang_name = "interface-ais"
                        self.yang_parent_name = "interface-aises"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.direction = YLeaf(YType.enumeration, "direction")

                        self.interface = YLeaf(YType.str, "interface")

                        self.interface_state = YLeaf(YType.str, "interface-state")

                        self.interworking_state = YLeaf(YType.enumeration, "interworking-state")

                        self.stp_state = YLeaf(YType.enumeration, "stp-state")

                        self.statistics = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics()
                        self.statistics.parent = self
                        self._children_name_map["statistics"] = "statistics"
                        self._children_yang_names.add("statistics")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name",
                                        "direction",
                                        "interface",
                                        "interface_state",
                                        "interworking_state",
                                        "stp_state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis, self).__setattr__(name, value)


                    class Statistics(Entity):
                        """
                        AIS statistics
                        
                        .. attribute:: defects
                        
                        	Defects detected
                        	**type**\:   :py:class:`Defects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects>`
                        
                        .. attribute:: direction
                        
                        	Direction of AIS packets
                        	**type**\:   :py:class:`CfmBagDirection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagDirection>`
                        
                        .. attribute:: last_started
                        
                        	Time elapsed since sending last started
                        	**type**\:   :py:class:`LastStarted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.LastStarted>`
                        
                        .. attribute:: lowest_level
                        
                        	Level of the lowest MEP transmitting AIS
                        	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                        
                        .. attribute:: sent_packets
                        
                        	Total number of packets sent by the transmitting MEP
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: transmission_interval
                        
                        	Interval at which AIS packets are transmitted
                        	**type**\:   :py:class:`CfmBagAisInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagAisInterval>`
                        
                        .. attribute:: transmission_level
                        
                        	Level that AIS packets are transmitted on
                        	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                        
                        .. attribute:: via_level
                        
                        	Levels of other MEPs receiving AIS
                        	**type**\:  list of   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics, self).__init__()

                            self.yang_name = "statistics"
                            self.yang_parent_name = "interface-ais"

                            self.direction = YLeaf(YType.enumeration, "direction")

                            self.lowest_level = YLeaf(YType.enumeration, "lowest-level")

                            self.sent_packets = YLeaf(YType.uint32, "sent-packets")

                            self.transmission_interval = YLeaf(YType.enumeration, "transmission-interval")

                            self.transmission_level = YLeaf(YType.enumeration, "transmission-level")

                            self.via_level = YLeafList(YType.enumeration, "via-level")

                            self.defects = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects()
                            self.defects.parent = self
                            self._children_name_map["defects"] = "defects"
                            self._children_yang_names.add("defects")

                            self.last_started = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.LastStarted()
                            self.last_started.parent = self
                            self._children_name_map["last_started"] = "last-started"
                            self._children_yang_names.add("last-started")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("direction",
                                            "lowest_level",
                                            "sent_packets",
                                            "transmission_interval",
                                            "transmission_level",
                                            "via_level") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics, self).__setattr__(name, value)


                        class Defects(Entity):
                            """
                            Defects detected
                            
                            .. attribute:: ais_received
                            
                            	AIS or LCK received
                            	**type**\:  bool
                            
                            .. attribute:: auto_missing
                            
                            	Number of missing auto cross\-check MEPs
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_port_status
                            
                            	The local port or interface is down
                            	**type**\:  bool
                            
                            .. attribute:: missing
                            
                            	Number of missing peer MEPs
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: peer_meps_that_timed_out
                            
                            	Number of peer MEPs that have timed out
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: peer_port_status
                            
                            	A peer port or interface is down
                            	**type**\:  bool
                            
                            .. attribute:: remote_meps_defects
                            
                            	Defects detected from remote MEPs
                            	**type**\:   :py:class:`RemoteMepsDefects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects.RemoteMepsDefects>`
                            
                            .. attribute:: unexpected
                            
                            	Number of unexpected peer MEPs
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects, self).__init__()

                                self.yang_name = "defects"
                                self.yang_parent_name = "statistics"

                                self.ais_received = YLeaf(YType.boolean, "ais-received")

                                self.auto_missing = YLeaf(YType.uint32, "auto-missing")

                                self.local_port_status = YLeaf(YType.boolean, "local-port-status")

                                self.missing = YLeaf(YType.uint32, "missing")

                                self.peer_meps_that_timed_out = YLeaf(YType.uint32, "peer-meps-that-timed-out")

                                self.peer_port_status = YLeaf(YType.boolean, "peer-port-status")

                                self.unexpected = YLeaf(YType.uint32, "unexpected")

                                self.remote_meps_defects = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects.RemoteMepsDefects()
                                self.remote_meps_defects.parent = self
                                self._children_name_map["remote_meps_defects"] = "remote-meps-defects"
                                self._children_yang_names.add("remote-meps-defects")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ais_received",
                                                "auto_missing",
                                                "local_port_status",
                                                "missing",
                                                "peer_meps_that_timed_out",
                                                "peer_port_status",
                                                "unexpected") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects, self).__setattr__(name, value)


                            class RemoteMepsDefects(Entity):
                                """
                                Defects detected from remote MEPs
                                
                                .. attribute:: invalid_ccm_interval
                                
                                	Invalid CCM interval
                                	**type**\:  bool
                                
                                .. attribute:: invalid_level
                                
                                	Invalid level
                                	**type**\:  bool
                                
                                .. attribute:: invalid_maid
                                
                                	Invalid MAID
                                	**type**\:  bool
                                
                                .. attribute:: loss_threshold_exceeded
                                
                                	Timed out (loss threshold exceeded)
                                	**type**\:  bool
                                
                                .. attribute:: received_our_mac
                                
                                	Loop detected (our MAC address received)
                                	**type**\:  bool
                                
                                .. attribute:: received_our_mep_id
                                
                                	Configuration Error (our MEP ID received)
                                	**type**\:  bool
                                
                                .. attribute:: received_rdi
                                
                                	Remote defection indication received
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects.RemoteMepsDefects, self).__init__()

                                    self.yang_name = "remote-meps-defects"
                                    self.yang_parent_name = "defects"

                                    self.invalid_ccm_interval = YLeaf(YType.boolean, "invalid-ccm-interval")

                                    self.invalid_level = YLeaf(YType.boolean, "invalid-level")

                                    self.invalid_maid = YLeaf(YType.boolean, "invalid-maid")

                                    self.loss_threshold_exceeded = YLeaf(YType.boolean, "loss-threshold-exceeded")

                                    self.received_our_mac = YLeaf(YType.boolean, "received-our-mac")

                                    self.received_our_mep_id = YLeaf(YType.boolean, "received-our-mep-id")

                                    self.received_rdi = YLeaf(YType.boolean, "received-rdi")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("invalid_ccm_interval",
                                                    "invalid_level",
                                                    "invalid_maid",
                                                    "loss_threshold_exceeded",
                                                    "received_our_mac",
                                                    "received_our_mep_id",
                                                    "received_rdi") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects.RemoteMepsDefects, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects.RemoteMepsDefects, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.invalid_ccm_interval.is_set or
                                        self.invalid_level.is_set or
                                        self.invalid_maid.is_set or
                                        self.loss_threshold_exceeded.is_set or
                                        self.received_our_mac.is_set or
                                        self.received_our_mep_id.is_set or
                                        self.received_rdi.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.invalid_ccm_interval.yfilter != YFilter.not_set or
                                        self.invalid_level.yfilter != YFilter.not_set or
                                        self.invalid_maid.yfilter != YFilter.not_set or
                                        self.loss_threshold_exceeded.yfilter != YFilter.not_set or
                                        self.received_our_mac.yfilter != YFilter.not_set or
                                        self.received_our_mep_id.yfilter != YFilter.not_set or
                                        self.received_rdi.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "remote-meps-defects" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.invalid_ccm_interval.is_set or self.invalid_ccm_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.invalid_ccm_interval.get_name_leafdata())
                                    if (self.invalid_level.is_set or self.invalid_level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.invalid_level.get_name_leafdata())
                                    if (self.invalid_maid.is_set or self.invalid_maid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.invalid_maid.get_name_leafdata())
                                    if (self.loss_threshold_exceeded.is_set or self.loss_threshold_exceeded.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.loss_threshold_exceeded.get_name_leafdata())
                                    if (self.received_our_mac.is_set or self.received_our_mac.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.received_our_mac.get_name_leafdata())
                                    if (self.received_our_mep_id.is_set or self.received_our_mep_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.received_our_mep_id.get_name_leafdata())
                                    if (self.received_rdi.is_set or self.received_rdi.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.received_rdi.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "invalid-ccm-interval" or name == "invalid-level" or name == "invalid-maid" or name == "loss-threshold-exceeded" or name == "received-our-mac" or name == "received-our-mep-id" or name == "received-rdi"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "invalid-ccm-interval"):
                                        self.invalid_ccm_interval = value
                                        self.invalid_ccm_interval.value_namespace = name_space
                                        self.invalid_ccm_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "invalid-level"):
                                        self.invalid_level = value
                                        self.invalid_level.value_namespace = name_space
                                        self.invalid_level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "invalid-maid"):
                                        self.invalid_maid = value
                                        self.invalid_maid.value_namespace = name_space
                                        self.invalid_maid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "loss-threshold-exceeded"):
                                        self.loss_threshold_exceeded = value
                                        self.loss_threshold_exceeded.value_namespace = name_space
                                        self.loss_threshold_exceeded.value_namespace_prefix = name_space_prefix
                                    if(value_path == "received-our-mac"):
                                        self.received_our_mac = value
                                        self.received_our_mac.value_namespace = name_space
                                        self.received_our_mac.value_namespace_prefix = name_space_prefix
                                    if(value_path == "received-our-mep-id"):
                                        self.received_our_mep_id = value
                                        self.received_our_mep_id.value_namespace = name_space
                                        self.received_our_mep_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "received-rdi"):
                                        self.received_rdi = value
                                        self.received_rdi.value_namespace = name_space
                                        self.received_rdi.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.ais_received.is_set or
                                    self.auto_missing.is_set or
                                    self.local_port_status.is_set or
                                    self.missing.is_set or
                                    self.peer_meps_that_timed_out.is_set or
                                    self.peer_port_status.is_set or
                                    self.unexpected.is_set or
                                    (self.remote_meps_defects is not None and self.remote_meps_defects.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ais_received.yfilter != YFilter.not_set or
                                    self.auto_missing.yfilter != YFilter.not_set or
                                    self.local_port_status.yfilter != YFilter.not_set or
                                    self.missing.yfilter != YFilter.not_set or
                                    self.peer_meps_that_timed_out.yfilter != YFilter.not_set or
                                    self.peer_port_status.yfilter != YFilter.not_set or
                                    self.unexpected.yfilter != YFilter.not_set or
                                    (self.remote_meps_defects is not None and self.remote_meps_defects.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "defects" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ais_received.is_set or self.ais_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ais_received.get_name_leafdata())
                                if (self.auto_missing.is_set or self.auto_missing.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_missing.get_name_leafdata())
                                if (self.local_port_status.is_set or self.local_port_status.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_port_status.get_name_leafdata())
                                if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.missing.get_name_leafdata())
                                if (self.peer_meps_that_timed_out.is_set or self.peer_meps_that_timed_out.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.peer_meps_that_timed_out.get_name_leafdata())
                                if (self.peer_port_status.is_set or self.peer_port_status.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.peer_port_status.get_name_leafdata())
                                if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unexpected.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "remote-meps-defects"):
                                    if (self.remote_meps_defects is None):
                                        self.remote_meps_defects = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects.RemoteMepsDefects()
                                        self.remote_meps_defects.parent = self
                                        self._children_name_map["remote_meps_defects"] = "remote-meps-defects"
                                    return self.remote_meps_defects

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "remote-meps-defects" or name == "ais-received" or name == "auto-missing" or name == "local-port-status" or name == "missing" or name == "peer-meps-that-timed-out" or name == "peer-port-status" or name == "unexpected"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ais-received"):
                                    self.ais_received = value
                                    self.ais_received.value_namespace = name_space
                                    self.ais_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "auto-missing"):
                                    self.auto_missing = value
                                    self.auto_missing.value_namespace = name_space
                                    self.auto_missing.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-port-status"):
                                    self.local_port_status = value
                                    self.local_port_status.value_namespace = name_space
                                    self.local_port_status.value_namespace_prefix = name_space_prefix
                                if(value_path == "missing"):
                                    self.missing = value
                                    self.missing.value_namespace = name_space
                                    self.missing.value_namespace_prefix = name_space_prefix
                                if(value_path == "peer-meps-that-timed-out"):
                                    self.peer_meps_that_timed_out = value
                                    self.peer_meps_that_timed_out.value_namespace = name_space
                                    self.peer_meps_that_timed_out.value_namespace_prefix = name_space_prefix
                                if(value_path == "peer-port-status"):
                                    self.peer_port_status = value
                                    self.peer_port_status.value_namespace = name_space
                                    self.peer_port_status.value_namespace_prefix = name_space_prefix
                                if(value_path == "unexpected"):
                                    self.unexpected = value
                                    self.unexpected.value_namespace = name_space
                                    self.unexpected.value_namespace_prefix = name_space_prefix


                        class LastStarted(Entity):
                            """
                            Time elapsed since sending last started
                            
                            .. attribute:: nanoseconds
                            
                            	Nanoseconds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**units**\: nanosecond
                            
                            .. attribute:: seconds
                            
                            	Seconds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.LastStarted, self).__init__()

                                self.yang_name = "last-started"
                                self.yang_parent_name = "statistics"

                                self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                                self.seconds = YLeaf(YType.uint32, "seconds")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("nanoseconds",
                                                "seconds") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.LastStarted, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.LastStarted, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.nanoseconds.is_set or
                                    self.seconds.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.nanoseconds.yfilter != YFilter.not_set or
                                    self.seconds.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "last-started" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                                if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seconds.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "nanoseconds" or name == "seconds"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "nanoseconds"):
                                    self.nanoseconds = value
                                    self.nanoseconds.value_namespace = name_space
                                    self.nanoseconds.value_namespace_prefix = name_space_prefix
                                if(value_path == "seconds"):
                                    self.seconds = value
                                    self.seconds.value_namespace = name_space
                                    self.seconds.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for leaf in self.via_level.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.direction.is_set or
                                self.lowest_level.is_set or
                                self.sent_packets.is_set or
                                self.transmission_interval.is_set or
                                self.transmission_level.is_set or
                                (self.defects is not None and self.defects.has_data()) or
                                (self.last_started is not None and self.last_started.has_data()))

                        def has_operation(self):
                            for leaf in self.via_level.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.direction.yfilter != YFilter.not_set or
                                self.lowest_level.yfilter != YFilter.not_set or
                                self.sent_packets.yfilter != YFilter.not_set or
                                self.transmission_interval.yfilter != YFilter.not_set or
                                self.transmission_level.yfilter != YFilter.not_set or
                                self.via_level.yfilter != YFilter.not_set or
                                (self.defects is not None and self.defects.has_operation()) or
                                (self.last_started is not None and self.last_started.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "statistics" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.direction.is_set or self.direction.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.direction.get_name_leafdata())
                            if (self.lowest_level.is_set or self.lowest_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lowest_level.get_name_leafdata())
                            if (self.sent_packets.is_set or self.sent_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sent_packets.get_name_leafdata())
                            if (self.transmission_interval.is_set or self.transmission_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.transmission_interval.get_name_leafdata())
                            if (self.transmission_level.is_set or self.transmission_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.transmission_level.get_name_leafdata())

                            leaf_name_data.extend(self.via_level.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "defects"):
                                if (self.defects is None):
                                    self.defects = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.Defects()
                                    self.defects.parent = self
                                    self._children_name_map["defects"] = "defects"
                                return self.defects

                            if (child_yang_name == "last-started"):
                                if (self.last_started is None):
                                    self.last_started = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics.LastStarted()
                                    self.last_started.parent = self
                                    self._children_name_map["last_started"] = "last-started"
                                return self.last_started

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "defects" or name == "last-started" or name == "direction" or name == "lowest-level" or name == "sent-packets" or name == "transmission-interval" or name == "transmission-level" or name == "via-level"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "direction"):
                                self.direction = value
                                self.direction.value_namespace = name_space
                                self.direction.value_namespace_prefix = name_space_prefix
                            if(value_path == "lowest-level"):
                                self.lowest_level = value
                                self.lowest_level.value_namespace = name_space
                                self.lowest_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "sent-packets"):
                                self.sent_packets = value
                                self.sent_packets.value_namespace = name_space
                                self.sent_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "transmission-interval"):
                                self.transmission_interval = value
                                self.transmission_interval.value_namespace = name_space
                                self.transmission_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "transmission-level"):
                                self.transmission_level = value
                                self.transmission_level.value_namespace = name_space
                                self.transmission_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "via-level"):
                                self.via_level.append(value)

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            self.direction.is_set or
                            self.interface.is_set or
                            self.interface_state.is_set or
                            self.interworking_state.is_set or
                            self.stp_state.is_set or
                            (self.statistics is not None and self.statistics.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.direction.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set or
                            self.interface_state.yfilter != YFilter.not_set or
                            self.interworking_state.yfilter != YFilter.not_set or
                            self.stp_state.yfilter != YFilter.not_set or
                            (self.statistics is not None and self.statistics.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface-ais" + "[interface-name='" + self.interface_name.get() + "']" + "[direction='" + self.direction.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.direction.is_set or self.direction.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.direction.get_name_leafdata())
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())
                        if (self.interface_state.is_set or self.interface_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_state.get_name_leafdata())
                        if (self.interworking_state.is_set or self.interworking_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interworking_state.get_name_leafdata())
                        if (self.stp_state.is_set or self.stp_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stp_state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "statistics"):
                            if (self.statistics is None):
                                self.statistics = Cfm.Nodes.Node.InterfaceAises.InterfaceAis.Statistics()
                                self.statistics.parent = self
                                self._children_name_map["statistics"] = "statistics"
                            return self.statistics

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "statistics" or name == "interface-name" or name == "direction" or name == "interface" or name == "interface-state" or name == "interworking-state" or name == "stp-state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "direction"):
                            self.direction = value
                            self.direction.value_namespace = name_space
                            self.direction.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-state"):
                            self.interface_state = value
                            self.interface_state.value_namespace = name_space
                            self.interface_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "interworking-state"):
                            self.interworking_state = value
                            self.interworking_state.value_namespace = name_space
                            self.interworking_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "stp-state"):
                            self.stp_state = value
                            self.stp_state.value_namespace = name_space
                            self.stp_state.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.interface_ais:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.interface_ais:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-aises" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface-ais"):
                        for c in self.interface_ais:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Cfm.Nodes.Node.InterfaceAises.InterfaceAis()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.interface_ais.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-ais"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class InterfaceStatistics(Entity):
                """
                Interface Statistics table
                
                .. attribute:: interface_statistic
                
                	Counters for a particular interface
                	**type**\: list of    :py:class:`InterfaceStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic>`
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Nodes.Node.InterfaceStatistics, self).__init__()

                    self.yang_name = "interface-statistics"
                    self.yang_parent_name = "node"

                    self.interface_statistic = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Nodes.Node.InterfaceStatistics, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Nodes.Node.InterfaceStatistics, self).__setattr__(name, value)


                class InterfaceStatistic(Entity):
                    """
                    Counters for a particular interface
                    
                    .. attribute:: interface  <key>
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: interface_xr
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: statistics
                    
                    	EFP statistics
                    	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic.Statistics>`
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic, self).__init__()

                        self.yang_name = "interface-statistic"
                        self.yang_parent_name = "interface-statistics"

                        self.interface = YLeaf(YType.str, "interface")

                        self.interface_xr = YLeaf(YType.str, "interface-xr")

                        self.statistics = Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic.Statistics()
                        self.statistics.parent = self
                        self._children_name_map["statistics"] = "statistics"
                        self._children_yang_names.add("statistics")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface",
                                        "interface_xr") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic, self).__setattr__(name, value)


                    class Statistics(Entity):
                        """
                        EFP statistics
                        
                        .. attribute:: dropped_packets
                        
                        	Number of packets dropped at this EFP
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: last_malformed_opcode
                        
                        	Opcode for last malformed packet
                        	**type**\:   :py:class:`CfmBagOpcode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagOpcode>`
                        
                        .. attribute:: last_malformed_reason
                        
                        	Reason last malformed packet was malformed
                        	**type**\:   :py:class:`CfmPmPktAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmPktAction>`
                        
                        .. attribute:: malformed_packets
                        
                        	Number of malformed packets received at this EFP
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic.Statistics, self).__init__()

                            self.yang_name = "statistics"
                            self.yang_parent_name = "interface-statistic"

                            self.dropped_packets = YLeaf(YType.uint64, "dropped-packets")

                            self.last_malformed_opcode = YLeaf(YType.enumeration, "last-malformed-opcode")

                            self.last_malformed_reason = YLeaf(YType.enumeration, "last-malformed-reason")

                            self.malformed_packets = YLeaf(YType.uint64, "malformed-packets")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("dropped_packets",
                                            "last_malformed_opcode",
                                            "last_malformed_reason",
                                            "malformed_packets") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic.Statistics, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic.Statistics, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.dropped_packets.is_set or
                                self.last_malformed_opcode.is_set or
                                self.last_malformed_reason.is_set or
                                self.malformed_packets.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.dropped_packets.yfilter != YFilter.not_set or
                                self.last_malformed_opcode.yfilter != YFilter.not_set or
                                self.last_malformed_reason.yfilter != YFilter.not_set or
                                self.malformed_packets.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "statistics" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.dropped_packets.is_set or self.dropped_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dropped_packets.get_name_leafdata())
                            if (self.last_malformed_opcode.is_set or self.last_malformed_opcode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_malformed_opcode.get_name_leafdata())
                            if (self.last_malformed_reason.is_set or self.last_malformed_reason.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_malformed_reason.get_name_leafdata())
                            if (self.malformed_packets.is_set or self.malformed_packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.malformed_packets.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dropped-packets" or name == "last-malformed-opcode" or name == "last-malformed-reason" or name == "malformed-packets"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "dropped-packets"):
                                self.dropped_packets = value
                                self.dropped_packets.value_namespace = name_space
                                self.dropped_packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-malformed-opcode"):
                                self.last_malformed_opcode = value
                                self.last_malformed_opcode.value_namespace = name_space
                                self.last_malformed_opcode.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-malformed-reason"):
                                self.last_malformed_reason = value
                                self.last_malformed_reason.value_namespace = name_space
                                self.last_malformed_reason.value_namespace_prefix = name_space_prefix
                            if(value_path == "malformed-packets"):
                                self.malformed_packets = value
                                self.malformed_packets.value_namespace = name_space
                                self.malformed_packets.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.interface.is_set or
                            self.interface_xr.is_set or
                            (self.statistics is not None and self.statistics.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set or
                            self.interface_xr.yfilter != YFilter.not_set or
                            (self.statistics is not None and self.statistics.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface-statistic" + "[interface='" + self.interface.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())
                        if (self.interface_xr.is_set or self.interface_xr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_xr.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "statistics"):
                            if (self.statistics is None):
                                self.statistics = Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic.Statistics()
                                self.statistics.parent = self
                                self._children_name_map["statistics"] = "statistics"
                            return self.statistics

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "statistics" or name == "interface" or name == "interface-xr"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-xr"):
                            self.interface_xr = value
                            self.interface_xr.value_namespace = name_space
                            self.interface_xr.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.interface_statistic:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.interface_statistic:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-statistics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface-statistic"):
                        for c in self.interface_statistic:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Cfm.Nodes.Node.InterfaceStatistics.InterfaceStatistic()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.interface_statistic.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-statistic"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Summary(Entity):
                """
                Summary
                
                .. attribute:: bnm_enabled_links
                
                	Number of BNM Enabled Links
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: bridge_domains_and_xconnects
                
                	Number or bridge domains and crossconnects
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: ccm_learning_db_entries
                
                	Number of entries in the CCM learning database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: ccm_rate
                
                	The combined rate of CCMs on this card
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: disabled_misconfigured
                
                	The number of local MEPs disabled due to configuration errors
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: disabled_operational_error
                
                	The number of local MEPs disabled due to operational errors
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: disabled_out_of_resources
                
                	The number of local MEPs disabled due to lack of resources
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: domains
                
                	The number of domains in the CFM database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: down_meps
                
                	The number of down\-MEPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interfaces
                
                	The number of interfaces running CFM
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: issu_role
                
                	ISSU Role of CFM\-D, if any
                	**type**\:   :py:class:`CfmBagIssuRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagIssuRole>`
                
                .. attribute:: local_meps
                
                	The number of local MEPs in the CFM database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: mips
                
                	The number of MIPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: offloaded
                
                	The number of MEPs for which CCM processing has been offloaded
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: offloaded_at10ms
                
                	The number of MEPs offloaded with CCMs at 10ms intervals
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: offloaded_at3_3ms
                
                	The number of MEPs offloaded with CCMs at 3.3ms intervals
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: operational_local_meps
                
                	The number of operational local MEPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: operational_peer_meps
                
                	The number of operational peer MEPs recorded in the CFM database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_meps
                
                	The number of peer MEPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_meps_timed_out
                
                	The number of peer MEPs that have timed out
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_meps_with_defects
                
                	The number of peer MEPs with defects
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_meps_without_defects
                
                	The number of peer MEPs without defects
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: services
                
                	The number of services in the CFM database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: traceroute_cache_entries
                
                	Number of traceroute cache entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: traceroute_cache_replies
                
                	Number of traceroute cache replies
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_meps
                
                	The number of up\-MEPs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Nodes.Node.Summary, self).__init__()

                    self.yang_name = "summary"
                    self.yang_parent_name = "node"

                    self.bnm_enabled_links = YLeaf(YType.uint32, "bnm-enabled-links")

                    self.bridge_domains_and_xconnects = YLeaf(YType.uint32, "bridge-domains-and-xconnects")

                    self.ccm_learning_db_entries = YLeaf(YType.uint32, "ccm-learning-db-entries")

                    self.ccm_rate = YLeaf(YType.uint32, "ccm-rate")

                    self.disabled_misconfigured = YLeaf(YType.uint32, "disabled-misconfigured")

                    self.disabled_operational_error = YLeaf(YType.uint32, "disabled-operational-error")

                    self.disabled_out_of_resources = YLeaf(YType.uint32, "disabled-out-of-resources")

                    self.domains = YLeaf(YType.uint32, "domains")

                    self.down_meps = YLeaf(YType.uint32, "down-meps")

                    self.interfaces = YLeaf(YType.uint32, "interfaces")

                    self.issu_role = YLeaf(YType.enumeration, "issu-role")

                    self.local_meps = YLeaf(YType.uint32, "local-meps")

                    self.mips = YLeaf(YType.uint32, "mips")

                    self.offloaded = YLeaf(YType.uint32, "offloaded")

                    self.offloaded_at10ms = YLeaf(YType.uint32, "offloaded-at10ms")

                    self.offloaded_at3_3ms = YLeaf(YType.uint32, "offloaded-at3-3ms")

                    self.operational_local_meps = YLeaf(YType.uint32, "operational-local-meps")

                    self.operational_peer_meps = YLeaf(YType.uint32, "operational-peer-meps")

                    self.peer_meps = YLeaf(YType.uint32, "peer-meps")

                    self.peer_meps_timed_out = YLeaf(YType.uint32, "peer-meps-timed-out")

                    self.peer_meps_with_defects = YLeaf(YType.uint32, "peer-meps-with-defects")

                    self.peer_meps_without_defects = YLeaf(YType.uint32, "peer-meps-without-defects")

                    self.services = YLeaf(YType.uint32, "services")

                    self.traceroute_cache_entries = YLeaf(YType.uint32, "traceroute-cache-entries")

                    self.traceroute_cache_replies = YLeaf(YType.uint32, "traceroute-cache-replies")

                    self.up_meps = YLeaf(YType.uint32, "up-meps")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("bnm_enabled_links",
                                    "bridge_domains_and_xconnects",
                                    "ccm_learning_db_entries",
                                    "ccm_rate",
                                    "disabled_misconfigured",
                                    "disabled_operational_error",
                                    "disabled_out_of_resources",
                                    "domains",
                                    "down_meps",
                                    "interfaces",
                                    "issu_role",
                                    "local_meps",
                                    "mips",
                                    "offloaded",
                                    "offloaded_at10ms",
                                    "offloaded_at3_3ms",
                                    "operational_local_meps",
                                    "operational_peer_meps",
                                    "peer_meps",
                                    "peer_meps_timed_out",
                                    "peer_meps_with_defects",
                                    "peer_meps_without_defects",
                                    "services",
                                    "traceroute_cache_entries",
                                    "traceroute_cache_replies",
                                    "up_meps") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Nodes.Node.Summary, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Nodes.Node.Summary, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.bnm_enabled_links.is_set or
                        self.bridge_domains_and_xconnects.is_set or
                        self.ccm_learning_db_entries.is_set or
                        self.ccm_rate.is_set or
                        self.disabled_misconfigured.is_set or
                        self.disabled_operational_error.is_set or
                        self.disabled_out_of_resources.is_set or
                        self.domains.is_set or
                        self.down_meps.is_set or
                        self.interfaces.is_set or
                        self.issu_role.is_set or
                        self.local_meps.is_set or
                        self.mips.is_set or
                        self.offloaded.is_set or
                        self.offloaded_at10ms.is_set or
                        self.offloaded_at3_3ms.is_set or
                        self.operational_local_meps.is_set or
                        self.operational_peer_meps.is_set or
                        self.peer_meps.is_set or
                        self.peer_meps_timed_out.is_set or
                        self.peer_meps_with_defects.is_set or
                        self.peer_meps_without_defects.is_set or
                        self.services.is_set or
                        self.traceroute_cache_entries.is_set or
                        self.traceroute_cache_replies.is_set or
                        self.up_meps.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.bnm_enabled_links.yfilter != YFilter.not_set or
                        self.bridge_domains_and_xconnects.yfilter != YFilter.not_set or
                        self.ccm_learning_db_entries.yfilter != YFilter.not_set or
                        self.ccm_rate.yfilter != YFilter.not_set or
                        self.disabled_misconfigured.yfilter != YFilter.not_set or
                        self.disabled_operational_error.yfilter != YFilter.not_set or
                        self.disabled_out_of_resources.yfilter != YFilter.not_set or
                        self.domains.yfilter != YFilter.not_set or
                        self.down_meps.yfilter != YFilter.not_set or
                        self.interfaces.yfilter != YFilter.not_set or
                        self.issu_role.yfilter != YFilter.not_set or
                        self.local_meps.yfilter != YFilter.not_set or
                        self.mips.yfilter != YFilter.not_set or
                        self.offloaded.yfilter != YFilter.not_set or
                        self.offloaded_at10ms.yfilter != YFilter.not_set or
                        self.offloaded_at3_3ms.yfilter != YFilter.not_set or
                        self.operational_local_meps.yfilter != YFilter.not_set or
                        self.operational_peer_meps.yfilter != YFilter.not_set or
                        self.peer_meps.yfilter != YFilter.not_set or
                        self.peer_meps_timed_out.yfilter != YFilter.not_set or
                        self.peer_meps_with_defects.yfilter != YFilter.not_set or
                        self.peer_meps_without_defects.yfilter != YFilter.not_set or
                        self.services.yfilter != YFilter.not_set or
                        self.traceroute_cache_entries.yfilter != YFilter.not_set or
                        self.traceroute_cache_replies.yfilter != YFilter.not_set or
                        self.up_meps.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "summary" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.bnm_enabled_links.is_set or self.bnm_enabled_links.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bnm_enabled_links.get_name_leafdata())
                    if (self.bridge_domains_and_xconnects.is_set or self.bridge_domains_and_xconnects.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bridge_domains_and_xconnects.get_name_leafdata())
                    if (self.ccm_learning_db_entries.is_set or self.ccm_learning_db_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ccm_learning_db_entries.get_name_leafdata())
                    if (self.ccm_rate.is_set or self.ccm_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ccm_rate.get_name_leafdata())
                    if (self.disabled_misconfigured.is_set or self.disabled_misconfigured.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disabled_misconfigured.get_name_leafdata())
                    if (self.disabled_operational_error.is_set or self.disabled_operational_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disabled_operational_error.get_name_leafdata())
                    if (self.disabled_out_of_resources.is_set or self.disabled_out_of_resources.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disabled_out_of_resources.get_name_leafdata())
                    if (self.domains.is_set or self.domains.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domains.get_name_leafdata())
                    if (self.down_meps.is_set or self.down_meps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_meps.get_name_leafdata())
                    if (self.interfaces.is_set or self.interfaces.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interfaces.get_name_leafdata())
                    if (self.issu_role.is_set or self.issu_role.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.issu_role.get_name_leafdata())
                    if (self.local_meps.is_set or self.local_meps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_meps.get_name_leafdata())
                    if (self.mips.is_set or self.mips.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mips.get_name_leafdata())
                    if (self.offloaded.is_set or self.offloaded.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offloaded.get_name_leafdata())
                    if (self.offloaded_at10ms.is_set or self.offloaded_at10ms.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offloaded_at10ms.get_name_leafdata())
                    if (self.offloaded_at3_3ms.is_set or self.offloaded_at3_3ms.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offloaded_at3_3ms.get_name_leafdata())
                    if (self.operational_local_meps.is_set or self.operational_local_meps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.operational_local_meps.get_name_leafdata())
                    if (self.operational_peer_meps.is_set or self.operational_peer_meps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.operational_peer_meps.get_name_leafdata())
                    if (self.peer_meps.is_set or self.peer_meps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_meps.get_name_leafdata())
                    if (self.peer_meps_timed_out.is_set or self.peer_meps_timed_out.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_meps_timed_out.get_name_leafdata())
                    if (self.peer_meps_with_defects.is_set or self.peer_meps_with_defects.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_meps_with_defects.get_name_leafdata())
                    if (self.peer_meps_without_defects.is_set or self.peer_meps_without_defects.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_meps_without_defects.get_name_leafdata())
                    if (self.services.is_set or self.services.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.services.get_name_leafdata())
                    if (self.traceroute_cache_entries.is_set or self.traceroute_cache_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.traceroute_cache_entries.get_name_leafdata())
                    if (self.traceroute_cache_replies.is_set or self.traceroute_cache_replies.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.traceroute_cache_replies.get_name_leafdata())
                    if (self.up_meps.is_set or self.up_meps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_meps.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bnm-enabled-links" or name == "bridge-domains-and-xconnects" or name == "ccm-learning-db-entries" or name == "ccm-rate" or name == "disabled-misconfigured" or name == "disabled-operational-error" or name == "disabled-out-of-resources" or name == "domains" or name == "down-meps" or name == "interfaces" or name == "issu-role" or name == "local-meps" or name == "mips" or name == "offloaded" or name == "offloaded-at10ms" or name == "offloaded-at3-3ms" or name == "operational-local-meps" or name == "operational-peer-meps" or name == "peer-meps" or name == "peer-meps-timed-out" or name == "peer-meps-with-defects" or name == "peer-meps-without-defects" or name == "services" or name == "traceroute-cache-entries" or name == "traceroute-cache-replies" or name == "up-meps"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "bnm-enabled-links"):
                        self.bnm_enabled_links = value
                        self.bnm_enabled_links.value_namespace = name_space
                        self.bnm_enabled_links.value_namespace_prefix = name_space_prefix
                    if(value_path == "bridge-domains-and-xconnects"):
                        self.bridge_domains_and_xconnects = value
                        self.bridge_domains_and_xconnects.value_namespace = name_space
                        self.bridge_domains_and_xconnects.value_namespace_prefix = name_space_prefix
                    if(value_path == "ccm-learning-db-entries"):
                        self.ccm_learning_db_entries = value
                        self.ccm_learning_db_entries.value_namespace = name_space
                        self.ccm_learning_db_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "ccm-rate"):
                        self.ccm_rate = value
                        self.ccm_rate.value_namespace = name_space
                        self.ccm_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "disabled-misconfigured"):
                        self.disabled_misconfigured = value
                        self.disabled_misconfigured.value_namespace = name_space
                        self.disabled_misconfigured.value_namespace_prefix = name_space_prefix
                    if(value_path == "disabled-operational-error"):
                        self.disabled_operational_error = value
                        self.disabled_operational_error.value_namespace = name_space
                        self.disabled_operational_error.value_namespace_prefix = name_space_prefix
                    if(value_path == "disabled-out-of-resources"):
                        self.disabled_out_of_resources = value
                        self.disabled_out_of_resources.value_namespace = name_space
                        self.disabled_out_of_resources.value_namespace_prefix = name_space_prefix
                    if(value_path == "domains"):
                        self.domains = value
                        self.domains.value_namespace = name_space
                        self.domains.value_namespace_prefix = name_space_prefix
                    if(value_path == "down-meps"):
                        self.down_meps = value
                        self.down_meps.value_namespace = name_space
                        self.down_meps.value_namespace_prefix = name_space_prefix
                    if(value_path == "interfaces"):
                        self.interfaces = value
                        self.interfaces.value_namespace = name_space
                        self.interfaces.value_namespace_prefix = name_space_prefix
                    if(value_path == "issu-role"):
                        self.issu_role = value
                        self.issu_role.value_namespace = name_space
                        self.issu_role.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-meps"):
                        self.local_meps = value
                        self.local_meps.value_namespace = name_space
                        self.local_meps.value_namespace_prefix = name_space_prefix
                    if(value_path == "mips"):
                        self.mips = value
                        self.mips.value_namespace = name_space
                        self.mips.value_namespace_prefix = name_space_prefix
                    if(value_path == "offloaded"):
                        self.offloaded = value
                        self.offloaded.value_namespace = name_space
                        self.offloaded.value_namespace_prefix = name_space_prefix
                    if(value_path == "offloaded-at10ms"):
                        self.offloaded_at10ms = value
                        self.offloaded_at10ms.value_namespace = name_space
                        self.offloaded_at10ms.value_namespace_prefix = name_space_prefix
                    if(value_path == "offloaded-at3-3ms"):
                        self.offloaded_at3_3ms = value
                        self.offloaded_at3_3ms.value_namespace = name_space
                        self.offloaded_at3_3ms.value_namespace_prefix = name_space_prefix
                    if(value_path == "operational-local-meps"):
                        self.operational_local_meps = value
                        self.operational_local_meps.value_namespace = name_space
                        self.operational_local_meps.value_namespace_prefix = name_space_prefix
                    if(value_path == "operational-peer-meps"):
                        self.operational_peer_meps = value
                        self.operational_peer_meps.value_namespace = name_space
                        self.operational_peer_meps.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-meps"):
                        self.peer_meps = value
                        self.peer_meps.value_namespace = name_space
                        self.peer_meps.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-meps-timed-out"):
                        self.peer_meps_timed_out = value
                        self.peer_meps_timed_out.value_namespace = name_space
                        self.peer_meps_timed_out.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-meps-with-defects"):
                        self.peer_meps_with_defects = value
                        self.peer_meps_with_defects.value_namespace = name_space
                        self.peer_meps_with_defects.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-meps-without-defects"):
                        self.peer_meps_without_defects = value
                        self.peer_meps_without_defects.value_namespace = name_space
                        self.peer_meps_without_defects.value_namespace_prefix = name_space_prefix
                    if(value_path == "services"):
                        self.services = value
                        self.services.value_namespace = name_space
                        self.services.value_namespace_prefix = name_space_prefix
                    if(value_path == "traceroute-cache-entries"):
                        self.traceroute_cache_entries = value
                        self.traceroute_cache_entries.value_namespace = name_space
                        self.traceroute_cache_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "traceroute-cache-replies"):
                        self.traceroute_cache_replies = value
                        self.traceroute_cache_replies.value_namespace = name_space
                        self.traceroute_cache_replies.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-meps"):
                        self.up_meps = value
                        self.up_meps.value_namespace = name_space
                        self.up_meps.value_namespace_prefix = name_space_prefix


            class CcmLearningDatabases(Entity):
                """
                CCMLearningDatabase table
                
                .. attribute:: ccm_learning_database
                
                	CCM Learning Database entry
                	**type**\: list of    :py:class:`CcmLearningDatabase <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Nodes.Node.CcmLearningDatabases.CcmLearningDatabase>`
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Nodes.Node.CcmLearningDatabases, self).__init__()

                    self.yang_name = "ccm-learning-databases"
                    self.yang_parent_name = "node"

                    self.ccm_learning_database = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Nodes.Node.CcmLearningDatabases, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Nodes.Node.CcmLearningDatabases, self).__setattr__(name, value)


                class CcmLearningDatabase(Entity):
                    """
                    CCM Learning Database entry
                    
                    .. attribute:: domain  <key>
                    
                    	Maintenance Domain
                    	**type**\:  str
                    
                    	**length:** 1..79
                    
                    .. attribute:: service  <key>
                    
                    	Service (Maintenance Association)
                    	**type**\:  str
                    
                    	**length:** 1..79
                    
                    .. attribute:: mac_address  <key>
                    
                    	MAC Address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: domain_xr
                    
                    	Maintenance domain name
                    	**type**\:  str
                    
                    .. attribute:: ingress_interface
                    
                    	The XID of the ingress interface for the CCM
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ingress_interface_string
                    
                    	String representation of the Bridge Domain or Cross\-Connect associated with the ingress XID
                    	**type**\:  str
                    
                    .. attribute:: level
                    
                    	Maintenance level
                    	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                    
                    .. attribute:: service_xr
                    
                    	Maintenance association name
                    	**type**\:  str
                    
                    .. attribute:: source_mac_address
                    
                    	Source MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: stale
                    
                    	The XID is stale and may have been reused for a different interface
                    	**type**\:  bool
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Nodes.Node.CcmLearningDatabases.CcmLearningDatabase, self).__init__()

                        self.yang_name = "ccm-learning-database"
                        self.yang_parent_name = "ccm-learning-databases"

                        self.domain = YLeaf(YType.str, "domain")

                        self.service = YLeaf(YType.str, "service")

                        self.mac_address = YLeaf(YType.str, "mac-address")

                        self.domain_xr = YLeaf(YType.str, "domain-xr")

                        self.ingress_interface = YLeaf(YType.uint32, "ingress-interface")

                        self.ingress_interface_string = YLeaf(YType.str, "ingress-interface-string")

                        self.level = YLeaf(YType.enumeration, "level")

                        self.service_xr = YLeaf(YType.str, "service-xr")

                        self.source_mac_address = YLeaf(YType.str, "source-mac-address")

                        self.stale = YLeaf(YType.boolean, "stale")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("domain",
                                        "service",
                                        "mac_address",
                                        "domain_xr",
                                        "ingress_interface",
                                        "ingress_interface_string",
                                        "level",
                                        "service_xr",
                                        "source_mac_address",
                                        "stale") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Nodes.Node.CcmLearningDatabases.CcmLearningDatabase, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Nodes.Node.CcmLearningDatabases.CcmLearningDatabase, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.domain.is_set or
                            self.service.is_set or
                            self.mac_address.is_set or
                            self.domain_xr.is_set or
                            self.ingress_interface.is_set or
                            self.ingress_interface_string.is_set or
                            self.level.is_set or
                            self.service_xr.is_set or
                            self.source_mac_address.is_set or
                            self.stale.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.domain.yfilter != YFilter.not_set or
                            self.service.yfilter != YFilter.not_set or
                            self.mac_address.yfilter != YFilter.not_set or
                            self.domain_xr.yfilter != YFilter.not_set or
                            self.ingress_interface.yfilter != YFilter.not_set or
                            self.ingress_interface_string.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.service_xr.yfilter != YFilter.not_set or
                            self.source_mac_address.yfilter != YFilter.not_set or
                            self.stale.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ccm-learning-database" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + "[mac-address='" + self.mac_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain.get_name_leafdata())
                        if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service.get_name_leafdata())
                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mac_address.get_name_leafdata())
                        if (self.domain_xr.is_set or self.domain_xr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_xr.get_name_leafdata())
                        if (self.ingress_interface.is_set or self.ingress_interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ingress_interface.get_name_leafdata())
                        if (self.ingress_interface_string.is_set or self.ingress_interface_string.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ingress_interface_string.get_name_leafdata())
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.service_xr.is_set or self.service_xr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service_xr.get_name_leafdata())
                        if (self.source_mac_address.is_set or self.source_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_mac_address.get_name_leafdata())
                        if (self.stale.is_set or self.stale.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.stale.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "domain" or name == "service" or name == "mac-address" or name == "domain-xr" or name == "ingress-interface" or name == "ingress-interface-string" or name == "level" or name == "service-xr" or name == "source-mac-address" or name == "stale"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "domain"):
                            self.domain = value
                            self.domain.value_namespace = name_space
                            self.domain.value_namespace_prefix = name_space_prefix
                        if(value_path == "service"):
                            self.service = value
                            self.service.value_namespace = name_space
                            self.service.value_namespace_prefix = name_space_prefix
                        if(value_path == "mac-address"):
                            self.mac_address = value
                            self.mac_address.value_namespace = name_space
                            self.mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain-xr"):
                            self.domain_xr = value
                            self.domain_xr.value_namespace = name_space
                            self.domain_xr.value_namespace_prefix = name_space_prefix
                        if(value_path == "ingress-interface"):
                            self.ingress_interface = value
                            self.ingress_interface.value_namespace = name_space
                            self.ingress_interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "ingress-interface-string"):
                            self.ingress_interface_string = value
                            self.ingress_interface_string.value_namespace = name_space
                            self.ingress_interface_string.value_namespace_prefix = name_space_prefix
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "service-xr"):
                            self.service_xr = value
                            self.service_xr.value_namespace = name_space
                            self.service_xr.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-mac-address"):
                            self.source_mac_address = value
                            self.source_mac_address.value_namespace = name_space
                            self.source_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "stale"):
                            self.stale = value
                            self.stale.value_namespace = name_space
                            self.stale.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.ccm_learning_database:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.ccm_learning_database:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ccm-learning-databases" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ccm-learning-database"):
                        for c in self.ccm_learning_database:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Cfm.Nodes.Node.CcmLearningDatabases.CcmLearningDatabase()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.ccm_learning_database.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ccm-learning-database"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.node.is_set or
                    (self.ccm_learning_databases is not None and self.ccm_learning_databases.has_data()) or
                    (self.interface_aises is not None and self.interface_aises.has_data()) or
                    (self.interface_statistics is not None and self.interface_statistics.has_data()) or
                    (self.summary is not None and self.summary.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.node.yfilter != YFilter.not_set or
                    (self.ccm_learning_databases is not None and self.ccm_learning_databases.has_operation()) or
                    (self.interface_aises is not None and self.interface_aises.has_operation()) or
                    (self.interface_statistics is not None and self.interface_statistics.has_operation()) or
                    (self.summary is not None and self.summary.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[node='" + self.node.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node.is_set or self.node.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ccm-learning-databases"):
                    if (self.ccm_learning_databases is None):
                        self.ccm_learning_databases = Cfm.Nodes.Node.CcmLearningDatabases()
                        self.ccm_learning_databases.parent = self
                        self._children_name_map["ccm_learning_databases"] = "ccm-learning-databases"
                    return self.ccm_learning_databases

                if (child_yang_name == "interface-aises"):
                    if (self.interface_aises is None):
                        self.interface_aises = Cfm.Nodes.Node.InterfaceAises()
                        self.interface_aises.parent = self
                        self._children_name_map["interface_aises"] = "interface-aises"
                    return self.interface_aises

                if (child_yang_name == "interface-statistics"):
                    if (self.interface_statistics is None):
                        self.interface_statistics = Cfm.Nodes.Node.InterfaceStatistics()
                        self.interface_statistics.parent = self
                        self._children_name_map["interface_statistics"] = "interface-statistics"
                    return self.interface_statistics

                if (child_yang_name == "summary"):
                    if (self.summary is None):
                        self.summary = Cfm.Nodes.Node.Summary()
                        self.summary.parent = self
                        self._children_name_map["summary"] = "summary"
                    return self.summary

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ccm-learning-databases" or name == "interface-aises" or name == "interface-statistics" or name == "summary" or name == "node"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node"):
                    self.node = value
                    self.node.value_namespace = name_space
                    self.node.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Cfm.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Global_(Entity):
        """
        Global operational data
        
        .. attribute:: global_configuration_errors
        
        	Global configuration errors table
        	**type**\:   :py:class:`GlobalConfigurationErrors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.GlobalConfigurationErrors>`
        
        .. attribute:: incomplete_traceroutes
        
        	Incomplete Traceroute table
        	**type**\:   :py:class:`IncompleteTraceroutes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.IncompleteTraceroutes>`
        
        .. attribute:: local_meps
        
        	Local MEPs table
        	**type**\:   :py:class:`LocalMeps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps>`
        
        .. attribute:: maintenance_points
        
        	Maintenance Points table
        	**type**\:   :py:class:`MaintenancePoints <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MaintenancePoints>`
        
        .. attribute:: mep_configuration_errors
        
        	MEP configuration errors table
        	**type**\:   :py:class:`MepConfigurationErrors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors>`
        
        .. attribute:: peer_me_pv2s
        
        	Peer MEPs table Version 2
        	**type**\:   :py:class:`PeerMePv2S <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S>`
        
        .. attribute:: traceroute_caches
        
        	Traceroute Cache table
        	**type**\:   :py:class:`TracerouteCaches <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches>`
        
        

        """

        _prefix = 'ethernet-cfm-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Cfm.Global_, self).__init__()

            self.yang_name = "global"
            self.yang_parent_name = "cfm"

            self.global_configuration_errors = Cfm.Global_.GlobalConfigurationErrors()
            self.global_configuration_errors.parent = self
            self._children_name_map["global_configuration_errors"] = "global-configuration-errors"
            self._children_yang_names.add("global-configuration-errors")

            self.incomplete_traceroutes = Cfm.Global_.IncompleteTraceroutes()
            self.incomplete_traceroutes.parent = self
            self._children_name_map["incomplete_traceroutes"] = "incomplete-traceroutes"
            self._children_yang_names.add("incomplete-traceroutes")

            self.local_meps = Cfm.Global_.LocalMeps()
            self.local_meps.parent = self
            self._children_name_map["local_meps"] = "local-meps"
            self._children_yang_names.add("local-meps")

            self.maintenance_points = Cfm.Global_.MaintenancePoints()
            self.maintenance_points.parent = self
            self._children_name_map["maintenance_points"] = "maintenance-points"
            self._children_yang_names.add("maintenance-points")

            self.mep_configuration_errors = Cfm.Global_.MepConfigurationErrors()
            self.mep_configuration_errors.parent = self
            self._children_name_map["mep_configuration_errors"] = "mep-configuration-errors"
            self._children_yang_names.add("mep-configuration-errors")

            self.peer_me_pv2s = Cfm.Global_.PeerMePv2S()
            self.peer_me_pv2s.parent = self
            self._children_name_map["peer_me_pv2s"] = "peer-me-pv2s"
            self._children_yang_names.add("peer-me-pv2s")

            self.traceroute_caches = Cfm.Global_.TracerouteCaches()
            self.traceroute_caches.parent = self
            self._children_name_map["traceroute_caches"] = "traceroute-caches"
            self._children_yang_names.add("traceroute-caches")


        class IncompleteTraceroutes(Entity):
            """
            Incomplete Traceroute table
            
            .. attribute:: incomplete_traceroute
            
            	Information about a traceroute operation that has not yet timed out
            	**type**\: list of    :py:class:`IncompleteTraceroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Global_.IncompleteTraceroutes, self).__init__()

                self.yang_name = "incomplete-traceroutes"
                self.yang_parent_name = "global"

                self.incomplete_traceroute = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Global_.IncompleteTraceroutes, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Global_.IncompleteTraceroutes, self).__setattr__(name, value)


            class IncompleteTraceroute(Entity):
                """
                Information about a traceroute operation that
                has not yet timed out
                
                .. attribute:: domain  <key>
                
                	Maintenance Domain
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: service  <key>
                
                	Service (Maintenance Association)
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: mep_id  <key>
                
                	MEP ID
                	**type**\:  int
                
                	**range:** 1..8191
                
                .. attribute:: interface  <key>
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: transaction_id  <key>
                
                	Transaction ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: time_left
                
                	Time (in seconds) before the traceroute completes
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                	**units**\: second
                
                .. attribute:: traceroute_information
                
                	Information about the traceroute operation
                	**type**\:   :py:class:`TracerouteInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation>`
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute, self).__init__()

                    self.yang_name = "incomplete-traceroute"
                    self.yang_parent_name = "incomplete-traceroutes"

                    self.domain = YLeaf(YType.str, "domain")

                    self.service = YLeaf(YType.str, "service")

                    self.mep_id = YLeaf(YType.uint32, "mep-id")

                    self.interface = YLeaf(YType.str, "interface")

                    self.transaction_id = YLeaf(YType.int32, "transaction-id")

                    self.time_left = YLeaf(YType.uint64, "time-left")

                    self.traceroute_information = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation()
                    self.traceroute_information.parent = self
                    self._children_name_map["traceroute_information"] = "traceroute-information"
                    self._children_yang_names.add("traceroute-information")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain",
                                    "service",
                                    "mep_id",
                                    "interface",
                                    "transaction_id",
                                    "time_left") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute, self).__setattr__(name, value)


                class TracerouteInformation(Entity):
                    """
                    Information about the traceroute operation
                    
                    .. attribute:: directed_mac_address
                    
                    	Directed MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: domain
                    
                    	Maintenance domain name
                    	**type**\:  str
                    
                    .. attribute:: level
                    
                    	Maintenance level
                    	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                    
                    .. attribute:: options
                    
                    	Options affecting traceroute behavior
                    	**type**\:   :py:class:`Options <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options>`
                    
                    .. attribute:: service
                    
                    	Service name
                    	**type**\:  str
                    
                    .. attribute:: source_interface
                    
                    	Source interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: source_mac_address
                    
                    	Source MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: source_mep_id
                    
                    	Source MEP ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: target_mac_address
                    
                    	Target MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: target_mep_id
                    
                    	Target MEP ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: timestamp
                    
                    	Timestamp of initiation time (seconds)
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    .. attribute:: transaction_id
                    
                    	Transaction ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ttl
                    
                    	Time to live
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation, self).__init__()

                        self.yang_name = "traceroute-information"
                        self.yang_parent_name = "incomplete-traceroute"

                        self.directed_mac_address = YLeaf(YType.str, "directed-mac-address")

                        self.domain = YLeaf(YType.str, "domain")

                        self.level = YLeaf(YType.enumeration, "level")

                        self.service = YLeaf(YType.str, "service")

                        self.source_interface = YLeaf(YType.str, "source-interface")

                        self.source_mac_address = YLeaf(YType.str, "source-mac-address")

                        self.source_mep_id = YLeaf(YType.uint16, "source-mep-id")

                        self.target_mac_address = YLeaf(YType.str, "target-mac-address")

                        self.target_mep_id = YLeaf(YType.uint16, "target-mep-id")

                        self.timestamp = YLeaf(YType.uint64, "timestamp")

                        self.transaction_id = YLeaf(YType.uint32, "transaction-id")

                        self.ttl = YLeaf(YType.uint8, "ttl")

                        self.options = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options()
                        self.options.parent = self
                        self._children_name_map["options"] = "options"
                        self._children_yang_names.add("options")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("directed_mac_address",
                                        "domain",
                                        "level",
                                        "service",
                                        "source_interface",
                                        "source_mac_address",
                                        "source_mep_id",
                                        "target_mac_address",
                                        "target_mep_id",
                                        "timestamp",
                                        "transaction_id",
                                        "ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation, self).__setattr__(name, value)


                    class Options(Entity):
                        """
                        Options affecting traceroute behavior
                        
                        .. attribute:: basic_options
                        
                        	Options for a basic IEEE 802.1ag Linktrace
                        	**type**\:   :py:class:`BasicOptions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.BasicOptions>`
                        
                        .. attribute:: exploratory_options
                        
                        	Options for an Exploratory Linktrace
                        	**type**\:   :py:class:`ExploratoryOptions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.ExploratoryOptions>`
                        
                        .. attribute:: mode
                        
                        	Mode
                        	**type**\:   :py:class:`CfmPmLtMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmLtMode>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options, self).__init__()

                            self.yang_name = "options"
                            self.yang_parent_name = "traceroute-information"

                            self.mode = YLeaf(YType.enumeration, "mode")

                            self.basic_options = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.BasicOptions()
                            self.basic_options.parent = self
                            self._children_name_map["basic_options"] = "basic-options"
                            self._children_yang_names.add("basic-options")

                            self.exploratory_options = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.ExploratoryOptions()
                            self.exploratory_options.parent = self
                            self._children_name_map["exploratory_options"] = "exploratory-options"
                            self._children_yang_names.add("exploratory-options")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("mode") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options, self).__setattr__(name, value)


                        class BasicOptions(Entity):
                            """
                            Options for a basic IEEE 802.1ag Linktrace
                            
                            .. attribute:: fdb_only
                            
                            	Only use the Filtering Database for forwarding lookups
                            	**type**\:  bool
                            
                            .. attribute:: is_auto
                            
                            	Traceroute was initiated automatically
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.BasicOptions, self).__init__()

                                self.yang_name = "basic-options"
                                self.yang_parent_name = "options"

                                self.fdb_only = YLeaf(YType.boolean, "fdb-only")

                                self.is_auto = YLeaf(YType.boolean, "is-auto")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fdb_only",
                                                "is_auto") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.BasicOptions, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.BasicOptions, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fdb_only.is_set or
                                    self.is_auto.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fdb_only.yfilter != YFilter.not_set or
                                    self.is_auto.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "basic-options" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fdb_only.is_set or self.fdb_only.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fdb_only.get_name_leafdata())
                                if (self.is_auto.is_set or self.is_auto.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_auto.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fdb-only" or name == "is-auto"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fdb-only"):
                                    self.fdb_only = value
                                    self.fdb_only.value_namespace = name_space
                                    self.fdb_only.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-auto"):
                                    self.is_auto = value
                                    self.is_auto.value_namespace = name_space
                                    self.is_auto.value_namespace_prefix = name_space_prefix


                        class ExploratoryOptions(Entity):
                            """
                            Options for an Exploratory Linktrace
                            
                            .. attribute:: delay_constant_factor
                            
                            	Constant Factor for delay calculations
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: delay_model
                            
                            	Delay model for delay calculations
                            	**type**\:   :py:class:`CfmPmEltDelayModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmEltDelayModel>`
                            
                            .. attribute:: reply_filter
                            
                            	Reply Filtering mode used by responders
                            	**type**\:   :py:class:`CfmPmElmReplyFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmElmReplyFilter>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.ExploratoryOptions, self).__init__()

                                self.yang_name = "exploratory-options"
                                self.yang_parent_name = "options"

                                self.delay_constant_factor = YLeaf(YType.uint32, "delay-constant-factor")

                                self.delay_model = YLeaf(YType.enumeration, "delay-model")

                                self.reply_filter = YLeaf(YType.enumeration, "reply-filter")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("delay_constant_factor",
                                                "delay_model",
                                                "reply_filter") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.ExploratoryOptions, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.ExploratoryOptions, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.delay_constant_factor.is_set or
                                    self.delay_model.is_set or
                                    self.reply_filter.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.delay_constant_factor.yfilter != YFilter.not_set or
                                    self.delay_model.yfilter != YFilter.not_set or
                                    self.reply_filter.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "exploratory-options" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.delay_constant_factor.is_set or self.delay_constant_factor.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay_constant_factor.get_name_leafdata())
                                if (self.delay_model.is_set or self.delay_model.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay_model.get_name_leafdata())
                                if (self.reply_filter.is_set or self.reply_filter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reply_filter.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "delay-constant-factor" or name == "delay-model" or name == "reply-filter"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "delay-constant-factor"):
                                    self.delay_constant_factor = value
                                    self.delay_constant_factor.value_namespace = name_space
                                    self.delay_constant_factor.value_namespace_prefix = name_space_prefix
                                if(value_path == "delay-model"):
                                    self.delay_model = value
                                    self.delay_model.value_namespace = name_space
                                    self.delay_model.value_namespace_prefix = name_space_prefix
                                if(value_path == "reply-filter"):
                                    self.reply_filter = value
                                    self.reply_filter.value_namespace = name_space
                                    self.reply_filter.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.mode.is_set or
                                (self.basic_options is not None and self.basic_options.has_data()) or
                                (self.exploratory_options is not None and self.exploratory_options.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.mode.yfilter != YFilter.not_set or
                                (self.basic_options is not None and self.basic_options.has_operation()) or
                                (self.exploratory_options is not None and self.exploratory_options.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "options" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mode.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "basic-options"):
                                if (self.basic_options is None):
                                    self.basic_options = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.BasicOptions()
                                    self.basic_options.parent = self
                                    self._children_name_map["basic_options"] = "basic-options"
                                return self.basic_options

                            if (child_yang_name == "exploratory-options"):
                                if (self.exploratory_options is None):
                                    self.exploratory_options = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options.ExploratoryOptions()
                                    self.exploratory_options.parent = self
                                    self._children_name_map["exploratory_options"] = "exploratory-options"
                                return self.exploratory_options

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "basic-options" or name == "exploratory-options" or name == "mode"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "mode"):
                                self.mode = value
                                self.mode.value_namespace = name_space
                                self.mode.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.directed_mac_address.is_set or
                            self.domain.is_set or
                            self.level.is_set or
                            self.service.is_set or
                            self.source_interface.is_set or
                            self.source_mac_address.is_set or
                            self.source_mep_id.is_set or
                            self.target_mac_address.is_set or
                            self.target_mep_id.is_set or
                            self.timestamp.is_set or
                            self.transaction_id.is_set or
                            self.ttl.is_set or
                            (self.options is not None and self.options.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.directed_mac_address.yfilter != YFilter.not_set or
                            self.domain.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.service.yfilter != YFilter.not_set or
                            self.source_interface.yfilter != YFilter.not_set or
                            self.source_mac_address.yfilter != YFilter.not_set or
                            self.source_mep_id.yfilter != YFilter.not_set or
                            self.target_mac_address.yfilter != YFilter.not_set or
                            self.target_mep_id.yfilter != YFilter.not_set or
                            self.timestamp.yfilter != YFilter.not_set or
                            self.transaction_id.yfilter != YFilter.not_set or
                            self.ttl.yfilter != YFilter.not_set or
                            (self.options is not None and self.options.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "traceroute-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.directed_mac_address.is_set or self.directed_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.directed_mac_address.get_name_leafdata())
                        if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain.get_name_leafdata())
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service.get_name_leafdata())
                        if (self.source_interface.is_set or self.source_interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_interface.get_name_leafdata())
                        if (self.source_mac_address.is_set or self.source_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_mac_address.get_name_leafdata())
                        if (self.source_mep_id.is_set or self.source_mep_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_mep_id.get_name_leafdata())
                        if (self.target_mac_address.is_set or self.target_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.target_mac_address.get_name_leafdata())
                        if (self.target_mep_id.is_set or self.target_mep_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.target_mep_id.get_name_leafdata())
                        if (self.timestamp.is_set or self.timestamp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.timestamp.get_name_leafdata())
                        if (self.transaction_id.is_set or self.transaction_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.transaction_id.get_name_leafdata())
                        if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "options"):
                            if (self.options is None):
                                self.options = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation.Options()
                                self.options.parent = self
                                self._children_name_map["options"] = "options"
                            return self.options

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "options" or name == "directed-mac-address" or name == "domain" or name == "level" or name == "service" or name == "source-interface" or name == "source-mac-address" or name == "source-mep-id" or name == "target-mac-address" or name == "target-mep-id" or name == "timestamp" or name == "transaction-id" or name == "ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "directed-mac-address"):
                            self.directed_mac_address = value
                            self.directed_mac_address.value_namespace = name_space
                            self.directed_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain"):
                            self.domain = value
                            self.domain.value_namespace = name_space
                            self.domain.value_namespace_prefix = name_space_prefix
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "service"):
                            self.service = value
                            self.service.value_namespace = name_space
                            self.service.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-interface"):
                            self.source_interface = value
                            self.source_interface.value_namespace = name_space
                            self.source_interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-mac-address"):
                            self.source_mac_address = value
                            self.source_mac_address.value_namespace = name_space
                            self.source_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-mep-id"):
                            self.source_mep_id = value
                            self.source_mep_id.value_namespace = name_space
                            self.source_mep_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "target-mac-address"):
                            self.target_mac_address = value
                            self.target_mac_address.value_namespace = name_space
                            self.target_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "target-mep-id"):
                            self.target_mep_id = value
                            self.target_mep_id.value_namespace = name_space
                            self.target_mep_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "timestamp"):
                            self.timestamp = value
                            self.timestamp.value_namespace = name_space
                            self.timestamp.value_namespace_prefix = name_space_prefix
                        if(value_path == "transaction-id"):
                            self.transaction_id = value
                            self.transaction_id.value_namespace = name_space
                            self.transaction_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ttl"):
                            self.ttl = value
                            self.ttl.value_namespace = name_space
                            self.ttl.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.domain.is_set or
                        self.service.is_set or
                        self.mep_id.is_set or
                        self.interface.is_set or
                        self.transaction_id.is_set or
                        self.time_left.is_set or
                        (self.traceroute_information is not None and self.traceroute_information.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain.yfilter != YFilter.not_set or
                        self.service.yfilter != YFilter.not_set or
                        self.mep_id.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.transaction_id.yfilter != YFilter.not_set or
                        self.time_left.yfilter != YFilter.not_set or
                        (self.traceroute_information is not None and self.traceroute_information.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "incomplete-traceroute" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + "[mep-id='" + self.mep_id.get() + "']" + "[interface='" + self.interface.get() + "']" + "[transaction-id='" + self.transaction_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/incomplete-traceroutes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain.get_name_leafdata())
                    if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service.get_name_leafdata())
                    if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_id.get_name_leafdata())
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.transaction_id.is_set or self.transaction_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.transaction_id.get_name_leafdata())
                    if (self.time_left.is_set or self.time_left.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.time_left.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "traceroute-information"):
                        if (self.traceroute_information is None):
                            self.traceroute_information = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute.TracerouteInformation()
                            self.traceroute_information.parent = self
                            self._children_name_map["traceroute_information"] = "traceroute-information"
                        return self.traceroute_information

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "traceroute-information" or name == "domain" or name == "service" or name == "mep-id" or name == "interface" or name == "transaction-id" or name == "time-left"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain"):
                        self.domain = value
                        self.domain.value_namespace = name_space
                        self.domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "service"):
                        self.service = value
                        self.service.value_namespace = name_space
                        self.service.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-id"):
                        self.mep_id = value
                        self.mep_id.value_namespace = name_space
                        self.mep_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "transaction-id"):
                        self.transaction_id = value
                        self.transaction_id.value_namespace = name_space
                        self.transaction_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "time-left"):
                        self.time_left = value
                        self.time_left.value_namespace = name_space
                        self.time_left.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.incomplete_traceroute:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.incomplete_traceroute:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "incomplete-traceroutes" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "incomplete-traceroute"):
                    for c in self.incomplete_traceroute:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Cfm.Global_.IncompleteTraceroutes.IncompleteTraceroute()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.incomplete_traceroute.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "incomplete-traceroute"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class MaintenancePoints(Entity):
            """
            Maintenance Points table
            
            .. attribute:: maintenance_point
            
            	Information about a particular Maintenance Point
            	**type**\: list of    :py:class:`MaintenancePoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MaintenancePoints.MaintenancePoint>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Global_.MaintenancePoints, self).__init__()

                self.yang_name = "maintenance-points"
                self.yang_parent_name = "global"

                self.maintenance_point = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Global_.MaintenancePoints, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Global_.MaintenancePoints, self).__setattr__(name, value)


            class MaintenancePoint(Entity):
                """
                Information about a particular Maintenance
                Point
                
                .. attribute:: domain  <key>
                
                	Maintenance Domain
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: service  <key>
                
                	Service (Maintenance Association)
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: interface  <key>
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: mac_address
                
                	MAC Address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: maintenance_point
                
                	Maintenance Point
                	**type**\:   :py:class:`MaintenancePoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MaintenancePoints.MaintenancePoint.MaintenancePoint>`
                
                .. attribute:: mep_has_error
                
                	MEP error flag
                	**type**\:  bool
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Global_.MaintenancePoints.MaintenancePoint, self).__init__()

                    self.yang_name = "maintenance-point"
                    self.yang_parent_name = "maintenance-points"

                    self.domain = YLeaf(YType.str, "domain")

                    self.service = YLeaf(YType.str, "service")

                    self.interface = YLeaf(YType.str, "interface")

                    self.mac_address = YLeaf(YType.str, "mac-address")

                    self.mep_has_error = YLeaf(YType.boolean, "mep-has-error")

                    self.maintenance_point = Cfm.Global_.MaintenancePoints.MaintenancePoint.MaintenancePoint()
                    self.maintenance_point.parent = self
                    self._children_name_map["maintenance_point"] = "maintenance-point"
                    self._children_yang_names.add("maintenance-point")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain",
                                    "service",
                                    "interface",
                                    "mac_address",
                                    "mep_has_error") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Global_.MaintenancePoints.MaintenancePoint, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Global_.MaintenancePoints.MaintenancePoint, self).__setattr__(name, value)


                class MaintenancePoint(Entity):
                    """
                    Maintenance Point
                    
                    .. attribute:: domain_name
                    
                    	Domain name
                    	**type**\:  str
                    
                    .. attribute:: interface
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: level
                    
                    	Domain level
                    	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                    
                    .. attribute:: maintenance_point_type
                    
                    	Type of Maintenance Point
                    	**type**\:   :py:class:`CfmMaMpVariety <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmMaMpVariety>`
                    
                    .. attribute:: mep_id
                    
                    	MEP ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: service_name
                    
                    	Service name
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.MaintenancePoints.MaintenancePoint.MaintenancePoint, self).__init__()

                        self.yang_name = "maintenance-point"
                        self.yang_parent_name = "maintenance-point"

                        self.domain_name = YLeaf(YType.str, "domain-name")

                        self.interface = YLeaf(YType.str, "interface")

                        self.level = YLeaf(YType.enumeration, "level")

                        self.maintenance_point_type = YLeaf(YType.enumeration, "maintenance-point-type")

                        self.mep_id = YLeaf(YType.uint16, "mep-id")

                        self.service_name = YLeaf(YType.str, "service-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("domain_name",
                                        "interface",
                                        "level",
                                        "maintenance_point_type",
                                        "mep_id",
                                        "service_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.MaintenancePoints.MaintenancePoint.MaintenancePoint, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.MaintenancePoints.MaintenancePoint.MaintenancePoint, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.domain_name.is_set or
                            self.interface.is_set or
                            self.level.is_set or
                            self.maintenance_point_type.is_set or
                            self.mep_id.is_set or
                            self.service_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.domain_name.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.maintenance_point_type.yfilter != YFilter.not_set or
                            self.mep_id.yfilter != YFilter.not_set or
                            self.service_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "maintenance-point" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.domain_name.is_set or self.domain_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_name.get_name_leafdata())
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.maintenance_point_type.is_set or self.maintenance_point_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maintenance_point_type.get_name_leafdata())
                        if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mep_id.get_name_leafdata())
                        if (self.service_name.is_set or self.service_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "domain-name" or name == "interface" or name == "level" or name == "maintenance-point-type" or name == "mep-id" or name == "service-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "domain-name"):
                            self.domain_name = value
                            self.domain_name.value_namespace = name_space
                            self.domain_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "maintenance-point-type"):
                            self.maintenance_point_type = value
                            self.maintenance_point_type.value_namespace = name_space
                            self.maintenance_point_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "mep-id"):
                            self.mep_id = value
                            self.mep_id.value_namespace = name_space
                            self.mep_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "service-name"):
                            self.service_name = value
                            self.service_name.value_namespace = name_space
                            self.service_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.domain.is_set or
                        self.service.is_set or
                        self.interface.is_set or
                        self.mac_address.is_set or
                        self.mep_has_error.is_set or
                        (self.maintenance_point is not None and self.maintenance_point.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain.yfilter != YFilter.not_set or
                        self.service.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.mac_address.yfilter != YFilter.not_set or
                        self.mep_has_error.yfilter != YFilter.not_set or
                        (self.maintenance_point is not None and self.maintenance_point.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "maintenance-point" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + "[interface='" + self.interface.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/maintenance-points/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain.get_name_leafdata())
                    if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service.get_name_leafdata())
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_address.get_name_leafdata())
                    if (self.mep_has_error.is_set or self.mep_has_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_has_error.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "maintenance-point"):
                        if (self.maintenance_point is None):
                            self.maintenance_point = Cfm.Global_.MaintenancePoints.MaintenancePoint.MaintenancePoint()
                            self.maintenance_point.parent = self
                            self._children_name_map["maintenance_point"] = "maintenance-point"
                        return self.maintenance_point

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "maintenance-point" or name == "domain" or name == "service" or name == "interface" or name == "mac-address" or name == "mep-has-error"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain"):
                        self.domain = value
                        self.domain.value_namespace = name_space
                        self.domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "service"):
                        self.service = value
                        self.service.value_namespace = name_space
                        self.service.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-address"):
                        self.mac_address = value
                        self.mac_address.value_namespace = name_space
                        self.mac_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-has-error"):
                        self.mep_has_error = value
                        self.mep_has_error.value_namespace = name_space
                        self.mep_has_error.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.maintenance_point:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.maintenance_point:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "maintenance-points" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "maintenance-point"):
                    for c in self.maintenance_point:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Cfm.Global_.MaintenancePoints.MaintenancePoint()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.maintenance_point.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "maintenance-point"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class GlobalConfigurationErrors(Entity):
            """
            Global configuration errors table
            
            .. attribute:: global_configuration_error
            
            	Information about a particular configuration error
            	**type**\: list of    :py:class:`GlobalConfigurationError <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Global_.GlobalConfigurationErrors, self).__init__()

                self.yang_name = "global-configuration-errors"
                self.yang_parent_name = "global"

                self.global_configuration_error = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Global_.GlobalConfigurationErrors, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Global_.GlobalConfigurationErrors, self).__setattr__(name, value)


            class GlobalConfigurationError(Entity):
                """
                Information about a particular configuration
                error
                
                .. attribute:: domain  <key>
                
                	Maintenance Domain
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: service  <key>
                
                	Service (Maintenance Association)
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: bridge_domain_id
                
                	BD/XC ID, or Service name if the Service is 'down\-only'
                	**type**\:   :py:class:`BridgeDomainId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError.BridgeDomainId>`
                
                .. attribute:: bridge_domain_is_configured
                
                	The BD/XC is configured globally
                	**type**\:  bool
                
                .. attribute:: domain_name
                
                	Domain name
                	**type**\:  str
                
                .. attribute:: l2_fib_download_error
                
                	The BD/XC could not be downloaded to L2FIB
                	**type**\:  bool
                
                .. attribute:: level
                
                	Level
                	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                
                .. attribute:: service_name
                
                	Service name
                	**type**\:  str
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError, self).__init__()

                    self.yang_name = "global-configuration-error"
                    self.yang_parent_name = "global-configuration-errors"

                    self.domain = YLeaf(YType.str, "domain")

                    self.service = YLeaf(YType.str, "service")

                    self.bridge_domain_is_configured = YLeaf(YType.boolean, "bridge-domain-is-configured")

                    self.domain_name = YLeaf(YType.str, "domain-name")

                    self.l2_fib_download_error = YLeaf(YType.boolean, "l2-fib-download-error")

                    self.level = YLeaf(YType.enumeration, "level")

                    self.service_name = YLeaf(YType.str, "service-name")

                    self.bridge_domain_id = Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError.BridgeDomainId()
                    self.bridge_domain_id.parent = self
                    self._children_name_map["bridge_domain_id"] = "bridge-domain-id"
                    self._children_yang_names.add("bridge-domain-id")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain",
                                    "service",
                                    "bridge_domain_is_configured",
                                    "domain_name",
                                    "l2_fib_download_error",
                                    "level",
                                    "service_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError, self).__setattr__(name, value)


                class BridgeDomainId(Entity):
                    """
                    BD/XC ID, or Service name if the Service is
                    'down\-only'
                    
                    .. attribute:: bridge_domain_id_format
                    
                    	Bridge domain identifier format
                    	**type**\:   :py:class:`CfmBagBdidFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagBdidFmt>`
                    
                    .. attribute:: ce_id
                    
                    	Local Customer Edge Identifier (CE\-ID)
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: group
                    
                    	Name of the Bridge/XConnect Group
                    	**type**\:  str
                    
                    .. attribute:: name
                    
                    	Name of the Bridge Domain/XConnect
                    	**type**\:  str
                    
                    .. attribute:: remote_ce_id
                    
                    	Remote Customer Edge Identifier (CE\-ID)
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError.BridgeDomainId, self).__init__()

                        self.yang_name = "bridge-domain-id"
                        self.yang_parent_name = "global-configuration-error"

                        self.bridge_domain_id_format = YLeaf(YType.enumeration, "bridge-domain-id-format")

                        self.ce_id = YLeaf(YType.uint16, "ce-id")

                        self.group = YLeaf(YType.str, "group")

                        self.name = YLeaf(YType.str, "name")

                        self.remote_ce_id = YLeaf(YType.uint16, "remote-ce-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bridge_domain_id_format",
                                        "ce_id",
                                        "group",
                                        "name",
                                        "remote_ce_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError.BridgeDomainId, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError.BridgeDomainId, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bridge_domain_id_format.is_set or
                            self.ce_id.is_set or
                            self.group.is_set or
                            self.name.is_set or
                            self.remote_ce_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bridge_domain_id_format.yfilter != YFilter.not_set or
                            self.ce_id.yfilter != YFilter.not_set or
                            self.group.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.remote_ce_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bridge-domain-id" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bridge_domain_id_format.is_set or self.bridge_domain_id_format.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bridge_domain_id_format.get_name_leafdata())
                        if (self.ce_id.is_set or self.ce_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ce_id.get_name_leafdata())
                        if (self.group.is_set or self.group.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.group.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.remote_ce_id.is_set or self.remote_ce_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_ce_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bridge-domain-id-format" or name == "ce-id" or name == "group" or name == "name" or name == "remote-ce-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bridge-domain-id-format"):
                            self.bridge_domain_id_format = value
                            self.bridge_domain_id_format.value_namespace = name_space
                            self.bridge_domain_id_format.value_namespace_prefix = name_space_prefix
                        if(value_path == "ce-id"):
                            self.ce_id = value
                            self.ce_id.value_namespace = name_space
                            self.ce_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "group"):
                            self.group = value
                            self.group.value_namespace = name_space
                            self.group.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-ce-id"):
                            self.remote_ce_id = value
                            self.remote_ce_id.value_namespace = name_space
                            self.remote_ce_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.domain.is_set or
                        self.service.is_set or
                        self.bridge_domain_is_configured.is_set or
                        self.domain_name.is_set or
                        self.l2_fib_download_error.is_set or
                        self.level.is_set or
                        self.service_name.is_set or
                        (self.bridge_domain_id is not None and self.bridge_domain_id.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain.yfilter != YFilter.not_set or
                        self.service.yfilter != YFilter.not_set or
                        self.bridge_domain_is_configured.yfilter != YFilter.not_set or
                        self.domain_name.yfilter != YFilter.not_set or
                        self.l2_fib_download_error.yfilter != YFilter.not_set or
                        self.level.yfilter != YFilter.not_set or
                        self.service_name.yfilter != YFilter.not_set or
                        (self.bridge_domain_id is not None and self.bridge_domain_id.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "global-configuration-error" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/global-configuration-errors/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain.get_name_leafdata())
                    if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service.get_name_leafdata())
                    if (self.bridge_domain_is_configured.is_set or self.bridge_domain_is_configured.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bridge_domain_is_configured.get_name_leafdata())
                    if (self.domain_name.is_set or self.domain_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain_name.get_name_leafdata())
                    if (self.l2_fib_download_error.is_set or self.l2_fib_download_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.l2_fib_download_error.get_name_leafdata())
                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.level.get_name_leafdata())
                    if (self.service_name.is_set or self.service_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bridge-domain-id"):
                        if (self.bridge_domain_id is None):
                            self.bridge_domain_id = Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError.BridgeDomainId()
                            self.bridge_domain_id.parent = self
                            self._children_name_map["bridge_domain_id"] = "bridge-domain-id"
                        return self.bridge_domain_id

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bridge-domain-id" or name == "domain" or name == "service" or name == "bridge-domain-is-configured" or name == "domain-name" or name == "l2-fib-download-error" or name == "level" or name == "service-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain"):
                        self.domain = value
                        self.domain.value_namespace = name_space
                        self.domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "service"):
                        self.service = value
                        self.service.value_namespace = name_space
                        self.service.value_namespace_prefix = name_space_prefix
                    if(value_path == "bridge-domain-is-configured"):
                        self.bridge_domain_is_configured = value
                        self.bridge_domain_is_configured.value_namespace = name_space
                        self.bridge_domain_is_configured.value_namespace_prefix = name_space_prefix
                    if(value_path == "domain-name"):
                        self.domain_name = value
                        self.domain_name.value_namespace = name_space
                        self.domain_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "l2-fib-download-error"):
                        self.l2_fib_download_error = value
                        self.l2_fib_download_error.value_namespace = name_space
                        self.l2_fib_download_error.value_namespace_prefix = name_space_prefix
                    if(value_path == "level"):
                        self.level = value
                        self.level.value_namespace = name_space
                        self.level.value_namespace_prefix = name_space_prefix
                    if(value_path == "service-name"):
                        self.service_name = value
                        self.service_name.value_namespace = name_space
                        self.service_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.global_configuration_error:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.global_configuration_error:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "global-configuration-errors" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "global-configuration-error"):
                    for c in self.global_configuration_error:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Cfm.Global_.GlobalConfigurationErrors.GlobalConfigurationError()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.global_configuration_error.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "global-configuration-error"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class MepConfigurationErrors(Entity):
            """
            MEP configuration errors table
            
            .. attribute:: mep_configuration_error
            
            	Information about a particular configuration error
            	**type**\: list of    :py:class:`MepConfigurationError <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Global_.MepConfigurationErrors, self).__init__()

                self.yang_name = "mep-configuration-errors"
                self.yang_parent_name = "global"

                self.mep_configuration_error = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Global_.MepConfigurationErrors, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Global_.MepConfigurationErrors, self).__setattr__(name, value)


            class MepConfigurationError(Entity):
                """
                Information about a particular configuration
                error
                
                .. attribute:: domain  <key>
                
                	Maintenance Domain
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: service  <key>
                
                	Service (Maintenance Association)
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: interface  <key>
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: ais_configured
                
                	AIS is configured on the same interface as the down MEP
                	**type**\:  bool
                
                .. attribute:: bridge_domain_mismatch
                
                	The MEP's EFP is not in the Service's Bridge Domain
                	**type**\:  bool
                
                .. attribute:: bridge_domain_not_in_bd_infra
                
                	A BD/XC specified in the MEG config, but it does not exist globally
                	**type**\:  bool
                
                .. attribute:: bundle_level0
                
                	The MEP is configured in a domain at level 0, on a bundle interface or sub\-interface.  This is not supported
                	**type**\:  bool
                
                .. attribute:: ccm_interval
                
                	Interval between CCMs sent on this MEP
                	**type**\:   :py:class:`CfmBagCcmInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagCcmInterval>`
                
                .. attribute:: ccm_interval_not_supported
                
                	CCM Interval is less than minimum interval supported by hardware
                	**type**\:  bool
                
                .. attribute:: fatal_offload_error
                
                	The platform returned a fatal error when passed the offload session
                	**type**\:  bool
                
                .. attribute:: interface_bridge_domain
                
                	ID of the BD/XC that the MEP's EFP is in, if any
                	**type**\:   :py:class:`InterfaceBridgeDomain <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError.InterfaceBridgeDomain>`
                
                .. attribute:: level_conflict
                
                	Another MEP facing in the same direction is at the same Maintenance Level
                	**type**\:  bool
                
                .. attribute:: maid_format_not_supported
                
                	The configured MAID format is not supported for hardware offload
                	**type**\:  bool
                
                .. attribute:: mep
                
                	The MEP that has errors
                	**type**\:   :py:class:`Mep <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError.Mep>`
                
                .. attribute:: no_domain
                
                	The MEP's Domain is not configured
                	**type**\:  bool
                
                .. attribute:: no_interface_type
                
                	We haven't yet been able to look up the interface type to find whether the interface is a bundle
                	**type**\:  bool
                
                .. attribute:: no_mlacp
                
                	The EFP is a bundle and the mLACP mode is not yet known
                	**type**\:  bool
                
                .. attribute:: no_service
                
                	The MEP's Service is not configured
                	**type**\:  bool
                
                .. attribute:: no_valid_mac_address
                
                	The EFP doesn't have a valid MAC address yet. This will also get set if the MAC address we have is a multicast address
                	**type**\:  bool
                
                .. attribute:: not_in_im
                
                	The EFP has been deleted from IM
                	**type**\:  bool
                
                .. attribute:: offload_mep_direction_not_supported
                
                	The MEP direction does not support offload
                	**type**\:  bool
                
                .. attribute:: offload_multiple_local_mep
                
                	Multiple offloaded MEPs on the same interface are not supported
                	**type**\:  bool
                
                .. attribute:: offload_multiple_peer_meps
                
                	The MEP should be offloaded but multiple crosscheck MEPs have been configured, and this is not supported
                	**type**\:  bool
                
                .. attribute:: offload_no_cross_check
                
                	The MEP should be offloaded but crosscheck has not been configured
                	**type**\:  bool
                
                .. attribute:: offload_out_of_resources
                
                	Offload resource limits have been exceeded
                	**type**\:  bool
                
                .. attribute:: satellite_capabilities
                
                	Satellite Capabilities
                	**type**\:   :py:class:`SatelliteCapabilities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities>`
                
                .. attribute:: satellite_error_string
                
                	Error string returned from satellite
                	**type**\:  str
                
                .. attribute:: satellite_id
                
                	ID of the satellite
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: satellite_limitation
                
                	A satellite limitation is preventing MEP being offloaded to satellite
                	**type**\:  bool
                
                .. attribute:: service_bridge_domain
                
                	BD/XC ID for the MEP's Service, or Service name if the Service is 'down\-only'
                	**type**\:   :py:class:`ServiceBridgeDomain <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError.ServiceBridgeDomain>`
                
                .. attribute:: sla_delay_measurement_operations_disabled
                
                	In\-progress Ethernet SLA delay measurement operations are disabled due to satellite having delay measurement responder\-only capabilities
                	**type**\:  bool
                
                .. attribute:: sla_loopback_operations_disabled
                
                	In\-progress Ethernet SLA loopback operations are disabled due to satellite having loopback responder\-only capabilities
                	**type**\:  bool
                
                .. attribute:: sla_synthetic_loss_operations_disabled
                
                	In\-progress Ethernet SLA synthetic loss measurement operations are disabled due to satellite having synthetic loss measurement responder\-only capabilities
                	**type**\:  bool
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError, self).__init__()

                    self.yang_name = "mep-configuration-error"
                    self.yang_parent_name = "mep-configuration-errors"

                    self.domain = YLeaf(YType.str, "domain")

                    self.service = YLeaf(YType.str, "service")

                    self.interface = YLeaf(YType.str, "interface")

                    self.ais_configured = YLeaf(YType.boolean, "ais-configured")

                    self.bridge_domain_mismatch = YLeaf(YType.boolean, "bridge-domain-mismatch")

                    self.bridge_domain_not_in_bd_infra = YLeaf(YType.boolean, "bridge-domain-not-in-bd-infra")

                    self.bundle_level0 = YLeaf(YType.boolean, "bundle-level0")

                    self.ccm_interval = YLeaf(YType.enumeration, "ccm-interval")

                    self.ccm_interval_not_supported = YLeaf(YType.boolean, "ccm-interval-not-supported")

                    self.fatal_offload_error = YLeaf(YType.boolean, "fatal-offload-error")

                    self.level_conflict = YLeaf(YType.boolean, "level-conflict")

                    self.maid_format_not_supported = YLeaf(YType.boolean, "maid-format-not-supported")

                    self.no_domain = YLeaf(YType.boolean, "no-domain")

                    self.no_interface_type = YLeaf(YType.boolean, "no-interface-type")

                    self.no_mlacp = YLeaf(YType.boolean, "no-mlacp")

                    self.no_service = YLeaf(YType.boolean, "no-service")

                    self.no_valid_mac_address = YLeaf(YType.boolean, "no-valid-mac-address")

                    self.not_in_im = YLeaf(YType.boolean, "not-in-im")

                    self.offload_mep_direction_not_supported = YLeaf(YType.boolean, "offload-mep-direction-not-supported")

                    self.offload_multiple_local_mep = YLeaf(YType.boolean, "offload-multiple-local-mep")

                    self.offload_multiple_peer_meps = YLeaf(YType.boolean, "offload-multiple-peer-meps")

                    self.offload_no_cross_check = YLeaf(YType.boolean, "offload-no-cross-check")

                    self.offload_out_of_resources = YLeaf(YType.boolean, "offload-out-of-resources")

                    self.satellite_error_string = YLeaf(YType.str, "satellite-error-string")

                    self.satellite_id = YLeaf(YType.uint16, "satellite-id")

                    self.satellite_limitation = YLeaf(YType.boolean, "satellite-limitation")

                    self.sla_delay_measurement_operations_disabled = YLeaf(YType.boolean, "sla-delay-measurement-operations-disabled")

                    self.sla_loopback_operations_disabled = YLeaf(YType.boolean, "sla-loopback-operations-disabled")

                    self.sla_synthetic_loss_operations_disabled = YLeaf(YType.boolean, "sla-synthetic-loss-operations-disabled")

                    self.interface_bridge_domain = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.InterfaceBridgeDomain()
                    self.interface_bridge_domain.parent = self
                    self._children_name_map["interface_bridge_domain"] = "interface-bridge-domain"
                    self._children_yang_names.add("interface-bridge-domain")

                    self.mep = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.Mep()
                    self.mep.parent = self
                    self._children_name_map["mep"] = "mep"
                    self._children_yang_names.add("mep")

                    self.satellite_capabilities = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities()
                    self.satellite_capabilities.parent = self
                    self._children_name_map["satellite_capabilities"] = "satellite-capabilities"
                    self._children_yang_names.add("satellite-capabilities")

                    self.service_bridge_domain = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.ServiceBridgeDomain()
                    self.service_bridge_domain.parent = self
                    self._children_name_map["service_bridge_domain"] = "service-bridge-domain"
                    self._children_yang_names.add("service-bridge-domain")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain",
                                    "service",
                                    "interface",
                                    "ais_configured",
                                    "bridge_domain_mismatch",
                                    "bridge_domain_not_in_bd_infra",
                                    "bundle_level0",
                                    "ccm_interval",
                                    "ccm_interval_not_supported",
                                    "fatal_offload_error",
                                    "level_conflict",
                                    "maid_format_not_supported",
                                    "no_domain",
                                    "no_interface_type",
                                    "no_mlacp",
                                    "no_service",
                                    "no_valid_mac_address",
                                    "not_in_im",
                                    "offload_mep_direction_not_supported",
                                    "offload_multiple_local_mep",
                                    "offload_multiple_peer_meps",
                                    "offload_no_cross_check",
                                    "offload_out_of_resources",
                                    "satellite_error_string",
                                    "satellite_id",
                                    "satellite_limitation",
                                    "sla_delay_measurement_operations_disabled",
                                    "sla_loopback_operations_disabled",
                                    "sla_synthetic_loss_operations_disabled") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError, self).__setattr__(name, value)


                class Mep(Entity):
                    """
                    The MEP that has errors
                    
                    .. attribute:: domain_name
                    
                    	Domain name
                    	**type**\:  str
                    
                    .. attribute:: interface
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: level
                    
                    	Domain level
                    	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                    
                    .. attribute:: maintenance_point_type
                    
                    	Type of Maintenance Point
                    	**type**\:   :py:class:`CfmMaMpVariety <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmMaMpVariety>`
                    
                    .. attribute:: mep_id
                    
                    	MEP ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: service_name
                    
                    	Service name
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.Mep, self).__init__()

                        self.yang_name = "mep"
                        self.yang_parent_name = "mep-configuration-error"

                        self.domain_name = YLeaf(YType.str, "domain-name")

                        self.interface = YLeaf(YType.str, "interface")

                        self.level = YLeaf(YType.enumeration, "level")

                        self.maintenance_point_type = YLeaf(YType.enumeration, "maintenance-point-type")

                        self.mep_id = YLeaf(YType.uint16, "mep-id")

                        self.service_name = YLeaf(YType.str, "service-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("domain_name",
                                        "interface",
                                        "level",
                                        "maintenance_point_type",
                                        "mep_id",
                                        "service_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.Mep, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.Mep, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.domain_name.is_set or
                            self.interface.is_set or
                            self.level.is_set or
                            self.maintenance_point_type.is_set or
                            self.mep_id.is_set or
                            self.service_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.domain_name.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.maintenance_point_type.yfilter != YFilter.not_set or
                            self.mep_id.yfilter != YFilter.not_set or
                            self.service_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "mep" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.domain_name.is_set or self.domain_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain_name.get_name_leafdata())
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.maintenance_point_type.is_set or self.maintenance_point_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maintenance_point_type.get_name_leafdata())
                        if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mep_id.get_name_leafdata())
                        if (self.service_name.is_set or self.service_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "domain-name" or name == "interface" or name == "level" or name == "maintenance-point-type" or name == "mep-id" or name == "service-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "domain-name"):
                            self.domain_name = value
                            self.domain_name.value_namespace = name_space
                            self.domain_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "maintenance-point-type"):
                            self.maintenance_point_type = value
                            self.maintenance_point_type.value_namespace = name_space
                            self.maintenance_point_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "mep-id"):
                            self.mep_id = value
                            self.mep_id.value_namespace = name_space
                            self.mep_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "service-name"):
                            self.service_name = value
                            self.service_name.value_namespace = name_space
                            self.service_name.value_namespace_prefix = name_space_prefix


                class ServiceBridgeDomain(Entity):
                    """
                    BD/XC ID for the MEP's Service, or Service name
                    if the Service is 'down\-only'
                    
                    .. attribute:: bridge_domain_id_format
                    
                    	Bridge domain identifier format
                    	**type**\:   :py:class:`CfmBagBdidFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagBdidFmt>`
                    
                    .. attribute:: ce_id
                    
                    	Local Customer Edge Identifier (CE\-ID)
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: group
                    
                    	Name of the Bridge/XConnect Group
                    	**type**\:  str
                    
                    .. attribute:: name
                    
                    	Name of the Bridge Domain/XConnect
                    	**type**\:  str
                    
                    .. attribute:: remote_ce_id
                    
                    	Remote Customer Edge Identifier (CE\-ID)
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.ServiceBridgeDomain, self).__init__()

                        self.yang_name = "service-bridge-domain"
                        self.yang_parent_name = "mep-configuration-error"

                        self.bridge_domain_id_format = YLeaf(YType.enumeration, "bridge-domain-id-format")

                        self.ce_id = YLeaf(YType.uint16, "ce-id")

                        self.group = YLeaf(YType.str, "group")

                        self.name = YLeaf(YType.str, "name")

                        self.remote_ce_id = YLeaf(YType.uint16, "remote-ce-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bridge_domain_id_format",
                                        "ce_id",
                                        "group",
                                        "name",
                                        "remote_ce_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.ServiceBridgeDomain, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.ServiceBridgeDomain, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bridge_domain_id_format.is_set or
                            self.ce_id.is_set or
                            self.group.is_set or
                            self.name.is_set or
                            self.remote_ce_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bridge_domain_id_format.yfilter != YFilter.not_set or
                            self.ce_id.yfilter != YFilter.not_set or
                            self.group.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.remote_ce_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "service-bridge-domain" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bridge_domain_id_format.is_set or self.bridge_domain_id_format.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bridge_domain_id_format.get_name_leafdata())
                        if (self.ce_id.is_set or self.ce_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ce_id.get_name_leafdata())
                        if (self.group.is_set or self.group.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.group.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.remote_ce_id.is_set or self.remote_ce_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_ce_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bridge-domain-id-format" or name == "ce-id" or name == "group" or name == "name" or name == "remote-ce-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bridge-domain-id-format"):
                            self.bridge_domain_id_format = value
                            self.bridge_domain_id_format.value_namespace = name_space
                            self.bridge_domain_id_format.value_namespace_prefix = name_space_prefix
                        if(value_path == "ce-id"):
                            self.ce_id = value
                            self.ce_id.value_namespace = name_space
                            self.ce_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "group"):
                            self.group = value
                            self.group.value_namespace = name_space
                            self.group.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-ce-id"):
                            self.remote_ce_id = value
                            self.remote_ce_id.value_namespace = name_space
                            self.remote_ce_id.value_namespace_prefix = name_space_prefix


                class InterfaceBridgeDomain(Entity):
                    """
                    ID of the BD/XC that the MEP's EFP is in, if any
                    
                    .. attribute:: bridge_domain_id_format
                    
                    	Bridge domain identifier format
                    	**type**\:   :py:class:`CfmBagBdidFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagBdidFmt>`
                    
                    .. attribute:: ce_id
                    
                    	Local Customer Edge Identifier (CE\-ID)
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: group
                    
                    	Name of the Bridge/XConnect Group
                    	**type**\:  str
                    
                    .. attribute:: name
                    
                    	Name of the Bridge Domain/XConnect
                    	**type**\:  str
                    
                    .. attribute:: remote_ce_id
                    
                    	Remote Customer Edge Identifier (CE\-ID)
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.InterfaceBridgeDomain, self).__init__()

                        self.yang_name = "interface-bridge-domain"
                        self.yang_parent_name = "mep-configuration-error"

                        self.bridge_domain_id_format = YLeaf(YType.enumeration, "bridge-domain-id-format")

                        self.ce_id = YLeaf(YType.uint16, "ce-id")

                        self.group = YLeaf(YType.str, "group")

                        self.name = YLeaf(YType.str, "name")

                        self.remote_ce_id = YLeaf(YType.uint16, "remote-ce-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bridge_domain_id_format",
                                        "ce_id",
                                        "group",
                                        "name",
                                        "remote_ce_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.InterfaceBridgeDomain, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.InterfaceBridgeDomain, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bridge_domain_id_format.is_set or
                            self.ce_id.is_set or
                            self.group.is_set or
                            self.name.is_set or
                            self.remote_ce_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bridge_domain_id_format.yfilter != YFilter.not_set or
                            self.ce_id.yfilter != YFilter.not_set or
                            self.group.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.remote_ce_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface-bridge-domain" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bridge_domain_id_format.is_set or self.bridge_domain_id_format.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bridge_domain_id_format.get_name_leafdata())
                        if (self.ce_id.is_set or self.ce_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ce_id.get_name_leafdata())
                        if (self.group.is_set or self.group.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.group.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.remote_ce_id.is_set or self.remote_ce_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_ce_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bridge-domain-id-format" or name == "ce-id" or name == "group" or name == "name" or name == "remote-ce-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bridge-domain-id-format"):
                            self.bridge_domain_id_format = value
                            self.bridge_domain_id_format.value_namespace = name_space
                            self.bridge_domain_id_format.value_namespace_prefix = name_space_prefix
                        if(value_path == "ce-id"):
                            self.ce_id = value
                            self.ce_id.value_namespace = name_space
                            self.ce_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "group"):
                            self.group = value
                            self.group.value_namespace = name_space
                            self.group.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-ce-id"):
                            self.remote_ce_id = value
                            self.remote_ce_id.value_namespace = name_space
                            self.remote_ce_id.value_namespace_prefix = name_space_prefix


                class SatelliteCapabilities(Entity):
                    """
                    Satellite Capabilities
                    
                    .. attribute:: delay_measurement
                    
                    	Delay Measurement
                    	**type**\:   :py:class:`DelayMeasurement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.DelayMeasurement>`
                    
                    .. attribute:: loopback
                    
                    	Loopback
                    	**type**\:   :py:class:`Loopback <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.Loopback>`
                    
                    .. attribute:: synthetic_loss_measurement
                    
                    	Synthetic Loss Measurement
                    	**type**\:   :py:class:`SyntheticLossMeasurement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.SyntheticLossMeasurement>`
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities, self).__init__()

                        self.yang_name = "satellite-capabilities"
                        self.yang_parent_name = "mep-configuration-error"

                        self.delay_measurement = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.DelayMeasurement()
                        self.delay_measurement.parent = self
                        self._children_name_map["delay_measurement"] = "delay-measurement"
                        self._children_yang_names.add("delay-measurement")

                        self.loopback = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.Loopback()
                        self.loopback.parent = self
                        self._children_name_map["loopback"] = "loopback"
                        self._children_yang_names.add("loopback")

                        self.synthetic_loss_measurement = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.SyntheticLossMeasurement()
                        self.synthetic_loss_measurement.parent = self
                        self._children_name_map["synthetic_loss_measurement"] = "synthetic-loss-measurement"
                        self._children_yang_names.add("synthetic-loss-measurement")


                    class Loopback(Entity):
                        """
                        Loopback
                        
                        .. attribute:: controller
                        
                        	Controller
                        	**type**\:  bool
                        
                        .. attribute:: responder
                        
                        	Responder
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.Loopback, self).__init__()

                            self.yang_name = "loopback"
                            self.yang_parent_name = "satellite-capabilities"

                            self.controller = YLeaf(YType.boolean, "controller")

                            self.responder = YLeaf(YType.boolean, "responder")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("controller",
                                            "responder") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.Loopback, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.Loopback, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.controller.is_set or
                                self.responder.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.controller.yfilter != YFilter.not_set or
                                self.responder.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "loopback" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.controller.is_set or self.controller.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.controller.get_name_leafdata())
                            if (self.responder.is_set or self.responder.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.responder.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "controller" or name == "responder"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "controller"):
                                self.controller = value
                                self.controller.value_namespace = name_space
                                self.controller.value_namespace_prefix = name_space_prefix
                            if(value_path == "responder"):
                                self.responder = value
                                self.responder.value_namespace = name_space
                                self.responder.value_namespace_prefix = name_space_prefix


                    class DelayMeasurement(Entity):
                        """
                        Delay Measurement
                        
                        .. attribute:: controller
                        
                        	Controller
                        	**type**\:  bool
                        
                        .. attribute:: responder
                        
                        	Responder
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.DelayMeasurement, self).__init__()

                            self.yang_name = "delay-measurement"
                            self.yang_parent_name = "satellite-capabilities"

                            self.controller = YLeaf(YType.boolean, "controller")

                            self.responder = YLeaf(YType.boolean, "responder")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("controller",
                                            "responder") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.DelayMeasurement, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.DelayMeasurement, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.controller.is_set or
                                self.responder.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.controller.yfilter != YFilter.not_set or
                                self.responder.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "delay-measurement" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.controller.is_set or self.controller.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.controller.get_name_leafdata())
                            if (self.responder.is_set or self.responder.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.responder.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "controller" or name == "responder"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "controller"):
                                self.controller = value
                                self.controller.value_namespace = name_space
                                self.controller.value_namespace_prefix = name_space_prefix
                            if(value_path == "responder"):
                                self.responder = value
                                self.responder.value_namespace = name_space
                                self.responder.value_namespace_prefix = name_space_prefix


                    class SyntheticLossMeasurement(Entity):
                        """
                        Synthetic Loss Measurement
                        
                        .. attribute:: controller
                        
                        	Controller
                        	**type**\:  bool
                        
                        .. attribute:: responder
                        
                        	Responder
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.SyntheticLossMeasurement, self).__init__()

                            self.yang_name = "synthetic-loss-measurement"
                            self.yang_parent_name = "satellite-capabilities"

                            self.controller = YLeaf(YType.boolean, "controller")

                            self.responder = YLeaf(YType.boolean, "responder")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("controller",
                                            "responder") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.SyntheticLossMeasurement, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.SyntheticLossMeasurement, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.controller.is_set or
                                self.responder.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.controller.yfilter != YFilter.not_set or
                                self.responder.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "synthetic-loss-measurement" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.controller.is_set or self.controller.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.controller.get_name_leafdata())
                            if (self.responder.is_set or self.responder.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.responder.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "controller" or name == "responder"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "controller"):
                                self.controller = value
                                self.controller.value_namespace = name_space
                                self.controller.value_namespace_prefix = name_space_prefix
                            if(value_path == "responder"):
                                self.responder = value
                                self.responder.value_namespace = name_space
                                self.responder.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.delay_measurement is not None and self.delay_measurement.has_data()) or
                            (self.loopback is not None and self.loopback.has_data()) or
                            (self.synthetic_loss_measurement is not None and self.synthetic_loss_measurement.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.delay_measurement is not None and self.delay_measurement.has_operation()) or
                            (self.loopback is not None and self.loopback.has_operation()) or
                            (self.synthetic_loss_measurement is not None and self.synthetic_loss_measurement.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "satellite-capabilities" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "delay-measurement"):
                            if (self.delay_measurement is None):
                                self.delay_measurement = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.DelayMeasurement()
                                self.delay_measurement.parent = self
                                self._children_name_map["delay_measurement"] = "delay-measurement"
                            return self.delay_measurement

                        if (child_yang_name == "loopback"):
                            if (self.loopback is None):
                                self.loopback = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.Loopback()
                                self.loopback.parent = self
                                self._children_name_map["loopback"] = "loopback"
                            return self.loopback

                        if (child_yang_name == "synthetic-loss-measurement"):
                            if (self.synthetic_loss_measurement is None):
                                self.synthetic_loss_measurement = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities.SyntheticLossMeasurement()
                                self.synthetic_loss_measurement.parent = self
                                self._children_name_map["synthetic_loss_measurement"] = "synthetic-loss-measurement"
                            return self.synthetic_loss_measurement

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "delay-measurement" or name == "loopback" or name == "synthetic-loss-measurement"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.domain.is_set or
                        self.service.is_set or
                        self.interface.is_set or
                        self.ais_configured.is_set or
                        self.bridge_domain_mismatch.is_set or
                        self.bridge_domain_not_in_bd_infra.is_set or
                        self.bundle_level0.is_set or
                        self.ccm_interval.is_set or
                        self.ccm_interval_not_supported.is_set or
                        self.fatal_offload_error.is_set or
                        self.level_conflict.is_set or
                        self.maid_format_not_supported.is_set or
                        self.no_domain.is_set or
                        self.no_interface_type.is_set or
                        self.no_mlacp.is_set or
                        self.no_service.is_set or
                        self.no_valid_mac_address.is_set or
                        self.not_in_im.is_set or
                        self.offload_mep_direction_not_supported.is_set or
                        self.offload_multiple_local_mep.is_set or
                        self.offload_multiple_peer_meps.is_set or
                        self.offload_no_cross_check.is_set or
                        self.offload_out_of_resources.is_set or
                        self.satellite_error_string.is_set or
                        self.satellite_id.is_set or
                        self.satellite_limitation.is_set or
                        self.sla_delay_measurement_operations_disabled.is_set or
                        self.sla_loopback_operations_disabled.is_set or
                        self.sla_synthetic_loss_operations_disabled.is_set or
                        (self.interface_bridge_domain is not None and self.interface_bridge_domain.has_data()) or
                        (self.mep is not None and self.mep.has_data()) or
                        (self.satellite_capabilities is not None and self.satellite_capabilities.has_data()) or
                        (self.service_bridge_domain is not None and self.service_bridge_domain.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain.yfilter != YFilter.not_set or
                        self.service.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.ais_configured.yfilter != YFilter.not_set or
                        self.bridge_domain_mismatch.yfilter != YFilter.not_set or
                        self.bridge_domain_not_in_bd_infra.yfilter != YFilter.not_set or
                        self.bundle_level0.yfilter != YFilter.not_set or
                        self.ccm_interval.yfilter != YFilter.not_set or
                        self.ccm_interval_not_supported.yfilter != YFilter.not_set or
                        self.fatal_offload_error.yfilter != YFilter.not_set or
                        self.level_conflict.yfilter != YFilter.not_set or
                        self.maid_format_not_supported.yfilter != YFilter.not_set or
                        self.no_domain.yfilter != YFilter.not_set or
                        self.no_interface_type.yfilter != YFilter.not_set or
                        self.no_mlacp.yfilter != YFilter.not_set or
                        self.no_service.yfilter != YFilter.not_set or
                        self.no_valid_mac_address.yfilter != YFilter.not_set or
                        self.not_in_im.yfilter != YFilter.not_set or
                        self.offload_mep_direction_not_supported.yfilter != YFilter.not_set or
                        self.offload_multiple_local_mep.yfilter != YFilter.not_set or
                        self.offload_multiple_peer_meps.yfilter != YFilter.not_set or
                        self.offload_no_cross_check.yfilter != YFilter.not_set or
                        self.offload_out_of_resources.yfilter != YFilter.not_set or
                        self.satellite_error_string.yfilter != YFilter.not_set or
                        self.satellite_id.yfilter != YFilter.not_set or
                        self.satellite_limitation.yfilter != YFilter.not_set or
                        self.sla_delay_measurement_operations_disabled.yfilter != YFilter.not_set or
                        self.sla_loopback_operations_disabled.yfilter != YFilter.not_set or
                        self.sla_synthetic_loss_operations_disabled.yfilter != YFilter.not_set or
                        (self.interface_bridge_domain is not None and self.interface_bridge_domain.has_operation()) or
                        (self.mep is not None and self.mep.has_operation()) or
                        (self.satellite_capabilities is not None and self.satellite_capabilities.has_operation()) or
                        (self.service_bridge_domain is not None and self.service_bridge_domain.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mep-configuration-error" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + "[interface='" + self.interface.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/mep-configuration-errors/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain.get_name_leafdata())
                    if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service.get_name_leafdata())
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.ais_configured.is_set or self.ais_configured.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ais_configured.get_name_leafdata())
                    if (self.bridge_domain_mismatch.is_set or self.bridge_domain_mismatch.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bridge_domain_mismatch.get_name_leafdata())
                    if (self.bridge_domain_not_in_bd_infra.is_set or self.bridge_domain_not_in_bd_infra.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bridge_domain_not_in_bd_infra.get_name_leafdata())
                    if (self.bundle_level0.is_set or self.bundle_level0.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bundle_level0.get_name_leafdata())
                    if (self.ccm_interval.is_set or self.ccm_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ccm_interval.get_name_leafdata())
                    if (self.ccm_interval_not_supported.is_set or self.ccm_interval_not_supported.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ccm_interval_not_supported.get_name_leafdata())
                    if (self.fatal_offload_error.is_set or self.fatal_offload_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fatal_offload_error.get_name_leafdata())
                    if (self.level_conflict.is_set or self.level_conflict.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.level_conflict.get_name_leafdata())
                    if (self.maid_format_not_supported.is_set or self.maid_format_not_supported.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maid_format_not_supported.get_name_leafdata())
                    if (self.no_domain.is_set or self.no_domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.no_domain.get_name_leafdata())
                    if (self.no_interface_type.is_set or self.no_interface_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.no_interface_type.get_name_leafdata())
                    if (self.no_mlacp.is_set or self.no_mlacp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.no_mlacp.get_name_leafdata())
                    if (self.no_service.is_set or self.no_service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.no_service.get_name_leafdata())
                    if (self.no_valid_mac_address.is_set or self.no_valid_mac_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.no_valid_mac_address.get_name_leafdata())
                    if (self.not_in_im.is_set or self.not_in_im.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.not_in_im.get_name_leafdata())
                    if (self.offload_mep_direction_not_supported.is_set or self.offload_mep_direction_not_supported.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offload_mep_direction_not_supported.get_name_leafdata())
                    if (self.offload_multiple_local_mep.is_set or self.offload_multiple_local_mep.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offload_multiple_local_mep.get_name_leafdata())
                    if (self.offload_multiple_peer_meps.is_set or self.offload_multiple_peer_meps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offload_multiple_peer_meps.get_name_leafdata())
                    if (self.offload_no_cross_check.is_set or self.offload_no_cross_check.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offload_no_cross_check.get_name_leafdata())
                    if (self.offload_out_of_resources.is_set or self.offload_out_of_resources.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.offload_out_of_resources.get_name_leafdata())
                    if (self.satellite_error_string.is_set or self.satellite_error_string.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.satellite_error_string.get_name_leafdata())
                    if (self.satellite_id.is_set or self.satellite_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.satellite_id.get_name_leafdata())
                    if (self.satellite_limitation.is_set or self.satellite_limitation.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.satellite_limitation.get_name_leafdata())
                    if (self.sla_delay_measurement_operations_disabled.is_set or self.sla_delay_measurement_operations_disabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sla_delay_measurement_operations_disabled.get_name_leafdata())
                    if (self.sla_loopback_operations_disabled.is_set or self.sla_loopback_operations_disabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sla_loopback_operations_disabled.get_name_leafdata())
                    if (self.sla_synthetic_loss_operations_disabled.is_set or self.sla_synthetic_loss_operations_disabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sla_synthetic_loss_operations_disabled.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface-bridge-domain"):
                        if (self.interface_bridge_domain is None):
                            self.interface_bridge_domain = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.InterfaceBridgeDomain()
                            self.interface_bridge_domain.parent = self
                            self._children_name_map["interface_bridge_domain"] = "interface-bridge-domain"
                        return self.interface_bridge_domain

                    if (child_yang_name == "mep"):
                        if (self.mep is None):
                            self.mep = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.Mep()
                            self.mep.parent = self
                            self._children_name_map["mep"] = "mep"
                        return self.mep

                    if (child_yang_name == "satellite-capabilities"):
                        if (self.satellite_capabilities is None):
                            self.satellite_capabilities = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.SatelliteCapabilities()
                            self.satellite_capabilities.parent = self
                            self._children_name_map["satellite_capabilities"] = "satellite-capabilities"
                        return self.satellite_capabilities

                    if (child_yang_name == "service-bridge-domain"):
                        if (self.service_bridge_domain is None):
                            self.service_bridge_domain = Cfm.Global_.MepConfigurationErrors.MepConfigurationError.ServiceBridgeDomain()
                            self.service_bridge_domain.parent = self
                            self._children_name_map["service_bridge_domain"] = "service-bridge-domain"
                        return self.service_bridge_domain

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-bridge-domain" or name == "mep" or name == "satellite-capabilities" or name == "service-bridge-domain" or name == "domain" or name == "service" or name == "interface" or name == "ais-configured" or name == "bridge-domain-mismatch" or name == "bridge-domain-not-in-bd-infra" or name == "bundle-level0" or name == "ccm-interval" or name == "ccm-interval-not-supported" or name == "fatal-offload-error" or name == "level-conflict" or name == "maid-format-not-supported" or name == "no-domain" or name == "no-interface-type" or name == "no-mlacp" or name == "no-service" or name == "no-valid-mac-address" or name == "not-in-im" or name == "offload-mep-direction-not-supported" or name == "offload-multiple-local-mep" or name == "offload-multiple-peer-meps" or name == "offload-no-cross-check" or name == "offload-out-of-resources" or name == "satellite-error-string" or name == "satellite-id" or name == "satellite-limitation" or name == "sla-delay-measurement-operations-disabled" or name == "sla-loopback-operations-disabled" or name == "sla-synthetic-loss-operations-disabled"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain"):
                        self.domain = value
                        self.domain.value_namespace = name_space
                        self.domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "service"):
                        self.service = value
                        self.service.value_namespace = name_space
                        self.service.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "ais-configured"):
                        self.ais_configured = value
                        self.ais_configured.value_namespace = name_space
                        self.ais_configured.value_namespace_prefix = name_space_prefix
                    if(value_path == "bridge-domain-mismatch"):
                        self.bridge_domain_mismatch = value
                        self.bridge_domain_mismatch.value_namespace = name_space
                        self.bridge_domain_mismatch.value_namespace_prefix = name_space_prefix
                    if(value_path == "bridge-domain-not-in-bd-infra"):
                        self.bridge_domain_not_in_bd_infra = value
                        self.bridge_domain_not_in_bd_infra.value_namespace = name_space
                        self.bridge_domain_not_in_bd_infra.value_namespace_prefix = name_space_prefix
                    if(value_path == "bundle-level0"):
                        self.bundle_level0 = value
                        self.bundle_level0.value_namespace = name_space
                        self.bundle_level0.value_namespace_prefix = name_space_prefix
                    if(value_path == "ccm-interval"):
                        self.ccm_interval = value
                        self.ccm_interval.value_namespace = name_space
                        self.ccm_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "ccm-interval-not-supported"):
                        self.ccm_interval_not_supported = value
                        self.ccm_interval_not_supported.value_namespace = name_space
                        self.ccm_interval_not_supported.value_namespace_prefix = name_space_prefix
                    if(value_path == "fatal-offload-error"):
                        self.fatal_offload_error = value
                        self.fatal_offload_error.value_namespace = name_space
                        self.fatal_offload_error.value_namespace_prefix = name_space_prefix
                    if(value_path == "level-conflict"):
                        self.level_conflict = value
                        self.level_conflict.value_namespace = name_space
                        self.level_conflict.value_namespace_prefix = name_space_prefix
                    if(value_path == "maid-format-not-supported"):
                        self.maid_format_not_supported = value
                        self.maid_format_not_supported.value_namespace = name_space
                        self.maid_format_not_supported.value_namespace_prefix = name_space_prefix
                    if(value_path == "no-domain"):
                        self.no_domain = value
                        self.no_domain.value_namespace = name_space
                        self.no_domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "no-interface-type"):
                        self.no_interface_type = value
                        self.no_interface_type.value_namespace = name_space
                        self.no_interface_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "no-mlacp"):
                        self.no_mlacp = value
                        self.no_mlacp.value_namespace = name_space
                        self.no_mlacp.value_namespace_prefix = name_space_prefix
                    if(value_path == "no-service"):
                        self.no_service = value
                        self.no_service.value_namespace = name_space
                        self.no_service.value_namespace_prefix = name_space_prefix
                    if(value_path == "no-valid-mac-address"):
                        self.no_valid_mac_address = value
                        self.no_valid_mac_address.value_namespace = name_space
                        self.no_valid_mac_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "not-in-im"):
                        self.not_in_im = value
                        self.not_in_im.value_namespace = name_space
                        self.not_in_im.value_namespace_prefix = name_space_prefix
                    if(value_path == "offload-mep-direction-not-supported"):
                        self.offload_mep_direction_not_supported = value
                        self.offload_mep_direction_not_supported.value_namespace = name_space
                        self.offload_mep_direction_not_supported.value_namespace_prefix = name_space_prefix
                    if(value_path == "offload-multiple-local-mep"):
                        self.offload_multiple_local_mep = value
                        self.offload_multiple_local_mep.value_namespace = name_space
                        self.offload_multiple_local_mep.value_namespace_prefix = name_space_prefix
                    if(value_path == "offload-multiple-peer-meps"):
                        self.offload_multiple_peer_meps = value
                        self.offload_multiple_peer_meps.value_namespace = name_space
                        self.offload_multiple_peer_meps.value_namespace_prefix = name_space_prefix
                    if(value_path == "offload-no-cross-check"):
                        self.offload_no_cross_check = value
                        self.offload_no_cross_check.value_namespace = name_space
                        self.offload_no_cross_check.value_namespace_prefix = name_space_prefix
                    if(value_path == "offload-out-of-resources"):
                        self.offload_out_of_resources = value
                        self.offload_out_of_resources.value_namespace = name_space
                        self.offload_out_of_resources.value_namespace_prefix = name_space_prefix
                    if(value_path == "satellite-error-string"):
                        self.satellite_error_string = value
                        self.satellite_error_string.value_namespace = name_space
                        self.satellite_error_string.value_namespace_prefix = name_space_prefix
                    if(value_path == "satellite-id"):
                        self.satellite_id = value
                        self.satellite_id.value_namespace = name_space
                        self.satellite_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "satellite-limitation"):
                        self.satellite_limitation = value
                        self.satellite_limitation.value_namespace = name_space
                        self.satellite_limitation.value_namespace_prefix = name_space_prefix
                    if(value_path == "sla-delay-measurement-operations-disabled"):
                        self.sla_delay_measurement_operations_disabled = value
                        self.sla_delay_measurement_operations_disabled.value_namespace = name_space
                        self.sla_delay_measurement_operations_disabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "sla-loopback-operations-disabled"):
                        self.sla_loopback_operations_disabled = value
                        self.sla_loopback_operations_disabled.value_namespace = name_space
                        self.sla_loopback_operations_disabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "sla-synthetic-loss-operations-disabled"):
                        self.sla_synthetic_loss_operations_disabled = value
                        self.sla_synthetic_loss_operations_disabled.value_namespace = name_space
                        self.sla_synthetic_loss_operations_disabled.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.mep_configuration_error:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.mep_configuration_error:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "mep-configuration-errors" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "mep-configuration-error"):
                    for c in self.mep_configuration_error:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Cfm.Global_.MepConfigurationErrors.MepConfigurationError()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.mep_configuration_error.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "mep-configuration-error"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class TracerouteCaches(Entity):
            """
            Traceroute Cache table
            
            .. attribute:: traceroute_cache
            
            	Information about a particular traceroute operation
            	**type**\: list of    :py:class:`TracerouteCache <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Global_.TracerouteCaches, self).__init__()

                self.yang_name = "traceroute-caches"
                self.yang_parent_name = "global"

                self.traceroute_cache = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Global_.TracerouteCaches, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Global_.TracerouteCaches, self).__setattr__(name, value)


            class TracerouteCache(Entity):
                """
                Information about a particular traceroute
                operation
                
                .. attribute:: domain  <key>
                
                	Maintenance Domain
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: service  <key>
                
                	Service (Maintenance Association)
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: mep_id  <key>
                
                	MEP ID
                	**type**\:  int
                
                	**range:** 1..8191
                
                .. attribute:: interface  <key>
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: transaction_id  <key>
                
                	Transaction ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: exploratory_linktrace_reply
                
                	Received exploratory linktrace replies
                	**type**\: list of    :py:class:`ExploratoryLinktraceReply <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply>`
                
                .. attribute:: linktrace_reply
                
                	Received linktrace replies
                	**type**\: list of    :py:class:`LinktraceReply <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply>`
                
                .. attribute:: replies_dropped
                
                	Count of ignored replies for this request
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: traceroute_information
                
                	Information about the traceroute operation
                	**type**\:   :py:class:`TracerouteInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation>`
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Global_.TracerouteCaches.TracerouteCache, self).__init__()

                    self.yang_name = "traceroute-cache"
                    self.yang_parent_name = "traceroute-caches"

                    self.domain = YLeaf(YType.str, "domain")

                    self.service = YLeaf(YType.str, "service")

                    self.mep_id = YLeaf(YType.uint32, "mep-id")

                    self.interface = YLeaf(YType.str, "interface")

                    self.transaction_id = YLeaf(YType.int32, "transaction-id")

                    self.replies_dropped = YLeaf(YType.uint32, "replies-dropped")

                    self.traceroute_information = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation()
                    self.traceroute_information.parent = self
                    self._children_name_map["traceroute_information"] = "traceroute-information"
                    self._children_yang_names.add("traceroute-information")

                    self.exploratory_linktrace_reply = YList(self)
                    self.linktrace_reply = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain",
                                    "service",
                                    "mep_id",
                                    "interface",
                                    "transaction_id",
                                    "replies_dropped") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache, self).__setattr__(name, value)


                class TracerouteInformation(Entity):
                    """
                    Information about the traceroute operation
                    
                    .. attribute:: directed_mac_address
                    
                    	Directed MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: domain
                    
                    	Maintenance domain name
                    	**type**\:  str
                    
                    .. attribute:: level
                    
                    	Maintenance level
                    	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                    
                    .. attribute:: options
                    
                    	Options affecting traceroute behavior
                    	**type**\:   :py:class:`Options <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options>`
                    
                    .. attribute:: service
                    
                    	Service name
                    	**type**\:  str
                    
                    .. attribute:: source_interface
                    
                    	Source interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: source_mac_address
                    
                    	Source MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: source_mep_id
                    
                    	Source MEP ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: target_mac_address
                    
                    	Target MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: target_mep_id
                    
                    	Target MEP ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: timestamp
                    
                    	Timestamp of initiation time (seconds)
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    .. attribute:: transaction_id
                    
                    	Transaction ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ttl
                    
                    	Time to live
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation, self).__init__()

                        self.yang_name = "traceroute-information"
                        self.yang_parent_name = "traceroute-cache"

                        self.directed_mac_address = YLeaf(YType.str, "directed-mac-address")

                        self.domain = YLeaf(YType.str, "domain")

                        self.level = YLeaf(YType.enumeration, "level")

                        self.service = YLeaf(YType.str, "service")

                        self.source_interface = YLeaf(YType.str, "source-interface")

                        self.source_mac_address = YLeaf(YType.str, "source-mac-address")

                        self.source_mep_id = YLeaf(YType.uint16, "source-mep-id")

                        self.target_mac_address = YLeaf(YType.str, "target-mac-address")

                        self.target_mep_id = YLeaf(YType.uint16, "target-mep-id")

                        self.timestamp = YLeaf(YType.uint64, "timestamp")

                        self.transaction_id = YLeaf(YType.uint32, "transaction-id")

                        self.ttl = YLeaf(YType.uint8, "ttl")

                        self.options = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options()
                        self.options.parent = self
                        self._children_name_map["options"] = "options"
                        self._children_yang_names.add("options")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("directed_mac_address",
                                        "domain",
                                        "level",
                                        "service",
                                        "source_interface",
                                        "source_mac_address",
                                        "source_mep_id",
                                        "target_mac_address",
                                        "target_mep_id",
                                        "timestamp",
                                        "transaction_id",
                                        "ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation, self).__setattr__(name, value)


                    class Options(Entity):
                        """
                        Options affecting traceroute behavior
                        
                        .. attribute:: basic_options
                        
                        	Options for a basic IEEE 802.1ag Linktrace
                        	**type**\:   :py:class:`BasicOptions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.BasicOptions>`
                        
                        .. attribute:: exploratory_options
                        
                        	Options for an Exploratory Linktrace
                        	**type**\:   :py:class:`ExploratoryOptions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.ExploratoryOptions>`
                        
                        .. attribute:: mode
                        
                        	Mode
                        	**type**\:   :py:class:`CfmPmLtMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmLtMode>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options, self).__init__()

                            self.yang_name = "options"
                            self.yang_parent_name = "traceroute-information"

                            self.mode = YLeaf(YType.enumeration, "mode")

                            self.basic_options = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.BasicOptions()
                            self.basic_options.parent = self
                            self._children_name_map["basic_options"] = "basic-options"
                            self._children_yang_names.add("basic-options")

                            self.exploratory_options = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.ExploratoryOptions()
                            self.exploratory_options.parent = self
                            self._children_name_map["exploratory_options"] = "exploratory-options"
                            self._children_yang_names.add("exploratory-options")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("mode") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options, self).__setattr__(name, value)


                        class BasicOptions(Entity):
                            """
                            Options for a basic IEEE 802.1ag Linktrace
                            
                            .. attribute:: fdb_only
                            
                            	Only use the Filtering Database for forwarding lookups
                            	**type**\:  bool
                            
                            .. attribute:: is_auto
                            
                            	Traceroute was initiated automatically
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.BasicOptions, self).__init__()

                                self.yang_name = "basic-options"
                                self.yang_parent_name = "options"

                                self.fdb_only = YLeaf(YType.boolean, "fdb-only")

                                self.is_auto = YLeaf(YType.boolean, "is-auto")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fdb_only",
                                                "is_auto") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.BasicOptions, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.BasicOptions, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fdb_only.is_set or
                                    self.is_auto.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fdb_only.yfilter != YFilter.not_set or
                                    self.is_auto.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "basic-options" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fdb_only.is_set or self.fdb_only.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fdb_only.get_name_leafdata())
                                if (self.is_auto.is_set or self.is_auto.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_auto.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fdb-only" or name == "is-auto"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fdb-only"):
                                    self.fdb_only = value
                                    self.fdb_only.value_namespace = name_space
                                    self.fdb_only.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-auto"):
                                    self.is_auto = value
                                    self.is_auto.value_namespace = name_space
                                    self.is_auto.value_namespace_prefix = name_space_prefix


                        class ExploratoryOptions(Entity):
                            """
                            Options for an Exploratory Linktrace
                            
                            .. attribute:: delay_constant_factor
                            
                            	Constant Factor for delay calculations
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: delay_model
                            
                            	Delay model for delay calculations
                            	**type**\:   :py:class:`CfmPmEltDelayModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmEltDelayModel>`
                            
                            .. attribute:: reply_filter
                            
                            	Reply Filtering mode used by responders
                            	**type**\:   :py:class:`CfmPmElmReplyFilter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmElmReplyFilter>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.ExploratoryOptions, self).__init__()

                                self.yang_name = "exploratory-options"
                                self.yang_parent_name = "options"

                                self.delay_constant_factor = YLeaf(YType.uint32, "delay-constant-factor")

                                self.delay_model = YLeaf(YType.enumeration, "delay-model")

                                self.reply_filter = YLeaf(YType.enumeration, "reply-filter")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("delay_constant_factor",
                                                "delay_model",
                                                "reply_filter") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.ExploratoryOptions, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.ExploratoryOptions, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.delay_constant_factor.is_set or
                                    self.delay_model.is_set or
                                    self.reply_filter.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.delay_constant_factor.yfilter != YFilter.not_set or
                                    self.delay_model.yfilter != YFilter.not_set or
                                    self.reply_filter.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "exploratory-options" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.delay_constant_factor.is_set or self.delay_constant_factor.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay_constant_factor.get_name_leafdata())
                                if (self.delay_model.is_set or self.delay_model.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay_model.get_name_leafdata())
                                if (self.reply_filter.is_set or self.reply_filter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reply_filter.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "delay-constant-factor" or name == "delay-model" or name == "reply-filter"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "delay-constant-factor"):
                                    self.delay_constant_factor = value
                                    self.delay_constant_factor.value_namespace = name_space
                                    self.delay_constant_factor.value_namespace_prefix = name_space_prefix
                                if(value_path == "delay-model"):
                                    self.delay_model = value
                                    self.delay_model.value_namespace = name_space
                                    self.delay_model.value_namespace_prefix = name_space_prefix
                                if(value_path == "reply-filter"):
                                    self.reply_filter = value
                                    self.reply_filter.value_namespace = name_space
                                    self.reply_filter.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.mode.is_set or
                                (self.basic_options is not None and self.basic_options.has_data()) or
                                (self.exploratory_options is not None and self.exploratory_options.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.mode.yfilter != YFilter.not_set or
                                (self.basic_options is not None and self.basic_options.has_operation()) or
                                (self.exploratory_options is not None and self.exploratory_options.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "options" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.mode.is_set or self.mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mode.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "basic-options"):
                                if (self.basic_options is None):
                                    self.basic_options = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.BasicOptions()
                                    self.basic_options.parent = self
                                    self._children_name_map["basic_options"] = "basic-options"
                                return self.basic_options

                            if (child_yang_name == "exploratory-options"):
                                if (self.exploratory_options is None):
                                    self.exploratory_options = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options.ExploratoryOptions()
                                    self.exploratory_options.parent = self
                                    self._children_name_map["exploratory_options"] = "exploratory-options"
                                return self.exploratory_options

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "basic-options" or name == "exploratory-options" or name == "mode"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "mode"):
                                self.mode = value
                                self.mode.value_namespace = name_space
                                self.mode.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.directed_mac_address.is_set or
                            self.domain.is_set or
                            self.level.is_set or
                            self.service.is_set or
                            self.source_interface.is_set or
                            self.source_mac_address.is_set or
                            self.source_mep_id.is_set or
                            self.target_mac_address.is_set or
                            self.target_mep_id.is_set or
                            self.timestamp.is_set or
                            self.transaction_id.is_set or
                            self.ttl.is_set or
                            (self.options is not None and self.options.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.directed_mac_address.yfilter != YFilter.not_set or
                            self.domain.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.service.yfilter != YFilter.not_set or
                            self.source_interface.yfilter != YFilter.not_set or
                            self.source_mac_address.yfilter != YFilter.not_set or
                            self.source_mep_id.yfilter != YFilter.not_set or
                            self.target_mac_address.yfilter != YFilter.not_set or
                            self.target_mep_id.yfilter != YFilter.not_set or
                            self.timestamp.yfilter != YFilter.not_set or
                            self.transaction_id.yfilter != YFilter.not_set or
                            self.ttl.yfilter != YFilter.not_set or
                            (self.options is not None and self.options.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "traceroute-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.directed_mac_address.is_set or self.directed_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.directed_mac_address.get_name_leafdata())
                        if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.domain.get_name_leafdata())
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.service.get_name_leafdata())
                        if (self.source_interface.is_set or self.source_interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_interface.get_name_leafdata())
                        if (self.source_mac_address.is_set or self.source_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_mac_address.get_name_leafdata())
                        if (self.source_mep_id.is_set or self.source_mep_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_mep_id.get_name_leafdata())
                        if (self.target_mac_address.is_set or self.target_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.target_mac_address.get_name_leafdata())
                        if (self.target_mep_id.is_set or self.target_mep_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.target_mep_id.get_name_leafdata())
                        if (self.timestamp.is_set or self.timestamp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.timestamp.get_name_leafdata())
                        if (self.transaction_id.is_set or self.transaction_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.transaction_id.get_name_leafdata())
                        if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "options"):
                            if (self.options is None):
                                self.options = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation.Options()
                                self.options.parent = self
                                self._children_name_map["options"] = "options"
                            return self.options

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "options" or name == "directed-mac-address" or name == "domain" or name == "level" or name == "service" or name == "source-interface" or name == "source-mac-address" or name == "source-mep-id" or name == "target-mac-address" or name == "target-mep-id" or name == "timestamp" or name == "transaction-id" or name == "ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "directed-mac-address"):
                            self.directed_mac_address = value
                            self.directed_mac_address.value_namespace = name_space
                            self.directed_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "domain"):
                            self.domain = value
                            self.domain.value_namespace = name_space
                            self.domain.value_namespace_prefix = name_space_prefix
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "service"):
                            self.service = value
                            self.service.value_namespace = name_space
                            self.service.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-interface"):
                            self.source_interface = value
                            self.source_interface.value_namespace = name_space
                            self.source_interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-mac-address"):
                            self.source_mac_address = value
                            self.source_mac_address.value_namespace = name_space
                            self.source_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-mep-id"):
                            self.source_mep_id = value
                            self.source_mep_id.value_namespace = name_space
                            self.source_mep_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "target-mac-address"):
                            self.target_mac_address = value
                            self.target_mac_address.value_namespace = name_space
                            self.target_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "target-mep-id"):
                            self.target_mep_id = value
                            self.target_mep_id.value_namespace = name_space
                            self.target_mep_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "timestamp"):
                            self.timestamp = value
                            self.timestamp.value_namespace = name_space
                            self.timestamp.value_namespace_prefix = name_space_prefix
                        if(value_path == "transaction-id"):
                            self.transaction_id = value
                            self.transaction_id.value_namespace = name_space
                            self.transaction_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "ttl"):
                            self.ttl = value
                            self.ttl.value_namespace = name_space
                            self.ttl.value_namespace_prefix = name_space_prefix


                class LinktraceReply(Entity):
                    """
                    Received linktrace replies
                    
                    .. attribute:: egress_id
                    
                    	Egress ID TLV
                    	**type**\:   :py:class:`EgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId>`
                    
                    .. attribute:: header
                    
                    	Frame header
                    	**type**\:   :py:class:`Header <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.Header>`
                    
                    .. attribute:: last_hop
                    
                    	Last hop ID
                    	**type**\:   :py:class:`LastHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop>`
                    
                    .. attribute:: organization_specific_tlv
                    
                    	Organizational\-specific TLVs
                    	**type**\: list of    :py:class:`OrganizationSpecificTlv <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.OrganizationSpecificTlv>`
                    
                    .. attribute:: raw_data
                    
                    	Undecoded frame
                    	**type**\:  str
                    
                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                    
                    .. attribute:: reply_egress
                    
                    	Reply egress TLV
                    	**type**\:   :py:class:`ReplyEgress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress>`
                    
                    .. attribute:: reply_ingress
                    
                    	Reply ingress TLV
                    	**type**\:   :py:class:`ReplyIngress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress>`
                    
                    .. attribute:: sender_id
                    
                    	Sender ID TLV
                    	**type**\:   :py:class:`SenderId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId>`
                    
                    .. attribute:: unknown_tlv
                    
                    	Unknown TLVs
                    	**type**\: list of    :py:class:`UnknownTlv <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.UnknownTlv>`
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply, self).__init__()

                        self.yang_name = "linktrace-reply"
                        self.yang_parent_name = "traceroute-cache"

                        self.raw_data = YLeaf(YType.str, "raw-data")

                        self.egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId()
                        self.egress_id.parent = self
                        self._children_name_map["egress_id"] = "egress-id"
                        self._children_yang_names.add("egress-id")

                        self.header = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.Header()
                        self.header.parent = self
                        self._children_name_map["header"] = "header"
                        self._children_yang_names.add("header")

                        self.last_hop = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop()
                        self.last_hop.parent = self
                        self._children_name_map["last_hop"] = "last-hop"
                        self._children_yang_names.add("last-hop")

                        self.reply_egress = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress()
                        self.reply_egress.parent = self
                        self._children_name_map["reply_egress"] = "reply-egress"
                        self._children_yang_names.add("reply-egress")

                        self.reply_ingress = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress()
                        self.reply_ingress.parent = self
                        self._children_name_map["reply_ingress"] = "reply-ingress"
                        self._children_yang_names.add("reply-ingress")

                        self.sender_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId()
                        self.sender_id.parent = self
                        self._children_name_map["sender_id"] = "sender-id"
                        self._children_yang_names.add("sender-id")

                        self.organization_specific_tlv = YList(self)
                        self.unknown_tlv = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("raw_data") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply, self).__setattr__(name, value)


                    class Header(Entity):
                        """
                        Frame header
                        
                        .. attribute:: forwarded
                        
                        	LTR was forwarded
                        	**type**\:  bool
                        
                        .. attribute:: level
                        
                        	MD level
                        	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                        
                        .. attribute:: relay_action
                        
                        	Relay action
                        	**type**\:   :py:class:`CfmPmRelayAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmRelayAction>`
                        
                        .. attribute:: terminal_mep
                        
                        	Terminal MEP reached
                        	**type**\:  bool
                        
                        .. attribute:: transaction_id
                        
                        	Transaction ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ttl
                        
                        	TTL
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: use_fdb_only
                        
                        	Use filtering DB only
                        	**type**\:  bool
                        
                        .. attribute:: version
                        
                        	Version
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.Header, self).__init__()

                            self.yang_name = "header"
                            self.yang_parent_name = "linktrace-reply"

                            self.forwarded = YLeaf(YType.boolean, "forwarded")

                            self.level = YLeaf(YType.enumeration, "level")

                            self.relay_action = YLeaf(YType.enumeration, "relay-action")

                            self.terminal_mep = YLeaf(YType.boolean, "terminal-mep")

                            self.transaction_id = YLeaf(YType.uint32, "transaction-id")

                            self.ttl = YLeaf(YType.uint8, "ttl")

                            self.use_fdb_only = YLeaf(YType.boolean, "use-fdb-only")

                            self.version = YLeaf(YType.uint8, "version")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("forwarded",
                                            "level",
                                            "relay_action",
                                            "terminal_mep",
                                            "transaction_id",
                                            "ttl",
                                            "use_fdb_only",
                                            "version") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.Header, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.Header, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.forwarded.is_set or
                                self.level.is_set or
                                self.relay_action.is_set or
                                self.terminal_mep.is_set or
                                self.transaction_id.is_set or
                                self.ttl.is_set or
                                self.use_fdb_only.is_set or
                                self.version.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.forwarded.yfilter != YFilter.not_set or
                                self.level.yfilter != YFilter.not_set or
                                self.relay_action.yfilter != YFilter.not_set or
                                self.terminal_mep.yfilter != YFilter.not_set or
                                self.transaction_id.yfilter != YFilter.not_set or
                                self.ttl.yfilter != YFilter.not_set or
                                self.use_fdb_only.yfilter != YFilter.not_set or
                                self.version.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "header" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.forwarded.is_set or self.forwarded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.forwarded.get_name_leafdata())
                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.level.get_name_leafdata())
                            if (self.relay_action.is_set or self.relay_action.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.relay_action.get_name_leafdata())
                            if (self.terminal_mep.is_set or self.terminal_mep.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.terminal_mep.get_name_leafdata())
                            if (self.transaction_id.is_set or self.transaction_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.transaction_id.get_name_leafdata())
                            if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ttl.get_name_leafdata())
                            if (self.use_fdb_only.is_set or self.use_fdb_only.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.use_fdb_only.get_name_leafdata())
                            if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.version.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "forwarded" or name == "level" or name == "relay-action" or name == "terminal-mep" or name == "transaction-id" or name == "ttl" or name == "use-fdb-only" or name == "version"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "forwarded"):
                                self.forwarded = value
                                self.forwarded.value_namespace = name_space
                                self.forwarded.value_namespace_prefix = name_space_prefix
                            if(value_path == "level"):
                                self.level = value
                                self.level.value_namespace = name_space
                                self.level.value_namespace_prefix = name_space_prefix
                            if(value_path == "relay-action"):
                                self.relay_action = value
                                self.relay_action.value_namespace = name_space
                                self.relay_action.value_namespace_prefix = name_space_prefix
                            if(value_path == "terminal-mep"):
                                self.terminal_mep = value
                                self.terminal_mep.value_namespace = name_space
                                self.terminal_mep.value_namespace_prefix = name_space_prefix
                            if(value_path == "transaction-id"):
                                self.transaction_id = value
                                self.transaction_id.value_namespace = name_space
                                self.transaction_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ttl"):
                                self.ttl = value
                                self.ttl.value_namespace = name_space
                                self.ttl.value_namespace_prefix = name_space_prefix
                            if(value_path == "use-fdb-only"):
                                self.use_fdb_only = value
                                self.use_fdb_only.value_namespace = name_space
                                self.use_fdb_only.value_namespace_prefix = name_space_prefix
                            if(value_path == "version"):
                                self.version = value
                                self.version.value_namespace = name_space
                                self.version.value_namespace_prefix = name_space_prefix


                    class SenderId(Entity):
                        """
                        Sender ID TLV
                        
                        .. attribute:: chassis_id
                        
                        	Chassis ID
                        	**type**\:   :py:class:`ChassisId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId>`
                        
                        .. attribute:: management_address
                        
                        	Management address
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: management_address_domain
                        
                        	Management address domain
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId, self).__init__()

                            self.yang_name = "sender-id"
                            self.yang_parent_name = "linktrace-reply"

                            self.management_address = YLeaf(YType.str, "management-address")

                            self.management_address_domain = YLeaf(YType.str, "management-address-domain")

                            self.chassis_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId()
                            self.chassis_id.parent = self
                            self._children_name_map["chassis_id"] = "chassis-id"
                            self._children_yang_names.add("chassis-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("management_address",
                                            "management_address_domain") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId, self).__setattr__(name, value)


                        class ChassisId(Entity):
                            """
                            Chassis ID
                            
                            .. attribute:: chassis_id
                            
                            	Chassis ID (Deprecated)
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: chassis_id_type
                            
                            	Chassis ID Type
                            	**type**\:   :py:class:`CfmPmChassisIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmChassisIdFmt>`
                            
                            .. attribute:: chassis_id_type_value
                            
                            	Chassis ID Type
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: chassis_id_value
                            
                            	Chassis ID (Current)
                            	**type**\:   :py:class:`ChassisIdValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId.ChassisIdValue>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId, self).__init__()

                                self.yang_name = "chassis-id"
                                self.yang_parent_name = "sender-id"

                                self.chassis_id = YLeaf(YType.str, "chassis-id")

                                self.chassis_id_type = YLeaf(YType.enumeration, "chassis-id-type")

                                self.chassis_id_type_value = YLeaf(YType.uint8, "chassis-id-type-value")

                                self.chassis_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId.ChassisIdValue()
                                self.chassis_id_value.parent = self
                                self._children_name_map["chassis_id_value"] = "chassis-id-value"
                                self._children_yang_names.add("chassis-id-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("chassis_id",
                                                "chassis_id_type",
                                                "chassis_id_type_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId, self).__setattr__(name, value)


                            class ChassisIdValue(Entity):
                                """
                                Chassis ID (Current)
                                
                                .. attribute:: chassis_id_format
                                
                                	ChassisIDFormat
                                	**type**\:   :py:class:`CfmPmIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIdFmt>`
                                
                                .. attribute:: chassis_id_mac
                                
                                	Chassis ID MAC Address
                                	**type**\:  str
                                
                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                
                                .. attribute:: chassis_id_raw
                                
                                	Raw Chassis ID
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: chassis_id_string
                                
                                	Chassis ID String
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId.ChassisIdValue, self).__init__()

                                    self.yang_name = "chassis-id-value"
                                    self.yang_parent_name = "chassis-id"

                                    self.chassis_id_format = YLeaf(YType.enumeration, "chassis-id-format")

                                    self.chassis_id_mac = YLeaf(YType.str, "chassis-id-mac")

                                    self.chassis_id_raw = YLeaf(YType.str, "chassis-id-raw")

                                    self.chassis_id_string = YLeaf(YType.str, "chassis-id-string")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("chassis_id_format",
                                                    "chassis_id_mac",
                                                    "chassis_id_raw",
                                                    "chassis_id_string") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId.ChassisIdValue, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId.ChassisIdValue, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.chassis_id_format.is_set or
                                        self.chassis_id_mac.is_set or
                                        self.chassis_id_raw.is_set or
                                        self.chassis_id_string.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.chassis_id_format.yfilter != YFilter.not_set or
                                        self.chassis_id_mac.yfilter != YFilter.not_set or
                                        self.chassis_id_raw.yfilter != YFilter.not_set or
                                        self.chassis_id_string.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "chassis-id-value" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.chassis_id_format.is_set or self.chassis_id_format.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_format.get_name_leafdata())
                                    if (self.chassis_id_mac.is_set or self.chassis_id_mac.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_mac.get_name_leafdata())
                                    if (self.chassis_id_raw.is_set or self.chassis_id_raw.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_raw.get_name_leafdata())
                                    if (self.chassis_id_string.is_set or self.chassis_id_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_string.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "chassis-id-format" or name == "chassis-id-mac" or name == "chassis-id-raw" or name == "chassis-id-string"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "chassis-id-format"):
                                        self.chassis_id_format = value
                                        self.chassis_id_format.value_namespace = name_space
                                        self.chassis_id_format.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-mac"):
                                        self.chassis_id_mac = value
                                        self.chassis_id_mac.value_namespace = name_space
                                        self.chassis_id_mac.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-raw"):
                                        self.chassis_id_raw = value
                                        self.chassis_id_raw.value_namespace = name_space
                                        self.chassis_id_raw.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-string"):
                                        self.chassis_id_string = value
                                        self.chassis_id_string.value_namespace = name_space
                                        self.chassis_id_string.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.chassis_id.is_set or
                                    self.chassis_id_type.is_set or
                                    self.chassis_id_type_value.is_set or
                                    (self.chassis_id_value is not None and self.chassis_id_value.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.chassis_id.yfilter != YFilter.not_set or
                                    self.chassis_id_type.yfilter != YFilter.not_set or
                                    self.chassis_id_type_value.yfilter != YFilter.not_set or
                                    (self.chassis_id_value is not None and self.chassis_id_value.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "chassis-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.chassis_id.is_set or self.chassis_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.chassis_id.get_name_leafdata())
                                if (self.chassis_id_type.is_set or self.chassis_id_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.chassis_id_type.get_name_leafdata())
                                if (self.chassis_id_type_value.is_set or self.chassis_id_type_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.chassis_id_type_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "chassis-id-value"):
                                    if (self.chassis_id_value is None):
                                        self.chassis_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId.ChassisIdValue()
                                        self.chassis_id_value.parent = self
                                        self._children_name_map["chassis_id_value"] = "chassis-id-value"
                                    return self.chassis_id_value

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "chassis-id-value" or name == "chassis-id" or name == "chassis-id-type" or name == "chassis-id-type-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "chassis-id"):
                                    self.chassis_id = value
                                    self.chassis_id.value_namespace = name_space
                                    self.chassis_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "chassis-id-type"):
                                    self.chassis_id_type = value
                                    self.chassis_id_type.value_namespace = name_space
                                    self.chassis_id_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "chassis-id-type-value"):
                                    self.chassis_id_type_value = value
                                    self.chassis_id_type_value.value_namespace = name_space
                                    self.chassis_id_type_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.management_address.is_set or
                                self.management_address_domain.is_set or
                                (self.chassis_id is not None and self.chassis_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.management_address.yfilter != YFilter.not_set or
                                self.management_address_domain.yfilter != YFilter.not_set or
                                (self.chassis_id is not None and self.chassis_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sender-id" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.management_address.is_set or self.management_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.management_address.get_name_leafdata())
                            if (self.management_address_domain.is_set or self.management_address_domain.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.management_address_domain.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "chassis-id"):
                                if (self.chassis_id is None):
                                    self.chassis_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId.ChassisId()
                                    self.chassis_id.parent = self
                                    self._children_name_map["chassis_id"] = "chassis-id"
                                return self.chassis_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "chassis-id" or name == "management-address" or name == "management-address-domain"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "management-address"):
                                self.management_address = value
                                self.management_address.value_namespace = name_space
                                self.management_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "management-address-domain"):
                                self.management_address_domain = value
                                self.management_address_domain.value_namespace = name_space
                                self.management_address_domain.value_namespace_prefix = name_space_prefix


                    class EgressId(Entity):
                        """
                        Egress ID TLV
                        
                        .. attribute:: last_egress_id
                        
                        	Last egress ID
                        	**type**\:   :py:class:`LastEgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.LastEgressId>`
                        
                        .. attribute:: next_egress_id
                        
                        	Next egress ID
                        	**type**\:   :py:class:`NextEgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.NextEgressId>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId, self).__init__()

                            self.yang_name = "egress-id"
                            self.yang_parent_name = "linktrace-reply"

                            self.last_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.LastEgressId()
                            self.last_egress_id.parent = self
                            self._children_name_map["last_egress_id"] = "last-egress-id"
                            self._children_yang_names.add("last-egress-id")

                            self.next_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.NextEgressId()
                            self.next_egress_id.parent = self
                            self._children_name_map["next_egress_id"] = "next-egress-id"
                            self._children_yang_names.add("next-egress-id")


                        class LastEgressId(Entity):
                            """
                            Last egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.LastEgressId, self).__init__()

                                self.yang_name = "last-egress-id"
                                self.yang_parent_name = "egress-id"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.LastEgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.LastEgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "last-egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix


                        class NextEgressId(Entity):
                            """
                            Next egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.NextEgressId, self).__init__()

                                self.yang_name = "next-egress-id"
                                self.yang_parent_name = "egress-id"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.NextEgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.NextEgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "next-egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.last_egress_id is not None and self.last_egress_id.has_data()) or
                                (self.next_egress_id is not None and self.next_egress_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.last_egress_id is not None and self.last_egress_id.has_operation()) or
                                (self.next_egress_id is not None and self.next_egress_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "egress-id" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "last-egress-id"):
                                if (self.last_egress_id is None):
                                    self.last_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.LastEgressId()
                                    self.last_egress_id.parent = self
                                    self._children_name_map["last_egress_id"] = "last-egress-id"
                                return self.last_egress_id

                            if (child_yang_name == "next-egress-id"):
                                if (self.next_egress_id is None):
                                    self.next_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId.NextEgressId()
                                    self.next_egress_id.parent = self
                                    self._children_name_map["next_egress_id"] = "next-egress-id"
                                return self.next_egress_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "last-egress-id" or name == "next-egress-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class ReplyIngress(Entity):
                        """
                        Reply ingress TLV
                        
                        .. attribute:: action
                        
                        	Reply ingress action
                        	**type**\:   :py:class:`CfmPmIngressAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIngressAction>`
                        
                        .. attribute:: mac_address
                        
                        	MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: port_id
                        
                        	Port ID
                        	**type**\:   :py:class:`PortId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress, self).__init__()

                            self.yang_name = "reply-ingress"
                            self.yang_parent_name = "linktrace-reply"

                            self.action = YLeaf(YType.enumeration, "action")

                            self.mac_address = YLeaf(YType.str, "mac-address")

                            self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId()
                            self.port_id.parent = self
                            self._children_name_map["port_id"] = "port-id"
                            self._children_yang_names.add("port-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("action",
                                            "mac_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress, self).__setattr__(name, value)


                        class PortId(Entity):
                            """
                            Port ID
                            
                            .. attribute:: port_id
                            
                            	Port ID (Deprecated)
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: port_id_type
                            
                            	Port ID type
                            	**type**\:   :py:class:`CfmPmPortIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmPortIdFmt>`
                            
                            .. attribute:: port_id_type_value
                            
                            	Port ID type value
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: port_id_value
                            
                            	Port ID (Current)
                            	**type**\:   :py:class:`PortIdValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId.PortIdValue>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId, self).__init__()

                                self.yang_name = "port-id"
                                self.yang_parent_name = "reply-ingress"

                                self.port_id = YLeaf(YType.str, "port-id")

                                self.port_id_type = YLeaf(YType.enumeration, "port-id-type")

                                self.port_id_type_value = YLeaf(YType.uint8, "port-id-type-value")

                                self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId.PortIdValue()
                                self.port_id_value.parent = self
                                self._children_name_map["port_id_value"] = "port-id-value"
                                self._children_yang_names.add("port-id-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("port_id",
                                                "port_id_type",
                                                "port_id_type_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId, self).__setattr__(name, value)


                            class PortIdValue(Entity):
                                """
                                Port ID (Current)
                                
                                .. attribute:: port_id_format
                                
                                	PortIDFormat
                                	**type**\:   :py:class:`CfmPmIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIdFmt>`
                                
                                .. attribute:: port_id_mac
                                
                                	Port ID MAC Address
                                	**type**\:  str
                                
                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                
                                .. attribute:: port_id_raw
                                
                                	Raw Port ID
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: port_id_string
                                
                                	Port ID String
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId.PortIdValue, self).__init__()

                                    self.yang_name = "port-id-value"
                                    self.yang_parent_name = "port-id"

                                    self.port_id_format = YLeaf(YType.enumeration, "port-id-format")

                                    self.port_id_mac = YLeaf(YType.str, "port-id-mac")

                                    self.port_id_raw = YLeaf(YType.str, "port-id-raw")

                                    self.port_id_string = YLeaf(YType.str, "port-id-string")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("port_id_format",
                                                    "port_id_mac",
                                                    "port_id_raw",
                                                    "port_id_string") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId.PortIdValue, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId.PortIdValue, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.port_id_format.is_set or
                                        self.port_id_mac.is_set or
                                        self.port_id_raw.is_set or
                                        self.port_id_string.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.port_id_format.yfilter != YFilter.not_set or
                                        self.port_id_mac.yfilter != YFilter.not_set or
                                        self.port_id_raw.yfilter != YFilter.not_set or
                                        self.port_id_string.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "port-id-value" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.port_id_format.is_set or self.port_id_format.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_format.get_name_leafdata())
                                    if (self.port_id_mac.is_set or self.port_id_mac.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_mac.get_name_leafdata())
                                    if (self.port_id_raw.is_set or self.port_id_raw.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_raw.get_name_leafdata())
                                    if (self.port_id_string.is_set or self.port_id_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_string.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "port-id-format" or name == "port-id-mac" or name == "port-id-raw" or name == "port-id-string"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "port-id-format"):
                                        self.port_id_format = value
                                        self.port_id_format.value_namespace = name_space
                                        self.port_id_format.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-mac"):
                                        self.port_id_mac = value
                                        self.port_id_mac.value_namespace = name_space
                                        self.port_id_mac.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-raw"):
                                        self.port_id_raw = value
                                        self.port_id_raw.value_namespace = name_space
                                        self.port_id_raw.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-string"):
                                        self.port_id_string = value
                                        self.port_id_string.value_namespace = name_space
                                        self.port_id_string.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.port_id.is_set or
                                    self.port_id_type.is_set or
                                    self.port_id_type_value.is_set or
                                    (self.port_id_value is not None and self.port_id_value.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.port_id.yfilter != YFilter.not_set or
                                    self.port_id_type.yfilter != YFilter.not_set or
                                    self.port_id_type_value.yfilter != YFilter.not_set or
                                    (self.port_id_value is not None and self.port_id_value.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "port-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.port_id.is_set or self.port_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id.get_name_leafdata())
                                if (self.port_id_type.is_set or self.port_id_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type.get_name_leafdata())
                                if (self.port_id_type_value.is_set or self.port_id_type_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "port-id-value"):
                                    if (self.port_id_value is None):
                                        self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId.PortIdValue()
                                        self.port_id_value.parent = self
                                        self._children_name_map["port_id_value"] = "port-id-value"
                                    return self.port_id_value

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "port-id-value" or name == "port-id" or name == "port-id-type" or name == "port-id-type-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "port-id"):
                                    self.port_id = value
                                    self.port_id.value_namespace = name_space
                                    self.port_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type"):
                                    self.port_id_type = value
                                    self.port_id_type.value_namespace = name_space
                                    self.port_id_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type-value"):
                                    self.port_id_type_value = value
                                    self.port_id_type_value.value_namespace = name_space
                                    self.port_id_type_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.action.is_set or
                                self.mac_address.is_set or
                                (self.port_id is not None and self.port_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.action.yfilter != YFilter.not_set or
                                self.mac_address.yfilter != YFilter.not_set or
                                (self.port_id is not None and self.port_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reply-ingress" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.action.get_name_leafdata())
                            if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "port-id"):
                                if (self.port_id is None):
                                    self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress.PortId()
                                    self.port_id.parent = self
                                    self._children_name_map["port_id"] = "port-id"
                                return self.port_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "port-id" or name == "action" or name == "mac-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "action"):
                                self.action = value
                                self.action.value_namespace = name_space
                                self.action.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address"):
                                self.mac_address = value
                                self.mac_address.value_namespace = name_space
                                self.mac_address.value_namespace_prefix = name_space_prefix


                    class ReplyEgress(Entity):
                        """
                        Reply egress TLV
                        
                        .. attribute:: action
                        
                        	Reply egress action
                        	**type**\:   :py:class:`CfmPmEgressAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmEgressAction>`
                        
                        .. attribute:: mac_address
                        
                        	MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: port_id
                        
                        	Port ID
                        	**type**\:   :py:class:`PortId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress, self).__init__()

                            self.yang_name = "reply-egress"
                            self.yang_parent_name = "linktrace-reply"

                            self.action = YLeaf(YType.enumeration, "action")

                            self.mac_address = YLeaf(YType.str, "mac-address")

                            self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId()
                            self.port_id.parent = self
                            self._children_name_map["port_id"] = "port-id"
                            self._children_yang_names.add("port-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("action",
                                            "mac_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress, self).__setattr__(name, value)


                        class PortId(Entity):
                            """
                            Port ID
                            
                            .. attribute:: port_id
                            
                            	Port ID (Deprecated)
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: port_id_type
                            
                            	Port ID type
                            	**type**\:   :py:class:`CfmPmPortIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmPortIdFmt>`
                            
                            .. attribute:: port_id_type_value
                            
                            	Port ID type value
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: port_id_value
                            
                            	Port ID (Current)
                            	**type**\:   :py:class:`PortIdValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId.PortIdValue>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId, self).__init__()

                                self.yang_name = "port-id"
                                self.yang_parent_name = "reply-egress"

                                self.port_id = YLeaf(YType.str, "port-id")

                                self.port_id_type = YLeaf(YType.enumeration, "port-id-type")

                                self.port_id_type_value = YLeaf(YType.uint8, "port-id-type-value")

                                self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId.PortIdValue()
                                self.port_id_value.parent = self
                                self._children_name_map["port_id_value"] = "port-id-value"
                                self._children_yang_names.add("port-id-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("port_id",
                                                "port_id_type",
                                                "port_id_type_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId, self).__setattr__(name, value)


                            class PortIdValue(Entity):
                                """
                                Port ID (Current)
                                
                                .. attribute:: port_id_format
                                
                                	PortIDFormat
                                	**type**\:   :py:class:`CfmPmIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIdFmt>`
                                
                                .. attribute:: port_id_mac
                                
                                	Port ID MAC Address
                                	**type**\:  str
                                
                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                
                                .. attribute:: port_id_raw
                                
                                	Raw Port ID
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: port_id_string
                                
                                	Port ID String
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId.PortIdValue, self).__init__()

                                    self.yang_name = "port-id-value"
                                    self.yang_parent_name = "port-id"

                                    self.port_id_format = YLeaf(YType.enumeration, "port-id-format")

                                    self.port_id_mac = YLeaf(YType.str, "port-id-mac")

                                    self.port_id_raw = YLeaf(YType.str, "port-id-raw")

                                    self.port_id_string = YLeaf(YType.str, "port-id-string")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("port_id_format",
                                                    "port_id_mac",
                                                    "port_id_raw",
                                                    "port_id_string") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId.PortIdValue, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId.PortIdValue, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.port_id_format.is_set or
                                        self.port_id_mac.is_set or
                                        self.port_id_raw.is_set or
                                        self.port_id_string.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.port_id_format.yfilter != YFilter.not_set or
                                        self.port_id_mac.yfilter != YFilter.not_set or
                                        self.port_id_raw.yfilter != YFilter.not_set or
                                        self.port_id_string.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "port-id-value" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.port_id_format.is_set or self.port_id_format.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_format.get_name_leafdata())
                                    if (self.port_id_mac.is_set or self.port_id_mac.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_mac.get_name_leafdata())
                                    if (self.port_id_raw.is_set or self.port_id_raw.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_raw.get_name_leafdata())
                                    if (self.port_id_string.is_set or self.port_id_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_string.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "port-id-format" or name == "port-id-mac" or name == "port-id-raw" or name == "port-id-string"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "port-id-format"):
                                        self.port_id_format = value
                                        self.port_id_format.value_namespace = name_space
                                        self.port_id_format.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-mac"):
                                        self.port_id_mac = value
                                        self.port_id_mac.value_namespace = name_space
                                        self.port_id_mac.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-raw"):
                                        self.port_id_raw = value
                                        self.port_id_raw.value_namespace = name_space
                                        self.port_id_raw.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-string"):
                                        self.port_id_string = value
                                        self.port_id_string.value_namespace = name_space
                                        self.port_id_string.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.port_id.is_set or
                                    self.port_id_type.is_set or
                                    self.port_id_type_value.is_set or
                                    (self.port_id_value is not None and self.port_id_value.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.port_id.yfilter != YFilter.not_set or
                                    self.port_id_type.yfilter != YFilter.not_set or
                                    self.port_id_type_value.yfilter != YFilter.not_set or
                                    (self.port_id_value is not None and self.port_id_value.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "port-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.port_id.is_set or self.port_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id.get_name_leafdata())
                                if (self.port_id_type.is_set or self.port_id_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type.get_name_leafdata())
                                if (self.port_id_type_value.is_set or self.port_id_type_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "port-id-value"):
                                    if (self.port_id_value is None):
                                        self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId.PortIdValue()
                                        self.port_id_value.parent = self
                                        self._children_name_map["port_id_value"] = "port-id-value"
                                    return self.port_id_value

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "port-id-value" or name == "port-id" or name == "port-id-type" or name == "port-id-type-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "port-id"):
                                    self.port_id = value
                                    self.port_id.value_namespace = name_space
                                    self.port_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type"):
                                    self.port_id_type = value
                                    self.port_id_type.value_namespace = name_space
                                    self.port_id_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type-value"):
                                    self.port_id_type_value = value
                                    self.port_id_type_value.value_namespace = name_space
                                    self.port_id_type_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.action.is_set or
                                self.mac_address.is_set or
                                (self.port_id is not None and self.port_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.action.yfilter != YFilter.not_set or
                                self.mac_address.yfilter != YFilter.not_set or
                                (self.port_id is not None and self.port_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reply-egress" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.action.get_name_leafdata())
                            if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "port-id"):
                                if (self.port_id is None):
                                    self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress.PortId()
                                    self.port_id.parent = self
                                    self._children_name_map["port_id"] = "port-id"
                                return self.port_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "port-id" or name == "action" or name == "mac-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "action"):
                                self.action = value
                                self.action.value_namespace = name_space
                                self.action.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address"):
                                self.mac_address = value
                                self.mac_address.value_namespace = name_space
                                self.mac_address.value_namespace_prefix = name_space_prefix


                    class LastHop(Entity):
                        """
                        Last hop ID
                        
                        .. attribute:: egress_id
                        
                        	Egress ID
                        	**type**\:   :py:class:`EgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop.EgressId>`
                        
                        .. attribute:: host_name
                        
                        	Hostname
                        	**type**\:  str
                        
                        .. attribute:: last_hop_format
                        
                        	LastHopFormat
                        	**type**\:   :py:class:`CfmPmLastHopFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmLastHopFmt>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop, self).__init__()

                            self.yang_name = "last-hop"
                            self.yang_parent_name = "linktrace-reply"

                            self.host_name = YLeaf(YType.str, "host-name")

                            self.last_hop_format = YLeaf(YType.enumeration, "last-hop-format")

                            self.egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop.EgressId()
                            self.egress_id.parent = self
                            self._children_name_map["egress_id"] = "egress-id"
                            self._children_yang_names.add("egress-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("host_name",
                                            "last_hop_format") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop, self).__setattr__(name, value)


                        class EgressId(Entity):
                            """
                            Egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop.EgressId, self).__init__()

                                self.yang_name = "egress-id"
                                self.yang_parent_name = "last-hop"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop.EgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop.EgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.host_name.is_set or
                                self.last_hop_format.is_set or
                                (self.egress_id is not None and self.egress_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.host_name.yfilter != YFilter.not_set or
                                self.last_hop_format.yfilter != YFilter.not_set or
                                (self.egress_id is not None and self.egress_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "last-hop" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.host_name.get_name_leafdata())
                            if (self.last_hop_format.is_set or self.last_hop_format.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_hop_format.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "egress-id"):
                                if (self.egress_id is None):
                                    self.egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop.EgressId()
                                    self.egress_id.parent = self
                                    self._children_name_map["egress_id"] = "egress-id"
                                return self.egress_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "egress-id" or name == "host-name" or name == "last-hop-format"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "host-name"):
                                self.host_name = value
                                self.host_name.value_namespace = name_space
                                self.host_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-hop-format"):
                                self.last_hop_format = value
                                self.last_hop_format.value_namespace = name_space
                                self.last_hop_format.value_namespace_prefix = name_space_prefix


                    class OrganizationSpecificTlv(Entity):
                        """
                        Organizational\-specific TLVs
                        
                        .. attribute:: oui
                        
                        	Organizationally\-unique ID
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: subtype
                        
                        	Subtype of TLV
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: value
                        
                        	Binary data in TLV
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.OrganizationSpecificTlv, self).__init__()

                            self.yang_name = "organization-specific-tlv"
                            self.yang_parent_name = "linktrace-reply"

                            self.oui = YLeaf(YType.str, "oui")

                            self.subtype = YLeaf(YType.uint8, "subtype")

                            self.value = YLeaf(YType.str, "value")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("oui",
                                            "subtype",
                                            "value") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.OrganizationSpecificTlv, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.OrganizationSpecificTlv, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.oui.is_set or
                                self.subtype.is_set or
                                self.value.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.oui.yfilter != YFilter.not_set or
                                self.subtype.yfilter != YFilter.not_set or
                                self.value.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "organization-specific-tlv" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.oui.is_set or self.oui.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.oui.get_name_leafdata())
                            if (self.subtype.is_set or self.subtype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.subtype.get_name_leafdata())
                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.value.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "oui" or name == "subtype" or name == "value"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "oui"):
                                self.oui = value
                                self.oui.value_namespace = name_space
                                self.oui.value_namespace_prefix = name_space_prefix
                            if(value_path == "subtype"):
                                self.subtype = value
                                self.subtype.value_namespace = name_space
                                self.subtype.value_namespace_prefix = name_space_prefix
                            if(value_path == "value"):
                                self.value = value
                                self.value.value_namespace = name_space
                                self.value.value_namespace_prefix = name_space_prefix


                    class UnknownTlv(Entity):
                        """
                        Unknown TLVs
                        
                        .. attribute:: typecode
                        
                        	Type code of TLV
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: value
                        
                        	Binary data in TLV
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.UnknownTlv, self).__init__()

                            self.yang_name = "unknown-tlv"
                            self.yang_parent_name = "linktrace-reply"

                            self.typecode = YLeaf(YType.uint8, "typecode")

                            self.value = YLeaf(YType.str, "value")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("typecode",
                                            "value") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.UnknownTlv, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.UnknownTlv, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.typecode.is_set or
                                self.value.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.typecode.yfilter != YFilter.not_set or
                                self.value.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "unknown-tlv" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.typecode.is_set or self.typecode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.typecode.get_name_leafdata())
                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.value.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "typecode" or name == "value"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "typecode"):
                                self.typecode = value
                                self.typecode.value_namespace = name_space
                                self.typecode.value_namespace_prefix = name_space_prefix
                            if(value_path == "value"):
                                self.value = value
                                self.value.value_namespace = name_space
                                self.value.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.organization_specific_tlv:
                            if (c.has_data()):
                                return True
                        for c in self.unknown_tlv:
                            if (c.has_data()):
                                return True
                        return (
                            self.raw_data.is_set or
                            (self.egress_id is not None and self.egress_id.has_data()) or
                            (self.header is not None and self.header.has_data()) or
                            (self.last_hop is not None and self.last_hop.has_data()) or
                            (self.reply_egress is not None and self.reply_egress.has_data()) or
                            (self.reply_ingress is not None and self.reply_ingress.has_data()) or
                            (self.sender_id is not None and self.sender_id.has_data()))

                    def has_operation(self):
                        for c in self.organization_specific_tlv:
                            if (c.has_operation()):
                                return True
                        for c in self.unknown_tlv:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.raw_data.yfilter != YFilter.not_set or
                            (self.egress_id is not None and self.egress_id.has_operation()) or
                            (self.header is not None and self.header.has_operation()) or
                            (self.last_hop is not None and self.last_hop.has_operation()) or
                            (self.reply_egress is not None and self.reply_egress.has_operation()) or
                            (self.reply_ingress is not None and self.reply_ingress.has_operation()) or
                            (self.sender_id is not None and self.sender_id.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "linktrace-reply" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.raw_data.is_set or self.raw_data.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.raw_data.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "egress-id"):
                            if (self.egress_id is None):
                                self.egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.EgressId()
                                self.egress_id.parent = self
                                self._children_name_map["egress_id"] = "egress-id"
                            return self.egress_id

                        if (child_yang_name == "header"):
                            if (self.header is None):
                                self.header = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.Header()
                                self.header.parent = self
                                self._children_name_map["header"] = "header"
                            return self.header

                        if (child_yang_name == "last-hop"):
                            if (self.last_hop is None):
                                self.last_hop = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.LastHop()
                                self.last_hop.parent = self
                                self._children_name_map["last_hop"] = "last-hop"
                            return self.last_hop

                        if (child_yang_name == "organization-specific-tlv"):
                            for c in self.organization_specific_tlv:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.OrganizationSpecificTlv()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.organization_specific_tlv.append(c)
                            return c

                        if (child_yang_name == "reply-egress"):
                            if (self.reply_egress is None):
                                self.reply_egress = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyEgress()
                                self.reply_egress.parent = self
                                self._children_name_map["reply_egress"] = "reply-egress"
                            return self.reply_egress

                        if (child_yang_name == "reply-ingress"):
                            if (self.reply_ingress is None):
                                self.reply_ingress = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.ReplyIngress()
                                self.reply_ingress.parent = self
                                self._children_name_map["reply_ingress"] = "reply-ingress"
                            return self.reply_ingress

                        if (child_yang_name == "sender-id"):
                            if (self.sender_id is None):
                                self.sender_id = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.SenderId()
                                self.sender_id.parent = self
                                self._children_name_map["sender_id"] = "sender-id"
                            return self.sender_id

                        if (child_yang_name == "unknown-tlv"):
                            for c in self.unknown_tlv:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply.UnknownTlv()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.unknown_tlv.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "egress-id" or name == "header" or name == "last-hop" or name == "organization-specific-tlv" or name == "reply-egress" or name == "reply-ingress" or name == "sender-id" or name == "unknown-tlv" or name == "raw-data"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "raw-data"):
                            self.raw_data = value
                            self.raw_data.value_namespace = name_space
                            self.raw_data.value_namespace_prefix = name_space_prefix


                class ExploratoryLinktraceReply(Entity):
                    """
                    Received exploratory linktrace replies
                    
                    .. attribute:: header
                    
                    	Frame header
                    	**type**\:   :py:class:`Header <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.Header>`
                    
                    .. attribute:: last_hop
                    
                    	Last hop ID
                    	**type**\:   :py:class:`LastHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop>`
                    
                    .. attribute:: organization_specific_tlv
                    
                    	Organizational\-specific TLVs
                    	**type**\: list of    :py:class:`OrganizationSpecificTlv <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.OrganizationSpecificTlv>`
                    
                    .. attribute:: raw_data
                    
                    	Undecoded frame
                    	**type**\:  str
                    
                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                    
                    .. attribute:: reply_egress
                    
                    	Reply egress TLV
                    	**type**\:   :py:class:`ReplyEgress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress>`
                    
                    .. attribute:: reply_ingress
                    
                    	Reply ingress TLV
                    	**type**\:   :py:class:`ReplyIngress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress>`
                    
                    .. attribute:: sender_id
                    
                    	Sender ID TLV
                    	**type**\:   :py:class:`SenderId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId>`
                    
                    .. attribute:: unknown_tlv
                    
                    	Unknown TLVs
                    	**type**\: list of    :py:class:`UnknownTlv <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.UnknownTlv>`
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply, self).__init__()

                        self.yang_name = "exploratory-linktrace-reply"
                        self.yang_parent_name = "traceroute-cache"

                        self.raw_data = YLeaf(YType.str, "raw-data")

                        self.header = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.Header()
                        self.header.parent = self
                        self._children_name_map["header"] = "header"
                        self._children_yang_names.add("header")

                        self.last_hop = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop()
                        self.last_hop.parent = self
                        self._children_name_map["last_hop"] = "last-hop"
                        self._children_yang_names.add("last-hop")

                        self.reply_egress = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress()
                        self.reply_egress.parent = self
                        self._children_name_map["reply_egress"] = "reply-egress"
                        self._children_yang_names.add("reply-egress")

                        self.reply_ingress = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress()
                        self.reply_ingress.parent = self
                        self._children_name_map["reply_ingress"] = "reply-ingress"
                        self._children_yang_names.add("reply-ingress")

                        self.sender_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId()
                        self.sender_id.parent = self
                        self._children_name_map["sender_id"] = "sender-id"
                        self._children_yang_names.add("sender-id")

                        self.organization_specific_tlv = YList(self)
                        self.unknown_tlv = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("raw_data") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply, self).__setattr__(name, value)


                    class Header(Entity):
                        """
                        Frame header
                        
                        .. attribute:: delay_model
                        
                        	Delay Model
                        	**type**\:   :py:class:`CfmPmEltDelayModel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmEltDelayModel>`
                        
                        .. attribute:: forwarded
                        
                        	ELR was forwarded
                        	**type**\:  bool
                        
                        .. attribute:: level
                        
                        	MD level
                        	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                        
                        .. attribute:: next_hop_timeout
                        
                        	Next Hop Timeout, in seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: relay_action
                        
                        	Relay action
                        	**type**\:   :py:class:`CfmPmElrRelayAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmElrRelayAction>`
                        
                        .. attribute:: reply_filter_unknown
                        
                        	Reply Filter unrecognized
                        	**type**\:  bool
                        
                        .. attribute:: terminal_mep
                        
                        	Terminal MEP reached
                        	**type**\:  bool
                        
                        .. attribute:: transaction_id
                        
                        	Transaction ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ttl
                        
                        	TTL
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: version
                        
                        	Version
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.Header, self).__init__()

                            self.yang_name = "header"
                            self.yang_parent_name = "exploratory-linktrace-reply"

                            self.delay_model = YLeaf(YType.enumeration, "delay-model")

                            self.forwarded = YLeaf(YType.boolean, "forwarded")

                            self.level = YLeaf(YType.enumeration, "level")

                            self.next_hop_timeout = YLeaf(YType.uint32, "next-hop-timeout")

                            self.relay_action = YLeaf(YType.enumeration, "relay-action")

                            self.reply_filter_unknown = YLeaf(YType.boolean, "reply-filter-unknown")

                            self.terminal_mep = YLeaf(YType.boolean, "terminal-mep")

                            self.transaction_id = YLeaf(YType.uint32, "transaction-id")

                            self.ttl = YLeaf(YType.uint8, "ttl")

                            self.version = YLeaf(YType.uint8, "version")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("delay_model",
                                            "forwarded",
                                            "level",
                                            "next_hop_timeout",
                                            "relay_action",
                                            "reply_filter_unknown",
                                            "terminal_mep",
                                            "transaction_id",
                                            "ttl",
                                            "version") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.Header, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.Header, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.delay_model.is_set or
                                self.forwarded.is_set or
                                self.level.is_set or
                                self.next_hop_timeout.is_set or
                                self.relay_action.is_set or
                                self.reply_filter_unknown.is_set or
                                self.terminal_mep.is_set or
                                self.transaction_id.is_set or
                                self.ttl.is_set or
                                self.version.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.delay_model.yfilter != YFilter.not_set or
                                self.forwarded.yfilter != YFilter.not_set or
                                self.level.yfilter != YFilter.not_set or
                                self.next_hop_timeout.yfilter != YFilter.not_set or
                                self.relay_action.yfilter != YFilter.not_set or
                                self.reply_filter_unknown.yfilter != YFilter.not_set or
                                self.terminal_mep.yfilter != YFilter.not_set or
                                self.transaction_id.yfilter != YFilter.not_set or
                                self.ttl.yfilter != YFilter.not_set or
                                self.version.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "header" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.delay_model.is_set or self.delay_model.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.delay_model.get_name_leafdata())
                            if (self.forwarded.is_set or self.forwarded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.forwarded.get_name_leafdata())
                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.level.get_name_leafdata())
                            if (self.next_hop_timeout.is_set or self.next_hop_timeout.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop_timeout.get_name_leafdata())
                            if (self.relay_action.is_set or self.relay_action.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.relay_action.get_name_leafdata())
                            if (self.reply_filter_unknown.is_set or self.reply_filter_unknown.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reply_filter_unknown.get_name_leafdata())
                            if (self.terminal_mep.is_set or self.terminal_mep.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.terminal_mep.get_name_leafdata())
                            if (self.transaction_id.is_set or self.transaction_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.transaction_id.get_name_leafdata())
                            if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ttl.get_name_leafdata())
                            if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.version.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "delay-model" or name == "forwarded" or name == "level" or name == "next-hop-timeout" or name == "relay-action" or name == "reply-filter-unknown" or name == "terminal-mep" or name == "transaction-id" or name == "ttl" or name == "version"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "delay-model"):
                                self.delay_model = value
                                self.delay_model.value_namespace = name_space
                                self.delay_model.value_namespace_prefix = name_space_prefix
                            if(value_path == "forwarded"):
                                self.forwarded = value
                                self.forwarded.value_namespace = name_space
                                self.forwarded.value_namespace_prefix = name_space_prefix
                            if(value_path == "level"):
                                self.level = value
                                self.level.value_namespace = name_space
                                self.level.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop-timeout"):
                                self.next_hop_timeout = value
                                self.next_hop_timeout.value_namespace = name_space
                                self.next_hop_timeout.value_namespace_prefix = name_space_prefix
                            if(value_path == "relay-action"):
                                self.relay_action = value
                                self.relay_action.value_namespace = name_space
                                self.relay_action.value_namespace_prefix = name_space_prefix
                            if(value_path == "reply-filter-unknown"):
                                self.reply_filter_unknown = value
                                self.reply_filter_unknown.value_namespace = name_space
                                self.reply_filter_unknown.value_namespace_prefix = name_space_prefix
                            if(value_path == "terminal-mep"):
                                self.terminal_mep = value
                                self.terminal_mep.value_namespace = name_space
                                self.terminal_mep.value_namespace_prefix = name_space_prefix
                            if(value_path == "transaction-id"):
                                self.transaction_id = value
                                self.transaction_id.value_namespace = name_space
                                self.transaction_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ttl"):
                                self.ttl = value
                                self.ttl.value_namespace = name_space
                                self.ttl.value_namespace_prefix = name_space_prefix
                            if(value_path == "version"):
                                self.version = value
                                self.version.value_namespace = name_space
                                self.version.value_namespace_prefix = name_space_prefix


                    class SenderId(Entity):
                        """
                        Sender ID TLV
                        
                        .. attribute:: chassis_id
                        
                        	Chassis ID
                        	**type**\:   :py:class:`ChassisId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId>`
                        
                        .. attribute:: management_address
                        
                        	Management address
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: management_address_domain
                        
                        	Management address domain
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId, self).__init__()

                            self.yang_name = "sender-id"
                            self.yang_parent_name = "exploratory-linktrace-reply"

                            self.management_address = YLeaf(YType.str, "management-address")

                            self.management_address_domain = YLeaf(YType.str, "management-address-domain")

                            self.chassis_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId()
                            self.chassis_id.parent = self
                            self._children_name_map["chassis_id"] = "chassis-id"
                            self._children_yang_names.add("chassis-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("management_address",
                                            "management_address_domain") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId, self).__setattr__(name, value)


                        class ChassisId(Entity):
                            """
                            Chassis ID
                            
                            .. attribute:: chassis_id
                            
                            	Chassis ID (Deprecated)
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: chassis_id_type
                            
                            	Chassis ID Type
                            	**type**\:   :py:class:`CfmPmChassisIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmChassisIdFmt>`
                            
                            .. attribute:: chassis_id_type_value
                            
                            	Chassis ID Type
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: chassis_id_value
                            
                            	Chassis ID (Current)
                            	**type**\:   :py:class:`ChassisIdValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId.ChassisIdValue>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId, self).__init__()

                                self.yang_name = "chassis-id"
                                self.yang_parent_name = "sender-id"

                                self.chassis_id = YLeaf(YType.str, "chassis-id")

                                self.chassis_id_type = YLeaf(YType.enumeration, "chassis-id-type")

                                self.chassis_id_type_value = YLeaf(YType.uint8, "chassis-id-type-value")

                                self.chassis_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId.ChassisIdValue()
                                self.chassis_id_value.parent = self
                                self._children_name_map["chassis_id_value"] = "chassis-id-value"
                                self._children_yang_names.add("chassis-id-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("chassis_id",
                                                "chassis_id_type",
                                                "chassis_id_type_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId, self).__setattr__(name, value)


                            class ChassisIdValue(Entity):
                                """
                                Chassis ID (Current)
                                
                                .. attribute:: chassis_id_format
                                
                                	ChassisIDFormat
                                	**type**\:   :py:class:`CfmPmIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIdFmt>`
                                
                                .. attribute:: chassis_id_mac
                                
                                	Chassis ID MAC Address
                                	**type**\:  str
                                
                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                
                                .. attribute:: chassis_id_raw
                                
                                	Raw Chassis ID
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: chassis_id_string
                                
                                	Chassis ID String
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId.ChassisIdValue, self).__init__()

                                    self.yang_name = "chassis-id-value"
                                    self.yang_parent_name = "chassis-id"

                                    self.chassis_id_format = YLeaf(YType.enumeration, "chassis-id-format")

                                    self.chassis_id_mac = YLeaf(YType.str, "chassis-id-mac")

                                    self.chassis_id_raw = YLeaf(YType.str, "chassis-id-raw")

                                    self.chassis_id_string = YLeaf(YType.str, "chassis-id-string")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("chassis_id_format",
                                                    "chassis_id_mac",
                                                    "chassis_id_raw",
                                                    "chassis_id_string") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId.ChassisIdValue, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId.ChassisIdValue, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.chassis_id_format.is_set or
                                        self.chassis_id_mac.is_set or
                                        self.chassis_id_raw.is_set or
                                        self.chassis_id_string.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.chassis_id_format.yfilter != YFilter.not_set or
                                        self.chassis_id_mac.yfilter != YFilter.not_set or
                                        self.chassis_id_raw.yfilter != YFilter.not_set or
                                        self.chassis_id_string.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "chassis-id-value" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.chassis_id_format.is_set or self.chassis_id_format.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_format.get_name_leafdata())
                                    if (self.chassis_id_mac.is_set or self.chassis_id_mac.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_mac.get_name_leafdata())
                                    if (self.chassis_id_raw.is_set or self.chassis_id_raw.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_raw.get_name_leafdata())
                                    if (self.chassis_id_string.is_set or self.chassis_id_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_string.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "chassis-id-format" or name == "chassis-id-mac" or name == "chassis-id-raw" or name == "chassis-id-string"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "chassis-id-format"):
                                        self.chassis_id_format = value
                                        self.chassis_id_format.value_namespace = name_space
                                        self.chassis_id_format.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-mac"):
                                        self.chassis_id_mac = value
                                        self.chassis_id_mac.value_namespace = name_space
                                        self.chassis_id_mac.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-raw"):
                                        self.chassis_id_raw = value
                                        self.chassis_id_raw.value_namespace = name_space
                                        self.chassis_id_raw.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-string"):
                                        self.chassis_id_string = value
                                        self.chassis_id_string.value_namespace = name_space
                                        self.chassis_id_string.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.chassis_id.is_set or
                                    self.chassis_id_type.is_set or
                                    self.chassis_id_type_value.is_set or
                                    (self.chassis_id_value is not None and self.chassis_id_value.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.chassis_id.yfilter != YFilter.not_set or
                                    self.chassis_id_type.yfilter != YFilter.not_set or
                                    self.chassis_id_type_value.yfilter != YFilter.not_set or
                                    (self.chassis_id_value is not None and self.chassis_id_value.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "chassis-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.chassis_id.is_set or self.chassis_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.chassis_id.get_name_leafdata())
                                if (self.chassis_id_type.is_set or self.chassis_id_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.chassis_id_type.get_name_leafdata())
                                if (self.chassis_id_type_value.is_set or self.chassis_id_type_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.chassis_id_type_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "chassis-id-value"):
                                    if (self.chassis_id_value is None):
                                        self.chassis_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId.ChassisIdValue()
                                        self.chassis_id_value.parent = self
                                        self._children_name_map["chassis_id_value"] = "chassis-id-value"
                                    return self.chassis_id_value

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "chassis-id-value" or name == "chassis-id" or name == "chassis-id-type" or name == "chassis-id-type-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "chassis-id"):
                                    self.chassis_id = value
                                    self.chassis_id.value_namespace = name_space
                                    self.chassis_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "chassis-id-type"):
                                    self.chassis_id_type = value
                                    self.chassis_id_type.value_namespace = name_space
                                    self.chassis_id_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "chassis-id-type-value"):
                                    self.chassis_id_type_value = value
                                    self.chassis_id_type_value.value_namespace = name_space
                                    self.chassis_id_type_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.management_address.is_set or
                                self.management_address_domain.is_set or
                                (self.chassis_id is not None and self.chassis_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.management_address.yfilter != YFilter.not_set or
                                self.management_address_domain.yfilter != YFilter.not_set or
                                (self.chassis_id is not None and self.chassis_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sender-id" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.management_address.is_set or self.management_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.management_address.get_name_leafdata())
                            if (self.management_address_domain.is_set or self.management_address_domain.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.management_address_domain.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "chassis-id"):
                                if (self.chassis_id is None):
                                    self.chassis_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId.ChassisId()
                                    self.chassis_id.parent = self
                                    self._children_name_map["chassis_id"] = "chassis-id"
                                return self.chassis_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "chassis-id" or name == "management-address" or name == "management-address-domain"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "management-address"):
                                self.management_address = value
                                self.management_address.value_namespace = name_space
                                self.management_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "management-address-domain"):
                                self.management_address_domain = value
                                self.management_address_domain.value_namespace = name_space
                                self.management_address_domain.value_namespace_prefix = name_space_prefix


                    class ReplyIngress(Entity):
                        """
                        Reply ingress TLV
                        
                        .. attribute:: action
                        
                        	ELR Reply ingress action
                        	**type**\:   :py:class:`CfmPmElrIngressAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmElrIngressAction>`
                        
                        .. attribute:: last_egress_id
                        
                        	Last egress ID
                        	**type**\:   :py:class:`LastEgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.LastEgressId>`
                        
                        .. attribute:: mac_address
                        
                        	MAC address
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: next_egress_id
                        
                        	Next egress ID
                        	**type**\:   :py:class:`NextEgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.NextEgressId>`
                        
                        .. attribute:: port_id
                        
                        	Port ID
                        	**type**\:   :py:class:`PortId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress, self).__init__()

                            self.yang_name = "reply-ingress"
                            self.yang_parent_name = "exploratory-linktrace-reply"

                            self.action = YLeaf(YType.enumeration, "action")

                            self.mac_address = YLeaf(YType.str, "mac-address")

                            self.last_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.LastEgressId()
                            self.last_egress_id.parent = self
                            self._children_name_map["last_egress_id"] = "last-egress-id"
                            self._children_yang_names.add("last-egress-id")

                            self.next_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.NextEgressId()
                            self.next_egress_id.parent = self
                            self._children_name_map["next_egress_id"] = "next-egress-id"
                            self._children_yang_names.add("next-egress-id")

                            self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId()
                            self.port_id.parent = self
                            self._children_name_map["port_id"] = "port-id"
                            self._children_yang_names.add("port-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("action",
                                            "mac_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress, self).__setattr__(name, value)


                        class LastEgressId(Entity):
                            """
                            Last egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.LastEgressId, self).__init__()

                                self.yang_name = "last-egress-id"
                                self.yang_parent_name = "reply-ingress"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.LastEgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.LastEgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "last-egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix


                        class NextEgressId(Entity):
                            """
                            Next egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.NextEgressId, self).__init__()

                                self.yang_name = "next-egress-id"
                                self.yang_parent_name = "reply-ingress"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.NextEgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.NextEgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "next-egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix


                        class PortId(Entity):
                            """
                            Port ID
                            
                            .. attribute:: port_id
                            
                            	Port ID (Deprecated)
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: port_id_type
                            
                            	Port ID type
                            	**type**\:   :py:class:`CfmPmPortIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmPortIdFmt>`
                            
                            .. attribute:: port_id_type_value
                            
                            	Port ID type value
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: port_id_value
                            
                            	Port ID (Current)
                            	**type**\:   :py:class:`PortIdValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId.PortIdValue>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId, self).__init__()

                                self.yang_name = "port-id"
                                self.yang_parent_name = "reply-ingress"

                                self.port_id = YLeaf(YType.str, "port-id")

                                self.port_id_type = YLeaf(YType.enumeration, "port-id-type")

                                self.port_id_type_value = YLeaf(YType.uint8, "port-id-type-value")

                                self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId.PortIdValue()
                                self.port_id_value.parent = self
                                self._children_name_map["port_id_value"] = "port-id-value"
                                self._children_yang_names.add("port-id-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("port_id",
                                                "port_id_type",
                                                "port_id_type_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId, self).__setattr__(name, value)


                            class PortIdValue(Entity):
                                """
                                Port ID (Current)
                                
                                .. attribute:: port_id_format
                                
                                	PortIDFormat
                                	**type**\:   :py:class:`CfmPmIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIdFmt>`
                                
                                .. attribute:: port_id_mac
                                
                                	Port ID MAC Address
                                	**type**\:  str
                                
                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                
                                .. attribute:: port_id_raw
                                
                                	Raw Port ID
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: port_id_string
                                
                                	Port ID String
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId.PortIdValue, self).__init__()

                                    self.yang_name = "port-id-value"
                                    self.yang_parent_name = "port-id"

                                    self.port_id_format = YLeaf(YType.enumeration, "port-id-format")

                                    self.port_id_mac = YLeaf(YType.str, "port-id-mac")

                                    self.port_id_raw = YLeaf(YType.str, "port-id-raw")

                                    self.port_id_string = YLeaf(YType.str, "port-id-string")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("port_id_format",
                                                    "port_id_mac",
                                                    "port_id_raw",
                                                    "port_id_string") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId.PortIdValue, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId.PortIdValue, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.port_id_format.is_set or
                                        self.port_id_mac.is_set or
                                        self.port_id_raw.is_set or
                                        self.port_id_string.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.port_id_format.yfilter != YFilter.not_set or
                                        self.port_id_mac.yfilter != YFilter.not_set or
                                        self.port_id_raw.yfilter != YFilter.not_set or
                                        self.port_id_string.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "port-id-value" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.port_id_format.is_set or self.port_id_format.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_format.get_name_leafdata())
                                    if (self.port_id_mac.is_set or self.port_id_mac.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_mac.get_name_leafdata())
                                    if (self.port_id_raw.is_set or self.port_id_raw.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_raw.get_name_leafdata())
                                    if (self.port_id_string.is_set or self.port_id_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_string.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "port-id-format" or name == "port-id-mac" or name == "port-id-raw" or name == "port-id-string"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "port-id-format"):
                                        self.port_id_format = value
                                        self.port_id_format.value_namespace = name_space
                                        self.port_id_format.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-mac"):
                                        self.port_id_mac = value
                                        self.port_id_mac.value_namespace = name_space
                                        self.port_id_mac.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-raw"):
                                        self.port_id_raw = value
                                        self.port_id_raw.value_namespace = name_space
                                        self.port_id_raw.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-string"):
                                        self.port_id_string = value
                                        self.port_id_string.value_namespace = name_space
                                        self.port_id_string.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.port_id.is_set or
                                    self.port_id_type.is_set or
                                    self.port_id_type_value.is_set or
                                    (self.port_id_value is not None and self.port_id_value.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.port_id.yfilter != YFilter.not_set or
                                    self.port_id_type.yfilter != YFilter.not_set or
                                    self.port_id_type_value.yfilter != YFilter.not_set or
                                    (self.port_id_value is not None and self.port_id_value.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "port-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.port_id.is_set or self.port_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id.get_name_leafdata())
                                if (self.port_id_type.is_set or self.port_id_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type.get_name_leafdata())
                                if (self.port_id_type_value.is_set or self.port_id_type_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "port-id-value"):
                                    if (self.port_id_value is None):
                                        self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId.PortIdValue()
                                        self.port_id_value.parent = self
                                        self._children_name_map["port_id_value"] = "port-id-value"
                                    return self.port_id_value

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "port-id-value" or name == "port-id" or name == "port-id-type" or name == "port-id-type-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "port-id"):
                                    self.port_id = value
                                    self.port_id.value_namespace = name_space
                                    self.port_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type"):
                                    self.port_id_type = value
                                    self.port_id_type.value_namespace = name_space
                                    self.port_id_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type-value"):
                                    self.port_id_type_value = value
                                    self.port_id_type_value.value_namespace = name_space
                                    self.port_id_type_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.action.is_set or
                                self.mac_address.is_set or
                                (self.last_egress_id is not None and self.last_egress_id.has_data()) or
                                (self.next_egress_id is not None and self.next_egress_id.has_data()) or
                                (self.port_id is not None and self.port_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.action.yfilter != YFilter.not_set or
                                self.mac_address.yfilter != YFilter.not_set or
                                (self.last_egress_id is not None and self.last_egress_id.has_operation()) or
                                (self.next_egress_id is not None and self.next_egress_id.has_operation()) or
                                (self.port_id is not None and self.port_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reply-ingress" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.action.get_name_leafdata())
                            if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "last-egress-id"):
                                if (self.last_egress_id is None):
                                    self.last_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.LastEgressId()
                                    self.last_egress_id.parent = self
                                    self._children_name_map["last_egress_id"] = "last-egress-id"
                                return self.last_egress_id

                            if (child_yang_name == "next-egress-id"):
                                if (self.next_egress_id is None):
                                    self.next_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.NextEgressId()
                                    self.next_egress_id.parent = self
                                    self._children_name_map["next_egress_id"] = "next-egress-id"
                                return self.next_egress_id

                            if (child_yang_name == "port-id"):
                                if (self.port_id is None):
                                    self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress.PortId()
                                    self.port_id.parent = self
                                    self._children_name_map["port_id"] = "port-id"
                                return self.port_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "last-egress-id" or name == "next-egress-id" or name == "port-id" or name == "action" or name == "mac-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "action"):
                                self.action = value
                                self.action.value_namespace = name_space
                                self.action.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address"):
                                self.mac_address = value
                                self.mac_address.value_namespace = name_space
                                self.mac_address.value_namespace_prefix = name_space_prefix


                    class ReplyEgress(Entity):
                        """
                        Reply egress TLV
                        
                        .. attribute:: action
                        
                        	Reply egress action
                        	**type**\:   :py:class:`CfmPmElrEgressAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmElrEgressAction>`
                        
                        .. attribute:: last_egress_id
                        
                        	Last Egress ID
                        	**type**\:   :py:class:`LastEgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.LastEgressId>`
                        
                        .. attribute:: mac_address
                        
                        	MAC address of egress interface
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                        
                        .. attribute:: next_egress_id
                        
                        	Next Egress ID
                        	**type**\:   :py:class:`NextEgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.NextEgressId>`
                        
                        .. attribute:: port_id
                        
                        	Port ID
                        	**type**\:   :py:class:`PortId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress, self).__init__()

                            self.yang_name = "reply-egress"
                            self.yang_parent_name = "exploratory-linktrace-reply"

                            self.action = YLeaf(YType.enumeration, "action")

                            self.mac_address = YLeaf(YType.str, "mac-address")

                            self.last_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.LastEgressId()
                            self.last_egress_id.parent = self
                            self._children_name_map["last_egress_id"] = "last-egress-id"
                            self._children_yang_names.add("last-egress-id")

                            self.next_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.NextEgressId()
                            self.next_egress_id.parent = self
                            self._children_name_map["next_egress_id"] = "next-egress-id"
                            self._children_yang_names.add("next-egress-id")

                            self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId()
                            self.port_id.parent = self
                            self._children_name_map["port_id"] = "port-id"
                            self._children_yang_names.add("port-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("action",
                                            "mac_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress, self).__setattr__(name, value)


                        class LastEgressId(Entity):
                            """
                            Last Egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.LastEgressId, self).__init__()

                                self.yang_name = "last-egress-id"
                                self.yang_parent_name = "reply-egress"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.LastEgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.LastEgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "last-egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix


                        class NextEgressId(Entity):
                            """
                            Next Egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.NextEgressId, self).__init__()

                                self.yang_name = "next-egress-id"
                                self.yang_parent_name = "reply-egress"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.NextEgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.NextEgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "next-egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix


                        class PortId(Entity):
                            """
                            Port ID
                            
                            .. attribute:: port_id
                            
                            	Port ID (Deprecated)
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: port_id_type
                            
                            	Port ID type
                            	**type**\:   :py:class:`CfmPmPortIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmPortIdFmt>`
                            
                            .. attribute:: port_id_type_value
                            
                            	Port ID type value
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: port_id_value
                            
                            	Port ID (Current)
                            	**type**\:   :py:class:`PortIdValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId.PortIdValue>`
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId, self).__init__()

                                self.yang_name = "port-id"
                                self.yang_parent_name = "reply-egress"

                                self.port_id = YLeaf(YType.str, "port-id")

                                self.port_id_type = YLeaf(YType.enumeration, "port-id-type")

                                self.port_id_type_value = YLeaf(YType.uint8, "port-id-type-value")

                                self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId.PortIdValue()
                                self.port_id_value.parent = self
                                self._children_name_map["port_id_value"] = "port-id-value"
                                self._children_yang_names.add("port-id-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("port_id",
                                                "port_id_type",
                                                "port_id_type_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId, self).__setattr__(name, value)


                            class PortIdValue(Entity):
                                """
                                Port ID (Current)
                                
                                .. attribute:: port_id_format
                                
                                	PortIDFormat
                                	**type**\:   :py:class:`CfmPmIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIdFmt>`
                                
                                .. attribute:: port_id_mac
                                
                                	Port ID MAC Address
                                	**type**\:  str
                                
                                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                
                                .. attribute:: port_id_raw
                                
                                	Raw Port ID
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: port_id_string
                                
                                	Port ID String
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId.PortIdValue, self).__init__()

                                    self.yang_name = "port-id-value"
                                    self.yang_parent_name = "port-id"

                                    self.port_id_format = YLeaf(YType.enumeration, "port-id-format")

                                    self.port_id_mac = YLeaf(YType.str, "port-id-mac")

                                    self.port_id_raw = YLeaf(YType.str, "port-id-raw")

                                    self.port_id_string = YLeaf(YType.str, "port-id-string")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("port_id_format",
                                                    "port_id_mac",
                                                    "port_id_raw",
                                                    "port_id_string") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId.PortIdValue, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId.PortIdValue, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.port_id_format.is_set or
                                        self.port_id_mac.is_set or
                                        self.port_id_raw.is_set or
                                        self.port_id_string.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.port_id_format.yfilter != YFilter.not_set or
                                        self.port_id_mac.yfilter != YFilter.not_set or
                                        self.port_id_raw.yfilter != YFilter.not_set or
                                        self.port_id_string.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "port-id-value" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.port_id_format.is_set or self.port_id_format.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_format.get_name_leafdata())
                                    if (self.port_id_mac.is_set or self.port_id_mac.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_mac.get_name_leafdata())
                                    if (self.port_id_raw.is_set or self.port_id_raw.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_raw.get_name_leafdata())
                                    if (self.port_id_string.is_set or self.port_id_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.port_id_string.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "port-id-format" or name == "port-id-mac" or name == "port-id-raw" or name == "port-id-string"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "port-id-format"):
                                        self.port_id_format = value
                                        self.port_id_format.value_namespace = name_space
                                        self.port_id_format.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-mac"):
                                        self.port_id_mac = value
                                        self.port_id_mac.value_namespace = name_space
                                        self.port_id_mac.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-raw"):
                                        self.port_id_raw = value
                                        self.port_id_raw.value_namespace = name_space
                                        self.port_id_raw.value_namespace_prefix = name_space_prefix
                                    if(value_path == "port-id-string"):
                                        self.port_id_string = value
                                        self.port_id_string.value_namespace = name_space
                                        self.port_id_string.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.port_id.is_set or
                                    self.port_id_type.is_set or
                                    self.port_id_type_value.is_set or
                                    (self.port_id_value is not None and self.port_id_value.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.port_id.yfilter != YFilter.not_set or
                                    self.port_id_type.yfilter != YFilter.not_set or
                                    self.port_id_type_value.yfilter != YFilter.not_set or
                                    (self.port_id_value is not None and self.port_id_value.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "port-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.port_id.is_set or self.port_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id.get_name_leafdata())
                                if (self.port_id_type.is_set or self.port_id_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type.get_name_leafdata())
                                if (self.port_id_type_value.is_set or self.port_id_type_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.port_id_type_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "port-id-value"):
                                    if (self.port_id_value is None):
                                        self.port_id_value = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId.PortIdValue()
                                        self.port_id_value.parent = self
                                        self._children_name_map["port_id_value"] = "port-id-value"
                                    return self.port_id_value

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "port-id-value" or name == "port-id" or name == "port-id-type" or name == "port-id-type-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "port-id"):
                                    self.port_id = value
                                    self.port_id.value_namespace = name_space
                                    self.port_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type"):
                                    self.port_id_type = value
                                    self.port_id_type.value_namespace = name_space
                                    self.port_id_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "port-id-type-value"):
                                    self.port_id_type_value = value
                                    self.port_id_type_value.value_namespace = name_space
                                    self.port_id_type_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.action.is_set or
                                self.mac_address.is_set or
                                (self.last_egress_id is not None and self.last_egress_id.has_data()) or
                                (self.next_egress_id is not None and self.next_egress_id.has_data()) or
                                (self.port_id is not None and self.port_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.action.yfilter != YFilter.not_set or
                                self.mac_address.yfilter != YFilter.not_set or
                                (self.last_egress_id is not None and self.last_egress_id.has_operation()) or
                                (self.next_egress_id is not None and self.next_egress_id.has_operation()) or
                                (self.port_id is not None and self.port_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reply-egress" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.action.is_set or self.action.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.action.get_name_leafdata())
                            if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mac_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "last-egress-id"):
                                if (self.last_egress_id is None):
                                    self.last_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.LastEgressId()
                                    self.last_egress_id.parent = self
                                    self._children_name_map["last_egress_id"] = "last-egress-id"
                                return self.last_egress_id

                            if (child_yang_name == "next-egress-id"):
                                if (self.next_egress_id is None):
                                    self.next_egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.NextEgressId()
                                    self.next_egress_id.parent = self
                                    self._children_name_map["next_egress_id"] = "next-egress-id"
                                return self.next_egress_id

                            if (child_yang_name == "port-id"):
                                if (self.port_id is None):
                                    self.port_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress.PortId()
                                    self.port_id.parent = self
                                    self._children_name_map["port_id"] = "port-id"
                                return self.port_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "last-egress-id" or name == "next-egress-id" or name == "port-id" or name == "action" or name == "mac-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "action"):
                                self.action = value
                                self.action.value_namespace = name_space
                                self.action.value_namespace_prefix = name_space_prefix
                            if(value_path == "mac-address"):
                                self.mac_address = value
                                self.mac_address.value_namespace = name_space
                                self.mac_address.value_namespace_prefix = name_space_prefix


                    class LastHop(Entity):
                        """
                        Last hop ID
                        
                        .. attribute:: egress_id
                        
                        	Egress ID
                        	**type**\:   :py:class:`EgressId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop.EgressId>`
                        
                        .. attribute:: host_name
                        
                        	Hostname
                        	**type**\:  str
                        
                        .. attribute:: last_hop_format
                        
                        	LastHopFormat
                        	**type**\:   :py:class:`CfmPmLastHopFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmLastHopFmt>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop, self).__init__()

                            self.yang_name = "last-hop"
                            self.yang_parent_name = "exploratory-linktrace-reply"

                            self.host_name = YLeaf(YType.str, "host-name")

                            self.last_hop_format = YLeaf(YType.enumeration, "last-hop-format")

                            self.egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop.EgressId()
                            self.egress_id.parent = self
                            self._children_name_map["egress_id"] = "egress-id"
                            self._children_yang_names.add("egress-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("host_name",
                                            "last_hop_format") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop, self).__setattr__(name, value)


                        class EgressId(Entity):
                            """
                            Egress ID
                            
                            .. attribute:: mac_address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: unique_id
                            
                            	Unique ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop.EgressId, self).__init__()

                                self.yang_name = "egress-id"
                                self.yang_parent_name = "last-hop"

                                self.mac_address = YLeaf(YType.str, "mac-address")

                                self.unique_id = YLeaf(YType.uint16, "unique-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mac_address",
                                                "unique_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop.EgressId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop.EgressId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mac_address.is_set or
                                    self.unique_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mac_address.yfilter != YFilter.not_set or
                                    self.unique_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "egress-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_address.get_name_leafdata())
                                if (self.unique_id.is_set or self.unique_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unique_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mac-address" or name == "unique-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mac-address"):
                                    self.mac_address = value
                                    self.mac_address.value_namespace = name_space
                                    self.mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "unique-id"):
                                    self.unique_id = value
                                    self.unique_id.value_namespace = name_space
                                    self.unique_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.host_name.is_set or
                                self.last_hop_format.is_set or
                                (self.egress_id is not None and self.egress_id.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.host_name.yfilter != YFilter.not_set or
                                self.last_hop_format.yfilter != YFilter.not_set or
                                (self.egress_id is not None and self.egress_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "last-hop" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.host_name.get_name_leafdata())
                            if (self.last_hop_format.is_set or self.last_hop_format.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_hop_format.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "egress-id"):
                                if (self.egress_id is None):
                                    self.egress_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop.EgressId()
                                    self.egress_id.parent = self
                                    self._children_name_map["egress_id"] = "egress-id"
                                return self.egress_id

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "egress-id" or name == "host-name" or name == "last-hop-format"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "host-name"):
                                self.host_name = value
                                self.host_name.value_namespace = name_space
                                self.host_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-hop-format"):
                                self.last_hop_format = value
                                self.last_hop_format.value_namespace = name_space
                                self.last_hop_format.value_namespace_prefix = name_space_prefix


                    class OrganizationSpecificTlv(Entity):
                        """
                        Organizational\-specific TLVs
                        
                        .. attribute:: oui
                        
                        	Organizationally\-unique ID
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: subtype
                        
                        	Subtype of TLV
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: value
                        
                        	Binary data in TLV
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.OrganizationSpecificTlv, self).__init__()

                            self.yang_name = "organization-specific-tlv"
                            self.yang_parent_name = "exploratory-linktrace-reply"

                            self.oui = YLeaf(YType.str, "oui")

                            self.subtype = YLeaf(YType.uint8, "subtype")

                            self.value = YLeaf(YType.str, "value")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("oui",
                                            "subtype",
                                            "value") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.OrganizationSpecificTlv, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.OrganizationSpecificTlv, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.oui.is_set or
                                self.subtype.is_set or
                                self.value.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.oui.yfilter != YFilter.not_set or
                                self.subtype.yfilter != YFilter.not_set or
                                self.value.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "organization-specific-tlv" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.oui.is_set or self.oui.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.oui.get_name_leafdata())
                            if (self.subtype.is_set or self.subtype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.subtype.get_name_leafdata())
                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.value.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "oui" or name == "subtype" or name == "value"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "oui"):
                                self.oui = value
                                self.oui.value_namespace = name_space
                                self.oui.value_namespace_prefix = name_space_prefix
                            if(value_path == "subtype"):
                                self.subtype = value
                                self.subtype.value_namespace = name_space
                                self.subtype.value_namespace_prefix = name_space_prefix
                            if(value_path == "value"):
                                self.value = value
                                self.value.value_namespace = name_space
                                self.value.value_namespace_prefix = name_space_prefix


                    class UnknownTlv(Entity):
                        """
                        Unknown TLVs
                        
                        .. attribute:: typecode
                        
                        	Type code of TLV
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: value
                        
                        	Binary data in TLV
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.UnknownTlv, self).__init__()

                            self.yang_name = "unknown-tlv"
                            self.yang_parent_name = "exploratory-linktrace-reply"

                            self.typecode = YLeaf(YType.uint8, "typecode")

                            self.value = YLeaf(YType.str, "value")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("typecode",
                                            "value") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.UnknownTlv, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.UnknownTlv, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.typecode.is_set or
                                self.value.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.typecode.yfilter != YFilter.not_set or
                                self.value.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "unknown-tlv" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.typecode.is_set or self.typecode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.typecode.get_name_leafdata())
                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.value.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "typecode" or name == "value"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "typecode"):
                                self.typecode = value
                                self.typecode.value_namespace = name_space
                                self.typecode.value_namespace_prefix = name_space_prefix
                            if(value_path == "value"):
                                self.value = value
                                self.value.value_namespace = name_space
                                self.value.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.organization_specific_tlv:
                            if (c.has_data()):
                                return True
                        for c in self.unknown_tlv:
                            if (c.has_data()):
                                return True
                        return (
                            self.raw_data.is_set or
                            (self.header is not None and self.header.has_data()) or
                            (self.last_hop is not None and self.last_hop.has_data()) or
                            (self.reply_egress is not None and self.reply_egress.has_data()) or
                            (self.reply_ingress is not None and self.reply_ingress.has_data()) or
                            (self.sender_id is not None and self.sender_id.has_data()))

                    def has_operation(self):
                        for c in self.organization_specific_tlv:
                            if (c.has_operation()):
                                return True
                        for c in self.unknown_tlv:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.raw_data.yfilter != YFilter.not_set or
                            (self.header is not None and self.header.has_operation()) or
                            (self.last_hop is not None and self.last_hop.has_operation()) or
                            (self.reply_egress is not None and self.reply_egress.has_operation()) or
                            (self.reply_ingress is not None and self.reply_ingress.has_operation()) or
                            (self.sender_id is not None and self.sender_id.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "exploratory-linktrace-reply" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.raw_data.is_set or self.raw_data.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.raw_data.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "header"):
                            if (self.header is None):
                                self.header = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.Header()
                                self.header.parent = self
                                self._children_name_map["header"] = "header"
                            return self.header

                        if (child_yang_name == "last-hop"):
                            if (self.last_hop is None):
                                self.last_hop = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.LastHop()
                                self.last_hop.parent = self
                                self._children_name_map["last_hop"] = "last-hop"
                            return self.last_hop

                        if (child_yang_name == "organization-specific-tlv"):
                            for c in self.organization_specific_tlv:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.OrganizationSpecificTlv()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.organization_specific_tlv.append(c)
                            return c

                        if (child_yang_name == "reply-egress"):
                            if (self.reply_egress is None):
                                self.reply_egress = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyEgress()
                                self.reply_egress.parent = self
                                self._children_name_map["reply_egress"] = "reply-egress"
                            return self.reply_egress

                        if (child_yang_name == "reply-ingress"):
                            if (self.reply_ingress is None):
                                self.reply_ingress = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.ReplyIngress()
                                self.reply_ingress.parent = self
                                self._children_name_map["reply_ingress"] = "reply-ingress"
                            return self.reply_ingress

                        if (child_yang_name == "sender-id"):
                            if (self.sender_id is None):
                                self.sender_id = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.SenderId()
                                self.sender_id.parent = self
                                self._children_name_map["sender_id"] = "sender-id"
                            return self.sender_id

                        if (child_yang_name == "unknown-tlv"):
                            for c in self.unknown_tlv:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply.UnknownTlv()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.unknown_tlv.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "header" or name == "last-hop" or name == "organization-specific-tlv" or name == "reply-egress" or name == "reply-ingress" or name == "sender-id" or name == "unknown-tlv" or name == "raw-data"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "raw-data"):
                            self.raw_data = value
                            self.raw_data.value_namespace = name_space
                            self.raw_data.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.exploratory_linktrace_reply:
                        if (c.has_data()):
                            return True
                    for c in self.linktrace_reply:
                        if (c.has_data()):
                            return True
                    return (
                        self.domain.is_set or
                        self.service.is_set or
                        self.mep_id.is_set or
                        self.interface.is_set or
                        self.transaction_id.is_set or
                        self.replies_dropped.is_set or
                        (self.traceroute_information is not None and self.traceroute_information.has_data()))

                def has_operation(self):
                    for c in self.exploratory_linktrace_reply:
                        if (c.has_operation()):
                            return True
                    for c in self.linktrace_reply:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain.yfilter != YFilter.not_set or
                        self.service.yfilter != YFilter.not_set or
                        self.mep_id.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.transaction_id.yfilter != YFilter.not_set or
                        self.replies_dropped.yfilter != YFilter.not_set or
                        (self.traceroute_information is not None and self.traceroute_information.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "traceroute-cache" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + "[mep-id='" + self.mep_id.get() + "']" + "[interface='" + self.interface.get() + "']" + "[transaction-id='" + self.transaction_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/traceroute-caches/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain.get_name_leafdata())
                    if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service.get_name_leafdata())
                    if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_id.get_name_leafdata())
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.transaction_id.is_set or self.transaction_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.transaction_id.get_name_leafdata())
                    if (self.replies_dropped.is_set or self.replies_dropped.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.replies_dropped.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "exploratory-linktrace-reply"):
                        for c in self.exploratory_linktrace_reply:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Cfm.Global_.TracerouteCaches.TracerouteCache.ExploratoryLinktraceReply()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.exploratory_linktrace_reply.append(c)
                        return c

                    if (child_yang_name == "linktrace-reply"):
                        for c in self.linktrace_reply:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Cfm.Global_.TracerouteCaches.TracerouteCache.LinktraceReply()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.linktrace_reply.append(c)
                        return c

                    if (child_yang_name == "traceroute-information"):
                        if (self.traceroute_information is None):
                            self.traceroute_information = Cfm.Global_.TracerouteCaches.TracerouteCache.TracerouteInformation()
                            self.traceroute_information.parent = self
                            self._children_name_map["traceroute_information"] = "traceroute-information"
                        return self.traceroute_information

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "exploratory-linktrace-reply" or name == "linktrace-reply" or name == "traceroute-information" or name == "domain" or name == "service" or name == "mep-id" or name == "interface" or name == "transaction-id" or name == "replies-dropped"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain"):
                        self.domain = value
                        self.domain.value_namespace = name_space
                        self.domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "service"):
                        self.service = value
                        self.service.value_namespace = name_space
                        self.service.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-id"):
                        self.mep_id = value
                        self.mep_id.value_namespace = name_space
                        self.mep_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "transaction-id"):
                        self.transaction_id = value
                        self.transaction_id.value_namespace = name_space
                        self.transaction_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "replies-dropped"):
                        self.replies_dropped = value
                        self.replies_dropped.value_namespace = name_space
                        self.replies_dropped.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.traceroute_cache:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.traceroute_cache:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "traceroute-caches" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "traceroute-cache"):
                    for c in self.traceroute_cache:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Cfm.Global_.TracerouteCaches.TracerouteCache()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.traceroute_cache.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "traceroute-cache"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class LocalMeps(Entity):
            """
            Local MEPs table
            
            .. attribute:: local_mep
            
            	Information about a particular local MEP
            	**type**\: list of    :py:class:`LocalMep <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps.LocalMep>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Global_.LocalMeps, self).__init__()

                self.yang_name = "local-meps"
                self.yang_parent_name = "global"

                self.local_mep = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Global_.LocalMeps, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Global_.LocalMeps, self).__setattr__(name, value)


            class LocalMep(Entity):
                """
                Information about a particular local MEP
                
                .. attribute:: domain  <key>
                
                	Maintenance Domain
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: service  <key>
                
                	Service (Maintenance Association)
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: mep_id  <key>
                
                	MEP ID
                	**type**\:  int
                
                	**range:** 1..8191
                
                .. attribute:: interface  <key>
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: ais_statistics
                
                	MEP AIS statistics
                	**type**\:   :py:class:`AisStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps.LocalMep.AisStatistics>`
                
                .. attribute:: ccm_generation_enabled
                
                	CCM generation enabled
                	**type**\:  bool
                
                .. attribute:: ccm_interval
                
                	The interval between CCMs
                	**type**\:   :py:class:`CfmBagCcmInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagCcmInterval>`
                
                .. attribute:: ccm_offload
                
                	Offload status of CCM processing
                	**type**\:   :py:class:`CfmBagCcmOffload <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagCcmOffload>`
                
                .. attribute:: cos
                
                	CoS bits the MEP will use for sent packets, if configured
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: cross_connect_ccm_defect
                
                	A cross\-connect CCM error has been reported
                	**type**\:  bool
                
                .. attribute:: defects
                
                	Defects detected from peer MEPs
                	**type**\:   :py:class:`Defects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps.LocalMep.Defects>`
                
                .. attribute:: defects_ignored
                
                	Defects present but ignored due to 'report defects' configuration
                	**type**\:  bool
                
                .. attribute:: domain_xr
                
                	Maintenance domain name
                	**type**\:  str
                
                .. attribute:: efd_triggered
                
                	EFD triggered on the interface
                	**type**\:  bool
                
                .. attribute:: error_ccm_defect
                
                	A CCM error has been reported
                	**type**\:  bool
                
                .. attribute:: fault_notification_state
                
                	Fault Notification Generation state
                	**type**\:   :py:class:`CfmPmMepFngState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmMepFngState>`
                
                .. attribute:: hairpin
                
                	MEP is on a sub\-interface in the same bridge\-domain and on the same trunk interface as another sub\-interface
                	**type**\:  bool
                
                .. attribute:: highest_defect
                
                	Highest\-priority defect present since last FNG reset
                	**type**\:   :py:class:`CfmPmMepDefect <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmMepDefect>`
                
                .. attribute:: interface_state
                
                	IM Interface state
                	**type**\:  str
                
                .. attribute:: interface_xr
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: interworking_state
                
                	Interface interworking state
                	**type**\:   :py:class:`CfmBagIwState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagIwState>`
                
                .. attribute:: level
                
                	Maintenance level
                	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                
                .. attribute:: mac_address
                
                	MAC address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: mac_status_defect
                
                	A peer MEP port or interface status error has been reported
                	**type**\:  bool
                
                .. attribute:: mep_direction
                
                	MEP facing direction
                	**type**\:   :py:class:`CfmBagDirection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagDirection>`
                
                .. attribute:: mep_id_xr
                
                	MEP ID
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: next_lbm_id
                
                	Next Transaction ID to be sent in a Loopback Message
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: next_ltm_id
                
                	Next Transaction ID to be sent in a Linktrace Message
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_mep_ccm_defect
                
                	A peer MEP CCM error has been reported
                	**type**\:  bool
                
                .. attribute:: peer_meps_detected
                
                	Number of peer MEPs detected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peer_meps_with_errors_detected
                
                	Number of peer MEPs detected with errors
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: rdi_defect
                
                	A peer MEP RDI defect has been reported
                	**type**\:  bool
                
                .. attribute:: remote_defect
                
                	Remote defect indicated
                	**type**\:  bool
                
                .. attribute:: service_xr
                
                	Service name
                	**type**\:  str
                
                .. attribute:: standby
                
                	The local MEP is on an interface in standby mode
                	**type**\:  bool
                
                .. attribute:: statistics
                
                	MEP statistics
                	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps.LocalMep.Statistics>`
                
                .. attribute:: stp_state
                
                	STP state
                	**type**\:   :py:class:`CfmBagStpState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagStpState>`
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Global_.LocalMeps.LocalMep, self).__init__()

                    self.yang_name = "local-mep"
                    self.yang_parent_name = "local-meps"

                    self.domain = YLeaf(YType.str, "domain")

                    self.service = YLeaf(YType.str, "service")

                    self.mep_id = YLeaf(YType.uint32, "mep-id")

                    self.interface = YLeaf(YType.str, "interface")

                    self.ccm_generation_enabled = YLeaf(YType.boolean, "ccm-generation-enabled")

                    self.ccm_interval = YLeaf(YType.enumeration, "ccm-interval")

                    self.ccm_offload = YLeaf(YType.enumeration, "ccm-offload")

                    self.cos = YLeaf(YType.uint8, "cos")

                    self.cross_connect_ccm_defect = YLeaf(YType.boolean, "cross-connect-ccm-defect")

                    self.defects_ignored = YLeaf(YType.boolean, "defects-ignored")

                    self.domain_xr = YLeaf(YType.str, "domain-xr")

                    self.efd_triggered = YLeaf(YType.boolean, "efd-triggered")

                    self.error_ccm_defect = YLeaf(YType.boolean, "error-ccm-defect")

                    self.fault_notification_state = YLeaf(YType.enumeration, "fault-notification-state")

                    self.hairpin = YLeaf(YType.boolean, "hairpin")

                    self.highest_defect = YLeaf(YType.enumeration, "highest-defect")

                    self.interface_state = YLeaf(YType.str, "interface-state")

                    self.interface_xr = YLeaf(YType.str, "interface-xr")

                    self.interworking_state = YLeaf(YType.enumeration, "interworking-state")

                    self.level = YLeaf(YType.enumeration, "level")

                    self.mac_address = YLeaf(YType.str, "mac-address")

                    self.mac_status_defect = YLeaf(YType.boolean, "mac-status-defect")

                    self.mep_direction = YLeaf(YType.enumeration, "mep-direction")

                    self.mep_id_xr = YLeaf(YType.uint16, "mep-id-xr")

                    self.next_lbm_id = YLeaf(YType.uint32, "next-lbm-id")

                    self.next_ltm_id = YLeaf(YType.uint32, "next-ltm-id")

                    self.peer_mep_ccm_defect = YLeaf(YType.boolean, "peer-mep-ccm-defect")

                    self.peer_meps_detected = YLeaf(YType.uint32, "peer-meps-detected")

                    self.peer_meps_with_errors_detected = YLeaf(YType.uint32, "peer-meps-with-errors-detected")

                    self.rdi_defect = YLeaf(YType.boolean, "rdi-defect")

                    self.remote_defect = YLeaf(YType.boolean, "remote-defect")

                    self.service_xr = YLeaf(YType.str, "service-xr")

                    self.standby = YLeaf(YType.boolean, "standby")

                    self.stp_state = YLeaf(YType.enumeration, "stp-state")

                    self.ais_statistics = Cfm.Global_.LocalMeps.LocalMep.AisStatistics()
                    self.ais_statistics.parent = self
                    self._children_name_map["ais_statistics"] = "ais-statistics"
                    self._children_yang_names.add("ais-statistics")

                    self.defects = Cfm.Global_.LocalMeps.LocalMep.Defects()
                    self.defects.parent = self
                    self._children_name_map["defects"] = "defects"
                    self._children_yang_names.add("defects")

                    self.statistics = Cfm.Global_.LocalMeps.LocalMep.Statistics()
                    self.statistics.parent = self
                    self._children_name_map["statistics"] = "statistics"
                    self._children_yang_names.add("statistics")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain",
                                    "service",
                                    "mep_id",
                                    "interface",
                                    "ccm_generation_enabled",
                                    "ccm_interval",
                                    "ccm_offload",
                                    "cos",
                                    "cross_connect_ccm_defect",
                                    "defects_ignored",
                                    "domain_xr",
                                    "efd_triggered",
                                    "error_ccm_defect",
                                    "fault_notification_state",
                                    "hairpin",
                                    "highest_defect",
                                    "interface_state",
                                    "interface_xr",
                                    "interworking_state",
                                    "level",
                                    "mac_address",
                                    "mac_status_defect",
                                    "mep_direction",
                                    "mep_id_xr",
                                    "next_lbm_id",
                                    "next_ltm_id",
                                    "peer_mep_ccm_defect",
                                    "peer_meps_detected",
                                    "peer_meps_with_errors_detected",
                                    "rdi_defect",
                                    "remote_defect",
                                    "service_xr",
                                    "standby",
                                    "stp_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Global_.LocalMeps.LocalMep, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Global_.LocalMeps.LocalMep, self).__setattr__(name, value)


                class Statistics(Entity):
                    """
                    MEP statistics
                    
                    .. attribute:: ai_ss_received
                    
                    	Number of AIS messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: ai_ss_sent
                    
                    	Number of AIS messages sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: bn_ms_discarded
                    
                    	Number of BNM messages discarded
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: bn_ms_received
                    
                    	Number of BNM messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: ccms_discarded
                    
                    	Number of CCMs discarded because maximum MEPs limit was reached
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: ccms_out_of_sequence
                    
                    	Number of CCMs received out\-of\-sequence
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: ccms_received
                    
                    	Number of CCMs received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: ccms_sent
                    
                    	Number of CCMs sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: dm_ms_received
                    
                    	Number of DMM messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: dm_ms_sent
                    
                    	Number of DMM messages sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: dm_rs_received
                    
                    	Number of DMR messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: dm_rs_sent
                    
                    	Number of DMR messages sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lb_ms_received
                    
                    	Number of LBMs received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lb_ms_sent
                    
                    	Number of LBMs sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lb_rs_bad_data
                    
                    	Number of LBRs received with non\-matching user\-specified data
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lb_rs_out_of_sequence
                    
                    	Number of LBRs received out\-of\-sequence
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lb_rs_received
                    
                    	Number of LBRs received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lb_rs_sent
                    
                    	Number of LBRs sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lc_ks_received
                    
                    	Number of LCK messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lm_ms_received
                    
                    	Number of LMM messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lm_ms_sent
                    
                    	Number of LMM messages sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lm_rs_received
                    
                    	Number of LMR messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lm_rs_sent
                    
                    	Number of LMR messages sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: lt_rs_received_unexpected
                    
                    	Number of unexpected LTRs received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: sl_ms_received
                    
                    	Number of SLM messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: sl_ms_sent
                    
                    	Number of SLM messages sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: sl_rs_received
                    
                    	Number of SLR messages received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: sl_rs_sent
                    
                    	Number of SLR messages sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.LocalMeps.LocalMep.Statistics, self).__init__()

                        self.yang_name = "statistics"
                        self.yang_parent_name = "local-mep"

                        self.ai_ss_received = YLeaf(YType.uint64, "ai-ss-received")

                        self.ai_ss_sent = YLeaf(YType.uint64, "ai-ss-sent")

                        self.bn_ms_discarded = YLeaf(YType.uint64, "bn-ms-discarded")

                        self.bn_ms_received = YLeaf(YType.uint64, "bn-ms-received")

                        self.ccms_discarded = YLeaf(YType.uint64, "ccms-discarded")

                        self.ccms_out_of_sequence = YLeaf(YType.uint64, "ccms-out-of-sequence")

                        self.ccms_received = YLeaf(YType.uint64, "ccms-received")

                        self.ccms_sent = YLeaf(YType.uint64, "ccms-sent")

                        self.dm_ms_received = YLeaf(YType.uint64, "dm-ms-received")

                        self.dm_ms_sent = YLeaf(YType.uint64, "dm-ms-sent")

                        self.dm_rs_received = YLeaf(YType.uint64, "dm-rs-received")

                        self.dm_rs_sent = YLeaf(YType.uint64, "dm-rs-sent")

                        self.lb_ms_received = YLeaf(YType.uint64, "lb-ms-received")

                        self.lb_ms_sent = YLeaf(YType.uint64, "lb-ms-sent")

                        self.lb_rs_bad_data = YLeaf(YType.uint64, "lb-rs-bad-data")

                        self.lb_rs_out_of_sequence = YLeaf(YType.uint64, "lb-rs-out-of-sequence")

                        self.lb_rs_received = YLeaf(YType.uint64, "lb-rs-received")

                        self.lb_rs_sent = YLeaf(YType.uint64, "lb-rs-sent")

                        self.lc_ks_received = YLeaf(YType.uint64, "lc-ks-received")

                        self.lm_ms_received = YLeaf(YType.uint64, "lm-ms-received")

                        self.lm_ms_sent = YLeaf(YType.uint64, "lm-ms-sent")

                        self.lm_rs_received = YLeaf(YType.uint64, "lm-rs-received")

                        self.lm_rs_sent = YLeaf(YType.uint64, "lm-rs-sent")

                        self.lt_rs_received_unexpected = YLeaf(YType.uint64, "lt-rs-received-unexpected")

                        self.sl_ms_received = YLeaf(YType.uint64, "sl-ms-received")

                        self.sl_ms_sent = YLeaf(YType.uint64, "sl-ms-sent")

                        self.sl_rs_received = YLeaf(YType.uint64, "sl-rs-received")

                        self.sl_rs_sent = YLeaf(YType.uint64, "sl-rs-sent")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ai_ss_received",
                                        "ai_ss_sent",
                                        "bn_ms_discarded",
                                        "bn_ms_received",
                                        "ccms_discarded",
                                        "ccms_out_of_sequence",
                                        "ccms_received",
                                        "ccms_sent",
                                        "dm_ms_received",
                                        "dm_ms_sent",
                                        "dm_rs_received",
                                        "dm_rs_sent",
                                        "lb_ms_received",
                                        "lb_ms_sent",
                                        "lb_rs_bad_data",
                                        "lb_rs_out_of_sequence",
                                        "lb_rs_received",
                                        "lb_rs_sent",
                                        "lc_ks_received",
                                        "lm_ms_received",
                                        "lm_ms_sent",
                                        "lm_rs_received",
                                        "lm_rs_sent",
                                        "lt_rs_received_unexpected",
                                        "sl_ms_received",
                                        "sl_ms_sent",
                                        "sl_rs_received",
                                        "sl_rs_sent") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.LocalMeps.LocalMep.Statistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.LocalMeps.LocalMep.Statistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.ai_ss_received.is_set or
                            self.ai_ss_sent.is_set or
                            self.bn_ms_discarded.is_set or
                            self.bn_ms_received.is_set or
                            self.ccms_discarded.is_set or
                            self.ccms_out_of_sequence.is_set or
                            self.ccms_received.is_set or
                            self.ccms_sent.is_set or
                            self.dm_ms_received.is_set or
                            self.dm_ms_sent.is_set or
                            self.dm_rs_received.is_set or
                            self.dm_rs_sent.is_set or
                            self.lb_ms_received.is_set or
                            self.lb_ms_sent.is_set or
                            self.lb_rs_bad_data.is_set or
                            self.lb_rs_out_of_sequence.is_set or
                            self.lb_rs_received.is_set or
                            self.lb_rs_sent.is_set or
                            self.lc_ks_received.is_set or
                            self.lm_ms_received.is_set or
                            self.lm_ms_sent.is_set or
                            self.lm_rs_received.is_set or
                            self.lm_rs_sent.is_set or
                            self.lt_rs_received_unexpected.is_set or
                            self.sl_ms_received.is_set or
                            self.sl_ms_sent.is_set or
                            self.sl_rs_received.is_set or
                            self.sl_rs_sent.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ai_ss_received.yfilter != YFilter.not_set or
                            self.ai_ss_sent.yfilter != YFilter.not_set or
                            self.bn_ms_discarded.yfilter != YFilter.not_set or
                            self.bn_ms_received.yfilter != YFilter.not_set or
                            self.ccms_discarded.yfilter != YFilter.not_set or
                            self.ccms_out_of_sequence.yfilter != YFilter.not_set or
                            self.ccms_received.yfilter != YFilter.not_set or
                            self.ccms_sent.yfilter != YFilter.not_set or
                            self.dm_ms_received.yfilter != YFilter.not_set or
                            self.dm_ms_sent.yfilter != YFilter.not_set or
                            self.dm_rs_received.yfilter != YFilter.not_set or
                            self.dm_rs_sent.yfilter != YFilter.not_set or
                            self.lb_ms_received.yfilter != YFilter.not_set or
                            self.lb_ms_sent.yfilter != YFilter.not_set or
                            self.lb_rs_bad_data.yfilter != YFilter.not_set or
                            self.lb_rs_out_of_sequence.yfilter != YFilter.not_set or
                            self.lb_rs_received.yfilter != YFilter.not_set or
                            self.lb_rs_sent.yfilter != YFilter.not_set or
                            self.lc_ks_received.yfilter != YFilter.not_set or
                            self.lm_ms_received.yfilter != YFilter.not_set or
                            self.lm_ms_sent.yfilter != YFilter.not_set or
                            self.lm_rs_received.yfilter != YFilter.not_set or
                            self.lm_rs_sent.yfilter != YFilter.not_set or
                            self.lt_rs_received_unexpected.yfilter != YFilter.not_set or
                            self.sl_ms_received.yfilter != YFilter.not_set or
                            self.sl_ms_sent.yfilter != YFilter.not_set or
                            self.sl_rs_received.yfilter != YFilter.not_set or
                            self.sl_rs_sent.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ai_ss_received.is_set or self.ai_ss_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ai_ss_received.get_name_leafdata())
                        if (self.ai_ss_sent.is_set or self.ai_ss_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ai_ss_sent.get_name_leafdata())
                        if (self.bn_ms_discarded.is_set or self.bn_ms_discarded.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bn_ms_discarded.get_name_leafdata())
                        if (self.bn_ms_received.is_set or self.bn_ms_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bn_ms_received.get_name_leafdata())
                        if (self.ccms_discarded.is_set or self.ccms_discarded.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ccms_discarded.get_name_leafdata())
                        if (self.ccms_out_of_sequence.is_set or self.ccms_out_of_sequence.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ccms_out_of_sequence.get_name_leafdata())
                        if (self.ccms_received.is_set or self.ccms_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ccms_received.get_name_leafdata())
                        if (self.ccms_sent.is_set or self.ccms_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ccms_sent.get_name_leafdata())
                        if (self.dm_ms_received.is_set or self.dm_ms_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dm_ms_received.get_name_leafdata())
                        if (self.dm_ms_sent.is_set or self.dm_ms_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dm_ms_sent.get_name_leafdata())
                        if (self.dm_rs_received.is_set or self.dm_rs_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dm_rs_received.get_name_leafdata())
                        if (self.dm_rs_sent.is_set or self.dm_rs_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dm_rs_sent.get_name_leafdata())
                        if (self.lb_ms_received.is_set or self.lb_ms_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lb_ms_received.get_name_leafdata())
                        if (self.lb_ms_sent.is_set or self.lb_ms_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lb_ms_sent.get_name_leafdata())
                        if (self.lb_rs_bad_data.is_set or self.lb_rs_bad_data.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lb_rs_bad_data.get_name_leafdata())
                        if (self.lb_rs_out_of_sequence.is_set or self.lb_rs_out_of_sequence.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lb_rs_out_of_sequence.get_name_leafdata())
                        if (self.lb_rs_received.is_set or self.lb_rs_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lb_rs_received.get_name_leafdata())
                        if (self.lb_rs_sent.is_set or self.lb_rs_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lb_rs_sent.get_name_leafdata())
                        if (self.lc_ks_received.is_set or self.lc_ks_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lc_ks_received.get_name_leafdata())
                        if (self.lm_ms_received.is_set or self.lm_ms_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lm_ms_received.get_name_leafdata())
                        if (self.lm_ms_sent.is_set or self.lm_ms_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lm_ms_sent.get_name_leafdata())
                        if (self.lm_rs_received.is_set or self.lm_rs_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lm_rs_received.get_name_leafdata())
                        if (self.lm_rs_sent.is_set or self.lm_rs_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lm_rs_sent.get_name_leafdata())
                        if (self.lt_rs_received_unexpected.is_set or self.lt_rs_received_unexpected.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lt_rs_received_unexpected.get_name_leafdata())
                        if (self.sl_ms_received.is_set or self.sl_ms_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sl_ms_received.get_name_leafdata())
                        if (self.sl_ms_sent.is_set or self.sl_ms_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sl_ms_sent.get_name_leafdata())
                        if (self.sl_rs_received.is_set or self.sl_rs_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sl_rs_received.get_name_leafdata())
                        if (self.sl_rs_sent.is_set or self.sl_rs_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sl_rs_sent.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ai-ss-received" or name == "ai-ss-sent" or name == "bn-ms-discarded" or name == "bn-ms-received" or name == "ccms-discarded" or name == "ccms-out-of-sequence" or name == "ccms-received" or name == "ccms-sent" or name == "dm-ms-received" or name == "dm-ms-sent" or name == "dm-rs-received" or name == "dm-rs-sent" or name == "lb-ms-received" or name == "lb-ms-sent" or name == "lb-rs-bad-data" or name == "lb-rs-out-of-sequence" or name == "lb-rs-received" or name == "lb-rs-sent" or name == "lc-ks-received" or name == "lm-ms-received" or name == "lm-ms-sent" or name == "lm-rs-received" or name == "lm-rs-sent" or name == "lt-rs-received-unexpected" or name == "sl-ms-received" or name == "sl-ms-sent" or name == "sl-rs-received" or name == "sl-rs-sent"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ai-ss-received"):
                            self.ai_ss_received = value
                            self.ai_ss_received.value_namespace = name_space
                            self.ai_ss_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "ai-ss-sent"):
                            self.ai_ss_sent = value
                            self.ai_ss_sent.value_namespace = name_space
                            self.ai_ss_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "bn-ms-discarded"):
                            self.bn_ms_discarded = value
                            self.bn_ms_discarded.value_namespace = name_space
                            self.bn_ms_discarded.value_namespace_prefix = name_space_prefix
                        if(value_path == "bn-ms-received"):
                            self.bn_ms_received = value
                            self.bn_ms_received.value_namespace = name_space
                            self.bn_ms_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "ccms-discarded"):
                            self.ccms_discarded = value
                            self.ccms_discarded.value_namespace = name_space
                            self.ccms_discarded.value_namespace_prefix = name_space_prefix
                        if(value_path == "ccms-out-of-sequence"):
                            self.ccms_out_of_sequence = value
                            self.ccms_out_of_sequence.value_namespace = name_space
                            self.ccms_out_of_sequence.value_namespace_prefix = name_space_prefix
                        if(value_path == "ccms-received"):
                            self.ccms_received = value
                            self.ccms_received.value_namespace = name_space
                            self.ccms_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "ccms-sent"):
                            self.ccms_sent = value
                            self.ccms_sent.value_namespace = name_space
                            self.ccms_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "dm-ms-received"):
                            self.dm_ms_received = value
                            self.dm_ms_received.value_namespace = name_space
                            self.dm_ms_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "dm-ms-sent"):
                            self.dm_ms_sent = value
                            self.dm_ms_sent.value_namespace = name_space
                            self.dm_ms_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "dm-rs-received"):
                            self.dm_rs_received = value
                            self.dm_rs_received.value_namespace = name_space
                            self.dm_rs_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "dm-rs-sent"):
                            self.dm_rs_sent = value
                            self.dm_rs_sent.value_namespace = name_space
                            self.dm_rs_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "lb-ms-received"):
                            self.lb_ms_received = value
                            self.lb_ms_received.value_namespace = name_space
                            self.lb_ms_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "lb-ms-sent"):
                            self.lb_ms_sent = value
                            self.lb_ms_sent.value_namespace = name_space
                            self.lb_ms_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "lb-rs-bad-data"):
                            self.lb_rs_bad_data = value
                            self.lb_rs_bad_data.value_namespace = name_space
                            self.lb_rs_bad_data.value_namespace_prefix = name_space_prefix
                        if(value_path == "lb-rs-out-of-sequence"):
                            self.lb_rs_out_of_sequence = value
                            self.lb_rs_out_of_sequence.value_namespace = name_space
                            self.lb_rs_out_of_sequence.value_namespace_prefix = name_space_prefix
                        if(value_path == "lb-rs-received"):
                            self.lb_rs_received = value
                            self.lb_rs_received.value_namespace = name_space
                            self.lb_rs_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "lb-rs-sent"):
                            self.lb_rs_sent = value
                            self.lb_rs_sent.value_namespace = name_space
                            self.lb_rs_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "lc-ks-received"):
                            self.lc_ks_received = value
                            self.lc_ks_received.value_namespace = name_space
                            self.lc_ks_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "lm-ms-received"):
                            self.lm_ms_received = value
                            self.lm_ms_received.value_namespace = name_space
                            self.lm_ms_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "lm-ms-sent"):
                            self.lm_ms_sent = value
                            self.lm_ms_sent.value_namespace = name_space
                            self.lm_ms_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "lm-rs-received"):
                            self.lm_rs_received = value
                            self.lm_rs_received.value_namespace = name_space
                            self.lm_rs_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "lm-rs-sent"):
                            self.lm_rs_sent = value
                            self.lm_rs_sent.value_namespace = name_space
                            self.lm_rs_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "lt-rs-received-unexpected"):
                            self.lt_rs_received_unexpected = value
                            self.lt_rs_received_unexpected.value_namespace = name_space
                            self.lt_rs_received_unexpected.value_namespace_prefix = name_space_prefix
                        if(value_path == "sl-ms-received"):
                            self.sl_ms_received = value
                            self.sl_ms_received.value_namespace = name_space
                            self.sl_ms_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "sl-ms-sent"):
                            self.sl_ms_sent = value
                            self.sl_ms_sent.value_namespace = name_space
                            self.sl_ms_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "sl-rs-received"):
                            self.sl_rs_received = value
                            self.sl_rs_received.value_namespace = name_space
                            self.sl_rs_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "sl-rs-sent"):
                            self.sl_rs_sent = value
                            self.sl_rs_sent.value_namespace = name_space
                            self.sl_rs_sent.value_namespace_prefix = name_space_prefix


                class AisStatistics(Entity):
                    """
                    MEP AIS statistics
                    
                    .. attribute:: interval
                    
                    	AIS transmission interval
                    	**type**\:   :py:class:`CfmBagAisInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagAisInterval>`
                    
                    .. attribute:: last_interval
                    
                    	The interval of the last received AIS packet
                    	**type**\:   :py:class:`CfmBagAisInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagAisInterval>`
                    
                    .. attribute:: last_mac_address
                    
                    	Source MAC address of the last received AIS packet
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: level
                    
                    	AIS transmission level
                    	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                    
                    .. attribute:: receiving_ais
                    
                    	Details of how the signal is being received
                    	**type**\:   :py:class:`CfmPmAisReceive <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmAisReceive>`
                    
                    .. attribute:: receiving_start
                    
                    	Time elapsed since AIS receiving started
                    	**type**\:   :py:class:`ReceivingStart <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps.LocalMep.AisStatistics.ReceivingStart>`
                    
                    .. attribute:: sending_ais
                    
                    	Details of how AIS is being transmitted
                    	**type**\:   :py:class:`CfmPmAisTransmit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmAisTransmit>`
                    
                    .. attribute:: sending_start
                    
                    	Time elapsed since AIS sending started
                    	**type**\:   :py:class:`SendingStart <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps.LocalMep.AisStatistics.SendingStart>`
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics, self).__init__()

                        self.yang_name = "ais-statistics"
                        self.yang_parent_name = "local-mep"

                        self.interval = YLeaf(YType.enumeration, "interval")

                        self.last_interval = YLeaf(YType.enumeration, "last-interval")

                        self.last_mac_address = YLeaf(YType.str, "last-mac-address")

                        self.level = YLeaf(YType.enumeration, "level")

                        self.receiving_ais = YLeaf(YType.enumeration, "receiving-ais")

                        self.sending_ais = YLeaf(YType.enumeration, "sending-ais")

                        self.receiving_start = Cfm.Global_.LocalMeps.LocalMep.AisStatistics.ReceivingStart()
                        self.receiving_start.parent = self
                        self._children_name_map["receiving_start"] = "receiving-start"
                        self._children_yang_names.add("receiving-start")

                        self.sending_start = Cfm.Global_.LocalMeps.LocalMep.AisStatistics.SendingStart()
                        self.sending_start.parent = self
                        self._children_name_map["sending_start"] = "sending-start"
                        self._children_yang_names.add("sending-start")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interval",
                                        "last_interval",
                                        "last_mac_address",
                                        "level",
                                        "receiving_ais",
                                        "sending_ais") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics, self).__setattr__(name, value)


                    class SendingStart(Entity):
                        """
                        Time elapsed since AIS sending started
                        
                        .. attribute:: nanoseconds
                        
                        	Nanoseconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: nanosecond
                        
                        .. attribute:: seconds
                        
                        	Seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics.SendingStart, self).__init__()

                            self.yang_name = "sending-start"
                            self.yang_parent_name = "ais-statistics"

                            self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                            self.seconds = YLeaf(YType.uint32, "seconds")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("nanoseconds",
                                            "seconds") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics.SendingStart, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics.SendingStart, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.nanoseconds.is_set or
                                self.seconds.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.nanoseconds.yfilter != YFilter.not_set or
                                self.seconds.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sending-start" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                            if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.seconds.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "nanoseconds" or name == "seconds"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "nanoseconds"):
                                self.nanoseconds = value
                                self.nanoseconds.value_namespace = name_space
                                self.nanoseconds.value_namespace_prefix = name_space_prefix
                            if(value_path == "seconds"):
                                self.seconds = value
                                self.seconds.value_namespace = name_space
                                self.seconds.value_namespace_prefix = name_space_prefix


                    class ReceivingStart(Entity):
                        """
                        Time elapsed since AIS receiving started
                        
                        .. attribute:: nanoseconds
                        
                        	Nanoseconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: nanosecond
                        
                        .. attribute:: seconds
                        
                        	Seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics.ReceivingStart, self).__init__()

                            self.yang_name = "receiving-start"
                            self.yang_parent_name = "ais-statistics"

                            self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                            self.seconds = YLeaf(YType.uint32, "seconds")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("nanoseconds",
                                            "seconds") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics.ReceivingStart, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.LocalMeps.LocalMep.AisStatistics.ReceivingStart, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.nanoseconds.is_set or
                                self.seconds.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.nanoseconds.yfilter != YFilter.not_set or
                                self.seconds.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "receiving-start" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                            if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.seconds.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "nanoseconds" or name == "seconds"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "nanoseconds"):
                                self.nanoseconds = value
                                self.nanoseconds.value_namespace = name_space
                                self.nanoseconds.value_namespace_prefix = name_space_prefix
                            if(value_path == "seconds"):
                                self.seconds = value
                                self.seconds.value_namespace = name_space
                                self.seconds.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.interval.is_set or
                            self.last_interval.is_set or
                            self.last_mac_address.is_set or
                            self.level.is_set or
                            self.receiving_ais.is_set or
                            self.sending_ais.is_set or
                            (self.receiving_start is not None and self.receiving_start.has_data()) or
                            (self.sending_start is not None and self.sending_start.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.last_interval.yfilter != YFilter.not_set or
                            self.last_mac_address.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.receiving_ais.yfilter != YFilter.not_set or
                            self.sending_ais.yfilter != YFilter.not_set or
                            (self.receiving_start is not None and self.receiving_start.has_operation()) or
                            (self.sending_start is not None and self.sending_start.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ais-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.last_interval.is_set or self.last_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_interval.get_name_leafdata())
                        if (self.last_mac_address.is_set or self.last_mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_mac_address.get_name_leafdata())
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.receiving_ais.is_set or self.receiving_ais.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.receiving_ais.get_name_leafdata())
                        if (self.sending_ais.is_set or self.sending_ais.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sending_ais.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "receiving-start"):
                            if (self.receiving_start is None):
                                self.receiving_start = Cfm.Global_.LocalMeps.LocalMep.AisStatistics.ReceivingStart()
                                self.receiving_start.parent = self
                                self._children_name_map["receiving_start"] = "receiving-start"
                            return self.receiving_start

                        if (child_yang_name == "sending-start"):
                            if (self.sending_start is None):
                                self.sending_start = Cfm.Global_.LocalMeps.LocalMep.AisStatistics.SendingStart()
                                self.sending_start.parent = self
                                self._children_name_map["sending_start"] = "sending-start"
                            return self.sending_start

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "receiving-start" or name == "sending-start" or name == "interval" or name == "last-interval" or name == "last-mac-address" or name == "level" or name == "receiving-ais" or name == "sending-ais"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-interval"):
                            self.last_interval = value
                            self.last_interval.value_namespace = name_space
                            self.last_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-mac-address"):
                            self.last_mac_address = value
                            self.last_mac_address.value_namespace = name_space
                            self.last_mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "receiving-ais"):
                            self.receiving_ais = value
                            self.receiving_ais.value_namespace = name_space
                            self.receiving_ais.value_namespace_prefix = name_space_prefix
                        if(value_path == "sending-ais"):
                            self.sending_ais = value
                            self.sending_ais.value_namespace = name_space
                            self.sending_ais.value_namespace_prefix = name_space_prefix


                class Defects(Entity):
                    """
                    Defects detected from peer MEPs
                    
                    .. attribute:: ais_received
                    
                    	AIS or LCK received
                    	**type**\:  bool
                    
                    .. attribute:: auto_missing
                    
                    	Number of missing auto cross\-check MEPs
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: local_port_status
                    
                    	The local port or interface is down
                    	**type**\:  bool
                    
                    .. attribute:: missing
                    
                    	Number of missing peer MEPs
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: peer_meps_that_timed_out
                    
                    	Number of peer MEPs that have timed out
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: peer_port_status
                    
                    	A peer port or interface is down
                    	**type**\:  bool
                    
                    .. attribute:: remote_meps_defects
                    
                    	Defects detected from remote MEPs
                    	**type**\:   :py:class:`RemoteMepsDefects <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.LocalMeps.LocalMep.Defects.RemoteMepsDefects>`
                    
                    .. attribute:: unexpected
                    
                    	Number of unexpected peer MEPs
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.LocalMeps.LocalMep.Defects, self).__init__()

                        self.yang_name = "defects"
                        self.yang_parent_name = "local-mep"

                        self.ais_received = YLeaf(YType.boolean, "ais-received")

                        self.auto_missing = YLeaf(YType.uint32, "auto-missing")

                        self.local_port_status = YLeaf(YType.boolean, "local-port-status")

                        self.missing = YLeaf(YType.uint32, "missing")

                        self.peer_meps_that_timed_out = YLeaf(YType.uint32, "peer-meps-that-timed-out")

                        self.peer_port_status = YLeaf(YType.boolean, "peer-port-status")

                        self.unexpected = YLeaf(YType.uint32, "unexpected")

                        self.remote_meps_defects = Cfm.Global_.LocalMeps.LocalMep.Defects.RemoteMepsDefects()
                        self.remote_meps_defects.parent = self
                        self._children_name_map["remote_meps_defects"] = "remote-meps-defects"
                        self._children_yang_names.add("remote-meps-defects")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ais_received",
                                        "auto_missing",
                                        "local_port_status",
                                        "missing",
                                        "peer_meps_that_timed_out",
                                        "peer_port_status",
                                        "unexpected") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.LocalMeps.LocalMep.Defects, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.LocalMeps.LocalMep.Defects, self).__setattr__(name, value)


                    class RemoteMepsDefects(Entity):
                        """
                        Defects detected from remote MEPs
                        
                        .. attribute:: invalid_ccm_interval
                        
                        	Invalid CCM interval
                        	**type**\:  bool
                        
                        .. attribute:: invalid_level
                        
                        	Invalid level
                        	**type**\:  bool
                        
                        .. attribute:: invalid_maid
                        
                        	Invalid MAID
                        	**type**\:  bool
                        
                        .. attribute:: loss_threshold_exceeded
                        
                        	Timed out (loss threshold exceeded)
                        	**type**\:  bool
                        
                        .. attribute:: received_our_mac
                        
                        	Loop detected (our MAC address received)
                        	**type**\:  bool
                        
                        .. attribute:: received_our_mep_id
                        
                        	Configuration Error (our MEP ID received)
                        	**type**\:  bool
                        
                        .. attribute:: received_rdi
                        
                        	Remote defection indication received
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.LocalMeps.LocalMep.Defects.RemoteMepsDefects, self).__init__()

                            self.yang_name = "remote-meps-defects"
                            self.yang_parent_name = "defects"

                            self.invalid_ccm_interval = YLeaf(YType.boolean, "invalid-ccm-interval")

                            self.invalid_level = YLeaf(YType.boolean, "invalid-level")

                            self.invalid_maid = YLeaf(YType.boolean, "invalid-maid")

                            self.loss_threshold_exceeded = YLeaf(YType.boolean, "loss-threshold-exceeded")

                            self.received_our_mac = YLeaf(YType.boolean, "received-our-mac")

                            self.received_our_mep_id = YLeaf(YType.boolean, "received-our-mep-id")

                            self.received_rdi = YLeaf(YType.boolean, "received-rdi")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("invalid_ccm_interval",
                                            "invalid_level",
                                            "invalid_maid",
                                            "loss_threshold_exceeded",
                                            "received_our_mac",
                                            "received_our_mep_id",
                                            "received_rdi") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.LocalMeps.LocalMep.Defects.RemoteMepsDefects, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.LocalMeps.LocalMep.Defects.RemoteMepsDefects, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.invalid_ccm_interval.is_set or
                                self.invalid_level.is_set or
                                self.invalid_maid.is_set or
                                self.loss_threshold_exceeded.is_set or
                                self.received_our_mac.is_set or
                                self.received_our_mep_id.is_set or
                                self.received_rdi.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.invalid_ccm_interval.yfilter != YFilter.not_set or
                                self.invalid_level.yfilter != YFilter.not_set or
                                self.invalid_maid.yfilter != YFilter.not_set or
                                self.loss_threshold_exceeded.yfilter != YFilter.not_set or
                                self.received_our_mac.yfilter != YFilter.not_set or
                                self.received_our_mep_id.yfilter != YFilter.not_set or
                                self.received_rdi.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "remote-meps-defects" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.invalid_ccm_interval.is_set or self.invalid_ccm_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.invalid_ccm_interval.get_name_leafdata())
                            if (self.invalid_level.is_set or self.invalid_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.invalid_level.get_name_leafdata())
                            if (self.invalid_maid.is_set or self.invalid_maid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.invalid_maid.get_name_leafdata())
                            if (self.loss_threshold_exceeded.is_set or self.loss_threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.loss_threshold_exceeded.get_name_leafdata())
                            if (self.received_our_mac.is_set or self.received_our_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_our_mac.get_name_leafdata())
                            if (self.received_our_mep_id.is_set or self.received_our_mep_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_our_mep_id.get_name_leafdata())
                            if (self.received_rdi.is_set or self.received_rdi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_rdi.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "invalid-ccm-interval" or name == "invalid-level" or name == "invalid-maid" or name == "loss-threshold-exceeded" or name == "received-our-mac" or name == "received-our-mep-id" or name == "received-rdi"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "invalid-ccm-interval"):
                                self.invalid_ccm_interval = value
                                self.invalid_ccm_interval.value_namespace = name_space
                                self.invalid_ccm_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "invalid-level"):
                                self.invalid_level = value
                                self.invalid_level.value_namespace = name_space
                                self.invalid_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "invalid-maid"):
                                self.invalid_maid = value
                                self.invalid_maid.value_namespace = name_space
                                self.invalid_maid.value_namespace_prefix = name_space_prefix
                            if(value_path == "loss-threshold-exceeded"):
                                self.loss_threshold_exceeded = value
                                self.loss_threshold_exceeded.value_namespace = name_space
                                self.loss_threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-our-mac"):
                                self.received_our_mac = value
                                self.received_our_mac.value_namespace = name_space
                                self.received_our_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-our-mep-id"):
                                self.received_our_mep_id = value
                                self.received_our_mep_id.value_namespace = name_space
                                self.received_our_mep_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-rdi"):
                                self.received_rdi = value
                                self.received_rdi.value_namespace = name_space
                                self.received_rdi.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.ais_received.is_set or
                            self.auto_missing.is_set or
                            self.local_port_status.is_set or
                            self.missing.is_set or
                            self.peer_meps_that_timed_out.is_set or
                            self.peer_port_status.is_set or
                            self.unexpected.is_set or
                            (self.remote_meps_defects is not None and self.remote_meps_defects.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ais_received.yfilter != YFilter.not_set or
                            self.auto_missing.yfilter != YFilter.not_set or
                            self.local_port_status.yfilter != YFilter.not_set or
                            self.missing.yfilter != YFilter.not_set or
                            self.peer_meps_that_timed_out.yfilter != YFilter.not_set or
                            self.peer_port_status.yfilter != YFilter.not_set or
                            self.unexpected.yfilter != YFilter.not_set or
                            (self.remote_meps_defects is not None and self.remote_meps_defects.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "defects" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ais_received.is_set or self.ais_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ais_received.get_name_leafdata())
                        if (self.auto_missing.is_set or self.auto_missing.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.auto_missing.get_name_leafdata())
                        if (self.local_port_status.is_set or self.local_port_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_port_status.get_name_leafdata())
                        if (self.missing.is_set or self.missing.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.missing.get_name_leafdata())
                        if (self.peer_meps_that_timed_out.is_set or self.peer_meps_that_timed_out.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_meps_that_timed_out.get_name_leafdata())
                        if (self.peer_port_status.is_set or self.peer_port_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_port_status.get_name_leafdata())
                        if (self.unexpected.is_set or self.unexpected.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unexpected.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "remote-meps-defects"):
                            if (self.remote_meps_defects is None):
                                self.remote_meps_defects = Cfm.Global_.LocalMeps.LocalMep.Defects.RemoteMepsDefects()
                                self.remote_meps_defects.parent = self
                                self._children_name_map["remote_meps_defects"] = "remote-meps-defects"
                            return self.remote_meps_defects

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "remote-meps-defects" or name == "ais-received" or name == "auto-missing" or name == "local-port-status" or name == "missing" or name == "peer-meps-that-timed-out" or name == "peer-port-status" or name == "unexpected"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ais-received"):
                            self.ais_received = value
                            self.ais_received.value_namespace = name_space
                            self.ais_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "auto-missing"):
                            self.auto_missing = value
                            self.auto_missing.value_namespace = name_space
                            self.auto_missing.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-port-status"):
                            self.local_port_status = value
                            self.local_port_status.value_namespace = name_space
                            self.local_port_status.value_namespace_prefix = name_space_prefix
                        if(value_path == "missing"):
                            self.missing = value
                            self.missing.value_namespace = name_space
                            self.missing.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-meps-that-timed-out"):
                            self.peer_meps_that_timed_out = value
                            self.peer_meps_that_timed_out.value_namespace = name_space
                            self.peer_meps_that_timed_out.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-port-status"):
                            self.peer_port_status = value
                            self.peer_port_status.value_namespace = name_space
                            self.peer_port_status.value_namespace_prefix = name_space_prefix
                        if(value_path == "unexpected"):
                            self.unexpected = value
                            self.unexpected.value_namespace = name_space
                            self.unexpected.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.domain.is_set or
                        self.service.is_set or
                        self.mep_id.is_set or
                        self.interface.is_set or
                        self.ccm_generation_enabled.is_set or
                        self.ccm_interval.is_set or
                        self.ccm_offload.is_set or
                        self.cos.is_set or
                        self.cross_connect_ccm_defect.is_set or
                        self.defects_ignored.is_set or
                        self.domain_xr.is_set or
                        self.efd_triggered.is_set or
                        self.error_ccm_defect.is_set or
                        self.fault_notification_state.is_set or
                        self.hairpin.is_set or
                        self.highest_defect.is_set or
                        self.interface_state.is_set or
                        self.interface_xr.is_set or
                        self.interworking_state.is_set or
                        self.level.is_set or
                        self.mac_address.is_set or
                        self.mac_status_defect.is_set or
                        self.mep_direction.is_set or
                        self.mep_id_xr.is_set or
                        self.next_lbm_id.is_set or
                        self.next_ltm_id.is_set or
                        self.peer_mep_ccm_defect.is_set or
                        self.peer_meps_detected.is_set or
                        self.peer_meps_with_errors_detected.is_set or
                        self.rdi_defect.is_set or
                        self.remote_defect.is_set or
                        self.service_xr.is_set or
                        self.standby.is_set or
                        self.stp_state.is_set or
                        (self.ais_statistics is not None and self.ais_statistics.has_data()) or
                        (self.defects is not None and self.defects.has_data()) or
                        (self.statistics is not None and self.statistics.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain.yfilter != YFilter.not_set or
                        self.service.yfilter != YFilter.not_set or
                        self.mep_id.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.ccm_generation_enabled.yfilter != YFilter.not_set or
                        self.ccm_interval.yfilter != YFilter.not_set or
                        self.ccm_offload.yfilter != YFilter.not_set or
                        self.cos.yfilter != YFilter.not_set or
                        self.cross_connect_ccm_defect.yfilter != YFilter.not_set or
                        self.defects_ignored.yfilter != YFilter.not_set or
                        self.domain_xr.yfilter != YFilter.not_set or
                        self.efd_triggered.yfilter != YFilter.not_set or
                        self.error_ccm_defect.yfilter != YFilter.not_set or
                        self.fault_notification_state.yfilter != YFilter.not_set or
                        self.hairpin.yfilter != YFilter.not_set or
                        self.highest_defect.yfilter != YFilter.not_set or
                        self.interface_state.yfilter != YFilter.not_set or
                        self.interface_xr.yfilter != YFilter.not_set or
                        self.interworking_state.yfilter != YFilter.not_set or
                        self.level.yfilter != YFilter.not_set or
                        self.mac_address.yfilter != YFilter.not_set or
                        self.mac_status_defect.yfilter != YFilter.not_set or
                        self.mep_direction.yfilter != YFilter.not_set or
                        self.mep_id_xr.yfilter != YFilter.not_set or
                        self.next_lbm_id.yfilter != YFilter.not_set or
                        self.next_ltm_id.yfilter != YFilter.not_set or
                        self.peer_mep_ccm_defect.yfilter != YFilter.not_set or
                        self.peer_meps_detected.yfilter != YFilter.not_set or
                        self.peer_meps_with_errors_detected.yfilter != YFilter.not_set or
                        self.rdi_defect.yfilter != YFilter.not_set or
                        self.remote_defect.yfilter != YFilter.not_set or
                        self.service_xr.yfilter != YFilter.not_set or
                        self.standby.yfilter != YFilter.not_set or
                        self.stp_state.yfilter != YFilter.not_set or
                        (self.ais_statistics is not None and self.ais_statistics.has_operation()) or
                        (self.defects is not None and self.defects.has_operation()) or
                        (self.statistics is not None and self.statistics.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "local-mep" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + "[mep-id='" + self.mep_id.get() + "']" + "[interface='" + self.interface.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/local-meps/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain.get_name_leafdata())
                    if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service.get_name_leafdata())
                    if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_id.get_name_leafdata())
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.ccm_generation_enabled.is_set or self.ccm_generation_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ccm_generation_enabled.get_name_leafdata())
                    if (self.ccm_interval.is_set or self.ccm_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ccm_interval.get_name_leafdata())
                    if (self.ccm_offload.is_set or self.ccm_offload.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ccm_offload.get_name_leafdata())
                    if (self.cos.is_set or self.cos.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cos.get_name_leafdata())
                    if (self.cross_connect_ccm_defect.is_set or self.cross_connect_ccm_defect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cross_connect_ccm_defect.get_name_leafdata())
                    if (self.defects_ignored.is_set or self.defects_ignored.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.defects_ignored.get_name_leafdata())
                    if (self.domain_xr.is_set or self.domain_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain_xr.get_name_leafdata())
                    if (self.efd_triggered.is_set or self.efd_triggered.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.efd_triggered.get_name_leafdata())
                    if (self.error_ccm_defect.is_set or self.error_ccm_defect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.error_ccm_defect.get_name_leafdata())
                    if (self.fault_notification_state.is_set or self.fault_notification_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fault_notification_state.get_name_leafdata())
                    if (self.hairpin.is_set or self.hairpin.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hairpin.get_name_leafdata())
                    if (self.highest_defect.is_set or self.highest_defect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.highest_defect.get_name_leafdata())
                    if (self.interface_state.is_set or self.interface_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_state.get_name_leafdata())
                    if (self.interface_xr.is_set or self.interface_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_xr.get_name_leafdata())
                    if (self.interworking_state.is_set or self.interworking_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interworking_state.get_name_leafdata())
                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.level.get_name_leafdata())
                    if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_address.get_name_leafdata())
                    if (self.mac_status_defect.is_set or self.mac_status_defect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mac_status_defect.get_name_leafdata())
                    if (self.mep_direction.is_set or self.mep_direction.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_direction.get_name_leafdata())
                    if (self.mep_id_xr.is_set or self.mep_id_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_id_xr.get_name_leafdata())
                    if (self.next_lbm_id.is_set or self.next_lbm_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.next_lbm_id.get_name_leafdata())
                    if (self.next_ltm_id.is_set or self.next_ltm_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.next_ltm_id.get_name_leafdata())
                    if (self.peer_mep_ccm_defect.is_set or self.peer_mep_ccm_defect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_mep_ccm_defect.get_name_leafdata())
                    if (self.peer_meps_detected.is_set or self.peer_meps_detected.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_meps_detected.get_name_leafdata())
                    if (self.peer_meps_with_errors_detected.is_set or self.peer_meps_with_errors_detected.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_meps_with_errors_detected.get_name_leafdata())
                    if (self.rdi_defect.is_set or self.rdi_defect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rdi_defect.get_name_leafdata())
                    if (self.remote_defect.is_set or self.remote_defect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_defect.get_name_leafdata())
                    if (self.service_xr.is_set or self.service_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service_xr.get_name_leafdata())
                    if (self.standby.is_set or self.standby.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby.get_name_leafdata())
                    if (self.stp_state.is_set or self.stp_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stp_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ais-statistics"):
                        if (self.ais_statistics is None):
                            self.ais_statistics = Cfm.Global_.LocalMeps.LocalMep.AisStatistics()
                            self.ais_statistics.parent = self
                            self._children_name_map["ais_statistics"] = "ais-statistics"
                        return self.ais_statistics

                    if (child_yang_name == "defects"):
                        if (self.defects is None):
                            self.defects = Cfm.Global_.LocalMeps.LocalMep.Defects()
                            self.defects.parent = self
                            self._children_name_map["defects"] = "defects"
                        return self.defects

                    if (child_yang_name == "statistics"):
                        if (self.statistics is None):
                            self.statistics = Cfm.Global_.LocalMeps.LocalMep.Statistics()
                            self.statistics.parent = self
                            self._children_name_map["statistics"] = "statistics"
                        return self.statistics

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ais-statistics" or name == "defects" or name == "statistics" or name == "domain" or name == "service" or name == "mep-id" or name == "interface" or name == "ccm-generation-enabled" or name == "ccm-interval" or name == "ccm-offload" or name == "cos" or name == "cross-connect-ccm-defect" or name == "defects-ignored" or name == "domain-xr" or name == "efd-triggered" or name == "error-ccm-defect" or name == "fault-notification-state" or name == "hairpin" or name == "highest-defect" or name == "interface-state" or name == "interface-xr" or name == "interworking-state" or name == "level" or name == "mac-address" or name == "mac-status-defect" or name == "mep-direction" or name == "mep-id-xr" or name == "next-lbm-id" or name == "next-ltm-id" or name == "peer-mep-ccm-defect" or name == "peer-meps-detected" or name == "peer-meps-with-errors-detected" or name == "rdi-defect" or name == "remote-defect" or name == "service-xr" or name == "standby" or name == "stp-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain"):
                        self.domain = value
                        self.domain.value_namespace = name_space
                        self.domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "service"):
                        self.service = value
                        self.service.value_namespace = name_space
                        self.service.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-id"):
                        self.mep_id = value
                        self.mep_id.value_namespace = name_space
                        self.mep_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "ccm-generation-enabled"):
                        self.ccm_generation_enabled = value
                        self.ccm_generation_enabled.value_namespace = name_space
                        self.ccm_generation_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "ccm-interval"):
                        self.ccm_interval = value
                        self.ccm_interval.value_namespace = name_space
                        self.ccm_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "ccm-offload"):
                        self.ccm_offload = value
                        self.ccm_offload.value_namespace = name_space
                        self.ccm_offload.value_namespace_prefix = name_space_prefix
                    if(value_path == "cos"):
                        self.cos = value
                        self.cos.value_namespace = name_space
                        self.cos.value_namespace_prefix = name_space_prefix
                    if(value_path == "cross-connect-ccm-defect"):
                        self.cross_connect_ccm_defect = value
                        self.cross_connect_ccm_defect.value_namespace = name_space
                        self.cross_connect_ccm_defect.value_namespace_prefix = name_space_prefix
                    if(value_path == "defects-ignored"):
                        self.defects_ignored = value
                        self.defects_ignored.value_namespace = name_space
                        self.defects_ignored.value_namespace_prefix = name_space_prefix
                    if(value_path == "domain-xr"):
                        self.domain_xr = value
                        self.domain_xr.value_namespace = name_space
                        self.domain_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "efd-triggered"):
                        self.efd_triggered = value
                        self.efd_triggered.value_namespace = name_space
                        self.efd_triggered.value_namespace_prefix = name_space_prefix
                    if(value_path == "error-ccm-defect"):
                        self.error_ccm_defect = value
                        self.error_ccm_defect.value_namespace = name_space
                        self.error_ccm_defect.value_namespace_prefix = name_space_prefix
                    if(value_path == "fault-notification-state"):
                        self.fault_notification_state = value
                        self.fault_notification_state.value_namespace = name_space
                        self.fault_notification_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "hairpin"):
                        self.hairpin = value
                        self.hairpin.value_namespace = name_space
                        self.hairpin.value_namespace_prefix = name_space_prefix
                    if(value_path == "highest-defect"):
                        self.highest_defect = value
                        self.highest_defect.value_namespace = name_space
                        self.highest_defect.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-state"):
                        self.interface_state = value
                        self.interface_state.value_namespace = name_space
                        self.interface_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-xr"):
                        self.interface_xr = value
                        self.interface_xr.value_namespace = name_space
                        self.interface_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "interworking-state"):
                        self.interworking_state = value
                        self.interworking_state.value_namespace = name_space
                        self.interworking_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "level"):
                        self.level = value
                        self.level.value_namespace = name_space
                        self.level.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-address"):
                        self.mac_address = value
                        self.mac_address.value_namespace = name_space
                        self.mac_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "mac-status-defect"):
                        self.mac_status_defect = value
                        self.mac_status_defect.value_namespace = name_space
                        self.mac_status_defect.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-direction"):
                        self.mep_direction = value
                        self.mep_direction.value_namespace = name_space
                        self.mep_direction.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-id-xr"):
                        self.mep_id_xr = value
                        self.mep_id_xr.value_namespace = name_space
                        self.mep_id_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "next-lbm-id"):
                        self.next_lbm_id = value
                        self.next_lbm_id.value_namespace = name_space
                        self.next_lbm_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "next-ltm-id"):
                        self.next_ltm_id = value
                        self.next_ltm_id.value_namespace = name_space
                        self.next_ltm_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-mep-ccm-defect"):
                        self.peer_mep_ccm_defect = value
                        self.peer_mep_ccm_defect.value_namespace = name_space
                        self.peer_mep_ccm_defect.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-meps-detected"):
                        self.peer_meps_detected = value
                        self.peer_meps_detected.value_namespace = name_space
                        self.peer_meps_detected.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-meps-with-errors-detected"):
                        self.peer_meps_with_errors_detected = value
                        self.peer_meps_with_errors_detected.value_namespace = name_space
                        self.peer_meps_with_errors_detected.value_namespace_prefix = name_space_prefix
                    if(value_path == "rdi-defect"):
                        self.rdi_defect = value
                        self.rdi_defect.value_namespace = name_space
                        self.rdi_defect.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-defect"):
                        self.remote_defect = value
                        self.remote_defect.value_namespace = name_space
                        self.remote_defect.value_namespace_prefix = name_space_prefix
                    if(value_path == "service-xr"):
                        self.service_xr = value
                        self.service_xr.value_namespace = name_space
                        self.service_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby"):
                        self.standby = value
                        self.standby.value_namespace = name_space
                        self.standby.value_namespace_prefix = name_space_prefix
                    if(value_path == "stp-state"):
                        self.stp_state = value
                        self.stp_state.value_namespace = name_space
                        self.stp_state.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.local_mep:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.local_mep:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "local-meps" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "local-mep"):
                    for c in self.local_mep:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Cfm.Global_.LocalMeps.LocalMep()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.local_mep.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "local-mep"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class PeerMePv2S(Entity):
            """
            Peer MEPs table Version 2
            
            .. attribute:: peer_me_pv2
            
            	Information about a peer MEP for a particular local MEP
            	**type**\: list of    :py:class:`PeerMePv2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2>`
            
            

            """

            _prefix = 'ethernet-cfm-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Cfm.Global_.PeerMePv2S, self).__init__()

                self.yang_name = "peer-me-pv2s"
                self.yang_parent_name = "global"

                self.peer_me_pv2 = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Cfm.Global_.PeerMePv2S, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Cfm.Global_.PeerMePv2S, self).__setattr__(name, value)


            class PeerMePv2(Entity):
                """
                Information about a peer MEP for a particular
                local MEP
                
                .. attribute:: domain  <key>
                
                	Maintenance Domain
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: service  <key>
                
                	Service (Maintenance Association)
                	**type**\:  str
                
                	**length:** 1..79
                
                .. attribute:: local_mep_id  <key>
                
                	MEP ID of Local MEP
                	**type**\:  int
                
                	**range:** 1..8191
                
                .. attribute:: interface  <key>
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: peer_mep_id  <key>
                
                	MEP ID of Peer MEP
                	**type**\:  int
                
                	**range:** 1..8191
                
                .. attribute:: peer_mac_address  <key>
                
                	Peer MAC address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                .. attribute:: domain_xr
                
                	Maintenance domain name
                	**type**\:  str
                
                .. attribute:: interface_xr
                
                	Interface
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: level
                
                	Maintenance level
                	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                
                .. attribute:: mep_direction
                
                	MEP facing direction
                	**type**\:   :py:class:`CfmBagDirection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagDirection>`
                
                .. attribute:: mep_id
                
                	MEP ID
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: peer_mep
                
                	Peer MEP
                	**type**\:   :py:class:`PeerMep <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep>`
                
                .. attribute:: service_xr
                
                	Service name
                	**type**\:  str
                
                .. attribute:: standby
                
                	The local MEP is on an interface in standby mode
                	**type**\:  bool
                
                

                """

                _prefix = 'ethernet-cfm-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Cfm.Global_.PeerMePv2S.PeerMePv2, self).__init__()

                    self.yang_name = "peer-me-pv2"
                    self.yang_parent_name = "peer-me-pv2s"

                    self.domain = YLeaf(YType.str, "domain")

                    self.service = YLeaf(YType.str, "service")

                    self.local_mep_id = YLeaf(YType.uint32, "local-mep-id")

                    self.interface = YLeaf(YType.str, "interface")

                    self.peer_mep_id = YLeaf(YType.uint32, "peer-mep-id")

                    self.peer_mac_address = YLeaf(YType.str, "peer-mac-address")

                    self.domain_xr = YLeaf(YType.str, "domain-xr")

                    self.interface_xr = YLeaf(YType.str, "interface-xr")

                    self.level = YLeaf(YType.enumeration, "level")

                    self.mep_direction = YLeaf(YType.enumeration, "mep-direction")

                    self.mep_id = YLeaf(YType.uint16, "mep-id")

                    self.service_xr = YLeaf(YType.str, "service-xr")

                    self.standby = YLeaf(YType.boolean, "standby")

                    self.peer_mep = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep()
                    self.peer_mep.parent = self
                    self._children_name_map["peer_mep"] = "peer-mep"
                    self._children_yang_names.add("peer-mep")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("domain",
                                    "service",
                                    "local_mep_id",
                                    "interface",
                                    "peer_mep_id",
                                    "peer_mac_address",
                                    "domain_xr",
                                    "interface_xr",
                                    "level",
                                    "mep_direction",
                                    "mep_id",
                                    "service_xr",
                                    "standby") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Cfm.Global_.PeerMePv2S.PeerMePv2, self).__setattr__(name, value)


                class PeerMep(Entity):
                    """
                    Peer MEP
                    
                    .. attribute:: ccm_offload
                    
                    	Offload status of received CCM handling
                    	**type**\:   :py:class:`CfmBagCcmOffload <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagCcmOffload>`
                    
                    .. attribute:: cross_check_state
                    
                    	Cross\-check state
                    	**type**\:   :py:class:`CfmPmRmepXcState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmRmepXcState>`
                    
                    .. attribute:: error_state
                    
                    	Error state
                    	**type**\:   :py:class:`ErrorState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.ErrorState>`
                    
                    .. attribute:: last_ccm_received
                    
                    	Last CCM received from the peer MEP
                    	**type**\:   :py:class:`LastCcmReceived <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived>`
                    
                    .. attribute:: last_up_down_time
                    
                    	Elapsed time since peer MEP became active or timed out
                    	**type**\:   :py:class:`LastUpDownTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastUpDownTime>`
                    
                    .. attribute:: mac_address
                    
                    	MAC address
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                    
                    .. attribute:: mep_id
                    
                    	MEP ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: peer_mep_state
                    
                    	State of the peer MEP state machine
                    	**type**\:   :py:class:`CfmPmRmepState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmRmepState>`
                    
                    .. attribute:: statistics
                    
                    	Peer MEP statistics
                    	**type**\:   :py:class:`Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics>`
                    
                    

                    """

                    _prefix = 'ethernet-cfm-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep, self).__init__()

                        self.yang_name = "peer-mep"
                        self.yang_parent_name = "peer-me-pv2"

                        self.ccm_offload = YLeaf(YType.enumeration, "ccm-offload")

                        self.cross_check_state = YLeaf(YType.enumeration, "cross-check-state")

                        self.mac_address = YLeaf(YType.str, "mac-address")

                        self.mep_id = YLeaf(YType.uint16, "mep-id")

                        self.peer_mep_state = YLeaf(YType.enumeration, "peer-mep-state")

                        self.error_state = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.ErrorState()
                        self.error_state.parent = self
                        self._children_name_map["error_state"] = "error-state"
                        self._children_yang_names.add("error-state")

                        self.last_ccm_received = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived()
                        self.last_ccm_received.parent = self
                        self._children_name_map["last_ccm_received"] = "last-ccm-received"
                        self._children_yang_names.add("last-ccm-received")

                        self.last_up_down_time = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastUpDownTime()
                        self.last_up_down_time.parent = self
                        self._children_name_map["last_up_down_time"] = "last-up-down-time"
                        self._children_yang_names.add("last-up-down-time")

                        self.statistics = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics()
                        self.statistics.parent = self
                        self._children_name_map["statistics"] = "statistics"
                        self._children_yang_names.add("statistics")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("ccm_offload",
                                        "cross_check_state",
                                        "mac_address",
                                        "mep_id",
                                        "peer_mep_state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep, self).__setattr__(name, value)


                    class ErrorState(Entity):
                        """
                        Error state
                        
                        .. attribute:: invalid_ccm_interval
                        
                        	Invalid CCM interval
                        	**type**\:  bool
                        
                        .. attribute:: invalid_level
                        
                        	Invalid level
                        	**type**\:  bool
                        
                        .. attribute:: invalid_maid
                        
                        	Invalid MAID
                        	**type**\:  bool
                        
                        .. attribute:: loss_threshold_exceeded
                        
                        	Timed out (loss threshold exceeded)
                        	**type**\:  bool
                        
                        .. attribute:: received_our_mac
                        
                        	Loop detected (our MAC address received)
                        	**type**\:  bool
                        
                        .. attribute:: received_our_mep_id
                        
                        	Configuration Error (our MEP ID received)
                        	**type**\:  bool
                        
                        .. attribute:: received_rdi
                        
                        	Remote defection indication received
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.ErrorState, self).__init__()

                            self.yang_name = "error-state"
                            self.yang_parent_name = "peer-mep"

                            self.invalid_ccm_interval = YLeaf(YType.boolean, "invalid-ccm-interval")

                            self.invalid_level = YLeaf(YType.boolean, "invalid-level")

                            self.invalid_maid = YLeaf(YType.boolean, "invalid-maid")

                            self.loss_threshold_exceeded = YLeaf(YType.boolean, "loss-threshold-exceeded")

                            self.received_our_mac = YLeaf(YType.boolean, "received-our-mac")

                            self.received_our_mep_id = YLeaf(YType.boolean, "received-our-mep-id")

                            self.received_rdi = YLeaf(YType.boolean, "received-rdi")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("invalid_ccm_interval",
                                            "invalid_level",
                                            "invalid_maid",
                                            "loss_threshold_exceeded",
                                            "received_our_mac",
                                            "received_our_mep_id",
                                            "received_rdi") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.ErrorState, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.ErrorState, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.invalid_ccm_interval.is_set or
                                self.invalid_level.is_set or
                                self.invalid_maid.is_set or
                                self.loss_threshold_exceeded.is_set or
                                self.received_our_mac.is_set or
                                self.received_our_mep_id.is_set or
                                self.received_rdi.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.invalid_ccm_interval.yfilter != YFilter.not_set or
                                self.invalid_level.yfilter != YFilter.not_set or
                                self.invalid_maid.yfilter != YFilter.not_set or
                                self.loss_threshold_exceeded.yfilter != YFilter.not_set or
                                self.received_our_mac.yfilter != YFilter.not_set or
                                self.received_our_mep_id.yfilter != YFilter.not_set or
                                self.received_rdi.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "error-state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.invalid_ccm_interval.is_set or self.invalid_ccm_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.invalid_ccm_interval.get_name_leafdata())
                            if (self.invalid_level.is_set or self.invalid_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.invalid_level.get_name_leafdata())
                            if (self.invalid_maid.is_set or self.invalid_maid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.invalid_maid.get_name_leafdata())
                            if (self.loss_threshold_exceeded.is_set or self.loss_threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.loss_threshold_exceeded.get_name_leafdata())
                            if (self.received_our_mac.is_set or self.received_our_mac.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_our_mac.get_name_leafdata())
                            if (self.received_our_mep_id.is_set or self.received_our_mep_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_our_mep_id.get_name_leafdata())
                            if (self.received_rdi.is_set or self.received_rdi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.received_rdi.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "invalid-ccm-interval" or name == "invalid-level" or name == "invalid-maid" or name == "loss-threshold-exceeded" or name == "received-our-mac" or name == "received-our-mep-id" or name == "received-rdi"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "invalid-ccm-interval"):
                                self.invalid_ccm_interval = value
                                self.invalid_ccm_interval.value_namespace = name_space
                                self.invalid_ccm_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "invalid-level"):
                                self.invalid_level = value
                                self.invalid_level.value_namespace = name_space
                                self.invalid_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "invalid-maid"):
                                self.invalid_maid = value
                                self.invalid_maid.value_namespace = name_space
                                self.invalid_maid.value_namespace_prefix = name_space_prefix
                            if(value_path == "loss-threshold-exceeded"):
                                self.loss_threshold_exceeded = value
                                self.loss_threshold_exceeded.value_namespace = name_space
                                self.loss_threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-our-mac"):
                                self.received_our_mac = value
                                self.received_our_mac.value_namespace = name_space
                                self.received_our_mac.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-our-mep-id"):
                                self.received_our_mep_id = value
                                self.received_our_mep_id.value_namespace = name_space
                                self.received_our_mep_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "received-rdi"):
                                self.received_rdi = value
                                self.received_rdi.value_namespace = name_space
                                self.received_rdi.value_namespace_prefix = name_space_prefix


                    class LastUpDownTime(Entity):
                        """
                        Elapsed time since peer MEP became active or
                        timed out
                        
                        .. attribute:: nanoseconds
                        
                        	Nanoseconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: nanosecond
                        
                        .. attribute:: seconds
                        
                        	Seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastUpDownTime, self).__init__()

                            self.yang_name = "last-up-down-time"
                            self.yang_parent_name = "peer-mep"

                            self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                            self.seconds = YLeaf(YType.uint32, "seconds")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("nanoseconds",
                                            "seconds") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastUpDownTime, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastUpDownTime, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.nanoseconds.is_set or
                                self.seconds.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.nanoseconds.yfilter != YFilter.not_set or
                                self.seconds.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "last-up-down-time" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                            if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.seconds.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "nanoseconds" or name == "seconds"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "nanoseconds"):
                                self.nanoseconds = value
                                self.nanoseconds.value_namespace = name_space
                                self.nanoseconds.value_namespace_prefix = name_space_prefix
                            if(value_path == "seconds"):
                                self.seconds = value
                                self.seconds.value_namespace = name_space
                                self.seconds.value_namespace_prefix = name_space_prefix


                    class LastCcmReceived(Entity):
                        """
                        Last CCM received from the peer MEP
                        
                        .. attribute:: additional_interface_status
                        
                        	Additional interface status
                        	**type**\:   :py:class:`CfmPmAddlIntfStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmAddlIntfStatus>`
                        
                        .. attribute:: header
                        
                        	Frame header
                        	**type**\:   :py:class:`Header <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header>`
                        
                        .. attribute:: interface_status
                        
                        	Interface status
                        	**type**\:   :py:class:`CfmPmIntfStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIntfStatus>`
                        
                        .. attribute:: mep_name
                        
                        	MEP name
                        	**type**\:   :py:class:`MepName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.MepName>`
                        
                        .. attribute:: organization_specific_tlv
                        
                        	Organizational\-specific TLVs
                        	**type**\: list of    :py:class:`OrganizationSpecificTlv <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.OrganizationSpecificTlv>`
                        
                        .. attribute:: port_status
                        
                        	Port status
                        	**type**\:   :py:class:`CfmPmPortStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmPortStatus>`
                        
                        .. attribute:: raw_data
                        
                        	Undecoded frame
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: sender_id
                        
                        	Sender ID TLV
                        	**type**\:   :py:class:`SenderId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId>`
                        
                        .. attribute:: unknown_tlv
                        
                        	Unknown TLVs
                        	**type**\: list of    :py:class:`UnknownTlv <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.UnknownTlv>`
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived, self).__init__()

                            self.yang_name = "last-ccm-received"
                            self.yang_parent_name = "peer-mep"

                            self.additional_interface_status = YLeaf(YType.enumeration, "additional-interface-status")

                            self.interface_status = YLeaf(YType.enumeration, "interface-status")

                            self.port_status = YLeaf(YType.enumeration, "port-status")

                            self.raw_data = YLeaf(YType.str, "raw-data")

                            self.header = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header()
                            self.header.parent = self
                            self._children_name_map["header"] = "header"
                            self._children_yang_names.add("header")

                            self.mep_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.MepName()
                            self.mep_name.parent = self
                            self._children_name_map["mep_name"] = "mep-name"
                            self._children_yang_names.add("mep-name")

                            self.sender_id = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId()
                            self.sender_id.parent = self
                            self._children_name_map["sender_id"] = "sender-id"
                            self._children_yang_names.add("sender-id")

                            self.organization_specific_tlv = YList(self)
                            self.unknown_tlv = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("additional_interface_status",
                                            "interface_status",
                                            "port_status",
                                            "raw_data") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived, self).__setattr__(name, value)


                        class Header(Entity):
                            """
                            Frame header
                            
                            .. attribute:: interval
                            
                            	CCM interval
                            	**type**\:   :py:class:`CfmBagCcmInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagCcmInterval>`
                            
                            .. attribute:: level
                            
                            	MD level
                            	**type**\:   :py:class:`CfmBagMdLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdLevel>`
                            
                            .. attribute:: mdid
                            
                            	MDID
                            	**type**\:   :py:class:`Mdid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid>`
                            
                            .. attribute:: mdid_format
                            
                            	MDID Format
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: mep_id
                            
                            	MEP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: rdi
                            
                            	Remote defect indicated
                            	**type**\:  bool
                            
                            .. attribute:: sequence_number
                            
                            	CCM sequence number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: short_ma_name
                            
                            	Short MA Name
                            	**type**\:   :py:class:`ShortMaName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName>`
                            
                            .. attribute:: short_ma_name_format
                            
                            	Short MA Name format
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: version
                            
                            	Version
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header, self).__init__()

                                self.yang_name = "header"
                                self.yang_parent_name = "last-ccm-received"

                                self.interval = YLeaf(YType.enumeration, "interval")

                                self.level = YLeaf(YType.enumeration, "level")

                                self.mdid_format = YLeaf(YType.uint8, "mdid-format")

                                self.mep_id = YLeaf(YType.uint16, "mep-id")

                                self.rdi = YLeaf(YType.boolean, "rdi")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                                self.short_ma_name_format = YLeaf(YType.uint8, "short-ma-name-format")

                                self.version = YLeaf(YType.uint8, "version")

                                self.mdid = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid()
                                self.mdid.parent = self
                                self._children_name_map["mdid"] = "mdid"
                                self._children_yang_names.add("mdid")

                                self.short_ma_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName()
                                self.short_ma_name.parent = self
                                self._children_name_map["short_ma_name"] = "short-ma-name"
                                self._children_yang_names.add("short-ma-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interval",
                                                "level",
                                                "mdid_format",
                                                "mep_id",
                                                "rdi",
                                                "sequence_number",
                                                "short_ma_name_format",
                                                "version") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header, self).__setattr__(name, value)


                            class Mdid(Entity):
                                """
                                MDID
                                
                                .. attribute:: dns_like_name
                                
                                	DNS\-like name
                                	**type**\:  str
                                
                                .. attribute:: mac_name
                                
                                	MAC address name
                                	**type**\:   :py:class:`MacName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid.MacName>`
                                
                                .. attribute:: mdid_data
                                
                                	Hex data
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: mdid_format_value
                                
                                	MDIDFormatValue
                                	**type**\:   :py:class:`CfmBagMdidFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagMdidFmt>`
                                
                                .. attribute:: string_name
                                
                                	String name
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid, self).__init__()

                                    self.yang_name = "mdid"
                                    self.yang_parent_name = "header"

                                    self.dns_like_name = YLeaf(YType.str, "dns-like-name")

                                    self.mdid_data = YLeaf(YType.str, "mdid-data")

                                    self.mdid_format_value = YLeaf(YType.enumeration, "mdid-format-value")

                                    self.string_name = YLeaf(YType.str, "string-name")

                                    self.mac_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid.MacName()
                                    self.mac_name.parent = self
                                    self._children_name_map["mac_name"] = "mac-name"
                                    self._children_yang_names.add("mac-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("dns_like_name",
                                                    "mdid_data",
                                                    "mdid_format_value",
                                                    "string_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid, self).__setattr__(name, value)


                                class MacName(Entity):
                                    """
                                    MAC address name
                                    
                                    .. attribute:: integer
                                    
                                    	Integer
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: mac_address
                                    
                                    	MAC address
                                    	**type**\:  str
                                    
                                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                    
                                    

                                    """

                                    _prefix = 'ethernet-cfm-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid.MacName, self).__init__()

                                        self.yang_name = "mac-name"
                                        self.yang_parent_name = "mdid"

                                        self.integer = YLeaf(YType.uint16, "integer")

                                        self.mac_address = YLeaf(YType.str, "mac-address")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("integer",
                                                        "mac_address") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid.MacName, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid.MacName, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.integer.is_set or
                                            self.mac_address.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.integer.yfilter != YFilter.not_set or
                                            self.mac_address.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mac-name" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.integer.is_set or self.integer.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.integer.get_name_leafdata())
                                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mac_address.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "integer" or name == "mac-address"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "integer"):
                                            self.integer = value
                                            self.integer.value_namespace = name_space
                                            self.integer.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mac-address"):
                                            self.mac_address = value
                                            self.mac_address.value_namespace = name_space
                                            self.mac_address.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.dns_like_name.is_set or
                                        self.mdid_data.is_set or
                                        self.mdid_format_value.is_set or
                                        self.string_name.is_set or
                                        (self.mac_name is not None and self.mac_name.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.dns_like_name.yfilter != YFilter.not_set or
                                        self.mdid_data.yfilter != YFilter.not_set or
                                        self.mdid_format_value.yfilter != YFilter.not_set or
                                        self.string_name.yfilter != YFilter.not_set or
                                        (self.mac_name is not None and self.mac_name.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "mdid" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.dns_like_name.is_set or self.dns_like_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dns_like_name.get_name_leafdata())
                                    if (self.mdid_data.is_set or self.mdid_data.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mdid_data.get_name_leafdata())
                                    if (self.mdid_format_value.is_set or self.mdid_format_value.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mdid_format_value.get_name_leafdata())
                                    if (self.string_name.is_set or self.string_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.string_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "mac-name"):
                                        if (self.mac_name is None):
                                            self.mac_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid.MacName()
                                            self.mac_name.parent = self
                                            self._children_name_map["mac_name"] = "mac-name"
                                        return self.mac_name

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "mac-name" or name == "dns-like-name" or name == "mdid-data" or name == "mdid-format-value" or name == "string-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "dns-like-name"):
                                        self.dns_like_name = value
                                        self.dns_like_name.value_namespace = name_space
                                        self.dns_like_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mdid-data"):
                                        self.mdid_data = value
                                        self.mdid_data.value_namespace = name_space
                                        self.mdid_data.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mdid-format-value"):
                                        self.mdid_format_value = value
                                        self.mdid_format_value.value_namespace = name_space
                                        self.mdid_format_value.value_namespace_prefix = name_space_prefix
                                    if(value_path == "string-name"):
                                        self.string_name = value
                                        self.string_name.value_namespace = name_space
                                        self.string_name.value_namespace_prefix = name_space_prefix


                            class ShortMaName(Entity):
                                """
                                Short MA Name
                                
                                .. attribute:: icc_based
                                
                                	ICC\-based format
                                	**type**\:  str
                                
                                .. attribute:: integer_name
                                
                                	Unsigned integer name
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: short_ma_name_data
                                
                                	Hex data
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: short_ma_name_format_value
                                
                                	ShortMANameFormatValue
                                	**type**\:   :py:class:`CfmBagSmanFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmBagSmanFmt>`
                                
                                .. attribute:: string_name
                                
                                	String name
                                	**type**\:  str
                                
                                .. attribute:: vlan_id_name
                                
                                	VLAN ID name
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: vpn_id_name
                                
                                	VPN ID name
                                	**type**\:   :py:class:`VpnIdName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName.VpnIdName>`
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName, self).__init__()

                                    self.yang_name = "short-ma-name"
                                    self.yang_parent_name = "header"

                                    self.icc_based = YLeaf(YType.str, "icc-based")

                                    self.integer_name = YLeaf(YType.uint16, "integer-name")

                                    self.short_ma_name_data = YLeaf(YType.str, "short-ma-name-data")

                                    self.short_ma_name_format_value = YLeaf(YType.enumeration, "short-ma-name-format-value")

                                    self.string_name = YLeaf(YType.str, "string-name")

                                    self.vlan_id_name = YLeaf(YType.uint16, "vlan-id-name")

                                    self.vpn_id_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName.VpnIdName()
                                    self.vpn_id_name.parent = self
                                    self._children_name_map["vpn_id_name"] = "vpn-id-name"
                                    self._children_yang_names.add("vpn-id-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("icc_based",
                                                    "integer_name",
                                                    "short_ma_name_data",
                                                    "short_ma_name_format_value",
                                                    "string_name",
                                                    "vlan_id_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName, self).__setattr__(name, value)


                                class VpnIdName(Entity):
                                    """
                                    VPN ID name
                                    
                                    .. attribute:: index
                                    
                                    	VPN index
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: oui
                                    
                                    	VPN authority organizationally\-unique ID
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ethernet-cfm-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName.VpnIdName, self).__init__()

                                        self.yang_name = "vpn-id-name"
                                        self.yang_parent_name = "short-ma-name"

                                        self.index = YLeaf(YType.uint32, "index")

                                        self.oui = YLeaf(YType.uint32, "oui")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("index",
                                                        "oui") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName.VpnIdName, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName.VpnIdName, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.index.is_set or
                                            self.oui.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.index.yfilter != YFilter.not_set or
                                            self.oui.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "vpn-id-name" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.index.get_name_leafdata())
                                        if (self.oui.is_set or self.oui.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.oui.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "index" or name == "oui"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "index"):
                                            self.index = value
                                            self.index.value_namespace = name_space
                                            self.index.value_namespace_prefix = name_space_prefix
                                        if(value_path == "oui"):
                                            self.oui = value
                                            self.oui.value_namespace = name_space
                                            self.oui.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.icc_based.is_set or
                                        self.integer_name.is_set or
                                        self.short_ma_name_data.is_set or
                                        self.short_ma_name_format_value.is_set or
                                        self.string_name.is_set or
                                        self.vlan_id_name.is_set or
                                        (self.vpn_id_name is not None and self.vpn_id_name.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.icc_based.yfilter != YFilter.not_set or
                                        self.integer_name.yfilter != YFilter.not_set or
                                        self.short_ma_name_data.yfilter != YFilter.not_set or
                                        self.short_ma_name_format_value.yfilter != YFilter.not_set or
                                        self.string_name.yfilter != YFilter.not_set or
                                        self.vlan_id_name.yfilter != YFilter.not_set or
                                        (self.vpn_id_name is not None and self.vpn_id_name.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "short-ma-name" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.icc_based.is_set or self.icc_based.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.icc_based.get_name_leafdata())
                                    if (self.integer_name.is_set or self.integer_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.integer_name.get_name_leafdata())
                                    if (self.short_ma_name_data.is_set or self.short_ma_name_data.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.short_ma_name_data.get_name_leafdata())
                                    if (self.short_ma_name_format_value.is_set or self.short_ma_name_format_value.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.short_ma_name_format_value.get_name_leafdata())
                                    if (self.string_name.is_set or self.string_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.string_name.get_name_leafdata())
                                    if (self.vlan_id_name.is_set or self.vlan_id_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.vlan_id_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "vpn-id-name"):
                                        if (self.vpn_id_name is None):
                                            self.vpn_id_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName.VpnIdName()
                                            self.vpn_id_name.parent = self
                                            self._children_name_map["vpn_id_name"] = "vpn-id-name"
                                        return self.vpn_id_name

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "vpn-id-name" or name == "icc-based" or name == "integer-name" or name == "short-ma-name-data" or name == "short-ma-name-format-value" or name == "string-name" or name == "vlan-id-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "icc-based"):
                                        self.icc_based = value
                                        self.icc_based.value_namespace = name_space
                                        self.icc_based.value_namespace_prefix = name_space_prefix
                                    if(value_path == "integer-name"):
                                        self.integer_name = value
                                        self.integer_name.value_namespace = name_space
                                        self.integer_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "short-ma-name-data"):
                                        self.short_ma_name_data = value
                                        self.short_ma_name_data.value_namespace = name_space
                                        self.short_ma_name_data.value_namespace_prefix = name_space_prefix
                                    if(value_path == "short-ma-name-format-value"):
                                        self.short_ma_name_format_value = value
                                        self.short_ma_name_format_value.value_namespace = name_space
                                        self.short_ma_name_format_value.value_namespace_prefix = name_space_prefix
                                    if(value_path == "string-name"):
                                        self.string_name = value
                                        self.string_name.value_namespace = name_space
                                        self.string_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "vlan-id-name"):
                                        self.vlan_id_name = value
                                        self.vlan_id_name.value_namespace = name_space
                                        self.vlan_id_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.interval.is_set or
                                    self.level.is_set or
                                    self.mdid_format.is_set or
                                    self.mep_id.is_set or
                                    self.rdi.is_set or
                                    self.sequence_number.is_set or
                                    self.short_ma_name_format.is_set or
                                    self.version.is_set or
                                    (self.mdid is not None and self.mdid.has_data()) or
                                    (self.short_ma_name is not None and self.short_ma_name.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.mdid_format.yfilter != YFilter.not_set or
                                    self.mep_id.yfilter != YFilter.not_set or
                                    self.rdi.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set or
                                    self.short_ma_name_format.yfilter != YFilter.not_set or
                                    self.version.yfilter != YFilter.not_set or
                                    (self.mdid is not None and self.mdid.has_operation()) or
                                    (self.short_ma_name is not None and self.short_ma_name.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "header" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.mdid_format.is_set or self.mdid_format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mdid_format.get_name_leafdata())
                                if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mep_id.get_name_leafdata())
                                if (self.rdi.is_set or self.rdi.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rdi.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())
                                if (self.short_ma_name_format.is_set or self.short_ma_name_format.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.short_ma_name_format.get_name_leafdata())
                                if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.version.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "mdid"):
                                    if (self.mdid is None):
                                        self.mdid = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.Mdid()
                                        self.mdid.parent = self
                                        self._children_name_map["mdid"] = "mdid"
                                    return self.mdid

                                if (child_yang_name == "short-ma-name"):
                                    if (self.short_ma_name is None):
                                        self.short_ma_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header.ShortMaName()
                                        self.short_ma_name.parent = self
                                        self._children_name_map["short_ma_name"] = "short-ma-name"
                                    return self.short_ma_name

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mdid" or name == "short-ma-name" or name == "interval" or name == "level" or name == "mdid-format" or name == "mep-id" or name == "rdi" or name == "sequence-number" or name == "short-ma-name-format" or name == "version"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "mdid-format"):
                                    self.mdid_format = value
                                    self.mdid_format.value_namespace = name_space
                                    self.mdid_format.value_namespace_prefix = name_space_prefix
                                if(value_path == "mep-id"):
                                    self.mep_id = value
                                    self.mep_id.value_namespace = name_space
                                    self.mep_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "rdi"):
                                    self.rdi = value
                                    self.rdi.value_namespace = name_space
                                    self.rdi.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix
                                if(value_path == "short-ma-name-format"):
                                    self.short_ma_name_format = value
                                    self.short_ma_name_format.value_namespace = name_space
                                    self.short_ma_name_format.value_namespace_prefix = name_space_prefix
                                if(value_path == "version"):
                                    self.version = value
                                    self.version.value_namespace = name_space
                                    self.version.value_namespace_prefix = name_space_prefix


                        class SenderId(Entity):
                            """
                            Sender ID TLV
                            
                            .. attribute:: chassis_id
                            
                            	Chassis ID
                            	**type**\:   :py:class:`ChassisId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId>`
                            
                            .. attribute:: management_address
                            
                            	Management address
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: management_address_domain
                            
                            	Management address domain
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId, self).__init__()

                                self.yang_name = "sender-id"
                                self.yang_parent_name = "last-ccm-received"

                                self.management_address = YLeaf(YType.str, "management-address")

                                self.management_address_domain = YLeaf(YType.str, "management-address-domain")

                                self.chassis_id = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId()
                                self.chassis_id.parent = self
                                self._children_name_map["chassis_id"] = "chassis-id"
                                self._children_yang_names.add("chassis-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("management_address",
                                                "management_address_domain") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId, self).__setattr__(name, value)


                            class ChassisId(Entity):
                                """
                                Chassis ID
                                
                                .. attribute:: chassis_id
                                
                                	Chassis ID (Deprecated)
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: chassis_id_type
                                
                                	Chassis ID Type
                                	**type**\:   :py:class:`CfmPmChassisIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmChassisIdFmt>`
                                
                                .. attribute:: chassis_id_type_value
                                
                                	Chassis ID Type
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: chassis_id_value
                                
                                	Chassis ID (Current)
                                	**type**\:   :py:class:`ChassisIdValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId.ChassisIdValue>`
                                
                                

                                """

                                _prefix = 'ethernet-cfm-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId, self).__init__()

                                    self.yang_name = "chassis-id"
                                    self.yang_parent_name = "sender-id"

                                    self.chassis_id = YLeaf(YType.str, "chassis-id")

                                    self.chassis_id_type = YLeaf(YType.enumeration, "chassis-id-type")

                                    self.chassis_id_type_value = YLeaf(YType.uint8, "chassis-id-type-value")

                                    self.chassis_id_value = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId.ChassisIdValue()
                                    self.chassis_id_value.parent = self
                                    self._children_name_map["chassis_id_value"] = "chassis-id-value"
                                    self._children_yang_names.add("chassis-id-value")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("chassis_id",
                                                    "chassis_id_type",
                                                    "chassis_id_type_value") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId, self).__setattr__(name, value)


                                class ChassisIdValue(Entity):
                                    """
                                    Chassis ID (Current)
                                    
                                    .. attribute:: chassis_id_format
                                    
                                    	ChassisIDFormat
                                    	**type**\:   :py:class:`CfmPmIdFmt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.CfmPmIdFmt>`
                                    
                                    .. attribute:: chassis_id_mac
                                    
                                    	Chassis ID MAC Address
                                    	**type**\:  str
                                    
                                    	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                                    
                                    .. attribute:: chassis_id_raw
                                    
                                    	Raw Chassis ID
                                    	**type**\:  str
                                    
                                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                    
                                    .. attribute:: chassis_id_string
                                    
                                    	Chassis ID String
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'ethernet-cfm-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId.ChassisIdValue, self).__init__()

                                        self.yang_name = "chassis-id-value"
                                        self.yang_parent_name = "chassis-id"

                                        self.chassis_id_format = YLeaf(YType.enumeration, "chassis-id-format")

                                        self.chassis_id_mac = YLeaf(YType.str, "chassis-id-mac")

                                        self.chassis_id_raw = YLeaf(YType.str, "chassis-id-raw")

                                        self.chassis_id_string = YLeaf(YType.str, "chassis-id-string")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("chassis_id_format",
                                                        "chassis_id_mac",
                                                        "chassis_id_raw",
                                                        "chassis_id_string") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId.ChassisIdValue, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId.ChassisIdValue, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.chassis_id_format.is_set or
                                            self.chassis_id_mac.is_set or
                                            self.chassis_id_raw.is_set or
                                            self.chassis_id_string.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.chassis_id_format.yfilter != YFilter.not_set or
                                            self.chassis_id_mac.yfilter != YFilter.not_set or
                                            self.chassis_id_raw.yfilter != YFilter.not_set or
                                            self.chassis_id_string.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "chassis-id-value" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.chassis_id_format.is_set or self.chassis_id_format.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.chassis_id_format.get_name_leafdata())
                                        if (self.chassis_id_mac.is_set or self.chassis_id_mac.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.chassis_id_mac.get_name_leafdata())
                                        if (self.chassis_id_raw.is_set or self.chassis_id_raw.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.chassis_id_raw.get_name_leafdata())
                                        if (self.chassis_id_string.is_set or self.chassis_id_string.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.chassis_id_string.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "chassis-id-format" or name == "chassis-id-mac" or name == "chassis-id-raw" or name == "chassis-id-string"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "chassis-id-format"):
                                            self.chassis_id_format = value
                                            self.chassis_id_format.value_namespace = name_space
                                            self.chassis_id_format.value_namespace_prefix = name_space_prefix
                                        if(value_path == "chassis-id-mac"):
                                            self.chassis_id_mac = value
                                            self.chassis_id_mac.value_namespace = name_space
                                            self.chassis_id_mac.value_namespace_prefix = name_space_prefix
                                        if(value_path == "chassis-id-raw"):
                                            self.chassis_id_raw = value
                                            self.chassis_id_raw.value_namespace = name_space
                                            self.chassis_id_raw.value_namespace_prefix = name_space_prefix
                                        if(value_path == "chassis-id-string"):
                                            self.chassis_id_string = value
                                            self.chassis_id_string.value_namespace = name_space
                                            self.chassis_id_string.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.chassis_id.is_set or
                                        self.chassis_id_type.is_set or
                                        self.chassis_id_type_value.is_set or
                                        (self.chassis_id_value is not None and self.chassis_id_value.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.chassis_id.yfilter != YFilter.not_set or
                                        self.chassis_id_type.yfilter != YFilter.not_set or
                                        self.chassis_id_type_value.yfilter != YFilter.not_set or
                                        (self.chassis_id_value is not None and self.chassis_id_value.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "chassis-id" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.chassis_id.is_set or self.chassis_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id.get_name_leafdata())
                                    if (self.chassis_id_type.is_set or self.chassis_id_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_type.get_name_leafdata())
                                    if (self.chassis_id_type_value.is_set or self.chassis_id_type_value.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.chassis_id_type_value.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "chassis-id-value"):
                                        if (self.chassis_id_value is None):
                                            self.chassis_id_value = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId.ChassisIdValue()
                                            self.chassis_id_value.parent = self
                                            self._children_name_map["chassis_id_value"] = "chassis-id-value"
                                        return self.chassis_id_value

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "chassis-id-value" or name == "chassis-id" or name == "chassis-id-type" or name == "chassis-id-type-value"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "chassis-id"):
                                        self.chassis_id = value
                                        self.chassis_id.value_namespace = name_space
                                        self.chassis_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-type"):
                                        self.chassis_id_type = value
                                        self.chassis_id_type.value_namespace = name_space
                                        self.chassis_id_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "chassis-id-type-value"):
                                        self.chassis_id_type_value = value
                                        self.chassis_id_type_value.value_namespace = name_space
                                        self.chassis_id_type_value.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.management_address.is_set or
                                    self.management_address_domain.is_set or
                                    (self.chassis_id is not None and self.chassis_id.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.management_address.yfilter != YFilter.not_set or
                                    self.management_address_domain.yfilter != YFilter.not_set or
                                    (self.chassis_id is not None and self.chassis_id.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "sender-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.management_address.is_set or self.management_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.management_address.get_name_leafdata())
                                if (self.management_address_domain.is_set or self.management_address_domain.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.management_address_domain.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "chassis-id"):
                                    if (self.chassis_id is None):
                                        self.chassis_id = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId.ChassisId()
                                        self.chassis_id.parent = self
                                        self._children_name_map["chassis_id"] = "chassis-id"
                                    return self.chassis_id

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "chassis-id" or name == "management-address" or name == "management-address-domain"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "management-address"):
                                    self.management_address = value
                                    self.management_address.value_namespace = name_space
                                    self.management_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "management-address-domain"):
                                    self.management_address_domain = value
                                    self.management_address_domain.value_namespace = name_space
                                    self.management_address_domain.value_namespace_prefix = name_space_prefix


                        class MepName(Entity):
                            """
                            MEP name
                            
                            .. attribute:: name
                            
                            	MEP name
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.MepName, self).__init__()

                                self.yang_name = "mep-name"
                                self.yang_parent_name = "last-ccm-received"

                                self.name = YLeaf(YType.str, "name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.MepName, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.MepName, self).__setattr__(name, value)

                            def has_data(self):
                                return self.name.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mep-name" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix


                        class OrganizationSpecificTlv(Entity):
                            """
                            Organizational\-specific TLVs
                            
                            .. attribute:: oui
                            
                            	Organizationally\-unique ID
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: subtype
                            
                            	Subtype of TLV
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: value
                            
                            	Binary data in TLV
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.OrganizationSpecificTlv, self).__init__()

                                self.yang_name = "organization-specific-tlv"
                                self.yang_parent_name = "last-ccm-received"

                                self.oui = YLeaf(YType.str, "oui")

                                self.subtype = YLeaf(YType.uint8, "subtype")

                                self.value = YLeaf(YType.str, "value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("oui",
                                                "subtype",
                                                "value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.OrganizationSpecificTlv, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.OrganizationSpecificTlv, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.oui.is_set or
                                    self.subtype.is_set or
                                    self.value.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.oui.yfilter != YFilter.not_set or
                                    self.subtype.yfilter != YFilter.not_set or
                                    self.value.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "organization-specific-tlv" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.oui.is_set or self.oui.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.oui.get_name_leafdata())
                                if (self.subtype.is_set or self.subtype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.subtype.get_name_leafdata())
                                if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "oui" or name == "subtype" or name == "value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "oui"):
                                    self.oui = value
                                    self.oui.value_namespace = name_space
                                    self.oui.value_namespace_prefix = name_space_prefix
                                if(value_path == "subtype"):
                                    self.subtype = value
                                    self.subtype.value_namespace = name_space
                                    self.subtype.value_namespace_prefix = name_space_prefix
                                if(value_path == "value"):
                                    self.value = value
                                    self.value.value_namespace = name_space
                                    self.value.value_namespace_prefix = name_space_prefix


                        class UnknownTlv(Entity):
                            """
                            Unknown TLVs
                            
                            .. attribute:: typecode
                            
                            	Type code of TLV
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: value
                            
                            	Binary data in TLV
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.UnknownTlv, self).__init__()

                                self.yang_name = "unknown-tlv"
                                self.yang_parent_name = "last-ccm-received"

                                self.typecode = YLeaf(YType.uint8, "typecode")

                                self.value = YLeaf(YType.str, "value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("typecode",
                                                "value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.UnknownTlv, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.UnknownTlv, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.typecode.is_set or
                                    self.value.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.typecode.yfilter != YFilter.not_set or
                                    self.value.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "unknown-tlv" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.typecode.is_set or self.typecode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.typecode.get_name_leafdata())
                                if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "typecode" or name == "value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "typecode"):
                                    self.typecode = value
                                    self.typecode.value_namespace = name_space
                                    self.typecode.value_namespace_prefix = name_space_prefix
                                if(value_path == "value"):
                                    self.value = value
                                    self.value.value_namespace = name_space
                                    self.value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.organization_specific_tlv:
                                if (c.has_data()):
                                    return True
                            for c in self.unknown_tlv:
                                if (c.has_data()):
                                    return True
                            return (
                                self.additional_interface_status.is_set or
                                self.interface_status.is_set or
                                self.port_status.is_set or
                                self.raw_data.is_set or
                                (self.header is not None and self.header.has_data()) or
                                (self.mep_name is not None and self.mep_name.has_data()) or
                                (self.sender_id is not None and self.sender_id.has_data()))

                        def has_operation(self):
                            for c in self.organization_specific_tlv:
                                if (c.has_operation()):
                                    return True
                            for c in self.unknown_tlv:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.additional_interface_status.yfilter != YFilter.not_set or
                                self.interface_status.yfilter != YFilter.not_set or
                                self.port_status.yfilter != YFilter.not_set or
                                self.raw_data.yfilter != YFilter.not_set or
                                (self.header is not None and self.header.has_operation()) or
                                (self.mep_name is not None and self.mep_name.has_operation()) or
                                (self.sender_id is not None and self.sender_id.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "last-ccm-received" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.additional_interface_status.is_set or self.additional_interface_status.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.additional_interface_status.get_name_leafdata())
                            if (self.interface_status.is_set or self.interface_status.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_status.get_name_leafdata())
                            if (self.port_status.is_set or self.port_status.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.port_status.get_name_leafdata())
                            if (self.raw_data.is_set or self.raw_data.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.raw_data.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "header"):
                                if (self.header is None):
                                    self.header = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.Header()
                                    self.header.parent = self
                                    self._children_name_map["header"] = "header"
                                return self.header

                            if (child_yang_name == "mep-name"):
                                if (self.mep_name is None):
                                    self.mep_name = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.MepName()
                                    self.mep_name.parent = self
                                    self._children_name_map["mep_name"] = "mep-name"
                                return self.mep_name

                            if (child_yang_name == "organization-specific-tlv"):
                                for c in self.organization_specific_tlv:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.OrganizationSpecificTlv()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.organization_specific_tlv.append(c)
                                return c

                            if (child_yang_name == "sender-id"):
                                if (self.sender_id is None):
                                    self.sender_id = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.SenderId()
                                    self.sender_id.parent = self
                                    self._children_name_map["sender_id"] = "sender-id"
                                return self.sender_id

                            if (child_yang_name == "unknown-tlv"):
                                for c in self.unknown_tlv:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived.UnknownTlv()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.unknown_tlv.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "header" or name == "mep-name" or name == "organization-specific-tlv" or name == "sender-id" or name == "unknown-tlv" or name == "additional-interface-status" or name == "interface-status" or name == "port-status" or name == "raw-data"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "additional-interface-status"):
                                self.additional_interface_status = value
                                self.additional_interface_status.value_namespace = name_space
                                self.additional_interface_status.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface-status"):
                                self.interface_status = value
                                self.interface_status.value_namespace = name_space
                                self.interface_status.value_namespace_prefix = name_space_prefix
                            if(value_path == "port-status"):
                                self.port_status = value
                                self.port_status.value_namespace = name_space
                                self.port_status.value_namespace_prefix = name_space_prefix
                            if(value_path == "raw-data"):
                                self.raw_data = value
                                self.raw_data.value_namespace = name_space
                                self.raw_data.value_namespace_prefix = name_space_prefix


                    class Statistics(Entity):
                        """
                        Peer MEP statistics
                        
                        .. attribute:: ccms_invalid_interval
                        
                        	Number of CCMs received with an invalid interval
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: ccms_invalid_maid
                        
                        	Number of CCMs received with an invalid MAID
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: ccms_invalid_source_mac_address
                        
                        	Number of CCMs received with an invalid source MAC address
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: ccms_our_mep_id
                        
                        	Number of CCMs received with our MEP ID
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: ccms_out_of_sequence
                        
                        	Number of CCMs received out\-of\-sequence
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: ccms_rdi
                        
                        	Number of CCMs received with the Remote Defect Indication bit set
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: ccms_received
                        
                        	Number of CCMs received
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: ccms_wrong_level
                        
                        	Number of CCMs received with an invalid level
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: last_ccm_received_time
                        
                        	Elapsed time since last CCM received
                        	**type**\:   :py:class:`LastCcmReceivedTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ethernet_cfm_oper.Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics.LastCcmReceivedTime>`
                        
                        .. attribute:: last_ccm_sequence_number
                        
                        	Sequence number of last CCM received
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'ethernet-cfm-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics, self).__init__()

                            self.yang_name = "statistics"
                            self.yang_parent_name = "peer-mep"

                            self.ccms_invalid_interval = YLeaf(YType.uint64, "ccms-invalid-interval")

                            self.ccms_invalid_maid = YLeaf(YType.uint64, "ccms-invalid-maid")

                            self.ccms_invalid_source_mac_address = YLeaf(YType.uint64, "ccms-invalid-source-mac-address")

                            self.ccms_our_mep_id = YLeaf(YType.uint64, "ccms-our-mep-id")

                            self.ccms_out_of_sequence = YLeaf(YType.uint64, "ccms-out-of-sequence")

                            self.ccms_rdi = YLeaf(YType.uint64, "ccms-rdi")

                            self.ccms_received = YLeaf(YType.uint64, "ccms-received")

                            self.ccms_wrong_level = YLeaf(YType.uint64, "ccms-wrong-level")

                            self.last_ccm_sequence_number = YLeaf(YType.uint32, "last-ccm-sequence-number")

                            self.last_ccm_received_time = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics.LastCcmReceivedTime()
                            self.last_ccm_received_time.parent = self
                            self._children_name_map["last_ccm_received_time"] = "last-ccm-received-time"
                            self._children_yang_names.add("last-ccm-received-time")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ccms_invalid_interval",
                                            "ccms_invalid_maid",
                                            "ccms_invalid_source_mac_address",
                                            "ccms_our_mep_id",
                                            "ccms_out_of_sequence",
                                            "ccms_rdi",
                                            "ccms_received",
                                            "ccms_wrong_level",
                                            "last_ccm_sequence_number") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics, self).__setattr__(name, value)


                        class LastCcmReceivedTime(Entity):
                            """
                            Elapsed time since last CCM received
                            
                            .. attribute:: nanoseconds
                            
                            	Nanoseconds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**units**\: nanosecond
                            
                            .. attribute:: seconds
                            
                            	Seconds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'ethernet-cfm-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics.LastCcmReceivedTime, self).__init__()

                                self.yang_name = "last-ccm-received-time"
                                self.yang_parent_name = "statistics"

                                self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                                self.seconds = YLeaf(YType.uint32, "seconds")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("nanoseconds",
                                                "seconds") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics.LastCcmReceivedTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics.LastCcmReceivedTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.nanoseconds.is_set or
                                    self.seconds.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.nanoseconds.yfilter != YFilter.not_set or
                                    self.seconds.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "last-ccm-received-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                                if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.seconds.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "nanoseconds" or name == "seconds"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "nanoseconds"):
                                    self.nanoseconds = value
                                    self.nanoseconds.value_namespace = name_space
                                    self.nanoseconds.value_namespace_prefix = name_space_prefix
                                if(value_path == "seconds"):
                                    self.seconds = value
                                    self.seconds.value_namespace = name_space
                                    self.seconds.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.ccms_invalid_interval.is_set or
                                self.ccms_invalid_maid.is_set or
                                self.ccms_invalid_source_mac_address.is_set or
                                self.ccms_our_mep_id.is_set or
                                self.ccms_out_of_sequence.is_set or
                                self.ccms_rdi.is_set or
                                self.ccms_received.is_set or
                                self.ccms_wrong_level.is_set or
                                self.last_ccm_sequence_number.is_set or
                                (self.last_ccm_received_time is not None and self.last_ccm_received_time.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ccms_invalid_interval.yfilter != YFilter.not_set or
                                self.ccms_invalid_maid.yfilter != YFilter.not_set or
                                self.ccms_invalid_source_mac_address.yfilter != YFilter.not_set or
                                self.ccms_our_mep_id.yfilter != YFilter.not_set or
                                self.ccms_out_of_sequence.yfilter != YFilter.not_set or
                                self.ccms_rdi.yfilter != YFilter.not_set or
                                self.ccms_received.yfilter != YFilter.not_set or
                                self.ccms_wrong_level.yfilter != YFilter.not_set or
                                self.last_ccm_sequence_number.yfilter != YFilter.not_set or
                                (self.last_ccm_received_time is not None and self.last_ccm_received_time.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "statistics" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ccms_invalid_interval.is_set or self.ccms_invalid_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_invalid_interval.get_name_leafdata())
                            if (self.ccms_invalid_maid.is_set or self.ccms_invalid_maid.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_invalid_maid.get_name_leafdata())
                            if (self.ccms_invalid_source_mac_address.is_set or self.ccms_invalid_source_mac_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_invalid_source_mac_address.get_name_leafdata())
                            if (self.ccms_our_mep_id.is_set or self.ccms_our_mep_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_our_mep_id.get_name_leafdata())
                            if (self.ccms_out_of_sequence.is_set or self.ccms_out_of_sequence.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_out_of_sequence.get_name_leafdata())
                            if (self.ccms_rdi.is_set or self.ccms_rdi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_rdi.get_name_leafdata())
                            if (self.ccms_received.is_set or self.ccms_received.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_received.get_name_leafdata())
                            if (self.ccms_wrong_level.is_set or self.ccms_wrong_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ccms_wrong_level.get_name_leafdata())
                            if (self.last_ccm_sequence_number.is_set or self.last_ccm_sequence_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_ccm_sequence_number.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "last-ccm-received-time"):
                                if (self.last_ccm_received_time is None):
                                    self.last_ccm_received_time = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics.LastCcmReceivedTime()
                                    self.last_ccm_received_time.parent = self
                                    self._children_name_map["last_ccm_received_time"] = "last-ccm-received-time"
                                return self.last_ccm_received_time

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "last-ccm-received-time" or name == "ccms-invalid-interval" or name == "ccms-invalid-maid" or name == "ccms-invalid-source-mac-address" or name == "ccms-our-mep-id" or name == "ccms-out-of-sequence" or name == "ccms-rdi" or name == "ccms-received" or name == "ccms-wrong-level" or name == "last-ccm-sequence-number"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ccms-invalid-interval"):
                                self.ccms_invalid_interval = value
                                self.ccms_invalid_interval.value_namespace = name_space
                                self.ccms_invalid_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccms-invalid-maid"):
                                self.ccms_invalid_maid = value
                                self.ccms_invalid_maid.value_namespace = name_space
                                self.ccms_invalid_maid.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccms-invalid-source-mac-address"):
                                self.ccms_invalid_source_mac_address = value
                                self.ccms_invalid_source_mac_address.value_namespace = name_space
                                self.ccms_invalid_source_mac_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccms-our-mep-id"):
                                self.ccms_our_mep_id = value
                                self.ccms_our_mep_id.value_namespace = name_space
                                self.ccms_our_mep_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccms-out-of-sequence"):
                                self.ccms_out_of_sequence = value
                                self.ccms_out_of_sequence.value_namespace = name_space
                                self.ccms_out_of_sequence.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccms-rdi"):
                                self.ccms_rdi = value
                                self.ccms_rdi.value_namespace = name_space
                                self.ccms_rdi.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccms-received"):
                                self.ccms_received = value
                                self.ccms_received.value_namespace = name_space
                                self.ccms_received.value_namespace_prefix = name_space_prefix
                            if(value_path == "ccms-wrong-level"):
                                self.ccms_wrong_level = value
                                self.ccms_wrong_level.value_namespace = name_space
                                self.ccms_wrong_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-ccm-sequence-number"):
                                self.last_ccm_sequence_number = value
                                self.last_ccm_sequence_number.value_namespace = name_space
                                self.last_ccm_sequence_number.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.ccm_offload.is_set or
                            self.cross_check_state.is_set or
                            self.mac_address.is_set or
                            self.mep_id.is_set or
                            self.peer_mep_state.is_set or
                            (self.error_state is not None and self.error_state.has_data()) or
                            (self.last_ccm_received is not None and self.last_ccm_received.has_data()) or
                            (self.last_up_down_time is not None and self.last_up_down_time.has_data()) or
                            (self.statistics is not None and self.statistics.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.ccm_offload.yfilter != YFilter.not_set or
                            self.cross_check_state.yfilter != YFilter.not_set or
                            self.mac_address.yfilter != YFilter.not_set or
                            self.mep_id.yfilter != YFilter.not_set or
                            self.peer_mep_state.yfilter != YFilter.not_set or
                            (self.error_state is not None and self.error_state.has_operation()) or
                            (self.last_ccm_received is not None and self.last_ccm_received.has_operation()) or
                            (self.last_up_down_time is not None and self.last_up_down_time.has_operation()) or
                            (self.statistics is not None and self.statistics.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "peer-mep" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.ccm_offload.is_set or self.ccm_offload.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ccm_offload.get_name_leafdata())
                        if (self.cross_check_state.is_set or self.cross_check_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.cross_check_state.get_name_leafdata())
                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mac_address.get_name_leafdata())
                        if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mep_id.get_name_leafdata())
                        if (self.peer_mep_state.is_set or self.peer_mep_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_mep_state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "error-state"):
                            if (self.error_state is None):
                                self.error_state = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.ErrorState()
                                self.error_state.parent = self
                                self._children_name_map["error_state"] = "error-state"
                            return self.error_state

                        if (child_yang_name == "last-ccm-received"):
                            if (self.last_ccm_received is None):
                                self.last_ccm_received = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastCcmReceived()
                                self.last_ccm_received.parent = self
                                self._children_name_map["last_ccm_received"] = "last-ccm-received"
                            return self.last_ccm_received

                        if (child_yang_name == "last-up-down-time"):
                            if (self.last_up_down_time is None):
                                self.last_up_down_time = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.LastUpDownTime()
                                self.last_up_down_time.parent = self
                                self._children_name_map["last_up_down_time"] = "last-up-down-time"
                            return self.last_up_down_time

                        if (child_yang_name == "statistics"):
                            if (self.statistics is None):
                                self.statistics = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep.Statistics()
                                self.statistics.parent = self
                                self._children_name_map["statistics"] = "statistics"
                            return self.statistics

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "error-state" or name == "last-ccm-received" or name == "last-up-down-time" or name == "statistics" or name == "ccm-offload" or name == "cross-check-state" or name == "mac-address" or name == "mep-id" or name == "peer-mep-state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "ccm-offload"):
                            self.ccm_offload = value
                            self.ccm_offload.value_namespace = name_space
                            self.ccm_offload.value_namespace_prefix = name_space_prefix
                        if(value_path == "cross-check-state"):
                            self.cross_check_state = value
                            self.cross_check_state.value_namespace = name_space
                            self.cross_check_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "mac-address"):
                            self.mac_address = value
                            self.mac_address.value_namespace = name_space
                            self.mac_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "mep-id"):
                            self.mep_id = value
                            self.mep_id.value_namespace = name_space
                            self.mep_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-mep-state"):
                            self.peer_mep_state = value
                            self.peer_mep_state.value_namespace = name_space
                            self.peer_mep_state.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.domain.is_set or
                        self.service.is_set or
                        self.local_mep_id.is_set or
                        self.interface.is_set or
                        self.peer_mep_id.is_set or
                        self.peer_mac_address.is_set or
                        self.domain_xr.is_set or
                        self.interface_xr.is_set or
                        self.level.is_set or
                        self.mep_direction.is_set or
                        self.mep_id.is_set or
                        self.service_xr.is_set or
                        self.standby.is_set or
                        (self.peer_mep is not None and self.peer_mep.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.domain.yfilter != YFilter.not_set or
                        self.service.yfilter != YFilter.not_set or
                        self.local_mep_id.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.peer_mep_id.yfilter != YFilter.not_set or
                        self.peer_mac_address.yfilter != YFilter.not_set or
                        self.domain_xr.yfilter != YFilter.not_set or
                        self.interface_xr.yfilter != YFilter.not_set or
                        self.level.yfilter != YFilter.not_set or
                        self.mep_direction.yfilter != YFilter.not_set or
                        self.mep_id.yfilter != YFilter.not_set or
                        self.service_xr.yfilter != YFilter.not_set or
                        self.standby.yfilter != YFilter.not_set or
                        (self.peer_mep is not None and self.peer_mep.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "peer-me-pv2" + "[domain='" + self.domain.get() + "']" + "[service='" + self.service.get() + "']" + "[local-mep-id='" + self.local_mep_id.get() + "']" + "[interface='" + self.interface.get() + "']" + "[peer-mep-id='" + self.peer_mep_id.get() + "']" + "[peer-mac-address='" + self.peer_mac_address.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/peer-me-pv2s/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.domain.is_set or self.domain.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain.get_name_leafdata())
                    if (self.service.is_set or self.service.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service.get_name_leafdata())
                    if (self.local_mep_id.is_set or self.local_mep_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_mep_id.get_name_leafdata())
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.peer_mep_id.is_set or self.peer_mep_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_mep_id.get_name_leafdata())
                    if (self.peer_mac_address.is_set or self.peer_mac_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_mac_address.get_name_leafdata())
                    if (self.domain_xr.is_set or self.domain_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.domain_xr.get_name_leafdata())
                    if (self.interface_xr.is_set or self.interface_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_xr.get_name_leafdata())
                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.level.get_name_leafdata())
                    if (self.mep_direction.is_set or self.mep_direction.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_direction.get_name_leafdata())
                    if (self.mep_id.is_set or self.mep_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mep_id.get_name_leafdata())
                    if (self.service_xr.is_set or self.service_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.service_xr.get_name_leafdata())
                    if (self.standby.is_set or self.standby.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "peer-mep"):
                        if (self.peer_mep is None):
                            self.peer_mep = Cfm.Global_.PeerMePv2S.PeerMePv2.PeerMep()
                            self.peer_mep.parent = self
                            self._children_name_map["peer_mep"] = "peer-mep"
                        return self.peer_mep

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "peer-mep" or name == "domain" or name == "service" or name == "local-mep-id" or name == "interface" or name == "peer-mep-id" or name == "peer-mac-address" or name == "domain-xr" or name == "interface-xr" or name == "level" or name == "mep-direction" or name == "mep-id" or name == "service-xr" or name == "standby"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "domain"):
                        self.domain = value
                        self.domain.value_namespace = name_space
                        self.domain.value_namespace_prefix = name_space_prefix
                    if(value_path == "service"):
                        self.service = value
                        self.service.value_namespace = name_space
                        self.service.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-mep-id"):
                        self.local_mep_id = value
                        self.local_mep_id.value_namespace = name_space
                        self.local_mep_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-mep-id"):
                        self.peer_mep_id = value
                        self.peer_mep_id.value_namespace = name_space
                        self.peer_mep_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-mac-address"):
                        self.peer_mac_address = value
                        self.peer_mac_address.value_namespace = name_space
                        self.peer_mac_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "domain-xr"):
                        self.domain_xr = value
                        self.domain_xr.value_namespace = name_space
                        self.domain_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-xr"):
                        self.interface_xr = value
                        self.interface_xr.value_namespace = name_space
                        self.interface_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "level"):
                        self.level = value
                        self.level.value_namespace = name_space
                        self.level.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-direction"):
                        self.mep_direction = value
                        self.mep_direction.value_namespace = name_space
                        self.mep_direction.value_namespace_prefix = name_space_prefix
                    if(value_path == "mep-id"):
                        self.mep_id = value
                        self.mep_id.value_namespace = name_space
                        self.mep_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "service-xr"):
                        self.service_xr = value
                        self.service_xr.value_namespace = name_space
                        self.service_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby"):
                        self.standby = value
                        self.standby.value_namespace = name_space
                        self.standby.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.peer_me_pv2:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.peer_me_pv2:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "peer-me-pv2s" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "peer-me-pv2"):
                    for c in self.peer_me_pv2:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Cfm.Global_.PeerMePv2S.PeerMePv2()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.peer_me_pv2.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "peer-me-pv2"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.global_configuration_errors is not None and self.global_configuration_errors.has_data()) or
                (self.incomplete_traceroutes is not None and self.incomplete_traceroutes.has_data()) or
                (self.local_meps is not None and self.local_meps.has_data()) or
                (self.maintenance_points is not None and self.maintenance_points.has_data()) or
                (self.mep_configuration_errors is not None and self.mep_configuration_errors.has_data()) or
                (self.peer_me_pv2s is not None and self.peer_me_pv2s.has_data()) or
                (self.traceroute_caches is not None and self.traceroute_caches.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.global_configuration_errors is not None and self.global_configuration_errors.has_operation()) or
                (self.incomplete_traceroutes is not None and self.incomplete_traceroutes.has_operation()) or
                (self.local_meps is not None and self.local_meps.has_operation()) or
                (self.maintenance_points is not None and self.maintenance_points.has_operation()) or
                (self.mep_configuration_errors is not None and self.mep_configuration_errors.has_operation()) or
                (self.peer_me_pv2s is not None and self.peer_me_pv2s.has_operation()) or
                (self.traceroute_caches is not None and self.traceroute_caches.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "global" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "global-configuration-errors"):
                if (self.global_configuration_errors is None):
                    self.global_configuration_errors = Cfm.Global_.GlobalConfigurationErrors()
                    self.global_configuration_errors.parent = self
                    self._children_name_map["global_configuration_errors"] = "global-configuration-errors"
                return self.global_configuration_errors

            if (child_yang_name == "incomplete-traceroutes"):
                if (self.incomplete_traceroutes is None):
                    self.incomplete_traceroutes = Cfm.Global_.IncompleteTraceroutes()
                    self.incomplete_traceroutes.parent = self
                    self._children_name_map["incomplete_traceroutes"] = "incomplete-traceroutes"
                return self.incomplete_traceroutes

            if (child_yang_name == "local-meps"):
                if (self.local_meps is None):
                    self.local_meps = Cfm.Global_.LocalMeps()
                    self.local_meps.parent = self
                    self._children_name_map["local_meps"] = "local-meps"
                return self.local_meps

            if (child_yang_name == "maintenance-points"):
                if (self.maintenance_points is None):
                    self.maintenance_points = Cfm.Global_.MaintenancePoints()
                    self.maintenance_points.parent = self
                    self._children_name_map["maintenance_points"] = "maintenance-points"
                return self.maintenance_points

            if (child_yang_name == "mep-configuration-errors"):
                if (self.mep_configuration_errors is None):
                    self.mep_configuration_errors = Cfm.Global_.MepConfigurationErrors()
                    self.mep_configuration_errors.parent = self
                    self._children_name_map["mep_configuration_errors"] = "mep-configuration-errors"
                return self.mep_configuration_errors

            if (child_yang_name == "peer-me-pv2s"):
                if (self.peer_me_pv2s is None):
                    self.peer_me_pv2s = Cfm.Global_.PeerMePv2S()
                    self.peer_me_pv2s.parent = self
                    self._children_name_map["peer_me_pv2s"] = "peer-me-pv2s"
                return self.peer_me_pv2s

            if (child_yang_name == "traceroute-caches"):
                if (self.traceroute_caches is None):
                    self.traceroute_caches = Cfm.Global_.TracerouteCaches()
                    self.traceroute_caches.parent = self
                    self._children_name_map["traceroute_caches"] = "traceroute-caches"
                return self.traceroute_caches

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "global-configuration-errors" or name == "incomplete-traceroutes" or name == "local-meps" or name == "maintenance-points" or name == "mep-configuration-errors" or name == "peer-me-pv2s" or name == "traceroute-caches"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.global_ is not None and self.global_.has_data()) or
            (self.nodes is not None and self.nodes.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.global_ is not None and self.global_.has_operation()) or
            (self.nodes is not None and self.nodes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-ethernet-cfm-oper:cfm" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "global"):
            if (self.global_ is None):
                self.global_ = Cfm.Global_()
                self.global_.parent = self
                self._children_name_map["global_"] = "global"
            return self.global_

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = Cfm.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "global" or name == "nodes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Cfm()
        return self._top_entity

