""" Cisco_IOS_XR_clns_isis_cfg 

This module contains a collection of YANG definitions
for Cisco IOS\-XR clns\-isis package configuration.

This module contains definitions
for the following management objects\:
  isis\: IS\-IS configuration for all instances

This YANG module augments the
  Cisco\-IOS\-XR\-snmp\-agent\-cfg
module with configuration data.

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class IsisAdjCheck(Enum):
    """
    IsisAdjCheck

    Isis adj check

    .. data:: disabled = 0

    	Disabled

    """

    disabled = Enum.YLeaf(0, "disabled")


class IsisAdvTypeExternal(Enum):
    """
    IsisAdvTypeExternal

    Isis adv type external

    .. data:: external = 1

    	External

    """

    external = Enum.YLeaf(1, "external")


class IsisAdvTypeInterLevel(Enum):
    """
    IsisAdvTypeInterLevel

    Isis adv type inter level

    .. data:: inter_level = 1

    	InterLevel

    """

    inter_level = Enum.YLeaf(1, "inter-level")


class IsisApplyWeight(Enum):
    """
    IsisApplyWeight

    Isis apply weight

    .. data:: ecmp_only = 1

    	Apply weight to ECMP prefixes

    .. data:: ucmp_only = 2

    	Apply weight to UCMP prefixes

    """

    ecmp_only = Enum.YLeaf(1, "ecmp-only")

    ucmp_only = Enum.YLeaf(2, "ucmp-only")


class IsisAttachedBit(Enum):
    """
    IsisAttachedBit

    Isis attached bit

    .. data:: area = 0

    	Computed from the attached areas

    .. data:: on = 1

    	Forced ON

    .. data:: off = 2

    	Forced OFF

    """

    area = Enum.YLeaf(0, "area")

    on = Enum.YLeaf(1, "on")

    off = Enum.YLeaf(2, "off")


class IsisAuthenticationAlgorithm(Enum):
    """
    IsisAuthenticationAlgorithm

    Isis authentication algorithm

    .. data:: cleartext = 1

    	Cleartext password

    .. data:: hmac_md5 = 2

    	HMAC-MD5 checksum

    .. data:: keychain = 3

    	Key Chain authentication

    """

    cleartext = Enum.YLeaf(1, "cleartext")

    hmac_md5 = Enum.YLeaf(2, "hmac-md5")

    keychain = Enum.YLeaf(3, "keychain")


class IsisAuthenticationFailureMode(Enum):
    """
    IsisAuthenticationFailureMode

    Isis authentication failure mode

    .. data:: drop = 0

    	Drop non-authenticating PDUs

    .. data:: send_only = 1

    	Accept non-authenticating PDUs

    """

    drop = Enum.YLeaf(0, "drop")

    send_only = Enum.YLeaf(1, "send-only")


class IsisConfigurableLevels(Enum):
    """
    IsisConfigurableLevels

    Isis configurable levels

    .. data:: level1 = 1

    	Level1

    .. data:: level2 = 2

    	Level2

    .. data:: level1_and2 = 3

    	Both Levels

    """

    level1 = Enum.YLeaf(1, "level1")

    level2 = Enum.YLeaf(2, "level2")

    level1_and2 = Enum.YLeaf(3, "level1-and2")


class IsisHelloPadding(Enum):
    """
    IsisHelloPadding

    Isis hello padding

    .. data:: never = 0

    	Never pad Hellos

    .. data:: sometimes = 1

    	Pad Hellos during adjacency formation only

    """

    never = Enum.YLeaf(0, "never")

    sometimes = Enum.YLeaf(1, "sometimes")


class IsisInterfaceAfState(Enum):
    """
    IsisInterfaceAfState

    Isis interface af state

    .. data:: disable = 0

    	Disable

    """

    disable = Enum.YLeaf(0, "disable")


class IsisInterfaceFrrTiebreaker(Enum):
    """
    IsisInterfaceFrrTiebreaker

    Isis interface frr tiebreaker

    .. data:: node_protecting = 3

    	Prefer node protecting backup path

    .. data:: srlg_disjoint = 6

    	Prefer SRLG disjoint backup path

    """

    node_protecting = Enum.YLeaf(3, "node-protecting")

    srlg_disjoint = Enum.YLeaf(6, "srlg-disjoint")


class IsisInterfaceState(Enum):
    """
    IsisInterfaceState

    Isis interface state

    .. data:: shutdown = 0

    	Shutdown

    .. data:: suppressed = 1

    	Suppressed

    .. data:: passive = 2

    	Passive

    """

    shutdown = Enum.YLeaf(0, "shutdown")

    suppressed = Enum.YLeaf(1, "suppressed")

    passive = Enum.YLeaf(2, "passive")


class IsisLabelPreference(Enum):
    """
    IsisLabelPreference

    Isis label preference

    .. data:: ldp = 0

    	Label Distribution Protocol

    .. data:: segment_routing = 1

    	Segment Routing

    """

    ldp = Enum.YLeaf(0, "ldp")

    segment_routing = Enum.YLeaf(1, "segment-routing")


class IsisMetric(Enum):
    """
    IsisMetric

    Isis metric

    .. data:: internal = 0

    	Internal metric

    .. data:: external = 1

    	External metric

    """

    internal = Enum.YLeaf(0, "internal")

    external = Enum.YLeaf(1, "external")


class IsisMetricStyle(Enum):
    """
    IsisMetricStyle

    Isis metric style

    .. data:: old_metric_style = 0

    	ISO 10589 metric style (old-style)

    .. data:: new_metric_style = 1

    	32-bit metric style (new-style)

    .. data:: both_metric_style = 2

    	Both forms of metric style

    """

    old_metric_style = Enum.YLeaf(0, "old-metric-style")

    new_metric_style = Enum.YLeaf(1, "new-metric-style")

    both_metric_style = Enum.YLeaf(2, "both-metric-style")


class IsisMetricStyleTransition(Enum):
    """
    IsisMetricStyleTransition

    Isis metric style transition

    .. data:: disabled = 0

    	Disabled

    .. data:: enabled = 1

    	Enabled

    """

    disabled = Enum.YLeaf(0, "disabled")

    enabled = Enum.YLeaf(1, "enabled")


class IsisMibAdjacencyChangeBoolean(Enum):
    """
    IsisMibAdjacencyChangeBoolean

    Isis mib adjacency change boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 17

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(17, "true")


class IsisMibAllBoolean(Enum):
    """
    IsisMibAllBoolean

    Isis mib all boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 19

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(19, "true")


class IsisMibAreaMismatchBoolean(Enum):
    """
    IsisMibAreaMismatchBoolean

    Isis mib area mismatch boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 12

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(12, "true")


class IsisMibAttemptToExceedMaxSequenceBoolean(Enum):
    """
    IsisMibAttemptToExceedMaxSequenceBoolean

    Isis mib attempt to exceed max sequence boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 4

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(4, "true")


class IsisMibAuthenticationFailureBoolean(Enum):
    """
    IsisMibAuthenticationFailureBoolean

    Isis mib authentication failure boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 10

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(10, "true")


class IsisMibAuthenticationTypeFailureBoolean(Enum):
    """
    IsisMibAuthenticationTypeFailureBoolean

    Isis mib authentication type failure boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 9

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(9, "true")


class IsisMibCorruptedLspDetectedBoolean(Enum):
    """
    IsisMibCorruptedLspDetectedBoolean

    Isis mib corrupted lsp detected boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 3

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(3, "true")


class IsisMibDatabaseOverFlowBoolean(Enum):
    """
    IsisMibDatabaseOverFlowBoolean

    Isis mib database over flow boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 1

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(1, "true")


class IsisMibIdLengthMismatchBoolean(Enum):
    """
    IsisMibIdLengthMismatchBoolean

    Isis mib id length mismatch boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 5

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(5, "true")


class IsisMibLspErrorDetectedBoolean(Enum):
    """
    IsisMibLspErrorDetectedBoolean

    Isis mib lsp error detected boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 18

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(18, "true")


class IsisMibLspTooLargeToPropagateBoolean(Enum):
    """
    IsisMibLspTooLargeToPropagateBoolean

    Isis mib lsp too large to propagate boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 14

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(14, "true")


class IsisMibManualAddressDropsBoolean(Enum):
    """
    IsisMibManualAddressDropsBoolean

    Isis mib manual address drops boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 2

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(2, "true")


class IsisMibMaxAreaAddressMismatchBoolean(Enum):
    """
    IsisMibMaxAreaAddressMismatchBoolean

    Isis mib max area address mismatch boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 6

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(6, "true")


class IsisMibOriginatedLspBufferSizeMismatchBoolean(Enum):
    """
    IsisMibOriginatedLspBufferSizeMismatchBoolean

    Isis mib originated lsp buffer size mismatch

    boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 15

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(15, "true")


class IsisMibOwnLspPurgeBoolean(Enum):
    """
    IsisMibOwnLspPurgeBoolean

    Isis mib own lsp purge boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 7

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(7, "true")


class IsisMibProtocolsSupportedMismatchBoolean(Enum):
    """
    IsisMibProtocolsSupportedMismatchBoolean

    Isis mib protocols supported mismatch boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 16

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(16, "true")


class IsisMibRejectedAdjacencyBoolean(Enum):
    """
    IsisMibRejectedAdjacencyBoolean

    Isis mib rejected adjacency boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 13

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(13, "true")


class IsisMibSequenceNumberSkipBoolean(Enum):
    """
    IsisMibSequenceNumberSkipBoolean

    Isis mib sequence number skip boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 8

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(8, "true")


class IsisMibVersionSkewBoolean(Enum):
    """
    IsisMibVersionSkewBoolean

    Isis mib version skew boolean

    .. data:: false = 0

    	Disable

    .. data:: true = 11

    	Enable

    """

    false = Enum.YLeaf(0, "false")

    true = Enum.YLeaf(11, "true")


class IsisMicroLoopAvoidance(Enum):
    """
    IsisMicroLoopAvoidance

    Isis micro loop avoidance

    .. data:: not_set = 0

    	No Avoidance type set

    .. data:: micro_loop_avoidance_all = 1

    	Provide mirco loop avoidance for all prefixes

    .. data:: micro_loop_avoidance_protected = 2

    	Provide mirco loop avoidance only for protected

    	prefixes

    .. data:: micro_loop_avoidance_segement_routing = 3

    	Provide segment-routing mirco loop avoidance

    """

    not_set = Enum.YLeaf(0, "not-set")

    micro_loop_avoidance_all = Enum.YLeaf(1, "micro-loop-avoidance-all")

    micro_loop_avoidance_protected = Enum.YLeaf(2, "micro-loop-avoidance-protected")

    micro_loop_avoidance_segement_routing = Enum.YLeaf(3, "micro-loop-avoidance-segement-routing")


class IsisNsfFlavor(Enum):
    """
    IsisNsfFlavor

    Isis nsf flavor

    .. data:: cisco_proprietary_nsf = 1

    	Cisco proprietary NSF

    .. data:: ietf_standard_nsf = 2

    	IETF standard NSF

    """

    cisco_proprietary_nsf = Enum.YLeaf(1, "cisco-proprietary-nsf")

    ietf_standard_nsf = Enum.YLeaf(2, "ietf-standard-nsf")


class IsisOverloadBitMode(Enum):
    """
    IsisOverloadBitMode

    Isis overload bit mode

    .. data:: permanently_set = 1

    	Set always

    .. data:: startup_period = 2

    	Set during the startup period

    .. data:: wait_for_bgp = 3

    	Set until BGP comverges

    """

    permanently_set = Enum.YLeaf(1, "permanently-set")

    startup_period = Enum.YLeaf(2, "startup-period")

    wait_for_bgp = Enum.YLeaf(3, "wait-for-bgp")


class IsisPrefixPriority(Enum):
    """
    IsisPrefixPriority

    Isis prefix priority

    .. data:: critical_priority = 0

    	Critical prefix priority

    .. data:: high_priority = 1

    	High prefix priority

    .. data:: medium_priority = 2

    	Medium prefix priority

    """

    critical_priority = Enum.YLeaf(0, "critical-priority")

    high_priority = Enum.YLeaf(1, "high-priority")

    medium_priority = Enum.YLeaf(2, "medium-priority")


class IsisRedistProto(Enum):
    """
    IsisRedistProto

    Isis redist proto

    .. data:: connected = 0

    	Connected

    .. data:: static = 1

    	Static

    .. data:: ospf = 2

    	OSPF

    .. data:: bgp = 3

    	BGP

    .. data:: isis = 4

    	ISIS

    .. data:: ospfv3 = 5

    	OSPFv3

    .. data:: rip = 6

    	RIP

    .. data:: eigrp = 7

    	EIGRP

    .. data:: subscriber = 8

    	Subscriber

    .. data:: application = 9

    	Application

    .. data:: mobile = 10

    	Mobile

    """

    connected = Enum.YLeaf(0, "connected")

    static = Enum.YLeaf(1, "static")

    ospf = Enum.YLeaf(2, "ospf")

    bgp = Enum.YLeaf(3, "bgp")

    isis = Enum.YLeaf(4, "isis")

    ospfv3 = Enum.YLeaf(5, "ospfv3")

    rip = Enum.YLeaf(6, "rip")

    eigrp = Enum.YLeaf(7, "eigrp")

    subscriber = Enum.YLeaf(8, "subscriber")

    application = Enum.YLeaf(9, "application")

    mobile = Enum.YLeaf(10, "mobile")


class IsisRemoteLfa(Enum):
    """
    IsisRemoteLfa

    Isis remote lfa

    .. data:: remote_lfa_none = 0

    	No remote LFA option set

    .. data:: remote_lfa_tunnel_ldp = 1

    	Construct remote LFA tunnel using MPLS LDP

    """

    remote_lfa_none = Enum.YLeaf(0, "remote-lfa-none")

    remote_lfa_tunnel_ldp = Enum.YLeaf(1, "remote-lfa-tunnel-ldp")


class IsisSnpAuth(Enum):
    """
    IsisSnpAuth

    Isis snp auth

    .. data:: send_only = 0

    	Authenticate SNP send only

    .. data:: full = 1

    	Authenticate SNP send and recv

    """

    send_only = Enum.YLeaf(0, "send-only")

    full = Enum.YLeaf(1, "full")


class IsisTracingMode(Enum):
    """
    IsisTracingMode

    Isis tracing mode

    .. data:: off = 0

    	No tracing

    .. data:: basic = 1

    	Basic tracing (less overhead)

    .. data:: enhanced = 2

    	Enhanced tracing (more overhead)

    """

    off = Enum.YLeaf(0, "off")

    basic = Enum.YLeaf(1, "basic")

    enhanced = Enum.YLeaf(2, "enhanced")


class IsisexplicitNullFlag(Enum):
    """
    IsisexplicitNullFlag

    Isisexplicit null flag

    .. data:: disable = 0

    	Disable EXPLICITNULL

    .. data:: enable = 1

    	Enable EXPLICITNULL

    """

    disable = Enum.YLeaf(0, "disable")

    enable = Enum.YLeaf(1, "enable")


class Isisfrr(Enum):
    """
    Isisfrr

    Isisfrr

    .. data:: per_link = 1

    	Prefix independent per-link computation

    .. data:: per_prefix = 2

    	Prefix dependent computation

    """

    per_link = Enum.YLeaf(1, "per-link")

    per_prefix = Enum.YLeaf(2, "per-prefix")


class IsisfrrLoadSharing(Enum):
    """
    IsisfrrLoadSharing

    Isisfrr load sharing

    .. data:: disable = 1

    	Disable load sharing of prefixes across

    	multiple backups

    """

    disable = Enum.YLeaf(1, "disable")


class IsisfrrTiebreaker(Enum):
    """
    IsisfrrTiebreaker

    Isisfrr tiebreaker

    .. data:: downstream = 0

    	Prefer backup path via downstream node

    .. data:: lc_disjoint = 1

    	Prefer line card disjoint backup path

    .. data:: lowest_backup_metric = 2

    	Prefer backup path with lowest total metric

    .. data:: node_protecting = 3

    	Prefer node protecting backup path

    .. data:: primary_path = 4

    	Prefer backup path from ECMP set

    .. data:: secondary_path = 5

    	Prefer non-ECMP backup path

    .. data:: srlg_disjoint = 6

    	Prefer SRLG disjoint backup path

    """

    downstream = Enum.YLeaf(0, "downstream")

    lc_disjoint = Enum.YLeaf(1, "lc-disjoint")

    lowest_backup_metric = Enum.YLeaf(2, "lowest-backup-metric")

    node_protecting = Enum.YLeaf(3, "node-protecting")

    primary_path = Enum.YLeaf(4, "primary-path")

    secondary_path = Enum.YLeaf(5, "secondary-path")

    srlg_disjoint = Enum.YLeaf(6, "srlg-disjoint")


class IsisispfState(Enum):
    """
    IsisispfState

    Isisispf state

    .. data:: enabled = 1

    	Enabled

    """

    enabled = Enum.YLeaf(1, "enabled")


class IsisphpFlag(Enum):
    """
    IsisphpFlag

    Isisphp flag

    .. data:: enable = 0

    	Enable PHP

    .. data:: disable = 1

    	Disable PHP

    """

    enable = Enum.YLeaf(0, "enable")

    disable = Enum.YLeaf(1, "disable")


class Isissid(Enum):
    """
    Isissid

    Isissid

    .. data:: index = 1

    	SID as an index

    .. data:: absolute = 2

    	SID as an absolute label

    """

    index = Enum.YLeaf(1, "index")

    absolute = Enum.YLeaf(2, "absolute")


class NflagClear(Enum):
    """
    NflagClear

    Nflag clear

    .. data:: disable = 0

    	Disable N-flag-clear

    .. data:: enable = 1

    	Enable N-flag-clear

    """

    disable = Enum.YLeaf(0, "disable")

    enable = Enum.YLeaf(1, "enable")



class Isis(Entity):
    """
    IS\-IS configuration for all instances
    
    .. attribute:: instances
    
    	IS\-IS instance configuration
    	**type**\:   :py:class:`Instances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances>`
    
    

    """

    _prefix = 'clns-isis-cfg'
    _revision = '2015-11-09'

    def __init__(self):
        super(Isis, self).__init__()
        self._top_entity = None

        self.yang_name = "isis"
        self.yang_parent_name = "Cisco-IOS-XR-clns-isis-cfg"

        self.instances = Isis.Instances()
        self.instances.parent = self
        self._children_name_map["instances"] = "instances"
        self._children_yang_names.add("instances")


    class Instances(Entity):
        """
        IS\-IS instance configuration
        
        .. attribute:: instance
        
        	Configuration for a single IS\-IS instance
        	**type**\: list of    :py:class:`Instance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance>`
        
        

        """

        _prefix = 'clns-isis-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(Isis.Instances, self).__init__()

            self.yang_name = "instances"
            self.yang_parent_name = "isis"

            self.instance = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Isis.Instances, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Isis.Instances, self).__setattr__(name, value)


        class Instance(Entity):
            """
            Configuration for a single IS\-IS instance
            
            .. attribute:: instance_name  <key>
            
            	Instance identifier
            	**type**\:  str
            
            	**length:** 1..40
            
            .. attribute:: adjacency_stagger
            
            	Stagger ISIS adjacency bring up
            	**type**\:   :py:class:`AdjacencyStagger <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.AdjacencyStagger>`
            
            	**presence node**\: True
            
            .. attribute:: afs
            
            	Per\-address\-family configuration
            	**type**\:   :py:class:`Afs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs>`
            
            .. attribute:: distribute
            
            	IS\-IS Distribute BGP\-LS configuration
            	**type**\:   :py:class:`Distribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Distribute>`
            
            	**presence node**\: True
            
            .. attribute:: dynamic_host_name
            
            	If TRUE, dynamic hostname resolution is disabled, and system IDs will always be displayed by show and debug output
            	**type**\:  bool
            
            .. attribute:: ignore_lsp_errors
            
            	If TRUE, LSPs recieved with bad checksums will result in the purging of that LSP from the LSP DB. If FALSE or not set, the received LSP will just be ignored
            	**type**\:  bool
            
            .. attribute:: instance_id
            
            	Instance ID of the IS\-IS process
            	**type**\:  int
            
            	**range:** 0..65535
            
            	**default value**\: 0
            
            .. attribute:: interfaces
            
            	Per\-interface configuration
            	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces>`
            
            .. attribute:: is_type
            
            	IS type of the IS\-IS process
            	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
            
            	**default value**\: level1-and2
            
            .. attribute:: link_groups
            
            	Link Group
            	**type**\:   :py:class:`LinkGroups <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LinkGroups>`
            
            .. attribute:: log_adjacency_changes
            
            	Log changes in adjacency state
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: log_pdu_drops
            
            	Log PDU drops
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: lsp_accept_passwords
            
            	LSP/SNP accept password configuration
            	**type**\:   :py:class:`LspAcceptPasswords <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspAcceptPasswords>`
            
            .. attribute:: lsp_arrival_times
            
            	LSP arrival time configuration
            	**type**\:   :py:class:`LspArrivalTimes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspArrivalTimes>`
            
            .. attribute:: lsp_check_intervals
            
            	LSP checksum check interval configuration
            	**type**\:   :py:class:`LspCheckIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspCheckIntervals>`
            
            .. attribute:: lsp_generation_intervals
            
            	LSP generation\-interval configuration
            	**type**\:   :py:class:`LspGenerationIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspGenerationIntervals>`
            
            .. attribute:: lsp_lifetimes
            
            	LSP lifetime configuration
            	**type**\:   :py:class:`LspLifetimes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspLifetimes>`
            
            .. attribute:: lsp_mtus
            
            	LSP MTU configuration
            	**type**\:   :py:class:`LspMtus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspMtus>`
            
            .. attribute:: lsp_passwords
            
            	LSP/SNP password configuration
            	**type**\:   :py:class:`LspPasswords <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspPasswords>`
            
            .. attribute:: lsp_refresh_intervals
            
            	LSP refresh\-interval configuration
            	**type**\:   :py:class:`LspRefreshIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspRefreshIntervals>`
            
            .. attribute:: max_link_metrics
            
            	Max Link Metric configuration
            	**type**\:   :py:class:`MaxLinkMetrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.MaxLinkMetrics>`
            
            .. attribute:: nets
            
            	NET configuration
            	**type**\:   :py:class:`Nets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Nets>`
            
            .. attribute:: nsf
            
            	IS\-IS NSF configuration
            	**type**\:   :py:class:`Nsf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Nsf>`
            
            .. attribute:: nsr
            
            	IS\-IS NSR configuration
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: overload_bits
            
            	LSP overload\-bit configuration
            	**type**\:   :py:class:`OverloadBits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.OverloadBits>`
            
            .. attribute:: running
            
            	Flag to indicate that instance should be running.  This must be the first object created when an IS\-IS instance is configured, and the last object deleted when it is deconfigured.  When this object is deleted, the IS\-IS instance will exit
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: srgb
            
            	Segment Routing Global Block configuration
            	**type**\:   :py:class:`Srgb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Srgb>`
            
            	**presence node**\: True
            
            .. attribute:: trace_buffer_size
            
            	Trace buffer size configuration
            	**type**\:   :py:class:`TraceBufferSize <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.TraceBufferSize>`
            
            .. attribute:: tracing_mode
            
            	Tracing mode configuration
            	**type**\:   :py:class:`IsisTracingMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisTracingMode>`
            
            	**default value**\: basic
            
            

            """

            _prefix = 'clns-isis-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(Isis.Instances.Instance, self).__init__()

                self.yang_name = "instance"
                self.yang_parent_name = "instances"

                self.instance_name = YLeaf(YType.str, "instance-name")

                self.dynamic_host_name = YLeaf(YType.boolean, "dynamic-host-name")

                self.ignore_lsp_errors = YLeaf(YType.boolean, "ignore-lsp-errors")

                self.instance_id = YLeaf(YType.uint32, "instance-id")

                self.is_type = YLeaf(YType.enumeration, "is-type")

                self.log_adjacency_changes = YLeaf(YType.empty, "log-adjacency-changes")

                self.log_pdu_drops = YLeaf(YType.empty, "log-pdu-drops")

                self.nsr = YLeaf(YType.empty, "nsr")

                self.running = YLeaf(YType.empty, "running")

                self.tracing_mode = YLeaf(YType.enumeration, "tracing-mode")

                self.adjacency_stagger = None
                self._children_name_map["adjacency_stagger"] = "adjacency-stagger"
                self._children_yang_names.add("adjacency-stagger")

                self.afs = Isis.Instances.Instance.Afs()
                self.afs.parent = self
                self._children_name_map["afs"] = "afs"
                self._children_yang_names.add("afs")

                self.distribute = None
                self._children_name_map["distribute"] = "distribute"
                self._children_yang_names.add("distribute")

                self.interfaces = Isis.Instances.Instance.Interfaces()
                self.interfaces.parent = self
                self._children_name_map["interfaces"] = "interfaces"
                self._children_yang_names.add("interfaces")

                self.link_groups = Isis.Instances.Instance.LinkGroups()
                self.link_groups.parent = self
                self._children_name_map["link_groups"] = "link-groups"
                self._children_yang_names.add("link-groups")

                self.lsp_accept_passwords = Isis.Instances.Instance.LspAcceptPasswords()
                self.lsp_accept_passwords.parent = self
                self._children_name_map["lsp_accept_passwords"] = "lsp-accept-passwords"
                self._children_yang_names.add("lsp-accept-passwords")

                self.lsp_arrival_times = Isis.Instances.Instance.LspArrivalTimes()
                self.lsp_arrival_times.parent = self
                self._children_name_map["lsp_arrival_times"] = "lsp-arrival-times"
                self._children_yang_names.add("lsp-arrival-times")

                self.lsp_check_intervals = Isis.Instances.Instance.LspCheckIntervals()
                self.lsp_check_intervals.parent = self
                self._children_name_map["lsp_check_intervals"] = "lsp-check-intervals"
                self._children_yang_names.add("lsp-check-intervals")

                self.lsp_generation_intervals = Isis.Instances.Instance.LspGenerationIntervals()
                self.lsp_generation_intervals.parent = self
                self._children_name_map["lsp_generation_intervals"] = "lsp-generation-intervals"
                self._children_yang_names.add("lsp-generation-intervals")

                self.lsp_lifetimes = Isis.Instances.Instance.LspLifetimes()
                self.lsp_lifetimes.parent = self
                self._children_name_map["lsp_lifetimes"] = "lsp-lifetimes"
                self._children_yang_names.add("lsp-lifetimes")

                self.lsp_mtus = Isis.Instances.Instance.LspMtus()
                self.lsp_mtus.parent = self
                self._children_name_map["lsp_mtus"] = "lsp-mtus"
                self._children_yang_names.add("lsp-mtus")

                self.lsp_passwords = Isis.Instances.Instance.LspPasswords()
                self.lsp_passwords.parent = self
                self._children_name_map["lsp_passwords"] = "lsp-passwords"
                self._children_yang_names.add("lsp-passwords")

                self.lsp_refresh_intervals = Isis.Instances.Instance.LspRefreshIntervals()
                self.lsp_refresh_intervals.parent = self
                self._children_name_map["lsp_refresh_intervals"] = "lsp-refresh-intervals"
                self._children_yang_names.add("lsp-refresh-intervals")

                self.max_link_metrics = Isis.Instances.Instance.MaxLinkMetrics()
                self.max_link_metrics.parent = self
                self._children_name_map["max_link_metrics"] = "max-link-metrics"
                self._children_yang_names.add("max-link-metrics")

                self.nets = Isis.Instances.Instance.Nets()
                self.nets.parent = self
                self._children_name_map["nets"] = "nets"
                self._children_yang_names.add("nets")

                self.nsf = Isis.Instances.Instance.Nsf()
                self.nsf.parent = self
                self._children_name_map["nsf"] = "nsf"
                self._children_yang_names.add("nsf")

                self.overload_bits = Isis.Instances.Instance.OverloadBits()
                self.overload_bits.parent = self
                self._children_name_map["overload_bits"] = "overload-bits"
                self._children_yang_names.add("overload-bits")

                self.srgb = None
                self._children_name_map["srgb"] = "srgb"
                self._children_yang_names.add("srgb")

                self.trace_buffer_size = Isis.Instances.Instance.TraceBufferSize()
                self.trace_buffer_size.parent = self
                self._children_name_map["trace_buffer_size"] = "trace-buffer-size"
                self._children_yang_names.add("trace-buffer-size")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("instance_name",
                                "dynamic_host_name",
                                "ignore_lsp_errors",
                                "instance_id",
                                "is_type",
                                "log_adjacency_changes",
                                "log_pdu_drops",
                                "nsr",
                                "running",
                                "tracing_mode") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Isis.Instances.Instance, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Isis.Instances.Instance, self).__setattr__(name, value)


            class Srgb(Entity):
                """
                Segment Routing Global Block configuration
                
                .. attribute:: lower_bound
                
                	The lower bound of the SRGB
                	**type**\:  int
                
                	**range:** 16000..1048574
                
                	**mandatory**\: True
                
                .. attribute:: upper_bound
                
                	The upper bound of the SRGB
                	**type**\:  int
                
                	**range:** 16001..1048575
                
                	**mandatory**\: True
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.Srgb, self).__init__()

                    self.yang_name = "srgb"
                    self.yang_parent_name = "instance"
                    self.is_presence_container = True

                    self.lower_bound = YLeaf(YType.uint32, "lower-bound")

                    self.upper_bound = YLeaf(YType.uint32, "upper-bound")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lower_bound",
                                    "upper_bound") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.Srgb, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.Srgb, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.lower_bound.is_set or
                        self.upper_bound.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lower_bound.yfilter != YFilter.not_set or
                        self.upper_bound.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "srgb" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lower_bound.is_set or self.lower_bound.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lower_bound.get_name_leafdata())
                    if (self.upper_bound.is_set or self.upper_bound.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.upper_bound.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lower-bound" or name == "upper-bound"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lower-bound"):
                        self.lower_bound = value
                        self.lower_bound.value_namespace = name_space
                        self.lower_bound.value_namespace_prefix = name_space_prefix
                    if(value_path == "upper-bound"):
                        self.upper_bound = value
                        self.upper_bound.value_namespace = name_space
                        self.upper_bound.value_namespace_prefix = name_space_prefix


            class LspGenerationIntervals(Entity):
                """
                LSP generation\-interval configuration
                
                .. attribute:: lsp_generation_interval
                
                	LSP generation scheduling parameters
                	**type**\: list of    :py:class:`LspGenerationInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspGenerationIntervals.LspGenerationInterval>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspGenerationIntervals, self).__init__()

                    self.yang_name = "lsp-generation-intervals"
                    self.yang_parent_name = "instance"

                    self.lsp_generation_interval = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspGenerationIntervals, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspGenerationIntervals, self).__setattr__(name, value)


                class LspGenerationInterval(Entity):
                    """
                    LSP generation scheduling parameters
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: initial_wait
                    
                    	Initial wait before generating local LSP in milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..120000
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum_wait
                    
                    	Maximum wait before generating local LSP in milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..120000
                    
                    	**units**\: millisecond
                    
                    .. attribute:: secondary_wait
                    
                    	Secondary wait before generating local LSP in milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..120000
                    
                    	**units**\: millisecond
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspGenerationIntervals.LspGenerationInterval, self).__init__()

                        self.yang_name = "lsp-generation-interval"
                        self.yang_parent_name = "lsp-generation-intervals"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.initial_wait = YLeaf(YType.uint32, "initial-wait")

                        self.maximum_wait = YLeaf(YType.uint32, "maximum-wait")

                        self.secondary_wait = YLeaf(YType.uint32, "secondary-wait")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "initial_wait",
                                        "maximum_wait",
                                        "secondary_wait") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspGenerationIntervals.LspGenerationInterval, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspGenerationIntervals.LspGenerationInterval, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.initial_wait.is_set or
                            self.maximum_wait.is_set or
                            self.secondary_wait.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.initial_wait.yfilter != YFilter.not_set or
                            self.maximum_wait.yfilter != YFilter.not_set or
                            self.secondary_wait.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-generation-interval" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.initial_wait.is_set or self.initial_wait.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.initial_wait.get_name_leafdata())
                        if (self.maximum_wait.is_set or self.maximum_wait.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_wait.get_name_leafdata())
                        if (self.secondary_wait.is_set or self.secondary_wait.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.secondary_wait.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "initial-wait" or name == "maximum-wait" or name == "secondary-wait"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "initial-wait"):
                            self.initial_wait = value
                            self.initial_wait.value_namespace = name_space
                            self.initial_wait.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum-wait"):
                            self.maximum_wait = value
                            self.maximum_wait.value_namespace = name_space
                            self.maximum_wait.value_namespace_prefix = name_space_prefix
                        if(value_path == "secondary-wait"):
                            self.secondary_wait = value
                            self.secondary_wait.value_namespace = name_space
                            self.secondary_wait.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_generation_interval:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_generation_interval:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-generation-intervals" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-generation-interval"):
                        for c in self.lsp_generation_interval:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspGenerationIntervals.LspGenerationInterval()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_generation_interval.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-generation-interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LspArrivalTimes(Entity):
                """
                LSP arrival time configuration
                
                .. attribute:: lsp_arrival_time
                
                	Minimum LSP arrival time
                	**type**\: list of    :py:class:`LspArrivalTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspArrivalTimes.LspArrivalTime>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspArrivalTimes, self).__init__()

                    self.yang_name = "lsp-arrival-times"
                    self.yang_parent_name = "instance"

                    self.lsp_arrival_time = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspArrivalTimes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspArrivalTimes, self).__setattr__(name, value)


                class LspArrivalTime(Entity):
                    """
                    Minimum LSP arrival time
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: initial_wait
                    
                    	Initial delay expected to take since last LSPin milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..120000
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum_wait
                    
                    	Maximum delay expected to take since last LSPin milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..120000
                    
                    	**units**\: millisecond
                    
                    .. attribute:: secondary_wait
                    
                    	Secondary delay expected to take since last LSPin milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..120000
                    
                    	**units**\: millisecond
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspArrivalTimes.LspArrivalTime, self).__init__()

                        self.yang_name = "lsp-arrival-time"
                        self.yang_parent_name = "lsp-arrival-times"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.initial_wait = YLeaf(YType.uint32, "initial-wait")

                        self.maximum_wait = YLeaf(YType.uint32, "maximum-wait")

                        self.secondary_wait = YLeaf(YType.uint32, "secondary-wait")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "initial_wait",
                                        "maximum_wait",
                                        "secondary_wait") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspArrivalTimes.LspArrivalTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspArrivalTimes.LspArrivalTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.initial_wait.is_set or
                            self.maximum_wait.is_set or
                            self.secondary_wait.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.initial_wait.yfilter != YFilter.not_set or
                            self.maximum_wait.yfilter != YFilter.not_set or
                            self.secondary_wait.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-arrival-time" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.initial_wait.is_set or self.initial_wait.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.initial_wait.get_name_leafdata())
                        if (self.maximum_wait.is_set or self.maximum_wait.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum_wait.get_name_leafdata())
                        if (self.secondary_wait.is_set or self.secondary_wait.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.secondary_wait.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "initial-wait" or name == "maximum-wait" or name == "secondary-wait"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "initial-wait"):
                            self.initial_wait = value
                            self.initial_wait.value_namespace = name_space
                            self.initial_wait.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum-wait"):
                            self.maximum_wait = value
                            self.maximum_wait.value_namespace = name_space
                            self.maximum_wait.value_namespace_prefix = name_space_prefix
                        if(value_path == "secondary-wait"):
                            self.secondary_wait = value
                            self.secondary_wait.value_namespace = name_space
                            self.secondary_wait.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_arrival_time:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_arrival_time:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-arrival-times" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-arrival-time"):
                        for c in self.lsp_arrival_time:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspArrivalTimes.LspArrivalTime()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_arrival_time.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-arrival-time"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class TraceBufferSize(Entity):
                """
                Trace buffer size configuration
                
                .. attribute:: detailed
                
                	Buffer size for detailed traces
                	**type**\:  int
                
                	**range:** 1..1000000
                
                .. attribute:: hello
                
                	Buffer size for hello trace
                	**type**\:  int
                
                	**range:** 1..1000000
                
                .. attribute:: severe
                
                	Buffer size for severe trace
                	**type**\:  int
                
                	**range:** 1..1000000
                
                .. attribute:: standard
                
                	Buffer size for standard traces
                	**type**\:  int
                
                	**range:** 1..1000000
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.TraceBufferSize, self).__init__()

                    self.yang_name = "trace-buffer-size"
                    self.yang_parent_name = "instance"

                    self.detailed = YLeaf(YType.uint32, "detailed")

                    self.hello = YLeaf(YType.uint32, "hello")

                    self.severe = YLeaf(YType.uint32, "severe")

                    self.standard = YLeaf(YType.uint32, "standard")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("detailed",
                                    "hello",
                                    "severe",
                                    "standard") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.TraceBufferSize, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.TraceBufferSize, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.detailed.is_set or
                        self.hello.is_set or
                        self.severe.is_set or
                        self.standard.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.detailed.yfilter != YFilter.not_set or
                        self.hello.yfilter != YFilter.not_set or
                        self.severe.yfilter != YFilter.not_set or
                        self.standard.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "trace-buffer-size" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.detailed.is_set or self.detailed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detailed.get_name_leafdata())
                    if (self.hello.is_set or self.hello.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello.get_name_leafdata())
                    if (self.severe.is_set or self.severe.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.severe.get_name_leafdata())
                    if (self.standard.is_set or self.standard.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standard.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "detailed" or name == "hello" or name == "severe" or name == "standard"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "detailed"):
                        self.detailed = value
                        self.detailed.value_namespace = name_space
                        self.detailed.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello"):
                        self.hello = value
                        self.hello.value_namespace = name_space
                        self.hello.value_namespace_prefix = name_space_prefix
                    if(value_path == "severe"):
                        self.severe = value
                        self.severe.value_namespace = name_space
                        self.severe.value_namespace_prefix = name_space_prefix
                    if(value_path == "standard"):
                        self.standard = value
                        self.standard.value_namespace = name_space
                        self.standard.value_namespace_prefix = name_space_prefix


            class MaxLinkMetrics(Entity):
                """
                Max Link Metric configuration
                
                .. attribute:: max_link_metric
                
                	Max Link Metric
                	**type**\: list of    :py:class:`MaxLinkMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.MaxLinkMetrics.MaxLinkMetric>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.MaxLinkMetrics, self).__init__()

                    self.yang_name = "max-link-metrics"
                    self.yang_parent_name = "instance"

                    self.max_link_metric = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.MaxLinkMetrics, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.MaxLinkMetrics, self).__setattr__(name, value)


                class MaxLinkMetric(Entity):
                    """
                    Max Link Metric
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.MaxLinkMetrics.MaxLinkMetric, self).__init__()

                        self.yang_name = "max-link-metric"
                        self.yang_parent_name = "max-link-metrics"

                        self.level = YLeaf(YType.enumeration, "level")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.MaxLinkMetrics.MaxLinkMetric, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.MaxLinkMetrics.MaxLinkMetric, self).__setattr__(name, value)

                    def has_data(self):
                        return self.level.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "max-link-metric" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.max_link_metric:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.max_link_metric:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "max-link-metrics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "max-link-metric"):
                        for c in self.max_link_metric:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.MaxLinkMetrics.MaxLinkMetric()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.max_link_metric.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "max-link-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AdjacencyStagger(Entity):
                """
                Stagger ISIS adjacency bring up
                
                .. attribute:: initial_nbr
                
                	Adjacency Stagger\: Initial number of neighbors to bring up per area
                	**type**\:  int
                
                	**range:** 2..65000
                
                	**default value**\: 2
                
                .. attribute:: max_nbr
                
                	Adjacency Stagger\: Subsequent simultaneous number of neighbors to bring up
                	**type**\:  int
                
                	**range:** 2..65000
                
                	**default value**\: 64
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.AdjacencyStagger, self).__init__()

                    self.yang_name = "adjacency-stagger"
                    self.yang_parent_name = "instance"
                    self.is_presence_container = True

                    self.initial_nbr = YLeaf(YType.uint32, "initial-nbr")

                    self.max_nbr = YLeaf(YType.uint32, "max-nbr")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("initial_nbr",
                                    "max_nbr") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.AdjacencyStagger, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.AdjacencyStagger, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.initial_nbr.is_set or
                        self.max_nbr.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.initial_nbr.yfilter != YFilter.not_set or
                        self.max_nbr.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "adjacency-stagger" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.initial_nbr.is_set or self.initial_nbr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.initial_nbr.get_name_leafdata())
                    if (self.max_nbr.is_set or self.max_nbr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.max_nbr.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "initial-nbr" or name == "max-nbr"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "initial-nbr"):
                        self.initial_nbr = value
                        self.initial_nbr.value_namespace = name_space
                        self.initial_nbr.value_namespace_prefix = name_space_prefix
                    if(value_path == "max-nbr"):
                        self.max_nbr = value
                        self.max_nbr.value_namespace = name_space
                        self.max_nbr.value_namespace_prefix = name_space_prefix


            class Afs(Entity):
                """
                Per\-address\-family configuration
                
                .. attribute:: af
                
                	Configuration for an IS\-IS address\-family. If a named (non\-default) topology is being created it must be multicast
                	**type**\: list of    :py:class:`Af <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.Afs, self).__init__()

                    self.yang_name = "afs"
                    self.yang_parent_name = "instance"

                    self.af = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.Afs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.Afs, self).__setattr__(name, value)


                class Af(Entity):
                    """
                    Configuration for an IS\-IS address\-family. If
                    a named (non\-default) topology is being
                    created it must be multicast.
                    
                    .. attribute:: af_name  <key>
                    
                    	Address family
                    	**type**\:   :py:class:`IsisAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisAddressFamily>`
                    
                    .. attribute:: saf_name  <key>
                    
                    	Sub address family
                    	**type**\:   :py:class:`IsisSubAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisSubAddressFamily>`
                    
                    .. attribute:: af_data
                    
                    	Data container
                    	**type**\:   :py:class:`AfData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: topology_name
                    
                    	keys\: topology\-name
                    	**type**\: list of    :py:class:`TopologyName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName>`
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.Afs.Af, self).__init__()

                        self.yang_name = "af"
                        self.yang_parent_name = "afs"

                        self.af_name = YLeaf(YType.enumeration, "af-name")

                        self.saf_name = YLeaf(YType.enumeration, "saf-name")

                        self.af_data = None
                        self._children_name_map["af_data"] = "af-data"
                        self._children_yang_names.add("af-data")

                        self.topology_name = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("af_name",
                                        "saf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.Afs.Af, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.Afs.Af, self).__setattr__(name, value)


                    class AfData(Entity):
                        """
                        Data container.
                        
                        .. attribute:: adjacency_check
                        
                        	Suppress check for consistent AF support on received IIHs
                        	**type**\:   :py:class:`IsisAdjCheck <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAdjCheck>`
                        
                        .. attribute:: admin_distances
                        
                        	Per\-route administrative distanceconfiguration
                        	**type**\:   :py:class:`AdminDistances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.AdminDistances>`
                        
                        .. attribute:: advertise_link_attributes
                        
                        	If TRUE, advertise additional link attributes in our LSP
                        	**type**\:  bool
                        
                        .. attribute:: advertise_passive_only
                        
                        	If enabled, advertise prefixes of passive interfaces only
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: apply_weight
                        
                        	Apply weights to UCMP or ECMP only
                        	**type**\:   :py:class:`IsisApplyWeight <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisApplyWeight>`
                        
                        .. attribute:: attached_bit
                        
                        	Set the attached bit in this router's level 1 System LSP
                        	**type**\:   :py:class:`IsisAttachedBit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAttachedBit>`
                        
                        	**default value**\: area
                        
                        .. attribute:: default_admin_distance
                        
                        	Default IS\-IS administrative distance configuration
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        	**default value**\: 115
                        
                        .. attribute:: default_information
                        
                        	Control origination of a default route with the option of using a policy.  If no policy is specified the default route is advertised with zero cost in level 2 only
                        	**type**\:   :py:class:`DefaultInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.DefaultInformation>`
                        
                        .. attribute:: frr_table
                        
                        	Fast\-ReRoute configuration
                        	**type**\:   :py:class:`FrrTable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable>`
                        
                        .. attribute:: ignore_attached_bit
                        
                        	If TRUE, Ignore other routers attached bit
                        	**type**\:  bool
                        
                        .. attribute:: ispf
                        
                        	ISPF configuration
                        	**type**\:   :py:class:`Ispf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Ispf>`
                        
                        .. attribute:: max_redist_prefixes
                        
                        	Maximum number of redistributed prefixesconfiguration
                        	**type**\:   :py:class:`MaxRedistPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes>`
                        
                        .. attribute:: maximum_paths
                        
                        	Maximum number of active parallel paths per route
                        	**type**\:  int
                        
                        	**range:** 1..64
                        
                        .. attribute:: metric_styles
                        
                        	Metric\-style configuration
                        	**type**\:   :py:class:`MetricStyles <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.MetricStyles>`
                        
                        .. attribute:: metrics
                        
                        	Metric configuration
                        	**type**\:   :py:class:`Metrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Metrics>`
                        
                        .. attribute:: micro_loop_avoidance
                        
                        	Micro Loop Avoidance configuration
                        	**type**\:   :py:class:`MicroLoopAvoidance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.MicroLoopAvoidance>`
                        
                        .. attribute:: monitor_convergence
                        
                        	Enable convergence monitoring
                        	**type**\:   :py:class:`MonitorConvergence <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.MonitorConvergence>`
                        
                        .. attribute:: mpls
                        
                        	MPLS configuration. MPLS configuration will only be applied for the IPv4\-unicast address\-family
                        	**type**\:   :py:class:`Mpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Mpls>`
                        
                        .. attribute:: mpls_ldp_global
                        
                        	MPLS LDP configuration. MPLS LDP configuration will only be applied for the IPv4\-unicast address\-family
                        	**type**\:   :py:class:`MplsLdpGlobal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.MplsLdpGlobal>`
                        
                        .. attribute:: propagations
                        
                        	Route propagation configuration
                        	**type**\:   :py:class:`Propagations <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Propagations>`
                        
                        .. attribute:: redistributions
                        
                        	Protocol redistribution configuration
                        	**type**\:   :py:class:`Redistributions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Redistributions>`
                        
                        .. attribute:: route_source_first_hop
                        
                        	If TRUE, routes will be installed with the IP address of the first\-hop node as the source instead of the originating node
                        	**type**\:  bool
                        
                        .. attribute:: router_id
                        
                        	Stable IP address for system. Will only be applied for the unicast sub\-address\-family
                        	**type**\:   :py:class:`RouterId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.RouterId>`
                        
                        .. attribute:: segment_routing
                        
                        	Enable Segment Routing configuration
                        	**type**\:   :py:class:`SegmentRouting <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting>`
                        
                        .. attribute:: single_topology
                        
                        	Run IPv6 Unicast using the standard (IPv4 Unicast) topology
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: spf_intervals
                        
                        	SPF\-interval configuration
                        	**type**\:   :py:class:`SpfIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals>`
                        
                        .. attribute:: spf_periodic_intervals
                        
                        	Peoridic SPF configuration
                        	**type**\:   :py:class:`SpfPeriodicIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals>`
                        
                        .. attribute:: spf_prefix_priorities
                        
                        	SPF Prefix Priority configuration
                        	**type**\:   :py:class:`SpfPrefixPriorities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities>`
                        
                        .. attribute:: summary_prefixes
                        
                        	Summary\-prefix configuration
                        	**type**\:   :py:class:`SummaryPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes>`
                        
                        .. attribute:: topology_id
                        
                        	Set the topology ID for a named (non\-default) topology. This object must be set before any other configuration is supplied for a named (non\-default) topology , and must be the last configuration object to be removed. This item should not be supplied for the non\-named default topologies
                        	**type**\:  int
                        
                        	**range:** 6..4095
                        
                        .. attribute:: ucmp
                        
                        	UCMP (UnEqual Cost MultiPath) configuration
                        	**type**\:   :py:class:`Ucmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Ucmp>`
                        
                        .. attribute:: weights
                        
                        	Weight configuration
                        	**type**\:   :py:class:`Weights <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Weights>`
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Afs.Af.AfData, self).__init__()

                            self.yang_name = "af-data"
                            self.yang_parent_name = "af"
                            self.is_presence_container = True

                            self.adjacency_check = YLeaf(YType.enumeration, "adjacency-check")

                            self.advertise_link_attributes = YLeaf(YType.boolean, "advertise-link-attributes")

                            self.advertise_passive_only = YLeaf(YType.empty, "advertise-passive-only")

                            self.apply_weight = YLeaf(YType.enumeration, "apply-weight")

                            self.attached_bit = YLeaf(YType.enumeration, "attached-bit")

                            self.default_admin_distance = YLeaf(YType.uint32, "default-admin-distance")

                            self.ignore_attached_bit = YLeaf(YType.boolean, "ignore-attached-bit")

                            self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                            self.route_source_first_hop = YLeaf(YType.boolean, "route-source-first-hop")

                            self.single_topology = YLeaf(YType.empty, "single-topology")

                            self.topology_id = YLeaf(YType.uint32, "topology-id")

                            self.admin_distances = Isis.Instances.Instance.Afs.Af.AfData.AdminDistances()
                            self.admin_distances.parent = self
                            self._children_name_map["admin_distances"] = "admin-distances"
                            self._children_yang_names.add("admin-distances")

                            self.default_information = Isis.Instances.Instance.Afs.Af.AfData.DefaultInformation()
                            self.default_information.parent = self
                            self._children_name_map["default_information"] = "default-information"
                            self._children_yang_names.add("default-information")

                            self.frr_table = Isis.Instances.Instance.Afs.Af.AfData.FrrTable()
                            self.frr_table.parent = self
                            self._children_name_map["frr_table"] = "frr-table"
                            self._children_yang_names.add("frr-table")

                            self.ispf = Isis.Instances.Instance.Afs.Af.AfData.Ispf()
                            self.ispf.parent = self
                            self._children_name_map["ispf"] = "ispf"
                            self._children_yang_names.add("ispf")

                            self.max_redist_prefixes = Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes()
                            self.max_redist_prefixes.parent = self
                            self._children_name_map["max_redist_prefixes"] = "max-redist-prefixes"
                            self._children_yang_names.add("max-redist-prefixes")

                            self.metric_styles = Isis.Instances.Instance.Afs.Af.AfData.MetricStyles()
                            self.metric_styles.parent = self
                            self._children_name_map["metric_styles"] = "metric-styles"
                            self._children_yang_names.add("metric-styles")

                            self.metrics = Isis.Instances.Instance.Afs.Af.AfData.Metrics()
                            self.metrics.parent = self
                            self._children_name_map["metrics"] = "metrics"
                            self._children_yang_names.add("metrics")

                            self.micro_loop_avoidance = Isis.Instances.Instance.Afs.Af.AfData.MicroLoopAvoidance()
                            self.micro_loop_avoidance.parent = self
                            self._children_name_map["micro_loop_avoidance"] = "micro-loop-avoidance"
                            self._children_yang_names.add("micro-loop-avoidance")

                            self.monitor_convergence = Isis.Instances.Instance.Afs.Af.AfData.MonitorConvergence()
                            self.monitor_convergence.parent = self
                            self._children_name_map["monitor_convergence"] = "monitor-convergence"
                            self._children_yang_names.add("monitor-convergence")

                            self.mpls = Isis.Instances.Instance.Afs.Af.AfData.Mpls()
                            self.mpls.parent = self
                            self._children_name_map["mpls"] = "mpls"
                            self._children_yang_names.add("mpls")

                            self.mpls_ldp_global = Isis.Instances.Instance.Afs.Af.AfData.MplsLdpGlobal()
                            self.mpls_ldp_global.parent = self
                            self._children_name_map["mpls_ldp_global"] = "mpls-ldp-global"
                            self._children_yang_names.add("mpls-ldp-global")

                            self.propagations = Isis.Instances.Instance.Afs.Af.AfData.Propagations()
                            self.propagations.parent = self
                            self._children_name_map["propagations"] = "propagations"
                            self._children_yang_names.add("propagations")

                            self.redistributions = Isis.Instances.Instance.Afs.Af.AfData.Redistributions()
                            self.redistributions.parent = self
                            self._children_name_map["redistributions"] = "redistributions"
                            self._children_yang_names.add("redistributions")

                            self.router_id = Isis.Instances.Instance.Afs.Af.AfData.RouterId()
                            self.router_id.parent = self
                            self._children_name_map["router_id"] = "router-id"
                            self._children_yang_names.add("router-id")

                            self.segment_routing = Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting()
                            self.segment_routing.parent = self
                            self._children_name_map["segment_routing"] = "segment-routing"
                            self._children_yang_names.add("segment-routing")

                            self.spf_intervals = Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals()
                            self.spf_intervals.parent = self
                            self._children_name_map["spf_intervals"] = "spf-intervals"
                            self._children_yang_names.add("spf-intervals")

                            self.spf_periodic_intervals = Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals()
                            self.spf_periodic_intervals.parent = self
                            self._children_name_map["spf_periodic_intervals"] = "spf-periodic-intervals"
                            self._children_yang_names.add("spf-periodic-intervals")

                            self.spf_prefix_priorities = Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities()
                            self.spf_prefix_priorities.parent = self
                            self._children_name_map["spf_prefix_priorities"] = "spf-prefix-priorities"
                            self._children_yang_names.add("spf-prefix-priorities")

                            self.summary_prefixes = Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes()
                            self.summary_prefixes.parent = self
                            self._children_name_map["summary_prefixes"] = "summary-prefixes"
                            self._children_yang_names.add("summary-prefixes")

                            self.ucmp = Isis.Instances.Instance.Afs.Af.AfData.Ucmp()
                            self.ucmp.parent = self
                            self._children_name_map["ucmp"] = "ucmp"
                            self._children_yang_names.add("ucmp")

                            self.weights = Isis.Instances.Instance.Afs.Af.AfData.Weights()
                            self.weights.parent = self
                            self._children_name_map["weights"] = "weights"
                            self._children_yang_names.add("weights")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("adjacency_check",
                                            "advertise_link_attributes",
                                            "advertise_passive_only",
                                            "apply_weight",
                                            "attached_bit",
                                            "default_admin_distance",
                                            "ignore_attached_bit",
                                            "maximum_paths",
                                            "route_source_first_hop",
                                            "single_topology",
                                            "topology_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Afs.Af.AfData, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Afs.Af.AfData, self).__setattr__(name, value)


                        class SegmentRouting(Entity):
                            """
                            Enable Segment Routing configuration
                            
                            .. attribute:: mpls
                            
                            	Prefer segment routing labels over LDP labels
                            	**type**\:   :py:class:`IsisLabelPreference <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisLabelPreference>`
                            
                            .. attribute:: prefix_sid_map
                            
                            	Enable Segment Routing prefix SID map configuration
                            	**type**\:   :py:class:`PrefixSidMap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting.PrefixSidMap>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting, self).__init__()

                                self.yang_name = "segment-routing"
                                self.yang_parent_name = "af-data"

                                self.mpls = YLeaf(YType.enumeration, "mpls")

                                self.prefix_sid_map = Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting.PrefixSidMap()
                                self.prefix_sid_map.parent = self
                                self._children_name_map["prefix_sid_map"] = "prefix-sid-map"
                                self._children_yang_names.add("prefix-sid-map")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mpls") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting, self).__setattr__(name, value)


                            class PrefixSidMap(Entity):
                                """
                                Enable Segment Routing prefix SID map
                                configuration
                                
                                .. attribute:: advertise_local
                                
                                	Enable Segment Routing prefix SID map advertise local
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: receive
                                
                                	If TRUE, remote prefix SID map advertisements will be used. If FALSE, they will not be used
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting.PrefixSidMap, self).__init__()

                                    self.yang_name = "prefix-sid-map"
                                    self.yang_parent_name = "segment-routing"

                                    self.advertise_local = YLeaf(YType.empty, "advertise-local")

                                    self.receive = YLeaf(YType.boolean, "receive")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("advertise_local",
                                                    "receive") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting.PrefixSidMap, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting.PrefixSidMap, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.advertise_local.is_set or
                                        self.receive.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.advertise_local.yfilter != YFilter.not_set or
                                        self.receive.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "prefix-sid-map" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.advertise_local.is_set or self.advertise_local.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.advertise_local.get_name_leafdata())
                                    if (self.receive.is_set or self.receive.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.receive.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "advertise-local" or name == "receive"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "advertise-local"):
                                        self.advertise_local = value
                                        self.advertise_local.value_namespace = name_space
                                        self.advertise_local.value_namespace_prefix = name_space_prefix
                                    if(value_path == "receive"):
                                        self.receive = value
                                        self.receive.value_namespace = name_space
                                        self.receive.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.mpls.is_set or
                                    (self.prefix_sid_map is not None and self.prefix_sid_map.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mpls.yfilter != YFilter.not_set or
                                    (self.prefix_sid_map is not None and self.prefix_sid_map.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "segment-routing" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mpls.is_set or self.mpls.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mpls.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "prefix-sid-map"):
                                    if (self.prefix_sid_map is None):
                                        self.prefix_sid_map = Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting.PrefixSidMap()
                                        self.prefix_sid_map.parent = self
                                        self._children_name_map["prefix_sid_map"] = "prefix-sid-map"
                                    return self.prefix_sid_map

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "prefix-sid-map" or name == "mpls"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mpls"):
                                    self.mpls = value
                                    self.mpls.value_namespace = name_space
                                    self.mpls.value_namespace_prefix = name_space_prefix


                        class MetricStyles(Entity):
                            """
                            Metric\-style configuration
                            
                            .. attribute:: metric_style
                            
                            	Configuration of metric style in LSPs
                            	**type**\: list of    :py:class:`MetricStyle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.MetricStyles.MetricStyle>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.MetricStyles, self).__init__()

                                self.yang_name = "metric-styles"
                                self.yang_parent_name = "af-data"

                                self.metric_style = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.MetricStyles, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.MetricStyles, self).__setattr__(name, value)


                            class MetricStyle(Entity):
                                """
                                Configuration of metric style in LSPs
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: style
                                
                                	Metric Style
                                	**type**\:   :py:class:`IsisMetricStyle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetricStyle>`
                                
                                	**default value**\: old-metric-style
                                
                                .. attribute:: transition_state
                                
                                	Transition state
                                	**type**\:   :py:class:`IsisMetricStyleTransition <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetricStyleTransition>`
                                
                                	**default value**\: disabled
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.MetricStyles.MetricStyle, self).__init__()

                                    self.yang_name = "metric-style"
                                    self.yang_parent_name = "metric-styles"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.style = YLeaf(YType.enumeration, "style")

                                    self.transition_state = YLeaf(YType.enumeration, "transition-state")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "style",
                                                    "transition_state") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.MetricStyles.MetricStyle, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.MetricStyles.MetricStyle, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.style.is_set or
                                        self.transition_state.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.style.yfilter != YFilter.not_set or
                                        self.transition_state.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "metric-style" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.style.is_set or self.style.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.style.get_name_leafdata())
                                    if (self.transition_state.is_set or self.transition_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transition_state.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "style" or name == "transition-state"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "style"):
                                        self.style = value
                                        self.style.value_namespace = name_space
                                        self.style.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transition-state"):
                                        self.transition_state = value
                                        self.transition_state.value_namespace = name_space
                                        self.transition_state.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.metric_style:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.metric_style:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "metric-styles" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "metric-style"):
                                    for c in self.metric_style:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.MetricStyles.MetricStyle()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.metric_style.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "metric-style"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class FrrTable(Entity):
                            """
                            Fast\-ReRoute configuration
                            
                            .. attribute:: frr_load_sharings
                            
                            	Load share prefixes across multiple backups
                            	**type**\:   :py:class:`FrrLoadSharings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings>`
                            
                            .. attribute:: frr_remote_lfa_prefixes
                            
                            	FRR remote LFA prefix list filter configuration
                            	**type**\:   :py:class:`FrrRemoteLfaPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes>`
                            
                            .. attribute:: frr_tiebreakers
                            
                            	FRR tiebreakers configuration
                            	**type**\:   :py:class:`FrrTiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers>`
                            
                            .. attribute:: frr_use_cand_onlies
                            
                            	FRR use candidate only configuration
                            	**type**\:   :py:class:`FrrUseCandOnlies <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies>`
                            
                            .. attribute:: priority_limits
                            
                            	FRR prefix\-limit configuration
                            	**type**\:   :py:class:`PriorityLimits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable, self).__init__()

                                self.yang_name = "frr-table"
                                self.yang_parent_name = "af-data"

                                self.frr_load_sharings = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings()
                                self.frr_load_sharings.parent = self
                                self._children_name_map["frr_load_sharings"] = "frr-load-sharings"
                                self._children_yang_names.add("frr-load-sharings")

                                self.frr_remote_lfa_prefixes = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes()
                                self.frr_remote_lfa_prefixes.parent = self
                                self._children_name_map["frr_remote_lfa_prefixes"] = "frr-remote-lfa-prefixes"
                                self._children_yang_names.add("frr-remote-lfa-prefixes")

                                self.frr_tiebreakers = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers()
                                self.frr_tiebreakers.parent = self
                                self._children_name_map["frr_tiebreakers"] = "frr-tiebreakers"
                                self._children_yang_names.add("frr-tiebreakers")

                                self.frr_use_cand_onlies = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies()
                                self.frr_use_cand_onlies.parent = self
                                self._children_name_map["frr_use_cand_onlies"] = "frr-use-cand-onlies"
                                self._children_yang_names.add("frr-use-cand-onlies")

                                self.priority_limits = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits()
                                self.priority_limits.parent = self
                                self._children_name_map["priority_limits"] = "priority-limits"
                                self._children_yang_names.add("priority-limits")


                            class FrrLoadSharings(Entity):
                                """
                                Load share prefixes across multiple
                                backups
                                
                                .. attribute:: frr_load_sharing
                                
                                	Disable load sharing
                                	**type**\: list of    :py:class:`FrrLoadSharing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings.FrrLoadSharing>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings, self).__init__()

                                    self.yang_name = "frr-load-sharings"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_load_sharing = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings, self).__setattr__(name, value)


                                class FrrLoadSharing(Entity):
                                    """
                                    Disable load sharing
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: load_sharing
                                    
                                    	Load sharing
                                    	**type**\:   :py:class:`IsisfrrLoadSharing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisfrrLoadSharing>`
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings.FrrLoadSharing, self).__init__()

                                        self.yang_name = "frr-load-sharing"
                                        self.yang_parent_name = "frr-load-sharings"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.load_sharing = YLeaf(YType.enumeration, "load-sharing")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "load_sharing") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings.FrrLoadSharing, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings.FrrLoadSharing, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.load_sharing.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.load_sharing.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-load-sharing" + "[level='" + self.level.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.load_sharing.is_set or self.load_sharing.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.load_sharing.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "load-sharing"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "load-sharing"):
                                            self.load_sharing = value
                                            self.load_sharing.value_namespace = name_space
                                            self.load_sharing.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_load_sharing:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_load_sharing:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-load-sharings" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-load-sharing"):
                                        for c in self.frr_load_sharing:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings.FrrLoadSharing()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_load_sharing.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-load-sharing"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class PriorityLimits(Entity):
                                """
                                FRR prefix\-limit configuration
                                
                                .. attribute:: priority_limit
                                
                                	Limit backup computation upto the prefix priority
                                	**type**\: list of    :py:class:`PriorityLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits.PriorityLimit>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits, self).__init__()

                                    self.yang_name = "priority-limits"
                                    self.yang_parent_name = "frr-table"

                                    self.priority_limit = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits, self).__setattr__(name, value)


                                class PriorityLimit(Entity):
                                    """
                                    Limit backup computation upto the prefix
                                    priority
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: frr_type  <key>
                                    
                                    	Computation Type
                                    	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                    
                                    .. attribute:: priority
                                    
                                    	Compute for all prefixes upto the specified priority
                                    	**type**\:   :py:class:`IsisPrefixPriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisPrefixPriority>`
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits.PriorityLimit, self).__init__()

                                        self.yang_name = "priority-limit"
                                        self.yang_parent_name = "priority-limits"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                        self.priority = YLeaf(YType.enumeration, "priority")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "frr_type",
                                                        "priority") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits.PriorityLimit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits.PriorityLimit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.frr_type.is_set or
                                            self.priority.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.frr_type.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "priority-limit" + "[level='" + self.level.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.frr_type.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "frr-type" or name == "priority"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "frr-type"):
                                            self.frr_type = value
                                            self.frr_type.value_namespace = name_space
                                            self.frr_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.priority_limit:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.priority_limit:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-limits" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "priority-limit"):
                                        for c in self.priority_limit:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits.PriorityLimit()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.priority_limit.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "priority-limit"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class FrrRemoteLfaPrefixes(Entity):
                                """
                                FRR remote LFA prefix list filter
                                configuration
                                
                                .. attribute:: frr_remote_lfa_prefix
                                
                                	Filter remote LFA router IDs using prefix\-list
                                	**type**\: list of    :py:class:`FrrRemoteLfaPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes, self).__init__()

                                    self.yang_name = "frr-remote-lfa-prefixes"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_remote_lfa_prefix = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes, self).__setattr__(name, value)


                                class FrrRemoteLfaPrefix(Entity):
                                    """
                                    Filter remote LFA router IDs using
                                    prefix\-list
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: prefix_list_name
                                    
                                    	Name of the prefix list
                                    	**type**\:  str
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix, self).__init__()

                                        self.yang_name = "frr-remote-lfa-prefix"
                                        self.yang_parent_name = "frr-remote-lfa-prefixes"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.prefix_list_name = YLeaf(YType.str, "prefix-list-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "prefix_list_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.prefix_list_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.prefix_list_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-remote-lfa-prefix" + "[level='" + self.level.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.prefix_list_name.is_set or self.prefix_list_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_list_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "prefix-list-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-list-name"):
                                            self.prefix_list_name = value
                                            self.prefix_list_name.value_namespace = name_space
                                            self.prefix_list_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_remote_lfa_prefix:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_remote_lfa_prefix:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-remote-lfa-prefixes" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-remote-lfa-prefix"):
                                        for c in self.frr_remote_lfa_prefix:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_remote_lfa_prefix.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-remote-lfa-prefix"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class FrrTiebreakers(Entity):
                                """
                                FRR tiebreakers configuration
                                
                                .. attribute:: frr_tiebreaker
                                
                                	Configure tiebreaker for multiple backups
                                	**type**\: list of    :py:class:`FrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers.FrrTiebreaker>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers, self).__init__()

                                    self.yang_name = "frr-tiebreakers"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_tiebreaker = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers, self).__setattr__(name, value)


                                class FrrTiebreaker(Entity):
                                    """
                                    Configure tiebreaker for multiple backups
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: tiebreaker  <key>
                                    
                                    	Tiebreaker for which configuration applies
                                    	**type**\:   :py:class:`IsisfrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisfrrTiebreaker>`
                                    
                                    .. attribute:: index
                                    
                                    	Preference order among tiebreakers
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers.FrrTiebreaker, self).__init__()

                                        self.yang_name = "frr-tiebreaker"
                                        self.yang_parent_name = "frr-tiebreakers"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.tiebreaker = YLeaf(YType.enumeration, "tiebreaker")

                                        self.index = YLeaf(YType.uint32, "index")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "tiebreaker",
                                                        "index") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers.FrrTiebreaker, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers.FrrTiebreaker, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.tiebreaker.is_set or
                                            self.index.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.tiebreaker.yfilter != YFilter.not_set or
                                            self.index.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-tiebreaker" + "[level='" + self.level.get() + "']" + "[tiebreaker='" + self.tiebreaker.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.tiebreaker.is_set or self.tiebreaker.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tiebreaker.get_name_leafdata())
                                        if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.index.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "tiebreaker" or name == "index"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tiebreaker"):
                                            self.tiebreaker = value
                                            self.tiebreaker.value_namespace = name_space
                                            self.tiebreaker.value_namespace_prefix = name_space_prefix
                                        if(value_path == "index"):
                                            self.index = value
                                            self.index.value_namespace = name_space
                                            self.index.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_tiebreaker:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_tiebreaker:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-tiebreakers" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-tiebreaker"):
                                        for c in self.frr_tiebreaker:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers.FrrTiebreaker()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_tiebreaker.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-tiebreaker"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class FrrUseCandOnlies(Entity):
                                """
                                FRR use candidate only configuration
                                
                                .. attribute:: frr_use_cand_only
                                
                                	Configure use candidate only to exclude interfaces as backup
                                	**type**\: list of    :py:class:`FrrUseCandOnly <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies.FrrUseCandOnly>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies, self).__init__()

                                    self.yang_name = "frr-use-cand-onlies"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_use_cand_only = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies, self).__setattr__(name, value)


                                class FrrUseCandOnly(Entity):
                                    """
                                    Configure use candidate only to exclude
                                    interfaces as backup
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: frr_type  <key>
                                    
                                    	Computation Type
                                    	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies.FrrUseCandOnly, self).__init__()

                                        self.yang_name = "frr-use-cand-only"
                                        self.yang_parent_name = "frr-use-cand-onlies"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "frr_type") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies.FrrUseCandOnly, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies.FrrUseCandOnly, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.frr_type.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.frr_type.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-use-cand-only" + "[level='" + self.level.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.frr_type.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "frr-type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "frr-type"):
                                            self.frr_type = value
                                            self.frr_type.value_namespace = name_space
                                            self.frr_type.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_use_cand_only:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_use_cand_only:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-use-cand-onlies" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-use-cand-only"):
                                        for c in self.frr_use_cand_only:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies.FrrUseCandOnly()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_use_cand_only.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-use-cand-only"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    (self.frr_load_sharings is not None and self.frr_load_sharings.has_data()) or
                                    (self.frr_remote_lfa_prefixes is not None and self.frr_remote_lfa_prefixes.has_data()) or
                                    (self.frr_tiebreakers is not None and self.frr_tiebreakers.has_data()) or
                                    (self.frr_use_cand_onlies is not None and self.frr_use_cand_onlies.has_data()) or
                                    (self.priority_limits is not None and self.priority_limits.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.frr_load_sharings is not None and self.frr_load_sharings.has_operation()) or
                                    (self.frr_remote_lfa_prefixes is not None and self.frr_remote_lfa_prefixes.has_operation()) or
                                    (self.frr_tiebreakers is not None and self.frr_tiebreakers.has_operation()) or
                                    (self.frr_use_cand_onlies is not None and self.frr_use_cand_onlies.has_operation()) or
                                    (self.priority_limits is not None and self.priority_limits.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "frr-table" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "frr-load-sharings"):
                                    if (self.frr_load_sharings is None):
                                        self.frr_load_sharings = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrLoadSharings()
                                        self.frr_load_sharings.parent = self
                                        self._children_name_map["frr_load_sharings"] = "frr-load-sharings"
                                    return self.frr_load_sharings

                                if (child_yang_name == "frr-remote-lfa-prefixes"):
                                    if (self.frr_remote_lfa_prefixes is None):
                                        self.frr_remote_lfa_prefixes = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrRemoteLfaPrefixes()
                                        self.frr_remote_lfa_prefixes.parent = self
                                        self._children_name_map["frr_remote_lfa_prefixes"] = "frr-remote-lfa-prefixes"
                                    return self.frr_remote_lfa_prefixes

                                if (child_yang_name == "frr-tiebreakers"):
                                    if (self.frr_tiebreakers is None):
                                        self.frr_tiebreakers = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrTiebreakers()
                                        self.frr_tiebreakers.parent = self
                                        self._children_name_map["frr_tiebreakers"] = "frr-tiebreakers"
                                    return self.frr_tiebreakers

                                if (child_yang_name == "frr-use-cand-onlies"):
                                    if (self.frr_use_cand_onlies is None):
                                        self.frr_use_cand_onlies = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.FrrUseCandOnlies()
                                        self.frr_use_cand_onlies.parent = self
                                        self._children_name_map["frr_use_cand_onlies"] = "frr-use-cand-onlies"
                                    return self.frr_use_cand_onlies

                                if (child_yang_name == "priority-limits"):
                                    if (self.priority_limits is None):
                                        self.priority_limits = Isis.Instances.Instance.Afs.Af.AfData.FrrTable.PriorityLimits()
                                        self.priority_limits.parent = self
                                        self._children_name_map["priority_limits"] = "priority-limits"
                                    return self.priority_limits

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "frr-load-sharings" or name == "frr-remote-lfa-prefixes" or name == "frr-tiebreakers" or name == "frr-use-cand-onlies" or name == "priority-limits"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class RouterId(Entity):
                            """
                            Stable IP address for system. Will only be
                            applied for the unicast sub\-address\-family.
                            
                            .. attribute:: address
                            
                            	IPv4/IPv6 address to be used as a router ID. Precisely one of Address and Interface must be specified
                            	**type**\:  str
                            
                            .. attribute:: interface_name
                            
                            	Interface with designated stable IP address to be used as a router ID. This must be a Loopback interface. Precisely one of Address and Interface must be specified
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.RouterId, self).__init__()

                                self.yang_name = "router-id"
                                self.yang_parent_name = "af-data"

                                self.address = YLeaf(YType.str, "address")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("address",
                                                "interface_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.RouterId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.RouterId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.address.is_set or
                                    self.interface_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "router-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "address" or name == "interface-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix


                        class SpfPrefixPriorities(Entity):
                            """
                            SPF Prefix Priority configuration
                            
                            .. attribute:: spf_prefix_priority
                            
                            	Determine SPF priority for prefixes
                            	**type**\: list of    :py:class:`SpfPrefixPriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities.SpfPrefixPriority>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities, self).__init__()

                                self.yang_name = "spf-prefix-priorities"
                                self.yang_parent_name = "af-data"

                                self.spf_prefix_priority = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities, self).__setattr__(name, value)


                            class SpfPrefixPriority(Entity):
                                """
                                Determine SPF priority for prefixes
                                
                                .. attribute:: level  <key>
                                
                                	SPF Level for prefix prioritization
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: prefix_priority_type  <key>
                                
                                	SPF Priority to assign matching prefixes
                                	**type**\:   :py:class:`IsisPrefixPriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisPrefixPriority>`
                                
                                .. attribute:: access_list_name
                                
                                	Access List to determine prefixes for this priority
                                	**type**\:  str
                                
                                .. attribute:: admin_tag
                                
                                	Tag value to determine prefixes for this priority
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities.SpfPrefixPriority, self).__init__()

                                    self.yang_name = "spf-prefix-priority"
                                    self.yang_parent_name = "spf-prefix-priorities"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.prefix_priority_type = YLeaf(YType.enumeration, "prefix-priority-type")

                                    self.access_list_name = YLeaf(YType.str, "access-list-name")

                                    self.admin_tag = YLeaf(YType.uint32, "admin-tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "prefix_priority_type",
                                                    "access_list_name",
                                                    "admin_tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities.SpfPrefixPriority, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities.SpfPrefixPriority, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.prefix_priority_type.is_set or
                                        self.access_list_name.is_set or
                                        self.admin_tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.prefix_priority_type.yfilter != YFilter.not_set or
                                        self.access_list_name.yfilter != YFilter.not_set or
                                        self.admin_tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "spf-prefix-priority" + "[level='" + self.level.get() + "']" + "[prefix-priority-type='" + self.prefix_priority_type.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.prefix_priority_type.is_set or self.prefix_priority_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_priority_type.get_name_leafdata())
                                    if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.access_list_name.get_name_leafdata())
                                    if (self.admin_tag.is_set or self.admin_tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.admin_tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "prefix-priority-type" or name == "access-list-name" or name == "admin-tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-priority-type"):
                                        self.prefix_priority_type = value
                                        self.prefix_priority_type.value_namespace = name_space
                                        self.prefix_priority_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "access-list-name"):
                                        self.access_list_name = value
                                        self.access_list_name.value_namespace = name_space
                                        self.access_list_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "admin-tag"):
                                        self.admin_tag = value
                                        self.admin_tag.value_namespace = name_space
                                        self.admin_tag.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.spf_prefix_priority:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.spf_prefix_priority:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-prefix-priorities" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "spf-prefix-priority"):
                                    for c in self.spf_prefix_priority:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities.SpfPrefixPriority()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.spf_prefix_priority.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "spf-prefix-priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class SummaryPrefixes(Entity):
                            """
                            Summary\-prefix configuration
                            
                            .. attribute:: summary_prefix
                            
                            	Configure IP address prefixes to advertise
                            	**type**\: list of    :py:class:`SummaryPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes.SummaryPrefix>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes, self).__init__()

                                self.yang_name = "summary-prefixes"
                                self.yang_parent_name = "af-data"

                                self.summary_prefix = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes, self).__setattr__(name, value)


                            class SummaryPrefix(Entity):
                                """
                                Configure IP address prefixes to advertise
                                
                                .. attribute:: address_prefix  <key>
                                
                                	IP summary address prefix
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                
                                
                                ----
                                .. attribute:: level
                                
                                	Level in which to summarize routes
                                	**type**\:  int
                                
                                	**range:** 1..2
                                
                                .. attribute:: tag
                                
                                	The tag value
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes.SummaryPrefix, self).__init__()

                                    self.yang_name = "summary-prefix"
                                    self.yang_parent_name = "summary-prefixes"

                                    self.address_prefix = YLeaf(YType.str, "address-prefix")

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.tag = YLeaf(YType.uint32, "tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address_prefix",
                                                    "level",
                                                    "tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address_prefix.is_set or
                                        self.level.is_set or
                                        self.tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address_prefix.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "summary-prefix" + "[address-prefix='" + self.address_prefix.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address_prefix.is_set or self.address_prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address_prefix.get_name_leafdata())
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address-prefix" or name == "level" or name == "tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address-prefix"):
                                        self.address_prefix = value
                                        self.address_prefix.value_namespace = name_space
                                        self.address_prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag"):
                                        self.tag = value
                                        self.tag.value_namespace = name_space
                                        self.tag.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.summary_prefix:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.summary_prefix:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "summary-prefixes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "summary-prefix"):
                                    for c in self.summary_prefix:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes.SummaryPrefix()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.summary_prefix.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "summary-prefix"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MicroLoopAvoidance(Entity):
                            """
                            Micro Loop Avoidance configuration
                            
                            .. attribute:: enable
                            
                            	MicroLoop avoidance enable configuration
                            	**type**\:   :py:class:`IsisMicroLoopAvoidance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMicroLoopAvoidance>`
                            
                            	**default value**\: micro-loop-avoidance-all
                            
                            .. attribute:: rib_update_delay
                            
                            	Value of delay in msecs in updating RIB
                            	**type**\:  int
                            
                            	**range:** 1000..65535
                            
                            	**units**\: millisecond
                            
                            	**default value**\: 5000
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.MicroLoopAvoidance, self).__init__()

                                self.yang_name = "micro-loop-avoidance"
                                self.yang_parent_name = "af-data"

                                self.enable = YLeaf(YType.enumeration, "enable")

                                self.rib_update_delay = YLeaf(YType.uint32, "rib-update-delay")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "rib_update_delay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.MicroLoopAvoidance, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.MicroLoopAvoidance, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.rib_update_delay.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.rib_update_delay.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "micro-loop-avoidance" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.rib_update_delay.is_set or self.rib_update_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rib_update_delay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "rib-update-delay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "rib-update-delay"):
                                    self.rib_update_delay = value
                                    self.rib_update_delay.value_namespace = name_space
                                    self.rib_update_delay.value_namespace_prefix = name_space_prefix


                        class Ucmp(Entity):
                            """
                            UCMP (UnEqual Cost MultiPath) configuration
                            
                            .. attribute:: delay_interval
                            
                            	Delay in msecs between primary SPF and UCMP computation
                            	**type**\:  int
                            
                            	**range:** 100..65535
                            
                            	**units**\: millisecond
                            
                            	**default value**\: 100
                            
                            .. attribute:: enable
                            
                            	UCMP feature enable configuration
                            	**type**\:   :py:class:`Enable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Ucmp.Enable>`
                            
                            .. attribute:: exclude_interfaces
                            
                            	Interfaces excluded from UCMP path computation
                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp, self).__init__()

                                self.yang_name = "ucmp"
                                self.yang_parent_name = "af-data"

                                self.delay_interval = YLeaf(YType.uint32, "delay-interval")

                                self.enable = Isis.Instances.Instance.Afs.Af.AfData.Ucmp.Enable()
                                self.enable.parent = self
                                self._children_name_map["enable"] = "enable"
                                self._children_yang_names.add("enable")

                                self.exclude_interfaces = Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces()
                                self.exclude_interfaces.parent = self
                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                self._children_yang_names.add("exclude-interfaces")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("delay_interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp, self).__setattr__(name, value)


                            class Enable(Entity):
                                """
                                UCMP feature enable configuration
                                
                                .. attribute:: prefix_list_name
                                
                                	Name of the Prefix List
                                	**type**\:  str
                                
                                .. attribute:: variance
                                
                                	Value of variance
                                	**type**\:  int
                                
                                	**range:** 101..10000
                                
                                	**default value**\: 200
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.Enable, self).__init__()

                                    self.yang_name = "enable"
                                    self.yang_parent_name = "ucmp"

                                    self.prefix_list_name = YLeaf(YType.str, "prefix-list-name")

                                    self.variance = YLeaf(YType.uint32, "variance")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix_list_name",
                                                    "variance") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.Enable, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.Enable, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.prefix_list_name.is_set or
                                        self.variance.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix_list_name.yfilter != YFilter.not_set or
                                        self.variance.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "enable" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix_list_name.is_set or self.prefix_list_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_list_name.get_name_leafdata())
                                    if (self.variance.is_set or self.variance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.variance.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix-list-name" or name == "variance"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix-list-name"):
                                        self.prefix_list_name = value
                                        self.prefix_list_name.value_namespace = name_space
                                        self.prefix_list_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "variance"):
                                        self.variance = value
                                        self.variance.value_namespace = name_space
                                        self.variance.value_namespace_prefix = name_space_prefix


                            class ExcludeInterfaces(Entity):
                                """
                                Interfaces excluded from UCMP path
                                computation
                                
                                .. attribute:: exclude_interface
                                
                                	Exclude this interface from UCMP path computation
                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces.ExcludeInterface>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces, self).__init__()

                                    self.yang_name = "exclude-interfaces"
                                    self.yang_parent_name = "ucmp"

                                    self.exclude_interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces, self).__setattr__(name, value)


                                class ExcludeInterface(Entity):
                                    """
                                    Exclude this interface from UCMP path
                                    computation
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Name of the interface to be excluded
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                        self.yang_name = "exclude-interface"
                                        self.yang_parent_name = "exclude-interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.interface_name.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.exclude_interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.exclude_interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exclude-interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "exclude-interface"):
                                        for c in self.exclude_interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces.ExcludeInterface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.exclude_interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.delay_interval.is_set or
                                    (self.enable is not None and self.enable.has_data()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.delay_interval.yfilter != YFilter.not_set or
                                    (self.enable is not None and self.enable.has_operation()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ucmp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.delay_interval.is_set or self.delay_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay_interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "enable"):
                                    if (self.enable is None):
                                        self.enable = Isis.Instances.Instance.Afs.Af.AfData.Ucmp.Enable()
                                        self.enable.parent = self
                                        self._children_name_map["enable"] = "enable"
                                    return self.enable

                                if (child_yang_name == "exclude-interfaces"):
                                    if (self.exclude_interfaces is None):
                                        self.exclude_interfaces = Isis.Instances.Instance.Afs.Af.AfData.Ucmp.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                    return self.exclude_interfaces

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "exclude-interfaces" or name == "delay-interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "delay-interval"):
                                    self.delay_interval = value
                                    self.delay_interval.value_namespace = name_space
                                    self.delay_interval.value_namespace_prefix = name_space_prefix


                        class MaxRedistPrefixes(Entity):
                            """
                            Maximum number of redistributed
                            prefixesconfiguration
                            
                            .. attribute:: max_redist_prefix
                            
                            	An upper limit on the number of redistributed prefixes which may be included in the local system's LSP
                            	**type**\: list of    :py:class:`MaxRedistPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes.MaxRedistPrefix>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes, self).__init__()

                                self.yang_name = "max-redist-prefixes"
                                self.yang_parent_name = "af-data"

                                self.max_redist_prefix = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes, self).__setattr__(name, value)


                            class MaxRedistPrefix(Entity):
                                """
                                An upper limit on the number of
                                redistributed prefixes which may be
                                included in the local system's LSP
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: prefix_limit
                                
                                	Max number of prefixes
                                	**type**\:  int
                                
                                	**range:** 1..28000
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes.MaxRedistPrefix, self).__init__()

                                    self.yang_name = "max-redist-prefix"
                                    self.yang_parent_name = "max-redist-prefixes"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.prefix_limit = YLeaf(YType.uint32, "prefix-limit")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "prefix_limit") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes.MaxRedistPrefix, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes.MaxRedistPrefix, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.prefix_limit.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.prefix_limit.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "max-redist-prefix" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.prefix_limit.is_set or self.prefix_limit.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_limit.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "prefix-limit"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-limit"):
                                        self.prefix_limit = value
                                        self.prefix_limit.value_namespace = name_space
                                        self.prefix_limit.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.max_redist_prefix:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.max_redist_prefix:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "max-redist-prefixes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "max-redist-prefix"):
                                    for c in self.max_redist_prefix:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes.MaxRedistPrefix()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.max_redist_prefix.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-redist-prefix"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Propagations(Entity):
                            """
                            Route propagation configuration
                            
                            .. attribute:: propagation
                            
                            	Propagate routes between IS\-IS levels
                            	**type**\: list of    :py:class:`Propagation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Propagations.Propagation>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.Propagations, self).__init__()

                                self.yang_name = "propagations"
                                self.yang_parent_name = "af-data"

                                self.propagation = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Propagations, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Propagations, self).__setattr__(name, value)


                            class Propagation(Entity):
                                """
                                Propagate routes between IS\-IS levels
                                
                                .. attribute:: source_level  <key>
                                
                                	Source level for routes
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: destination_level  <key>
                                
                                	Destination level for routes.  Must differ from SourceLevel
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: route_policy_name
                                
                                	Route policy limiting routes to be propagated
                                	**type**\:  str
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Propagations.Propagation, self).__init__()

                                    self.yang_name = "propagation"
                                    self.yang_parent_name = "propagations"

                                    self.source_level = YLeaf(YType.enumeration, "source-level")

                                    self.destination_level = YLeaf(YType.enumeration, "destination-level")

                                    self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("source_level",
                                                    "destination_level",
                                                    "route_policy_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Propagations.Propagation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Propagations.Propagation, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.source_level.is_set or
                                        self.destination_level.is_set or
                                        self.route_policy_name.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.source_level.yfilter != YFilter.not_set or
                                        self.destination_level.yfilter != YFilter.not_set or
                                        self.route_policy_name.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "propagation" + "[source-level='" + self.source_level.get() + "']" + "[destination-level='" + self.destination_level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.source_level.is_set or self.source_level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source_level.get_name_leafdata())
                                    if (self.destination_level.is_set or self.destination_level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.destination_level.get_name_leafdata())
                                    if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "source-level" or name == "destination-level" or name == "route-policy-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "source-level"):
                                        self.source_level = value
                                        self.source_level.value_namespace = name_space
                                        self.source_level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "destination-level"):
                                        self.destination_level = value
                                        self.destination_level.value_namespace = name_space
                                        self.destination_level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "route-policy-name"):
                                        self.route_policy_name = value
                                        self.route_policy_name.value_namespace = name_space
                                        self.route_policy_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.propagation:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.propagation:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "propagations" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "propagation"):
                                    for c in self.propagation:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.Propagations.Propagation()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.propagation.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "propagation"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Redistributions(Entity):
                            """
                            Protocol redistribution configuration
                            
                            .. attribute:: redistribution
                            
                            	Redistribution of other protocols into this IS\-IS instance
                            	**type**\: list of    :py:class:`Redistribution <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions, self).__init__()

                                self.yang_name = "redistributions"
                                self.yang_parent_name = "af-data"

                                self.redistribution = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions, self).__setattr__(name, value)


                            class Redistribution(Entity):
                                """
                                Redistribution of other protocols into
                                this IS\-IS instance
                                
                                .. attribute:: protocol_name  <key>
                                
                                	The protocol to be redistributed.  OSPFv3 may not be specified for an IPv4 topology and OSPF may not be specified for an IPv6 topology
                                	**type**\:   :py:class:`IsisRedistProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisRedistProto>`
                                
                                .. attribute:: bgp
                                
                                	bgp
                                	**type**\: list of    :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Bgp>`
                                
                                .. attribute:: connected_or_static_or_rip_or_subscriber_or_mobile
                                
                                	connected or static or rip or subscriber or mobile
                                	**type**\:   :py:class:`ConnectedOrStaticOrRipOrSubscriberOrMobile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: eigrp
                                
                                	eigrp
                                	**type**\: list of    :py:class:`Eigrp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Eigrp>`
                                
                                .. attribute:: ospf_or_ospfv3_or_isis_or_application
                                
                                	ospf or ospfv3 or isis or application
                                	**type**\: list of    :py:class:`OspfOrOspfv3OrIsisOrApplication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution, self).__init__()

                                    self.yang_name = "redistribution"
                                    self.yang_parent_name = "redistributions"

                                    self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                                    self.connected_or_static_or_rip_or_subscriber_or_mobile = None
                                    self._children_name_map["connected_or_static_or_rip_or_subscriber_or_mobile"] = "connected-or-static-or-rip-or-subscriber-or-mobile"
                                    self._children_yang_names.add("connected-or-static-or-rip-or-subscriber-or-mobile")

                                    self.bgp = YList(self)
                                    self.eigrp = YList(self)
                                    self.ospf_or_ospfv3_or_isis_or_application = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("protocol_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution, self).__setattr__(name, value)


                                class ConnectedOrStaticOrRipOrSubscriberOrMobile(Entity):
                                    """
                                    connected or static or rip or subscriber
                                    or mobile
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile, self).__init__()

                                        self.yang_name = "connected-or-static-or-rip-or-subscriber-or-mobile"
                                        self.yang_parent_name = "redistribution"
                                        self.is_presence_container = True

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "connected-or-static-or-rip-or-subscriber-or-mobile" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix


                                class OspfOrOspfv3OrIsisOrApplication(Entity):
                                    """
                                    ospf or ospfv3 or isis or application
                                    
                                    .. attribute:: instance_name  <key>
                                    
                                    	Protocol Instance Identifier.  Mandatory for ISIS, OSPF and application, must not be specified otherwise
                                    	**type**\:  str
                                    
                                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication, self).__init__()

                                        self.yang_name = "ospf-or-ospfv3-or-isis-or-application"
                                        self.yang_parent_name = "redistribution"

                                        self.instance_name = YLeaf(YType.str, "instance-name")

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("instance_name",
                                                        "levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.instance_name.is_set or
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.instance_name.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ospf-or-ospfv3-or-isis-or-application" + "[instance-name='" + self.instance_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.instance_name.is_set or self.instance_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.instance_name.get_name_leafdata())
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "instance-name" or name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "instance-name"):
                                            self.instance_name = value
                                            self.instance_name.value_namespace = name_space
                                            self.instance_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix


                                class Bgp(Entity):
                                    """
                                    bgp
                                    
                                    .. attribute:: as_xx  <key>
                                    
                                    	First half of BGP AS number in XX.YY format.  Mandatory if Protocol is BGP and must not be specified otherwise. Must be a non\-zero value if second half is zero
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: as_yy  <key>
                                    
                                    	Second half of BGP AS number in XX.YY format. Mandatory if Protocol is BGP and must not be specified otherwise. Must be a non\-zero value if first half is zero
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Bgp, self).__init__()

                                        self.yang_name = "bgp"
                                        self.yang_parent_name = "redistribution"

                                        self.as_xx = YLeaf(YType.uint32, "as-xx")

                                        self.as_yy = YLeaf(YType.uint32, "as-yy")

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("as_xx",
                                                        "as_yy",
                                                        "levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Bgp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Bgp, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.as_xx.is_set or
                                            self.as_yy.is_set or
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.as_xx.yfilter != YFilter.not_set or
                                            self.as_yy.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bgp" + "[as-xx='" + self.as_xx.get() + "']" + "[as-yy='" + self.as_yy.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_xx.get_name_leafdata())
                                        if (self.as_yy.is_set or self.as_yy.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_yy.get_name_leafdata())
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "as-xx" or name == "as-yy" or name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "as-xx"):
                                            self.as_xx = value
                                            self.as_xx.value_namespace = name_space
                                            self.as_xx.value_namespace_prefix = name_space_prefix
                                        if(value_path == "as-yy"):
                                            self.as_yy = value
                                            self.as_yy.value_namespace = name_space
                                            self.as_yy.value_namespace_prefix = name_space_prefix
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix


                                class Eigrp(Entity):
                                    """
                                    eigrp
                                    
                                    .. attribute:: as_zz  <key>
                                    
                                    	Eigrp as number
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Eigrp, self).__init__()

                                        self.yang_name = "eigrp"
                                        self.yang_parent_name = "redistribution"

                                        self.as_zz = YLeaf(YType.uint32, "as-zz")

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("as_zz",
                                                        "levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Eigrp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Eigrp, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.as_zz.is_set or
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.as_zz.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "eigrp" + "[as-zz='" + self.as_zz.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.as_zz.is_set or self.as_zz.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_zz.get_name_leafdata())
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "as-zz" or name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "as-zz"):
                                            self.as_zz = value
                                            self.as_zz.value_namespace = name_space
                                            self.as_zz.value_namespace_prefix = name_space_prefix
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.bgp:
                                        if (c.has_data()):
                                            return True
                                    for c in self.eigrp:
                                        if (c.has_data()):
                                            return True
                                    for c in self.ospf_or_ospfv3_or_isis_or_application:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.protocol_name.is_set or
                                        (self.connected_or_static_or_rip_or_subscriber_or_mobile is not None))

                                def has_operation(self):
                                    for c in self.bgp:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.eigrp:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.ospf_or_ospfv3_or_isis_or_application:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.protocol_name.yfilter != YFilter.not_set or
                                        (self.connected_or_static_or_rip_or_subscriber_or_mobile is not None and self.connected_or_static_or_rip_or_subscriber_or_mobile.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "redistribution" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.protocol_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "bgp"):
                                        for c in self.bgp:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Bgp()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.bgp.append(c)
                                        return c

                                    if (child_yang_name == "connected-or-static-or-rip-or-subscriber-or-mobile"):
                                        if (self.connected_or_static_or_rip_or_subscriber_or_mobile is None):
                                            self.connected_or_static_or_rip_or_subscriber_or_mobile = Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile()
                                            self.connected_or_static_or_rip_or_subscriber_or_mobile.parent = self
                                            self._children_name_map["connected_or_static_or_rip_or_subscriber_or_mobile"] = "connected-or-static-or-rip-or-subscriber-or-mobile"
                                        return self.connected_or_static_or_rip_or_subscriber_or_mobile

                                    if (child_yang_name == "eigrp"):
                                        for c in self.eigrp:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.Eigrp()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.eigrp.append(c)
                                        return c

                                    if (child_yang_name == "ospf-or-ospfv3-or-isis-or-application"):
                                        for c in self.ospf_or_ospfv3_or_isis_or_application:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.ospf_or_ospfv3_or_isis_or_application.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bgp" or name == "connected-or-static-or-rip-or-subscriber-or-mobile" or name == "eigrp" or name == "ospf-or-ospfv3-or-isis-or-application" or name == "protocol-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "protocol-name"):
                                        self.protocol_name = value
                                        self.protocol_name.value_namespace = name_space
                                        self.protocol_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.redistribution:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.redistribution:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "redistributions" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "redistribution"):
                                    for c in self.redistribution:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.Redistributions.Redistribution()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.redistribution.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "redistribution"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class SpfPeriodicIntervals(Entity):
                            """
                            Peoridic SPF configuration
                            
                            .. attribute:: spf_periodic_interval
                            
                            	Maximum interval between spf runs
                            	**type**\: list of    :py:class:`SpfPeriodicInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals.SpfPeriodicInterval>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals, self).__init__()

                                self.yang_name = "spf-periodic-intervals"
                                self.yang_parent_name = "af-data"

                                self.spf_periodic_interval = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals, self).__setattr__(name, value)


                            class SpfPeriodicInterval(Entity):
                                """
                                Maximum interval between spf runs
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: periodic_interval
                                
                                	Maximum interval in between SPF runs in seconds
                                	**type**\:  int
                                
                                	**range:** 0..3600
                                
                                	**mandatory**\: True
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals.SpfPeriodicInterval, self).__init__()

                                    self.yang_name = "spf-periodic-interval"
                                    self.yang_parent_name = "spf-periodic-intervals"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.periodic_interval = YLeaf(YType.uint32, "periodic-interval")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "periodic_interval") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals.SpfPeriodicInterval, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals.SpfPeriodicInterval, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.periodic_interval.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.periodic_interval.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "spf-periodic-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.periodic_interval.is_set or self.periodic_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.periodic_interval.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "periodic-interval"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "periodic-interval"):
                                        self.periodic_interval = value
                                        self.periodic_interval.value_namespace = name_space
                                        self.periodic_interval.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.spf_periodic_interval:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.spf_periodic_interval:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-periodic-intervals" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "spf-periodic-interval"):
                                    for c in self.spf_periodic_interval:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals.SpfPeriodicInterval()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.spf_periodic_interval.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "spf-periodic-interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class SpfIntervals(Entity):
                            """
                            SPF\-interval configuration
                            
                            .. attribute:: spf_interval
                            
                            	Route calculation scheduling parameters
                            	**type**\: list of    :py:class:`SpfInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals.SpfInterval>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals, self).__init__()

                                self.yang_name = "spf-intervals"
                                self.yang_parent_name = "af-data"

                                self.spf_interval = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals, self).__setattr__(name, value)


                            class SpfInterval(Entity):
                                """
                                Route calculation scheduling parameters
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: initial_wait
                                
                                	Initial wait before running a route calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..120000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: maximum_wait
                                
                                	Maximum wait before running a route calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..120000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: secondary_wait
                                
                                	Secondary wait before running a route calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..120000
                                
                                	**units**\: millisecond
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals.SpfInterval, self).__init__()

                                    self.yang_name = "spf-interval"
                                    self.yang_parent_name = "spf-intervals"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.initial_wait = YLeaf(YType.uint32, "initial-wait")

                                    self.maximum_wait = YLeaf(YType.uint32, "maximum-wait")

                                    self.secondary_wait = YLeaf(YType.uint32, "secondary-wait")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "initial_wait",
                                                    "maximum_wait",
                                                    "secondary_wait") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals.SpfInterval, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals.SpfInterval, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.initial_wait.is_set or
                                        self.maximum_wait.is_set or
                                        self.secondary_wait.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.initial_wait.yfilter != YFilter.not_set or
                                        self.maximum_wait.yfilter != YFilter.not_set or
                                        self.secondary_wait.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "spf-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.initial_wait.is_set or self.initial_wait.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.initial_wait.get_name_leafdata())
                                    if (self.maximum_wait.is_set or self.maximum_wait.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_wait.get_name_leafdata())
                                    if (self.secondary_wait.is_set or self.secondary_wait.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.secondary_wait.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "initial-wait" or name == "maximum-wait" or name == "secondary-wait"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "initial-wait"):
                                        self.initial_wait = value
                                        self.initial_wait.value_namespace = name_space
                                        self.initial_wait.value_namespace_prefix = name_space_prefix
                                    if(value_path == "maximum-wait"):
                                        self.maximum_wait = value
                                        self.maximum_wait.value_namespace = name_space
                                        self.maximum_wait.value_namespace_prefix = name_space_prefix
                                    if(value_path == "secondary-wait"):
                                        self.secondary_wait = value
                                        self.secondary_wait.value_namespace = name_space
                                        self.secondary_wait.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.spf_interval:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.spf_interval:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-intervals" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "spf-interval"):
                                    for c in self.spf_interval:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals.SpfInterval()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.spf_interval.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "spf-interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MonitorConvergence(Entity):
                            """
                            Enable convergence monitoring
                            
                            .. attribute:: enable
                            
                            	Enable convergence monitoring
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: prefix_list
                            
                            	Enable the monitoring of individual prefixes (prefix list name)
                            	**type**\:  str
                            
                            .. attribute:: track_ip_frr
                            
                            	Enable the Tracking of IP\-Frr Convergence
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.MonitorConvergence, self).__init__()

                                self.yang_name = "monitor-convergence"
                                self.yang_parent_name = "af-data"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.prefix_list = YLeaf(YType.str, "prefix-list")

                                self.track_ip_frr = YLeaf(YType.empty, "track-ip-frr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "prefix_list",
                                                "track_ip_frr") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.MonitorConvergence, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.MonitorConvergence, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.prefix_list.is_set or
                                    self.track_ip_frr.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.prefix_list.yfilter != YFilter.not_set or
                                    self.track_ip_frr.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "monitor-convergence" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_list.get_name_leafdata())
                                if (self.track_ip_frr.is_set or self.track_ip_frr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.track_ip_frr.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "prefix-list" or name == "track-ip-frr"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-list"):
                                    self.prefix_list = value
                                    self.prefix_list.value_namespace = name_space
                                    self.prefix_list.value_namespace_prefix = name_space_prefix
                                if(value_path == "track-ip-frr"):
                                    self.track_ip_frr = value
                                    self.track_ip_frr.value_namespace = name_space
                                    self.track_ip_frr.value_namespace_prefix = name_space_prefix


                        class DefaultInformation(Entity):
                            """
                            Control origination of a default route with
                            the option of using a policy.  If no policy
                            is specified the default route is
                            advertised with zero cost in level 2 only.
                            
                            .. attribute:: external
                            
                            	Flag to indicate that the default prefix should be originated as an external route
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: policy_name
                            
                            	Policy name
                            	**type**\:  str
                            
                            .. attribute:: use_policy
                            
                            	Flag to indicate whether default origination is controlled using a policy
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.DefaultInformation, self).__init__()

                                self.yang_name = "default-information"
                                self.yang_parent_name = "af-data"

                                self.external = YLeaf(YType.empty, "external")

                                self.policy_name = YLeaf(YType.str, "policy-name")

                                self.use_policy = YLeaf(YType.boolean, "use-policy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("external",
                                                "policy_name",
                                                "use_policy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.DefaultInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.DefaultInformation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.external.is_set or
                                    self.policy_name.is_set or
                                    self.use_policy.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.external.yfilter != YFilter.not_set or
                                    self.policy_name.yfilter != YFilter.not_set or
                                    self.use_policy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "default-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.external.is_set or self.external.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external.get_name_leafdata())
                                if (self.policy_name.is_set or self.policy_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.policy_name.get_name_leafdata())
                                if (self.use_policy.is_set or self.use_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.use_policy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "external" or name == "policy-name" or name == "use-policy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "external"):
                                    self.external = value
                                    self.external.value_namespace = name_space
                                    self.external.value_namespace_prefix = name_space_prefix
                                if(value_path == "policy-name"):
                                    self.policy_name = value
                                    self.policy_name.value_namespace = name_space
                                    self.policy_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "use-policy"):
                                    self.use_policy = value
                                    self.use_policy.value_namespace = name_space
                                    self.use_policy.value_namespace_prefix = name_space_prefix


                        class AdminDistances(Entity):
                            """
                            Per\-route administrative
                            distanceconfiguration
                            
                            .. attribute:: admin_distance
                            
                            	Administrative distance configuration. The supplied distance is applied to all routes discovered from the specified source, or only those that match the supplied prefix list if this is specified
                            	**type**\: list of    :py:class:`AdminDistance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.AdminDistances.AdminDistance>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.AdminDistances, self).__init__()

                                self.yang_name = "admin-distances"
                                self.yang_parent_name = "af-data"

                                self.admin_distance = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.AdminDistances, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.AdminDistances, self).__setattr__(name, value)


                            class AdminDistance(Entity):
                                """
                                Administrative distance configuration. The
                                supplied distance is applied to all routes
                                discovered from the specified source, or
                                only those that match the supplied prefix
                                list if this is specified
                                
                                .. attribute:: address_prefix  <key>
                                
                                	IP route source prefix
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                
                                
                                ----
                                .. attribute:: distance
                                
                                	Administrative distance
                                	**type**\:  int
                                
                                	**range:** 1..255
                                
                                	**mandatory**\: True
                                
                                .. attribute:: prefix_list
                                
                                	List of prefixes to which this distance applies
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.AdminDistances.AdminDistance, self).__init__()

                                    self.yang_name = "admin-distance"
                                    self.yang_parent_name = "admin-distances"

                                    self.address_prefix = YLeaf(YType.str, "address-prefix")

                                    self.distance = YLeaf(YType.uint32, "distance")

                                    self.prefix_list = YLeaf(YType.str, "prefix-list")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address_prefix",
                                                    "distance",
                                                    "prefix_list") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.AdminDistances.AdminDistance, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.AdminDistances.AdminDistance, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address_prefix.is_set or
                                        self.distance.is_set or
                                        self.prefix_list.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address_prefix.yfilter != YFilter.not_set or
                                        self.distance.yfilter != YFilter.not_set or
                                        self.prefix_list.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "admin-distance" + "[address-prefix='" + self.address_prefix.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address_prefix.is_set or self.address_prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address_prefix.get_name_leafdata())
                                    if (self.distance.is_set or self.distance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.distance.get_name_leafdata())
                                    if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address-prefix" or name == "distance" or name == "prefix-list"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address-prefix"):
                                        self.address_prefix = value
                                        self.address_prefix.value_namespace = name_space
                                        self.address_prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "distance"):
                                        self.distance = value
                                        self.distance.value_namespace = name_space
                                        self.distance.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-list"):
                                        self.prefix_list = value
                                        self.prefix_list.value_namespace = name_space
                                        self.prefix_list.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.admin_distance:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.admin_distance:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "admin-distances" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "admin-distance"):
                                    for c in self.admin_distance:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.AdminDistances.AdminDistance()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.admin_distance.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "admin-distance"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Ispf(Entity):
                            """
                            ISPF configuration
                            
                            .. attribute:: states
                            
                            	ISPF state (enable/disable)
                            	**type**\:   :py:class:`States <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Ispf.States>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.Ispf, self).__init__()

                                self.yang_name = "ispf"
                                self.yang_parent_name = "af-data"

                                self.states = Isis.Instances.Instance.Afs.Af.AfData.Ispf.States()
                                self.states.parent = self
                                self._children_name_map["states"] = "states"
                                self._children_yang_names.add("states")


                            class States(Entity):
                                """
                                ISPF state (enable/disable)
                                
                                .. attribute:: state
                                
                                	Enable/disable ISPF
                                	**type**\: list of    :py:class:`State <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Ispf.States.State>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Ispf.States, self).__init__()

                                    self.yang_name = "states"
                                    self.yang_parent_name = "ispf"

                                    self.state = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Ispf.States, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Ispf.States, self).__setattr__(name, value)


                                class State(Entity):
                                    """
                                    Enable/disable ISPF
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: state
                                    
                                    	State
                                    	**type**\:   :py:class:`IsisispfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisispfState>`
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Ispf.States.State, self).__init__()

                                        self.yang_name = "state"
                                        self.yang_parent_name = "states"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.state = YLeaf(YType.enumeration, "state")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "state") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.AfData.Ispf.States.State, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Ispf.States.State, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.state.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.state.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "state" + "[level='" + self.level.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.state.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "state"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "state"):
                                            self.state = value
                                            self.state.value_namespace = name_space
                                            self.state.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.state:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.state:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "states" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "state"):
                                        for c in self.state:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.AfData.Ispf.States.State()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.state.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "state"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (self.states is not None and self.states.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.states is not None and self.states.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ispf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "states"):
                                    if (self.states is None):
                                        self.states = Isis.Instances.Instance.Afs.Af.AfData.Ispf.States()
                                        self.states.parent = self
                                        self._children_name_map["states"] = "states"
                                    return self.states

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "states"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MplsLdpGlobal(Entity):
                            """
                            MPLS LDP configuration. MPLS LDP
                            configuration will only be applied for the
                            IPv4\-unicast address\-family.
                            
                            .. attribute:: auto_config
                            
                            	If TRUE, LDP will be enabled onall IS\-IS interfaces enabled for this address\-family
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.MplsLdpGlobal, self).__init__()

                                self.yang_name = "mpls-ldp-global"
                                self.yang_parent_name = "af-data"

                                self.auto_config = YLeaf(YType.boolean, "auto-config")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("auto_config") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.MplsLdpGlobal, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.MplsLdpGlobal, self).__setattr__(name, value)

                            def has_data(self):
                                return self.auto_config.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.auto_config.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-ldp-global" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.auto_config.is_set or self.auto_config.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_config.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto-config"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "auto-config"):
                                    self.auto_config = value
                                    self.auto_config.value_namespace = name_space
                                    self.auto_config.value_namespace_prefix = name_space_prefix


                        class Mpls(Entity):
                            """
                            MPLS configuration. MPLS configuration will
                            only be applied for the IPv4\-unicast
                            address\-family.
                            
                            .. attribute:: igp_intact
                            
                            	Install TE and non\-TE nexthops in the RIB
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: level
                            
                            	Enable MPLS for an IS\-IS at the given levels
                            	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                            
                            .. attribute:: multicast_intact
                            
                            	Install non\-TE nexthops in the RIB for use by multicast
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: router_id
                            
                            	Traffic Engineering stable IP address for system
                            	**type**\:   :py:class:`RouterId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Mpls.RouterId>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.Mpls, self).__init__()

                                self.yang_name = "mpls"
                                self.yang_parent_name = "af-data"

                                self.igp_intact = YLeaf(YType.empty, "igp-intact")

                                self.level = YLeaf(YType.enumeration, "level")

                                self.multicast_intact = YLeaf(YType.empty, "multicast-intact")

                                self.router_id = Isis.Instances.Instance.Afs.Af.AfData.Mpls.RouterId()
                                self.router_id.parent = self
                                self._children_name_map["router_id"] = "router-id"
                                self._children_yang_names.add("router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_intact",
                                                "level",
                                                "multicast_intact") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Mpls, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Mpls, self).__setattr__(name, value)


                            class RouterId(Entity):
                                """
                                Traffic Engineering stable IP address for
                                system
                                
                                .. attribute:: address
                                
                                	IPv4 address to be used as a router ID. Precisely one of Address and Interface must be specified
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: interface_name
                                
                                	Interface with designated stable IP address to be used as a router ID. This must be a Loopback interface. Precisely one of Address and Interface must be specified
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Mpls.RouterId, self).__init__()

                                    self.yang_name = "router-id"
                                    self.yang_parent_name = "mpls"

                                    self.address = YLeaf(YType.str, "address")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address",
                                                    "interface_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Mpls.RouterId, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Mpls.RouterId, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address.is_set or
                                        self.interface_name.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "router-id" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address" or name == "interface-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address"):
                                        self.address = value
                                        self.address.value_namespace = name_space
                                        self.address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_intact.is_set or
                                    self.level.is_set or
                                    self.multicast_intact.is_set or
                                    (self.router_id is not None and self.router_id.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_intact.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.multicast_intact.yfilter != YFilter.not_set or
                                    (self.router_id is not None and self.router_id.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_intact.is_set or self.igp_intact.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_intact.get_name_leafdata())
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.multicast_intact.is_set or self.multicast_intact.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_intact.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "router-id"):
                                    if (self.router_id is None):
                                        self.router_id = Isis.Instances.Instance.Afs.Af.AfData.Mpls.RouterId()
                                        self.router_id.parent = self
                                        self._children_name_map["router_id"] = "router-id"
                                    return self.router_id

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "router-id" or name == "igp-intact" or name == "level" or name == "multicast-intact"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-intact"):
                                    self.igp_intact = value
                                    self.igp_intact.value_namespace = name_space
                                    self.igp_intact.value_namespace_prefix = name_space_prefix
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-intact"):
                                    self.multicast_intact = value
                                    self.multicast_intact.value_namespace = name_space
                                    self.multicast_intact.value_namespace_prefix = name_space_prefix


                        class Metrics(Entity):
                            """
                            Metric configuration
                            
                            .. attribute:: metric
                            
                            	Metric configuration. Legal value depends on the metric\-style specified for the topology. If the metric\-style defined is narrow, then only a value between <1\-63> is allowed and if the metric\-style is defined as wide, then a value between <1\-16777215> is allowed as the metric value.  All routers exclude links with the maximum wide metric (16777215) from their SPF
                            	**type**\: list of    :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Metrics.Metric>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.Metrics, self).__init__()

                                self.yang_name = "metrics"
                                self.yang_parent_name = "af-data"

                                self.metric = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Metrics, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Metrics, self).__setattr__(name, value)


                            class Metric(Entity):
                                """
                                Metric configuration. Legal value depends on
                                the metric\-style specified for the topology. If
                                the metric\-style defined is narrow, then only a
                                value between <1\-63> is allowed and if the
                                metric\-style is defined as wide, then a value
                                between <1\-16777215> is allowed as the metric
                                value.  All routers exclude links with the
                                maximum wide metric (16777215) from their SPF
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: metric
                                
                                	Allowed metric\: <1\-63> for narrow, <1\-16777215> for wide
                                	**type**\: one of the below types:
                                
                                	**type**\:   :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric.Metric>`
                                
                                	**mandatory**\: True
                                
                                
                                ----
                                	**type**\:  int
                                
                                	**range:** 1..16777215
                                
                                	**mandatory**\: True
                                
                                
                                ----
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Metrics.Metric, self).__init__()

                                    self.yang_name = "metric"
                                    self.yang_parent_name = "metrics"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.metric = YLeaf(YType.str, "metric")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "metric") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Metrics.Metric, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Metrics.Metric, self).__setattr__(name, value)

                                class Metric(Enum):
                                    """
                                    Metric

                                    Allowed metric\: <1\-63> for narrow,

                                    <1\-16777215> for wide

                                    .. data:: maximum = 16777215

                                    	Maximum wide metric.  All routers will

                                    	exclude this link from their SPF

                                    """

                                    maximum = Enum.YLeaf(16777215, "maximum")


                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.metric.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.metric.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "metric" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "metric"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric"):
                                        self.metric = value
                                        self.metric.value_namespace = name_space
                                        self.metric.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.metric:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.metric:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "metrics" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "metric"):
                                    for c in self.metric:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.Metrics.Metric()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.metric.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Weights(Entity):
                            """
                            Weight configuration
                            
                            .. attribute:: weight
                            
                            	Weight configuration under interface for load balancing
                            	**type**\: list of    :py:class:`Weight <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.AfData.Weights.Weight>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.AfData.Weights, self).__init__()

                                self.yang_name = "weights"
                                self.yang_parent_name = "af-data"

                                self.weight = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Weights, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.AfData.Weights, self).__setattr__(name, value)


                            class Weight(Entity):
                                """
                                Weight configuration under interface for load
                                balancing
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: weight
                                
                                	Weight to be configured under interface for Load Balancing. Allowed weight\: <1\-16777215>
                                	**type**\:  int
                                
                                	**range:** 1..16777214
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.AfData.Weights.Weight, self).__init__()

                                    self.yang_name = "weight"
                                    self.yang_parent_name = "weights"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.weight = YLeaf(YType.uint32, "weight")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "weight") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.AfData.Weights.Weight, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.AfData.Weights.Weight, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.weight.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.weight.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "weight" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.weight.is_set or self.weight.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.weight.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "weight"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "weight"):
                                        self.weight = value
                                        self.weight.value_namespace = name_space
                                        self.weight.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.weight:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.weight:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "weights" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "weight"):
                                    for c in self.weight:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.AfData.Weights.Weight()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.weight.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "weight"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.adjacency_check.is_set or
                                self.advertise_link_attributes.is_set or
                                self.advertise_passive_only.is_set or
                                self.apply_weight.is_set or
                                self.attached_bit.is_set or
                                self.default_admin_distance.is_set or
                                self.ignore_attached_bit.is_set or
                                self.maximum_paths.is_set or
                                self.route_source_first_hop.is_set or
                                self.single_topology.is_set or
                                self.topology_id.is_set or
                                (self.admin_distances is not None and self.admin_distances.has_data()) or
                                (self.default_information is not None and self.default_information.has_data()) or
                                (self.frr_table is not None and self.frr_table.has_data()) or
                                (self.ispf is not None and self.ispf.has_data()) or
                                (self.max_redist_prefixes is not None and self.max_redist_prefixes.has_data()) or
                                (self.metric_styles is not None and self.metric_styles.has_data()) or
                                (self.metrics is not None and self.metrics.has_data()) or
                                (self.micro_loop_avoidance is not None and self.micro_loop_avoidance.has_data()) or
                                (self.monitor_convergence is not None and self.monitor_convergence.has_data()) or
                                (self.mpls is not None and self.mpls.has_data()) or
                                (self.mpls_ldp_global is not None and self.mpls_ldp_global.has_data()) or
                                (self.propagations is not None and self.propagations.has_data()) or
                                (self.redistributions is not None and self.redistributions.has_data()) or
                                (self.router_id is not None and self.router_id.has_data()) or
                                (self.segment_routing is not None and self.segment_routing.has_data()) or
                                (self.spf_intervals is not None and self.spf_intervals.has_data()) or
                                (self.spf_periodic_intervals is not None and self.spf_periodic_intervals.has_data()) or
                                (self.spf_prefix_priorities is not None and self.spf_prefix_priorities.has_data()) or
                                (self.summary_prefixes is not None and self.summary_prefixes.has_data()) or
                                (self.ucmp is not None and self.ucmp.has_data()) or
                                (self.weights is not None and self.weights.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.adjacency_check.yfilter != YFilter.not_set or
                                self.advertise_link_attributes.yfilter != YFilter.not_set or
                                self.advertise_passive_only.yfilter != YFilter.not_set or
                                self.apply_weight.yfilter != YFilter.not_set or
                                self.attached_bit.yfilter != YFilter.not_set or
                                self.default_admin_distance.yfilter != YFilter.not_set or
                                self.ignore_attached_bit.yfilter != YFilter.not_set or
                                self.maximum_paths.yfilter != YFilter.not_set or
                                self.route_source_first_hop.yfilter != YFilter.not_set or
                                self.single_topology.yfilter != YFilter.not_set or
                                self.topology_id.yfilter != YFilter.not_set or
                                (self.admin_distances is not None and self.admin_distances.has_operation()) or
                                (self.default_information is not None and self.default_information.has_operation()) or
                                (self.frr_table is not None and self.frr_table.has_operation()) or
                                (self.ispf is not None and self.ispf.has_operation()) or
                                (self.max_redist_prefixes is not None and self.max_redist_prefixes.has_operation()) or
                                (self.metric_styles is not None and self.metric_styles.has_operation()) or
                                (self.metrics is not None and self.metrics.has_operation()) or
                                (self.micro_loop_avoidance is not None and self.micro_loop_avoidance.has_operation()) or
                                (self.monitor_convergence is not None and self.monitor_convergence.has_operation()) or
                                (self.mpls is not None and self.mpls.has_operation()) or
                                (self.mpls_ldp_global is not None and self.mpls_ldp_global.has_operation()) or
                                (self.propagations is not None and self.propagations.has_operation()) or
                                (self.redistributions is not None and self.redistributions.has_operation()) or
                                (self.router_id is not None and self.router_id.has_operation()) or
                                (self.segment_routing is not None and self.segment_routing.has_operation()) or
                                (self.spf_intervals is not None and self.spf_intervals.has_operation()) or
                                (self.spf_periodic_intervals is not None and self.spf_periodic_intervals.has_operation()) or
                                (self.spf_prefix_priorities is not None and self.spf_prefix_priorities.has_operation()) or
                                (self.summary_prefixes is not None and self.summary_prefixes.has_operation()) or
                                (self.ucmp is not None and self.ucmp.has_operation()) or
                                (self.weights is not None and self.weights.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "af-data" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.adjacency_check.is_set or self.adjacency_check.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.adjacency_check.get_name_leafdata())
                            if (self.advertise_link_attributes.is_set or self.advertise_link_attributes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_link_attributes.get_name_leafdata())
                            if (self.advertise_passive_only.is_set or self.advertise_passive_only.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_passive_only.get_name_leafdata())
                            if (self.apply_weight.is_set or self.apply_weight.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.apply_weight.get_name_leafdata())
                            if (self.attached_bit.is_set or self.attached_bit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.attached_bit.get_name_leafdata())
                            if (self.default_admin_distance.is_set or self.default_admin_distance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_admin_distance.get_name_leafdata())
                            if (self.ignore_attached_bit.is_set or self.ignore_attached_bit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignore_attached_bit.get_name_leafdata())
                            if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_paths.get_name_leafdata())
                            if (self.route_source_first_hop.is_set or self.route_source_first_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_source_first_hop.get_name_leafdata())
                            if (self.single_topology.is_set or self.single_topology.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.single_topology.get_name_leafdata())
                            if (self.topology_id.is_set or self.topology_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.topology_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "admin-distances"):
                                if (self.admin_distances is None):
                                    self.admin_distances = Isis.Instances.Instance.Afs.Af.AfData.AdminDistances()
                                    self.admin_distances.parent = self
                                    self._children_name_map["admin_distances"] = "admin-distances"
                                return self.admin_distances

                            if (child_yang_name == "default-information"):
                                if (self.default_information is None):
                                    self.default_information = Isis.Instances.Instance.Afs.Af.AfData.DefaultInformation()
                                    self.default_information.parent = self
                                    self._children_name_map["default_information"] = "default-information"
                                return self.default_information

                            if (child_yang_name == "frr-table"):
                                if (self.frr_table is None):
                                    self.frr_table = Isis.Instances.Instance.Afs.Af.AfData.FrrTable()
                                    self.frr_table.parent = self
                                    self._children_name_map["frr_table"] = "frr-table"
                                return self.frr_table

                            if (child_yang_name == "ispf"):
                                if (self.ispf is None):
                                    self.ispf = Isis.Instances.Instance.Afs.Af.AfData.Ispf()
                                    self.ispf.parent = self
                                    self._children_name_map["ispf"] = "ispf"
                                return self.ispf

                            if (child_yang_name == "max-redist-prefixes"):
                                if (self.max_redist_prefixes is None):
                                    self.max_redist_prefixes = Isis.Instances.Instance.Afs.Af.AfData.MaxRedistPrefixes()
                                    self.max_redist_prefixes.parent = self
                                    self._children_name_map["max_redist_prefixes"] = "max-redist-prefixes"
                                return self.max_redist_prefixes

                            if (child_yang_name == "metric-styles"):
                                if (self.metric_styles is None):
                                    self.metric_styles = Isis.Instances.Instance.Afs.Af.AfData.MetricStyles()
                                    self.metric_styles.parent = self
                                    self._children_name_map["metric_styles"] = "metric-styles"
                                return self.metric_styles

                            if (child_yang_name == "metrics"):
                                if (self.metrics is None):
                                    self.metrics = Isis.Instances.Instance.Afs.Af.AfData.Metrics()
                                    self.metrics.parent = self
                                    self._children_name_map["metrics"] = "metrics"
                                return self.metrics

                            if (child_yang_name == "micro-loop-avoidance"):
                                if (self.micro_loop_avoidance is None):
                                    self.micro_loop_avoidance = Isis.Instances.Instance.Afs.Af.AfData.MicroLoopAvoidance()
                                    self.micro_loop_avoidance.parent = self
                                    self._children_name_map["micro_loop_avoidance"] = "micro-loop-avoidance"
                                return self.micro_loop_avoidance

                            if (child_yang_name == "monitor-convergence"):
                                if (self.monitor_convergence is None):
                                    self.monitor_convergence = Isis.Instances.Instance.Afs.Af.AfData.MonitorConvergence()
                                    self.monitor_convergence.parent = self
                                    self._children_name_map["monitor_convergence"] = "monitor-convergence"
                                return self.monitor_convergence

                            if (child_yang_name == "mpls"):
                                if (self.mpls is None):
                                    self.mpls = Isis.Instances.Instance.Afs.Af.AfData.Mpls()
                                    self.mpls.parent = self
                                    self._children_name_map["mpls"] = "mpls"
                                return self.mpls

                            if (child_yang_name == "mpls-ldp-global"):
                                if (self.mpls_ldp_global is None):
                                    self.mpls_ldp_global = Isis.Instances.Instance.Afs.Af.AfData.MplsLdpGlobal()
                                    self.mpls_ldp_global.parent = self
                                    self._children_name_map["mpls_ldp_global"] = "mpls-ldp-global"
                                return self.mpls_ldp_global

                            if (child_yang_name == "propagations"):
                                if (self.propagations is None):
                                    self.propagations = Isis.Instances.Instance.Afs.Af.AfData.Propagations()
                                    self.propagations.parent = self
                                    self._children_name_map["propagations"] = "propagations"
                                return self.propagations

                            if (child_yang_name == "redistributions"):
                                if (self.redistributions is None):
                                    self.redistributions = Isis.Instances.Instance.Afs.Af.AfData.Redistributions()
                                    self.redistributions.parent = self
                                    self._children_name_map["redistributions"] = "redistributions"
                                return self.redistributions

                            if (child_yang_name == "router-id"):
                                if (self.router_id is None):
                                    self.router_id = Isis.Instances.Instance.Afs.Af.AfData.RouterId()
                                    self.router_id.parent = self
                                    self._children_name_map["router_id"] = "router-id"
                                return self.router_id

                            if (child_yang_name == "segment-routing"):
                                if (self.segment_routing is None):
                                    self.segment_routing = Isis.Instances.Instance.Afs.Af.AfData.SegmentRouting()
                                    self.segment_routing.parent = self
                                    self._children_name_map["segment_routing"] = "segment-routing"
                                return self.segment_routing

                            if (child_yang_name == "spf-intervals"):
                                if (self.spf_intervals is None):
                                    self.spf_intervals = Isis.Instances.Instance.Afs.Af.AfData.SpfIntervals()
                                    self.spf_intervals.parent = self
                                    self._children_name_map["spf_intervals"] = "spf-intervals"
                                return self.spf_intervals

                            if (child_yang_name == "spf-periodic-intervals"):
                                if (self.spf_periodic_intervals is None):
                                    self.spf_periodic_intervals = Isis.Instances.Instance.Afs.Af.AfData.SpfPeriodicIntervals()
                                    self.spf_periodic_intervals.parent = self
                                    self._children_name_map["spf_periodic_intervals"] = "spf-periodic-intervals"
                                return self.spf_periodic_intervals

                            if (child_yang_name == "spf-prefix-priorities"):
                                if (self.spf_prefix_priorities is None):
                                    self.spf_prefix_priorities = Isis.Instances.Instance.Afs.Af.AfData.SpfPrefixPriorities()
                                    self.spf_prefix_priorities.parent = self
                                    self._children_name_map["spf_prefix_priorities"] = "spf-prefix-priorities"
                                return self.spf_prefix_priorities

                            if (child_yang_name == "summary-prefixes"):
                                if (self.summary_prefixes is None):
                                    self.summary_prefixes = Isis.Instances.Instance.Afs.Af.AfData.SummaryPrefixes()
                                    self.summary_prefixes.parent = self
                                    self._children_name_map["summary_prefixes"] = "summary-prefixes"
                                return self.summary_prefixes

                            if (child_yang_name == "ucmp"):
                                if (self.ucmp is None):
                                    self.ucmp = Isis.Instances.Instance.Afs.Af.AfData.Ucmp()
                                    self.ucmp.parent = self
                                    self._children_name_map["ucmp"] = "ucmp"
                                return self.ucmp

                            if (child_yang_name == "weights"):
                                if (self.weights is None):
                                    self.weights = Isis.Instances.Instance.Afs.Af.AfData.Weights()
                                    self.weights.parent = self
                                    self._children_name_map["weights"] = "weights"
                                return self.weights

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "admin-distances" or name == "default-information" or name == "frr-table" or name == "ispf" or name == "max-redist-prefixes" or name == "metric-styles" or name == "metrics" or name == "micro-loop-avoidance" or name == "monitor-convergence" or name == "mpls" or name == "mpls-ldp-global" or name == "propagations" or name == "redistributions" or name == "router-id" or name == "segment-routing" or name == "spf-intervals" or name == "spf-periodic-intervals" or name == "spf-prefix-priorities" or name == "summary-prefixes" or name == "ucmp" or name == "weights" or name == "adjacency-check" or name == "advertise-link-attributes" or name == "advertise-passive-only" or name == "apply-weight" or name == "attached-bit" or name == "default-admin-distance" or name == "ignore-attached-bit" or name == "maximum-paths" or name == "route-source-first-hop" or name == "single-topology" or name == "topology-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "adjacency-check"):
                                self.adjacency_check = value
                                self.adjacency_check.value_namespace = name_space
                                self.adjacency_check.value_namespace_prefix = name_space_prefix
                            if(value_path == "advertise-link-attributes"):
                                self.advertise_link_attributes = value
                                self.advertise_link_attributes.value_namespace = name_space
                                self.advertise_link_attributes.value_namespace_prefix = name_space_prefix
                            if(value_path == "advertise-passive-only"):
                                self.advertise_passive_only = value
                                self.advertise_passive_only.value_namespace = name_space
                                self.advertise_passive_only.value_namespace_prefix = name_space_prefix
                            if(value_path == "apply-weight"):
                                self.apply_weight = value
                                self.apply_weight.value_namespace = name_space
                                self.apply_weight.value_namespace_prefix = name_space_prefix
                            if(value_path == "attached-bit"):
                                self.attached_bit = value
                                self.attached_bit.value_namespace = name_space
                                self.attached_bit.value_namespace_prefix = name_space_prefix
                            if(value_path == "default-admin-distance"):
                                self.default_admin_distance = value
                                self.default_admin_distance.value_namespace = name_space
                                self.default_admin_distance.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignore-attached-bit"):
                                self.ignore_attached_bit = value
                                self.ignore_attached_bit.value_namespace = name_space
                                self.ignore_attached_bit.value_namespace_prefix = name_space_prefix
                            if(value_path == "maximum-paths"):
                                self.maximum_paths = value
                                self.maximum_paths.value_namespace = name_space
                                self.maximum_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-source-first-hop"):
                                self.route_source_first_hop = value
                                self.route_source_first_hop.value_namespace = name_space
                                self.route_source_first_hop.value_namespace_prefix = name_space_prefix
                            if(value_path == "single-topology"):
                                self.single_topology = value
                                self.single_topology.value_namespace = name_space
                                self.single_topology.value_namespace_prefix = name_space_prefix
                            if(value_path == "topology-id"):
                                self.topology_id = value
                                self.topology_id.value_namespace = name_space
                                self.topology_id.value_namespace_prefix = name_space_prefix


                    class TopologyName(Entity):
                        """
                        keys\: topology\-name
                        
                        .. attribute:: topology_name  <key>
                        
                        	Topology Name
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: adjacency_check
                        
                        	Suppress check for consistent AF support on received IIHs
                        	**type**\:   :py:class:`IsisAdjCheck <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAdjCheck>`
                        
                        .. attribute:: admin_distances
                        
                        	Per\-route administrative distanceconfiguration
                        	**type**\:   :py:class:`AdminDistances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances>`
                        
                        .. attribute:: advertise_link_attributes
                        
                        	If TRUE, advertise additional link attributes in our LSP
                        	**type**\:  bool
                        
                        .. attribute:: advertise_passive_only
                        
                        	If enabled, advertise prefixes of passive interfaces only
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: apply_weight
                        
                        	Apply weights to UCMP or ECMP only
                        	**type**\:   :py:class:`IsisApplyWeight <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisApplyWeight>`
                        
                        .. attribute:: attached_bit
                        
                        	Set the attached bit in this router's level 1 System LSP
                        	**type**\:   :py:class:`IsisAttachedBit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAttachedBit>`
                        
                        	**default value**\: area
                        
                        .. attribute:: default_admin_distance
                        
                        	Default IS\-IS administrative distance configuration
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        	**default value**\: 115
                        
                        .. attribute:: default_information
                        
                        	Control origination of a default route with the option of using a policy.  If no policy is specified the default route is advertised with zero cost in level 2 only
                        	**type**\:   :py:class:`DefaultInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.DefaultInformation>`
                        
                        .. attribute:: frr_table
                        
                        	Fast\-ReRoute configuration
                        	**type**\:   :py:class:`FrrTable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable>`
                        
                        .. attribute:: ignore_attached_bit
                        
                        	If TRUE, Ignore other routers attached bit
                        	**type**\:  bool
                        
                        .. attribute:: ispf
                        
                        	ISPF configuration
                        	**type**\:   :py:class:`Ispf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Ispf>`
                        
                        .. attribute:: max_redist_prefixes
                        
                        	Maximum number of redistributed prefixesconfiguration
                        	**type**\:   :py:class:`MaxRedistPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes>`
                        
                        .. attribute:: maximum_paths
                        
                        	Maximum number of active parallel paths per route
                        	**type**\:  int
                        
                        	**range:** 1..64
                        
                        .. attribute:: metric_styles
                        
                        	Metric\-style configuration
                        	**type**\:   :py:class:`MetricStyles <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles>`
                        
                        .. attribute:: metrics
                        
                        	Metric configuration
                        	**type**\:   :py:class:`Metrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Metrics>`
                        
                        .. attribute:: micro_loop_avoidance
                        
                        	Micro Loop Avoidance configuration
                        	**type**\:   :py:class:`MicroLoopAvoidance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.MicroLoopAvoidance>`
                        
                        .. attribute:: monitor_convergence
                        
                        	Enable convergence monitoring
                        	**type**\:   :py:class:`MonitorConvergence <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.MonitorConvergence>`
                        
                        .. attribute:: mpls
                        
                        	MPLS configuration. MPLS configuration will only be applied for the IPv4\-unicast address\-family
                        	**type**\:   :py:class:`Mpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Mpls>`
                        
                        .. attribute:: mpls_ldp_global
                        
                        	MPLS LDP configuration. MPLS LDP configuration will only be applied for the IPv4\-unicast address\-family
                        	**type**\:   :py:class:`MplsLdpGlobal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.MplsLdpGlobal>`
                        
                        .. attribute:: propagations
                        
                        	Route propagation configuration
                        	**type**\:   :py:class:`Propagations <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Propagations>`
                        
                        .. attribute:: redistributions
                        
                        	Protocol redistribution configuration
                        	**type**\:   :py:class:`Redistributions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions>`
                        
                        .. attribute:: route_source_first_hop
                        
                        	If TRUE, routes will be installed with the IP address of the first\-hop node as the source instead of the originating node
                        	**type**\:  bool
                        
                        .. attribute:: router_id
                        
                        	Stable IP address for system. Will only be applied for the unicast sub\-address\-family
                        	**type**\:   :py:class:`RouterId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.RouterId>`
                        
                        .. attribute:: segment_routing
                        
                        	Enable Segment Routing configuration
                        	**type**\:   :py:class:`SegmentRouting <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting>`
                        
                        .. attribute:: single_topology
                        
                        	Run IPv6 Unicast using the standard (IPv4 Unicast) topology
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: spf_intervals
                        
                        	SPF\-interval configuration
                        	**type**\:   :py:class:`SpfIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals>`
                        
                        .. attribute:: spf_periodic_intervals
                        
                        	Peoridic SPF configuration
                        	**type**\:   :py:class:`SpfPeriodicIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals>`
                        
                        .. attribute:: spf_prefix_priorities
                        
                        	SPF Prefix Priority configuration
                        	**type**\:   :py:class:`SpfPrefixPriorities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities>`
                        
                        .. attribute:: summary_prefixes
                        
                        	Summary\-prefix configuration
                        	**type**\:   :py:class:`SummaryPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes>`
                        
                        .. attribute:: topology_id
                        
                        	Set the topology ID for a named (non\-default) topology. This object must be set before any other configuration is supplied for a named (non\-default) topology , and must be the last configuration object to be removed. This item should not be supplied for the non\-named default topologies
                        	**type**\:  int
                        
                        	**range:** 6..4095
                        
                        .. attribute:: ucmp
                        
                        	UCMP (UnEqual Cost MultiPath) configuration
                        	**type**\:   :py:class:`Ucmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp>`
                        
                        .. attribute:: weights
                        
                        	Weight configuration
                        	**type**\:   :py:class:`Weights <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Weights>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Afs.Af.TopologyName, self).__init__()

                            self.yang_name = "topology-name"
                            self.yang_parent_name = "af"

                            self.topology_name = YLeaf(YType.str, "topology-name")

                            self.adjacency_check = YLeaf(YType.enumeration, "adjacency-check")

                            self.advertise_link_attributes = YLeaf(YType.boolean, "advertise-link-attributes")

                            self.advertise_passive_only = YLeaf(YType.empty, "advertise-passive-only")

                            self.apply_weight = YLeaf(YType.enumeration, "apply-weight")

                            self.attached_bit = YLeaf(YType.enumeration, "attached-bit")

                            self.default_admin_distance = YLeaf(YType.uint32, "default-admin-distance")

                            self.ignore_attached_bit = YLeaf(YType.boolean, "ignore-attached-bit")

                            self.maximum_paths = YLeaf(YType.uint32, "maximum-paths")

                            self.route_source_first_hop = YLeaf(YType.boolean, "route-source-first-hop")

                            self.single_topology = YLeaf(YType.empty, "single-topology")

                            self.topology_id = YLeaf(YType.uint32, "topology-id")

                            self.admin_distances = Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances()
                            self.admin_distances.parent = self
                            self._children_name_map["admin_distances"] = "admin-distances"
                            self._children_yang_names.add("admin-distances")

                            self.default_information = Isis.Instances.Instance.Afs.Af.TopologyName.DefaultInformation()
                            self.default_information.parent = self
                            self._children_name_map["default_information"] = "default-information"
                            self._children_yang_names.add("default-information")

                            self.frr_table = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable()
                            self.frr_table.parent = self
                            self._children_name_map["frr_table"] = "frr-table"
                            self._children_yang_names.add("frr-table")

                            self.ispf = Isis.Instances.Instance.Afs.Af.TopologyName.Ispf()
                            self.ispf.parent = self
                            self._children_name_map["ispf"] = "ispf"
                            self._children_yang_names.add("ispf")

                            self.max_redist_prefixes = Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes()
                            self.max_redist_prefixes.parent = self
                            self._children_name_map["max_redist_prefixes"] = "max-redist-prefixes"
                            self._children_yang_names.add("max-redist-prefixes")

                            self.metric_styles = Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles()
                            self.metric_styles.parent = self
                            self._children_name_map["metric_styles"] = "metric-styles"
                            self._children_yang_names.add("metric-styles")

                            self.metrics = Isis.Instances.Instance.Afs.Af.TopologyName.Metrics()
                            self.metrics.parent = self
                            self._children_name_map["metrics"] = "metrics"
                            self._children_yang_names.add("metrics")

                            self.micro_loop_avoidance = Isis.Instances.Instance.Afs.Af.TopologyName.MicroLoopAvoidance()
                            self.micro_loop_avoidance.parent = self
                            self._children_name_map["micro_loop_avoidance"] = "micro-loop-avoidance"
                            self._children_yang_names.add("micro-loop-avoidance")

                            self.monitor_convergence = Isis.Instances.Instance.Afs.Af.TopologyName.MonitorConvergence()
                            self.monitor_convergence.parent = self
                            self._children_name_map["monitor_convergence"] = "monitor-convergence"
                            self._children_yang_names.add("monitor-convergence")

                            self.mpls = Isis.Instances.Instance.Afs.Af.TopologyName.Mpls()
                            self.mpls.parent = self
                            self._children_name_map["mpls"] = "mpls"
                            self._children_yang_names.add("mpls")

                            self.mpls_ldp_global = Isis.Instances.Instance.Afs.Af.TopologyName.MplsLdpGlobal()
                            self.mpls_ldp_global.parent = self
                            self._children_name_map["mpls_ldp_global"] = "mpls-ldp-global"
                            self._children_yang_names.add("mpls-ldp-global")

                            self.propagations = Isis.Instances.Instance.Afs.Af.TopologyName.Propagations()
                            self.propagations.parent = self
                            self._children_name_map["propagations"] = "propagations"
                            self._children_yang_names.add("propagations")

                            self.redistributions = Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions()
                            self.redistributions.parent = self
                            self._children_name_map["redistributions"] = "redistributions"
                            self._children_yang_names.add("redistributions")

                            self.router_id = Isis.Instances.Instance.Afs.Af.TopologyName.RouterId()
                            self.router_id.parent = self
                            self._children_name_map["router_id"] = "router-id"
                            self._children_yang_names.add("router-id")

                            self.segment_routing = Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting()
                            self.segment_routing.parent = self
                            self._children_name_map["segment_routing"] = "segment-routing"
                            self._children_yang_names.add("segment-routing")

                            self.spf_intervals = Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals()
                            self.spf_intervals.parent = self
                            self._children_name_map["spf_intervals"] = "spf-intervals"
                            self._children_yang_names.add("spf-intervals")

                            self.spf_periodic_intervals = Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals()
                            self.spf_periodic_intervals.parent = self
                            self._children_name_map["spf_periodic_intervals"] = "spf-periodic-intervals"
                            self._children_yang_names.add("spf-periodic-intervals")

                            self.spf_prefix_priorities = Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities()
                            self.spf_prefix_priorities.parent = self
                            self._children_name_map["spf_prefix_priorities"] = "spf-prefix-priorities"
                            self._children_yang_names.add("spf-prefix-priorities")

                            self.summary_prefixes = Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes()
                            self.summary_prefixes.parent = self
                            self._children_name_map["summary_prefixes"] = "summary-prefixes"
                            self._children_yang_names.add("summary-prefixes")

                            self.ucmp = Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp()
                            self.ucmp.parent = self
                            self._children_name_map["ucmp"] = "ucmp"
                            self._children_yang_names.add("ucmp")

                            self.weights = Isis.Instances.Instance.Afs.Af.TopologyName.Weights()
                            self.weights.parent = self
                            self._children_name_map["weights"] = "weights"
                            self._children_yang_names.add("weights")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("topology_name",
                                            "adjacency_check",
                                            "advertise_link_attributes",
                                            "advertise_passive_only",
                                            "apply_weight",
                                            "attached_bit",
                                            "default_admin_distance",
                                            "ignore_attached_bit",
                                            "maximum_paths",
                                            "route_source_first_hop",
                                            "single_topology",
                                            "topology_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName, self).__setattr__(name, value)


                        class SegmentRouting(Entity):
                            """
                            Enable Segment Routing configuration
                            
                            .. attribute:: mpls
                            
                            	Prefer segment routing labels over LDP labels
                            	**type**\:   :py:class:`IsisLabelPreference <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisLabelPreference>`
                            
                            .. attribute:: prefix_sid_map
                            
                            	Enable Segment Routing prefix SID map configuration
                            	**type**\:   :py:class:`PrefixSidMap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting.PrefixSidMap>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting, self).__init__()

                                self.yang_name = "segment-routing"
                                self.yang_parent_name = "topology-name"

                                self.mpls = YLeaf(YType.enumeration, "mpls")

                                self.prefix_sid_map = Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting.PrefixSidMap()
                                self.prefix_sid_map.parent = self
                                self._children_name_map["prefix_sid_map"] = "prefix-sid-map"
                                self._children_yang_names.add("prefix-sid-map")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mpls") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting, self).__setattr__(name, value)


                            class PrefixSidMap(Entity):
                                """
                                Enable Segment Routing prefix SID map
                                configuration
                                
                                .. attribute:: advertise_local
                                
                                	Enable Segment Routing prefix SID map advertise local
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: receive
                                
                                	If TRUE, remote prefix SID map advertisements will be used. If FALSE, they will not be used
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting.PrefixSidMap, self).__init__()

                                    self.yang_name = "prefix-sid-map"
                                    self.yang_parent_name = "segment-routing"

                                    self.advertise_local = YLeaf(YType.empty, "advertise-local")

                                    self.receive = YLeaf(YType.boolean, "receive")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("advertise_local",
                                                    "receive") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting.PrefixSidMap, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting.PrefixSidMap, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.advertise_local.is_set or
                                        self.receive.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.advertise_local.yfilter != YFilter.not_set or
                                        self.receive.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "prefix-sid-map" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.advertise_local.is_set or self.advertise_local.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.advertise_local.get_name_leafdata())
                                    if (self.receive.is_set or self.receive.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.receive.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "advertise-local" or name == "receive"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "advertise-local"):
                                        self.advertise_local = value
                                        self.advertise_local.value_namespace = name_space
                                        self.advertise_local.value_namespace_prefix = name_space_prefix
                                    if(value_path == "receive"):
                                        self.receive = value
                                        self.receive.value_namespace = name_space
                                        self.receive.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.mpls.is_set or
                                    (self.prefix_sid_map is not None and self.prefix_sid_map.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mpls.yfilter != YFilter.not_set or
                                    (self.prefix_sid_map is not None and self.prefix_sid_map.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "segment-routing" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mpls.is_set or self.mpls.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mpls.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "prefix-sid-map"):
                                    if (self.prefix_sid_map is None):
                                        self.prefix_sid_map = Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting.PrefixSidMap()
                                        self.prefix_sid_map.parent = self
                                        self._children_name_map["prefix_sid_map"] = "prefix-sid-map"
                                    return self.prefix_sid_map

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "prefix-sid-map" or name == "mpls"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mpls"):
                                    self.mpls = value
                                    self.mpls.value_namespace = name_space
                                    self.mpls.value_namespace_prefix = name_space_prefix


                        class MetricStyles(Entity):
                            """
                            Metric\-style configuration
                            
                            .. attribute:: metric_style
                            
                            	Configuration of metric style in LSPs
                            	**type**\: list of    :py:class:`MetricStyle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles.MetricStyle>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles, self).__init__()

                                self.yang_name = "metric-styles"
                                self.yang_parent_name = "topology-name"

                                self.metric_style = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles, self).__setattr__(name, value)


                            class MetricStyle(Entity):
                                """
                                Configuration of metric style in LSPs
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: style
                                
                                	Metric Style
                                	**type**\:   :py:class:`IsisMetricStyle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetricStyle>`
                                
                                	**default value**\: old-metric-style
                                
                                .. attribute:: transition_state
                                
                                	Transition state
                                	**type**\:   :py:class:`IsisMetricStyleTransition <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetricStyleTransition>`
                                
                                	**default value**\: disabled
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles.MetricStyle, self).__init__()

                                    self.yang_name = "metric-style"
                                    self.yang_parent_name = "metric-styles"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.style = YLeaf(YType.enumeration, "style")

                                    self.transition_state = YLeaf(YType.enumeration, "transition-state")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "style",
                                                    "transition_state") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles.MetricStyle, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles.MetricStyle, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.style.is_set or
                                        self.transition_state.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.style.yfilter != YFilter.not_set or
                                        self.transition_state.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "metric-style" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.style.is_set or self.style.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.style.get_name_leafdata())
                                    if (self.transition_state.is_set or self.transition_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transition_state.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "style" or name == "transition-state"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "style"):
                                        self.style = value
                                        self.style.value_namespace = name_space
                                        self.style.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transition-state"):
                                        self.transition_state = value
                                        self.transition_state.value_namespace = name_space
                                        self.transition_state.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.metric_style:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.metric_style:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "metric-styles" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "metric-style"):
                                    for c in self.metric_style:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles.MetricStyle()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.metric_style.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "metric-style"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class FrrTable(Entity):
                            """
                            Fast\-ReRoute configuration
                            
                            .. attribute:: frr_load_sharings
                            
                            	Load share prefixes across multiple backups
                            	**type**\:   :py:class:`FrrLoadSharings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings>`
                            
                            .. attribute:: frr_remote_lfa_prefixes
                            
                            	FRR remote LFA prefix list filter configuration
                            	**type**\:   :py:class:`FrrRemoteLfaPrefixes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes>`
                            
                            .. attribute:: frr_tiebreakers
                            
                            	FRR tiebreakers configuration
                            	**type**\:   :py:class:`FrrTiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers>`
                            
                            .. attribute:: frr_use_cand_onlies
                            
                            	FRR use candidate only configuration
                            	**type**\:   :py:class:`FrrUseCandOnlies <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies>`
                            
                            .. attribute:: priority_limits
                            
                            	FRR prefix\-limit configuration
                            	**type**\:   :py:class:`PriorityLimits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable, self).__init__()

                                self.yang_name = "frr-table"
                                self.yang_parent_name = "topology-name"

                                self.frr_load_sharings = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings()
                                self.frr_load_sharings.parent = self
                                self._children_name_map["frr_load_sharings"] = "frr-load-sharings"
                                self._children_yang_names.add("frr-load-sharings")

                                self.frr_remote_lfa_prefixes = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes()
                                self.frr_remote_lfa_prefixes.parent = self
                                self._children_name_map["frr_remote_lfa_prefixes"] = "frr-remote-lfa-prefixes"
                                self._children_yang_names.add("frr-remote-lfa-prefixes")

                                self.frr_tiebreakers = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers()
                                self.frr_tiebreakers.parent = self
                                self._children_name_map["frr_tiebreakers"] = "frr-tiebreakers"
                                self._children_yang_names.add("frr-tiebreakers")

                                self.frr_use_cand_onlies = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies()
                                self.frr_use_cand_onlies.parent = self
                                self._children_name_map["frr_use_cand_onlies"] = "frr-use-cand-onlies"
                                self._children_yang_names.add("frr-use-cand-onlies")

                                self.priority_limits = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits()
                                self.priority_limits.parent = self
                                self._children_name_map["priority_limits"] = "priority-limits"
                                self._children_yang_names.add("priority-limits")


                            class FrrLoadSharings(Entity):
                                """
                                Load share prefixes across multiple
                                backups
                                
                                .. attribute:: frr_load_sharing
                                
                                	Disable load sharing
                                	**type**\: list of    :py:class:`FrrLoadSharing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings.FrrLoadSharing>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings, self).__init__()

                                    self.yang_name = "frr-load-sharings"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_load_sharing = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings, self).__setattr__(name, value)


                                class FrrLoadSharing(Entity):
                                    """
                                    Disable load sharing
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: load_sharing
                                    
                                    	Load sharing
                                    	**type**\:   :py:class:`IsisfrrLoadSharing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisfrrLoadSharing>`
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings.FrrLoadSharing, self).__init__()

                                        self.yang_name = "frr-load-sharing"
                                        self.yang_parent_name = "frr-load-sharings"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.load_sharing = YLeaf(YType.enumeration, "load-sharing")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "load_sharing") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings.FrrLoadSharing, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings.FrrLoadSharing, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.load_sharing.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.load_sharing.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-load-sharing" + "[level='" + self.level.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.load_sharing.is_set or self.load_sharing.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.load_sharing.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "load-sharing"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "load-sharing"):
                                            self.load_sharing = value
                                            self.load_sharing.value_namespace = name_space
                                            self.load_sharing.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_load_sharing:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_load_sharing:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-load-sharings" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-load-sharing"):
                                        for c in self.frr_load_sharing:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings.FrrLoadSharing()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_load_sharing.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-load-sharing"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class PriorityLimits(Entity):
                                """
                                FRR prefix\-limit configuration
                                
                                .. attribute:: priority_limit
                                
                                	Limit backup computation upto the prefix priority
                                	**type**\: list of    :py:class:`PriorityLimit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits.PriorityLimit>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits, self).__init__()

                                    self.yang_name = "priority-limits"
                                    self.yang_parent_name = "frr-table"

                                    self.priority_limit = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits, self).__setattr__(name, value)


                                class PriorityLimit(Entity):
                                    """
                                    Limit backup computation upto the prefix
                                    priority
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: frr_type  <key>
                                    
                                    	Computation Type
                                    	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                    
                                    .. attribute:: priority
                                    
                                    	Compute for all prefixes upto the specified priority
                                    	**type**\:   :py:class:`IsisPrefixPriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisPrefixPriority>`
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits.PriorityLimit, self).__init__()

                                        self.yang_name = "priority-limit"
                                        self.yang_parent_name = "priority-limits"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                        self.priority = YLeaf(YType.enumeration, "priority")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "frr_type",
                                                        "priority") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits.PriorityLimit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits.PriorityLimit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.frr_type.is_set or
                                            self.priority.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.frr_type.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "priority-limit" + "[level='" + self.level.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.frr_type.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "frr-type" or name == "priority"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "frr-type"):
                                            self.frr_type = value
                                            self.frr_type.value_namespace = name_space
                                            self.frr_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.priority_limit:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.priority_limit:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-limits" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "priority-limit"):
                                        for c in self.priority_limit:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits.PriorityLimit()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.priority_limit.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "priority-limit"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class FrrRemoteLfaPrefixes(Entity):
                                """
                                FRR remote LFA prefix list filter
                                configuration
                                
                                .. attribute:: frr_remote_lfa_prefix
                                
                                	Filter remote LFA router IDs using prefix\-list
                                	**type**\: list of    :py:class:`FrrRemoteLfaPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes, self).__init__()

                                    self.yang_name = "frr-remote-lfa-prefixes"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_remote_lfa_prefix = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes, self).__setattr__(name, value)


                                class FrrRemoteLfaPrefix(Entity):
                                    """
                                    Filter remote LFA router IDs using
                                    prefix\-list
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: prefix_list_name
                                    
                                    	Name of the prefix list
                                    	**type**\:  str
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix, self).__init__()

                                        self.yang_name = "frr-remote-lfa-prefix"
                                        self.yang_parent_name = "frr-remote-lfa-prefixes"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.prefix_list_name = YLeaf(YType.str, "prefix-list-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "prefix_list_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.prefix_list_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.prefix_list_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-remote-lfa-prefix" + "[level='" + self.level.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.prefix_list_name.is_set or self.prefix_list_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_list_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "prefix-list-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-list-name"):
                                            self.prefix_list_name = value
                                            self.prefix_list_name.value_namespace = name_space
                                            self.prefix_list_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_remote_lfa_prefix:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_remote_lfa_prefix:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-remote-lfa-prefixes" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-remote-lfa-prefix"):
                                        for c in self.frr_remote_lfa_prefix:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes.FrrRemoteLfaPrefix()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_remote_lfa_prefix.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-remote-lfa-prefix"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class FrrTiebreakers(Entity):
                                """
                                FRR tiebreakers configuration
                                
                                .. attribute:: frr_tiebreaker
                                
                                	Configure tiebreaker for multiple backups
                                	**type**\: list of    :py:class:`FrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers.FrrTiebreaker>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers, self).__init__()

                                    self.yang_name = "frr-tiebreakers"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_tiebreaker = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers, self).__setattr__(name, value)


                                class FrrTiebreaker(Entity):
                                    """
                                    Configure tiebreaker for multiple backups
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: tiebreaker  <key>
                                    
                                    	Tiebreaker for which configuration applies
                                    	**type**\:   :py:class:`IsisfrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisfrrTiebreaker>`
                                    
                                    .. attribute:: index
                                    
                                    	Preference order among tiebreakers
                                    	**type**\:  int
                                    
                                    	**range:** 1..255
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers.FrrTiebreaker, self).__init__()

                                        self.yang_name = "frr-tiebreaker"
                                        self.yang_parent_name = "frr-tiebreakers"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.tiebreaker = YLeaf(YType.enumeration, "tiebreaker")

                                        self.index = YLeaf(YType.uint32, "index")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "tiebreaker",
                                                        "index") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers.FrrTiebreaker, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers.FrrTiebreaker, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.tiebreaker.is_set or
                                            self.index.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.tiebreaker.yfilter != YFilter.not_set or
                                            self.index.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-tiebreaker" + "[level='" + self.level.get() + "']" + "[tiebreaker='" + self.tiebreaker.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.tiebreaker.is_set or self.tiebreaker.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tiebreaker.get_name_leafdata())
                                        if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.index.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "tiebreaker" or name == "index"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tiebreaker"):
                                            self.tiebreaker = value
                                            self.tiebreaker.value_namespace = name_space
                                            self.tiebreaker.value_namespace_prefix = name_space_prefix
                                        if(value_path == "index"):
                                            self.index = value
                                            self.index.value_namespace = name_space
                                            self.index.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_tiebreaker:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_tiebreaker:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-tiebreakers" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-tiebreaker"):
                                        for c in self.frr_tiebreaker:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers.FrrTiebreaker()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_tiebreaker.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-tiebreaker"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class FrrUseCandOnlies(Entity):
                                """
                                FRR use candidate only configuration
                                
                                .. attribute:: frr_use_cand_only
                                
                                	Configure use candidate only to exclude interfaces as backup
                                	**type**\: list of    :py:class:`FrrUseCandOnly <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies.FrrUseCandOnly>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies, self).__init__()

                                    self.yang_name = "frr-use-cand-onlies"
                                    self.yang_parent_name = "frr-table"

                                    self.frr_use_cand_only = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies, self).__setattr__(name, value)


                                class FrrUseCandOnly(Entity):
                                    """
                                    Configure use candidate only to exclude
                                    interfaces as backup
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: frr_type  <key>
                                    
                                    	Computation Type
                                    	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies.FrrUseCandOnly, self).__init__()

                                        self.yang_name = "frr-use-cand-only"
                                        self.yang_parent_name = "frr-use-cand-onlies"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "frr_type") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies.FrrUseCandOnly, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies.FrrUseCandOnly, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.frr_type.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.frr_type.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-use-cand-only" + "[level='" + self.level.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.frr_type.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "frr-type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "frr-type"):
                                            self.frr_type = value
                                            self.frr_type.value_namespace = name_space
                                            self.frr_type.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_use_cand_only:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.frr_use_cand_only:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-use-cand-onlies" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-use-cand-only"):
                                        for c in self.frr_use_cand_only:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies.FrrUseCandOnly()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_use_cand_only.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-use-cand-only"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    (self.frr_load_sharings is not None and self.frr_load_sharings.has_data()) or
                                    (self.frr_remote_lfa_prefixes is not None and self.frr_remote_lfa_prefixes.has_data()) or
                                    (self.frr_tiebreakers is not None and self.frr_tiebreakers.has_data()) or
                                    (self.frr_use_cand_onlies is not None and self.frr_use_cand_onlies.has_data()) or
                                    (self.priority_limits is not None and self.priority_limits.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.frr_load_sharings is not None and self.frr_load_sharings.has_operation()) or
                                    (self.frr_remote_lfa_prefixes is not None and self.frr_remote_lfa_prefixes.has_operation()) or
                                    (self.frr_tiebreakers is not None and self.frr_tiebreakers.has_operation()) or
                                    (self.frr_use_cand_onlies is not None and self.frr_use_cand_onlies.has_operation()) or
                                    (self.priority_limits is not None and self.priority_limits.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "frr-table" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "frr-load-sharings"):
                                    if (self.frr_load_sharings is None):
                                        self.frr_load_sharings = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrLoadSharings()
                                        self.frr_load_sharings.parent = self
                                        self._children_name_map["frr_load_sharings"] = "frr-load-sharings"
                                    return self.frr_load_sharings

                                if (child_yang_name == "frr-remote-lfa-prefixes"):
                                    if (self.frr_remote_lfa_prefixes is None):
                                        self.frr_remote_lfa_prefixes = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrRemoteLfaPrefixes()
                                        self.frr_remote_lfa_prefixes.parent = self
                                        self._children_name_map["frr_remote_lfa_prefixes"] = "frr-remote-lfa-prefixes"
                                    return self.frr_remote_lfa_prefixes

                                if (child_yang_name == "frr-tiebreakers"):
                                    if (self.frr_tiebreakers is None):
                                        self.frr_tiebreakers = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrTiebreakers()
                                        self.frr_tiebreakers.parent = self
                                        self._children_name_map["frr_tiebreakers"] = "frr-tiebreakers"
                                    return self.frr_tiebreakers

                                if (child_yang_name == "frr-use-cand-onlies"):
                                    if (self.frr_use_cand_onlies is None):
                                        self.frr_use_cand_onlies = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.FrrUseCandOnlies()
                                        self.frr_use_cand_onlies.parent = self
                                        self._children_name_map["frr_use_cand_onlies"] = "frr-use-cand-onlies"
                                    return self.frr_use_cand_onlies

                                if (child_yang_name == "priority-limits"):
                                    if (self.priority_limits is None):
                                        self.priority_limits = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable.PriorityLimits()
                                        self.priority_limits.parent = self
                                        self._children_name_map["priority_limits"] = "priority-limits"
                                    return self.priority_limits

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "frr-load-sharings" or name == "frr-remote-lfa-prefixes" or name == "frr-tiebreakers" or name == "frr-use-cand-onlies" or name == "priority-limits"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class RouterId(Entity):
                            """
                            Stable IP address for system. Will only be
                            applied for the unicast sub\-address\-family.
                            
                            .. attribute:: address
                            
                            	IPv4/IPv6 address to be used as a router ID. Precisely one of Address and Interface must be specified
                            	**type**\:  str
                            
                            .. attribute:: interface_name
                            
                            	Interface with designated stable IP address to be used as a router ID. This must be a Loopback interface. Precisely one of Address and Interface must be specified
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.RouterId, self).__init__()

                                self.yang_name = "router-id"
                                self.yang_parent_name = "topology-name"

                                self.address = YLeaf(YType.str, "address")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("address",
                                                "interface_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.RouterId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.RouterId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.address.is_set or
                                    self.interface_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "router-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "address" or name == "interface-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix


                        class SpfPrefixPriorities(Entity):
                            """
                            SPF Prefix Priority configuration
                            
                            .. attribute:: spf_prefix_priority
                            
                            	Determine SPF priority for prefixes
                            	**type**\: list of    :py:class:`SpfPrefixPriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities.SpfPrefixPriority>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities, self).__init__()

                                self.yang_name = "spf-prefix-priorities"
                                self.yang_parent_name = "topology-name"

                                self.spf_prefix_priority = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities, self).__setattr__(name, value)


                            class SpfPrefixPriority(Entity):
                                """
                                Determine SPF priority for prefixes
                                
                                .. attribute:: level  <key>
                                
                                	SPF Level for prefix prioritization
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: prefix_priority_type  <key>
                                
                                	SPF Priority to assign matching prefixes
                                	**type**\:   :py:class:`IsisPrefixPriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisPrefixPriority>`
                                
                                .. attribute:: access_list_name
                                
                                	Access List to determine prefixes for this priority
                                	**type**\:  str
                                
                                .. attribute:: admin_tag
                                
                                	Tag value to determine prefixes for this priority
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities.SpfPrefixPriority, self).__init__()

                                    self.yang_name = "spf-prefix-priority"
                                    self.yang_parent_name = "spf-prefix-priorities"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.prefix_priority_type = YLeaf(YType.enumeration, "prefix-priority-type")

                                    self.access_list_name = YLeaf(YType.str, "access-list-name")

                                    self.admin_tag = YLeaf(YType.uint32, "admin-tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "prefix_priority_type",
                                                    "access_list_name",
                                                    "admin_tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities.SpfPrefixPriority, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities.SpfPrefixPriority, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.prefix_priority_type.is_set or
                                        self.access_list_name.is_set or
                                        self.admin_tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.prefix_priority_type.yfilter != YFilter.not_set or
                                        self.access_list_name.yfilter != YFilter.not_set or
                                        self.admin_tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "spf-prefix-priority" + "[level='" + self.level.get() + "']" + "[prefix-priority-type='" + self.prefix_priority_type.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.prefix_priority_type.is_set or self.prefix_priority_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_priority_type.get_name_leafdata())
                                    if (self.access_list_name.is_set or self.access_list_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.access_list_name.get_name_leafdata())
                                    if (self.admin_tag.is_set or self.admin_tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.admin_tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "prefix-priority-type" or name == "access-list-name" or name == "admin-tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-priority-type"):
                                        self.prefix_priority_type = value
                                        self.prefix_priority_type.value_namespace = name_space
                                        self.prefix_priority_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "access-list-name"):
                                        self.access_list_name = value
                                        self.access_list_name.value_namespace = name_space
                                        self.access_list_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "admin-tag"):
                                        self.admin_tag = value
                                        self.admin_tag.value_namespace = name_space
                                        self.admin_tag.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.spf_prefix_priority:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.spf_prefix_priority:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-prefix-priorities" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "spf-prefix-priority"):
                                    for c in self.spf_prefix_priority:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities.SpfPrefixPriority()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.spf_prefix_priority.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "spf-prefix-priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class SummaryPrefixes(Entity):
                            """
                            Summary\-prefix configuration
                            
                            .. attribute:: summary_prefix
                            
                            	Configure IP address prefixes to advertise
                            	**type**\: list of    :py:class:`SummaryPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes.SummaryPrefix>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes, self).__init__()

                                self.yang_name = "summary-prefixes"
                                self.yang_parent_name = "topology-name"

                                self.summary_prefix = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes, self).__setattr__(name, value)


                            class SummaryPrefix(Entity):
                                """
                                Configure IP address prefixes to advertise
                                
                                .. attribute:: address_prefix  <key>
                                
                                	IP summary address prefix
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                
                                
                                ----
                                .. attribute:: level
                                
                                	Level in which to summarize routes
                                	**type**\:  int
                                
                                	**range:** 1..2
                                
                                .. attribute:: tag
                                
                                	The tag value
                                	**type**\:  int
                                
                                	**range:** 1..4294967295
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes.SummaryPrefix, self).__init__()

                                    self.yang_name = "summary-prefix"
                                    self.yang_parent_name = "summary-prefixes"

                                    self.address_prefix = YLeaf(YType.str, "address-prefix")

                                    self.level = YLeaf(YType.uint32, "level")

                                    self.tag = YLeaf(YType.uint32, "tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address_prefix",
                                                    "level",
                                                    "tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address_prefix.is_set or
                                        self.level.is_set or
                                        self.tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address_prefix.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "summary-prefix" + "[address-prefix='" + self.address_prefix.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address_prefix.is_set or self.address_prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address_prefix.get_name_leafdata())
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address-prefix" or name == "level" or name == "tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address-prefix"):
                                        self.address_prefix = value
                                        self.address_prefix.value_namespace = name_space
                                        self.address_prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag"):
                                        self.tag = value
                                        self.tag.value_namespace = name_space
                                        self.tag.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.summary_prefix:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.summary_prefix:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "summary-prefixes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "summary-prefix"):
                                    for c in self.summary_prefix:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes.SummaryPrefix()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.summary_prefix.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "summary-prefix"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MicroLoopAvoidance(Entity):
                            """
                            Micro Loop Avoidance configuration
                            
                            .. attribute:: enable
                            
                            	MicroLoop avoidance enable configuration
                            	**type**\:   :py:class:`IsisMicroLoopAvoidance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMicroLoopAvoidance>`
                            
                            	**default value**\: micro-loop-avoidance-all
                            
                            .. attribute:: rib_update_delay
                            
                            	Value of delay in msecs in updating RIB
                            	**type**\:  int
                            
                            	**range:** 1000..65535
                            
                            	**units**\: millisecond
                            
                            	**default value**\: 5000
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.MicroLoopAvoidance, self).__init__()

                                self.yang_name = "micro-loop-avoidance"
                                self.yang_parent_name = "topology-name"

                                self.enable = YLeaf(YType.enumeration, "enable")

                                self.rib_update_delay = YLeaf(YType.uint32, "rib-update-delay")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "rib_update_delay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.MicroLoopAvoidance, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.MicroLoopAvoidance, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.rib_update_delay.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.rib_update_delay.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "micro-loop-avoidance" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.rib_update_delay.is_set or self.rib_update_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rib_update_delay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "rib-update-delay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "rib-update-delay"):
                                    self.rib_update_delay = value
                                    self.rib_update_delay.value_namespace = name_space
                                    self.rib_update_delay.value_namespace_prefix = name_space_prefix


                        class Ucmp(Entity):
                            """
                            UCMP (UnEqual Cost MultiPath) configuration
                            
                            .. attribute:: delay_interval
                            
                            	Delay in msecs between primary SPF and UCMP computation
                            	**type**\:  int
                            
                            	**range:** 100..65535
                            
                            	**units**\: millisecond
                            
                            	**default value**\: 100
                            
                            .. attribute:: enable
                            
                            	UCMP feature enable configuration
                            	**type**\:   :py:class:`Enable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.Enable>`
                            
                            .. attribute:: exclude_interfaces
                            
                            	Interfaces excluded from UCMP path computation
                            	**type**\:   :py:class:`ExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp, self).__init__()

                                self.yang_name = "ucmp"
                                self.yang_parent_name = "topology-name"

                                self.delay_interval = YLeaf(YType.uint32, "delay-interval")

                                self.enable = Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.Enable()
                                self.enable.parent = self
                                self._children_name_map["enable"] = "enable"
                                self._children_yang_names.add("enable")

                                self.exclude_interfaces = Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces()
                                self.exclude_interfaces.parent = self
                                self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                self._children_yang_names.add("exclude-interfaces")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("delay_interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp, self).__setattr__(name, value)


                            class Enable(Entity):
                                """
                                UCMP feature enable configuration
                                
                                .. attribute:: prefix_list_name
                                
                                	Name of the Prefix List
                                	**type**\:  str
                                
                                .. attribute:: variance
                                
                                	Value of variance
                                	**type**\:  int
                                
                                	**range:** 101..10000
                                
                                	**default value**\: 200
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.Enable, self).__init__()

                                    self.yang_name = "enable"
                                    self.yang_parent_name = "ucmp"

                                    self.prefix_list_name = YLeaf(YType.str, "prefix-list-name")

                                    self.variance = YLeaf(YType.uint32, "variance")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix_list_name",
                                                    "variance") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.Enable, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.Enable, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.prefix_list_name.is_set or
                                        self.variance.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix_list_name.yfilter != YFilter.not_set or
                                        self.variance.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "enable" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix_list_name.is_set or self.prefix_list_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_list_name.get_name_leafdata())
                                    if (self.variance.is_set or self.variance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.variance.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix-list-name" or name == "variance"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix-list-name"):
                                        self.prefix_list_name = value
                                        self.prefix_list_name.value_namespace = name_space
                                        self.prefix_list_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "variance"):
                                        self.variance = value
                                        self.variance.value_namespace = name_space
                                        self.variance.value_namespace_prefix = name_space_prefix


                            class ExcludeInterfaces(Entity):
                                """
                                Interfaces excluded from UCMP path
                                computation
                                
                                .. attribute:: exclude_interface
                                
                                	Exclude this interface from UCMP path computation
                                	**type**\: list of    :py:class:`ExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces.ExcludeInterface>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces, self).__init__()

                                    self.yang_name = "exclude-interfaces"
                                    self.yang_parent_name = "ucmp"

                                    self.exclude_interface = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces, self).__setattr__(name, value)


                                class ExcludeInterface(Entity):
                                    """
                                    Exclude this interface from UCMP path
                                    computation
                                    
                                    .. attribute:: interface_name  <key>
                                    
                                    	Name of the interface to be excluded
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces.ExcludeInterface, self).__init__()

                                        self.yang_name = "exclude-interface"
                                        self.yang_parent_name = "exclude-interfaces"

                                        self.interface_name = YLeaf(YType.str, "interface-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("interface_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces.ExcludeInterface, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.interface_name.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.interface_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interface-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "interface-name"):
                                            self.interface_name = value
                                            self.interface_name.value_namespace = name_space
                                            self.interface_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.exclude_interface:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.exclude_interface:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exclude-interfaces" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "exclude-interface"):
                                        for c in self.exclude_interface:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces.ExcludeInterface()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.exclude_interface.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.delay_interval.is_set or
                                    (self.enable is not None and self.enable.has_data()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.delay_interval.yfilter != YFilter.not_set or
                                    (self.enable is not None and self.enable.has_operation()) or
                                    (self.exclude_interfaces is not None and self.exclude_interfaces.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ucmp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.delay_interval.is_set or self.delay_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay_interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "enable"):
                                    if (self.enable is None):
                                        self.enable = Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.Enable()
                                        self.enable.parent = self
                                        self._children_name_map["enable"] = "enable"
                                    return self.enable

                                if (child_yang_name == "exclude-interfaces"):
                                    if (self.exclude_interfaces is None):
                                        self.exclude_interfaces = Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp.ExcludeInterfaces()
                                        self.exclude_interfaces.parent = self
                                        self._children_name_map["exclude_interfaces"] = "exclude-interfaces"
                                    return self.exclude_interfaces

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "exclude-interfaces" or name == "delay-interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "delay-interval"):
                                    self.delay_interval = value
                                    self.delay_interval.value_namespace = name_space
                                    self.delay_interval.value_namespace_prefix = name_space_prefix


                        class MaxRedistPrefixes(Entity):
                            """
                            Maximum number of redistributed
                            prefixesconfiguration
                            
                            .. attribute:: max_redist_prefix
                            
                            	An upper limit on the number of redistributed prefixes which may be included in the local system's LSP
                            	**type**\: list of    :py:class:`MaxRedistPrefix <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes.MaxRedistPrefix>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes, self).__init__()

                                self.yang_name = "max-redist-prefixes"
                                self.yang_parent_name = "topology-name"

                                self.max_redist_prefix = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes, self).__setattr__(name, value)


                            class MaxRedistPrefix(Entity):
                                """
                                An upper limit on the number of
                                redistributed prefixes which may be
                                included in the local system's LSP
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: prefix_limit
                                
                                	Max number of prefixes
                                	**type**\:  int
                                
                                	**range:** 1..28000
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes.MaxRedistPrefix, self).__init__()

                                    self.yang_name = "max-redist-prefix"
                                    self.yang_parent_name = "max-redist-prefixes"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.prefix_limit = YLeaf(YType.uint32, "prefix-limit")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "prefix_limit") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes.MaxRedistPrefix, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes.MaxRedistPrefix, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.prefix_limit.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.prefix_limit.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "max-redist-prefix" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.prefix_limit.is_set or self.prefix_limit.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_limit.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "prefix-limit"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-limit"):
                                        self.prefix_limit = value
                                        self.prefix_limit.value_namespace = name_space
                                        self.prefix_limit.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.max_redist_prefix:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.max_redist_prefix:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "max-redist-prefixes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "max-redist-prefix"):
                                    for c in self.max_redist_prefix:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes.MaxRedistPrefix()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.max_redist_prefix.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-redist-prefix"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Propagations(Entity):
                            """
                            Route propagation configuration
                            
                            .. attribute:: propagation
                            
                            	Propagate routes between IS\-IS levels
                            	**type**\: list of    :py:class:`Propagation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Propagations.Propagation>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Propagations, self).__init__()

                                self.yang_name = "propagations"
                                self.yang_parent_name = "topology-name"

                                self.propagation = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Propagations, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Propagations, self).__setattr__(name, value)


                            class Propagation(Entity):
                                """
                                Propagate routes between IS\-IS levels
                                
                                .. attribute:: source_level  <key>
                                
                                	Source level for routes
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: destination_level  <key>
                                
                                	Destination level for routes.  Must differ from SourceLevel
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: route_policy_name
                                
                                	Route policy limiting routes to be propagated
                                	**type**\:  str
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Propagations.Propagation, self).__init__()

                                    self.yang_name = "propagation"
                                    self.yang_parent_name = "propagations"

                                    self.source_level = YLeaf(YType.enumeration, "source-level")

                                    self.destination_level = YLeaf(YType.enumeration, "destination-level")

                                    self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("source_level",
                                                    "destination_level",
                                                    "route_policy_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Propagations.Propagation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Propagations.Propagation, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.source_level.is_set or
                                        self.destination_level.is_set or
                                        self.route_policy_name.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.source_level.yfilter != YFilter.not_set or
                                        self.destination_level.yfilter != YFilter.not_set or
                                        self.route_policy_name.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "propagation" + "[source-level='" + self.source_level.get() + "']" + "[destination-level='" + self.destination_level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.source_level.is_set or self.source_level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source_level.get_name_leafdata())
                                    if (self.destination_level.is_set or self.destination_level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.destination_level.get_name_leafdata())
                                    if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "source-level" or name == "destination-level" or name == "route-policy-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "source-level"):
                                        self.source_level = value
                                        self.source_level.value_namespace = name_space
                                        self.source_level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "destination-level"):
                                        self.destination_level = value
                                        self.destination_level.value_namespace = name_space
                                        self.destination_level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "route-policy-name"):
                                        self.route_policy_name = value
                                        self.route_policy_name.value_namespace = name_space
                                        self.route_policy_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.propagation:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.propagation:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "propagations" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "propagation"):
                                    for c in self.propagation:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.Propagations.Propagation()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.propagation.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "propagation"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Redistributions(Entity):
                            """
                            Protocol redistribution configuration
                            
                            .. attribute:: redistribution
                            
                            	Redistribution of other protocols into this IS\-IS instance
                            	**type**\: list of    :py:class:`Redistribution <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions, self).__init__()

                                self.yang_name = "redistributions"
                                self.yang_parent_name = "topology-name"

                                self.redistribution = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions, self).__setattr__(name, value)


                            class Redistribution(Entity):
                                """
                                Redistribution of other protocols into
                                this IS\-IS instance
                                
                                .. attribute:: protocol_name  <key>
                                
                                	The protocol to be redistributed.  OSPFv3 may not be specified for an IPv4 topology and OSPF may not be specified for an IPv6 topology
                                	**type**\:   :py:class:`IsisRedistProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisRedistProto>`
                                
                                .. attribute:: bgp
                                
                                	bgp
                                	**type**\: list of    :py:class:`Bgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Bgp>`
                                
                                .. attribute:: connected_or_static_or_rip_or_subscriber_or_mobile
                                
                                	connected or static or rip or subscriber or mobile
                                	**type**\:   :py:class:`ConnectedOrStaticOrRipOrSubscriberOrMobile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: eigrp
                                
                                	eigrp
                                	**type**\: list of    :py:class:`Eigrp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Eigrp>`
                                
                                .. attribute:: ospf_or_ospfv3_or_isis_or_application
                                
                                	ospf or ospfv3 or isis or application
                                	**type**\: list of    :py:class:`OspfOrOspfv3OrIsisOrApplication <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution, self).__init__()

                                    self.yang_name = "redistribution"
                                    self.yang_parent_name = "redistributions"

                                    self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                                    self.connected_or_static_or_rip_or_subscriber_or_mobile = None
                                    self._children_name_map["connected_or_static_or_rip_or_subscriber_or_mobile"] = "connected-or-static-or-rip-or-subscriber-or-mobile"
                                    self._children_yang_names.add("connected-or-static-or-rip-or-subscriber-or-mobile")

                                    self.bgp = YList(self)
                                    self.eigrp = YList(self)
                                    self.ospf_or_ospfv3_or_isis_or_application = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("protocol_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution, self).__setattr__(name, value)


                                class ConnectedOrStaticOrRipOrSubscriberOrMobile(Entity):
                                    """
                                    connected or static or rip or subscriber
                                    or mobile
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile, self).__init__()

                                        self.yang_name = "connected-or-static-or-rip-or-subscriber-or-mobile"
                                        self.yang_parent_name = "redistribution"
                                        self.is_presence_container = True

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "connected-or-static-or-rip-or-subscriber-or-mobile" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix


                                class OspfOrOspfv3OrIsisOrApplication(Entity):
                                    """
                                    ospf or ospfv3 or isis or application
                                    
                                    .. attribute:: instance_name  <key>
                                    
                                    	Protocol Instance Identifier.  Mandatory for ISIS, OSPF and application, must not be specified otherwise
                                    	**type**\:  str
                                    
                                    	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication, self).__init__()

                                        self.yang_name = "ospf-or-ospfv3-or-isis-or-application"
                                        self.yang_parent_name = "redistribution"

                                        self.instance_name = YLeaf(YType.str, "instance-name")

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("instance_name",
                                                        "levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.instance_name.is_set or
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.instance_name.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ospf-or-ospfv3-or-isis-or-application" + "[instance-name='" + self.instance_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.instance_name.is_set or self.instance_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.instance_name.get_name_leafdata())
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "instance-name" or name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "instance-name"):
                                            self.instance_name = value
                                            self.instance_name.value_namespace = name_space
                                            self.instance_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix


                                class Bgp(Entity):
                                    """
                                    bgp
                                    
                                    .. attribute:: as_xx  <key>
                                    
                                    	First half of BGP AS number in XX.YY format.  Mandatory if Protocol is BGP and must not be specified otherwise. Must be a non\-zero value if second half is zero
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: as_yy  <key>
                                    
                                    	Second half of BGP AS number in XX.YY format. Mandatory if Protocol is BGP and must not be specified otherwise. Must be a non\-zero value if first half is zero
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Bgp, self).__init__()

                                        self.yang_name = "bgp"
                                        self.yang_parent_name = "redistribution"

                                        self.as_xx = YLeaf(YType.uint32, "as-xx")

                                        self.as_yy = YLeaf(YType.uint32, "as-yy")

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("as_xx",
                                                        "as_yy",
                                                        "levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Bgp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Bgp, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.as_xx.is_set or
                                            self.as_yy.is_set or
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.as_xx.yfilter != YFilter.not_set or
                                            self.as_yy.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bgp" + "[as-xx='" + self.as_xx.get() + "']" + "[as-yy='" + self.as_yy.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_xx.get_name_leafdata())
                                        if (self.as_yy.is_set or self.as_yy.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_yy.get_name_leafdata())
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "as-xx" or name == "as-yy" or name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "as-xx"):
                                            self.as_xx = value
                                            self.as_xx.value_namespace = name_space
                                            self.as_xx.value_namespace_prefix = name_space_prefix
                                        if(value_path == "as-yy"):
                                            self.as_yy = value
                                            self.as_yy.value_namespace = name_space
                                            self.as_yy.value_namespace_prefix = name_space_prefix
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix


                                class Eigrp(Entity):
                                    """
                                    eigrp
                                    
                                    .. attribute:: as_zz  <key>
                                    
                                    	Eigrp as number
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    .. attribute:: levels
                                    
                                    	Levels to redistribute routes into
                                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                                    
                                    .. attribute:: metric
                                    
                                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	IS\-IS metric type
                                    	**type**\:   :py:class:`IsisMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisMetric>`
                                    
                                    .. attribute:: ospf_route_type
                                    
                                    	OSPF route types to redistribute.  May only be specified if Protocol is OSPF
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: route_policy_name
                                    
                                    	Route policy to control redistribution
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Eigrp, self).__init__()

                                        self.yang_name = "eigrp"
                                        self.yang_parent_name = "redistribution"

                                        self.as_zz = YLeaf(YType.uint32, "as-zz")

                                        self.levels = YLeaf(YType.enumeration, "levels")

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                        self.ospf_route_type = YLeaf(YType.int32, "ospf-route-type")

                                        self.route_policy_name = YLeaf(YType.str, "route-policy-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("as_zz",
                                                        "levels",
                                                        "metric",
                                                        "metric_type",
                                                        "ospf_route_type",
                                                        "route_policy_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Eigrp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Eigrp, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.as_zz.is_set or
                                            self.levels.is_set or
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.ospf_route_type.is_set or
                                            self.route_policy_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.as_zz.yfilter != YFilter.not_set or
                                            self.levels.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.ospf_route_type.yfilter != YFilter.not_set or
                                            self.route_policy_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "eigrp" + "[as-zz='" + self.as_zz.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.as_zz.is_set or self.as_zz.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_zz.get_name_leafdata())
                                        if (self.levels.is_set or self.levels.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.levels.get_name_leafdata())
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.ospf_route_type.is_set or self.ospf_route_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ospf_route_type.get_name_leafdata())
                                        if (self.route_policy_name.is_set or self.route_policy_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_policy_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "as-zz" or name == "levels" or name == "metric" or name == "metric-type" or name == "ospf-route-type" or name == "route-policy-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "as-zz"):
                                            self.as_zz = value
                                            self.as_zz.value_namespace = name_space
                                            self.as_zz.value_namespace_prefix = name_space_prefix
                                        if(value_path == "levels"):
                                            self.levels = value
                                            self.levels.value_namespace = name_space
                                            self.levels.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ospf-route-type"):
                                            self.ospf_route_type = value
                                            self.ospf_route_type.value_namespace = name_space
                                            self.ospf_route_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-policy-name"):
                                            self.route_policy_name = value
                                            self.route_policy_name.value_namespace = name_space
                                            self.route_policy_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.bgp:
                                        if (c.has_data()):
                                            return True
                                    for c in self.eigrp:
                                        if (c.has_data()):
                                            return True
                                    for c in self.ospf_or_ospfv3_or_isis_or_application:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.protocol_name.is_set or
                                        (self.connected_or_static_or_rip_or_subscriber_or_mobile is not None))

                                def has_operation(self):
                                    for c in self.bgp:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.eigrp:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.ospf_or_ospfv3_or_isis_or_application:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.protocol_name.yfilter != YFilter.not_set or
                                        (self.connected_or_static_or_rip_or_subscriber_or_mobile is not None and self.connected_or_static_or_rip_or_subscriber_or_mobile.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "redistribution" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.protocol_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "bgp"):
                                        for c in self.bgp:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Bgp()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.bgp.append(c)
                                        return c

                                    if (child_yang_name == "connected-or-static-or-rip-or-subscriber-or-mobile"):
                                        if (self.connected_or_static_or_rip_or_subscriber_or_mobile is None):
                                            self.connected_or_static_or_rip_or_subscriber_or_mobile = Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.ConnectedOrStaticOrRipOrSubscriberOrMobile()
                                            self.connected_or_static_or_rip_or_subscriber_or_mobile.parent = self
                                            self._children_name_map["connected_or_static_or_rip_or_subscriber_or_mobile"] = "connected-or-static-or-rip-or-subscriber-or-mobile"
                                        return self.connected_or_static_or_rip_or_subscriber_or_mobile

                                    if (child_yang_name == "eigrp"):
                                        for c in self.eigrp:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.Eigrp()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.eigrp.append(c)
                                        return c

                                    if (child_yang_name == "ospf-or-ospfv3-or-isis-or-application"):
                                        for c in self.ospf_or_ospfv3_or_isis_or_application:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution.OspfOrOspfv3OrIsisOrApplication()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.ospf_or_ospfv3_or_isis_or_application.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bgp" or name == "connected-or-static-or-rip-or-subscriber-or-mobile" or name == "eigrp" or name == "ospf-or-ospfv3-or-isis-or-application" or name == "protocol-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "protocol-name"):
                                        self.protocol_name = value
                                        self.protocol_name.value_namespace = name_space
                                        self.protocol_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.redistribution:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.redistribution:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "redistributions" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "redistribution"):
                                    for c in self.redistribution:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions.Redistribution()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.redistribution.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "redistribution"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class SpfPeriodicIntervals(Entity):
                            """
                            Peoridic SPF configuration
                            
                            .. attribute:: spf_periodic_interval
                            
                            	Maximum interval between spf runs
                            	**type**\: list of    :py:class:`SpfPeriodicInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals.SpfPeriodicInterval>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals, self).__init__()

                                self.yang_name = "spf-periodic-intervals"
                                self.yang_parent_name = "topology-name"

                                self.spf_periodic_interval = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals, self).__setattr__(name, value)


                            class SpfPeriodicInterval(Entity):
                                """
                                Maximum interval between spf runs
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: periodic_interval
                                
                                	Maximum interval in between SPF runs in seconds
                                	**type**\:  int
                                
                                	**range:** 0..3600
                                
                                	**mandatory**\: True
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals.SpfPeriodicInterval, self).__init__()

                                    self.yang_name = "spf-periodic-interval"
                                    self.yang_parent_name = "spf-periodic-intervals"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.periodic_interval = YLeaf(YType.uint32, "periodic-interval")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "periodic_interval") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals.SpfPeriodicInterval, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals.SpfPeriodicInterval, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.periodic_interval.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.periodic_interval.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "spf-periodic-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.periodic_interval.is_set or self.periodic_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.periodic_interval.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "periodic-interval"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "periodic-interval"):
                                        self.periodic_interval = value
                                        self.periodic_interval.value_namespace = name_space
                                        self.periodic_interval.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.spf_periodic_interval:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.spf_periodic_interval:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-periodic-intervals" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "spf-periodic-interval"):
                                    for c in self.spf_periodic_interval:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals.SpfPeriodicInterval()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.spf_periodic_interval.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "spf-periodic-interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class SpfIntervals(Entity):
                            """
                            SPF\-interval configuration
                            
                            .. attribute:: spf_interval
                            
                            	Route calculation scheduling parameters
                            	**type**\: list of    :py:class:`SpfInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals.SpfInterval>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals, self).__init__()

                                self.yang_name = "spf-intervals"
                                self.yang_parent_name = "topology-name"

                                self.spf_interval = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals, self).__setattr__(name, value)


                            class SpfInterval(Entity):
                                """
                                Route calculation scheduling parameters
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: initial_wait
                                
                                	Initial wait before running a route calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..120000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: maximum_wait
                                
                                	Maximum wait before running a route calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..120000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: secondary_wait
                                
                                	Secondary wait before running a route calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..120000
                                
                                	**units**\: millisecond
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals.SpfInterval, self).__init__()

                                    self.yang_name = "spf-interval"
                                    self.yang_parent_name = "spf-intervals"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.initial_wait = YLeaf(YType.uint32, "initial-wait")

                                    self.maximum_wait = YLeaf(YType.uint32, "maximum-wait")

                                    self.secondary_wait = YLeaf(YType.uint32, "secondary-wait")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "initial_wait",
                                                    "maximum_wait",
                                                    "secondary_wait") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals.SpfInterval, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals.SpfInterval, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.initial_wait.is_set or
                                        self.maximum_wait.is_set or
                                        self.secondary_wait.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.initial_wait.yfilter != YFilter.not_set or
                                        self.maximum_wait.yfilter != YFilter.not_set or
                                        self.secondary_wait.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "spf-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.initial_wait.is_set or self.initial_wait.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.initial_wait.get_name_leafdata())
                                    if (self.maximum_wait.is_set or self.maximum_wait.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.maximum_wait.get_name_leafdata())
                                    if (self.secondary_wait.is_set or self.secondary_wait.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.secondary_wait.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "initial-wait" or name == "maximum-wait" or name == "secondary-wait"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "initial-wait"):
                                        self.initial_wait = value
                                        self.initial_wait.value_namespace = name_space
                                        self.initial_wait.value_namespace_prefix = name_space_prefix
                                    if(value_path == "maximum-wait"):
                                        self.maximum_wait = value
                                        self.maximum_wait.value_namespace = name_space
                                        self.maximum_wait.value_namespace_prefix = name_space_prefix
                                    if(value_path == "secondary-wait"):
                                        self.secondary_wait = value
                                        self.secondary_wait.value_namespace = name_space
                                        self.secondary_wait.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.spf_interval:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.spf_interval:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-intervals" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "spf-interval"):
                                    for c in self.spf_interval:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals.SpfInterval()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.spf_interval.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "spf-interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MonitorConvergence(Entity):
                            """
                            Enable convergence monitoring
                            
                            .. attribute:: enable
                            
                            	Enable convergence monitoring
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: prefix_list
                            
                            	Enable the monitoring of individual prefixes (prefix list name)
                            	**type**\:  str
                            
                            .. attribute:: track_ip_frr
                            
                            	Enable the Tracking of IP\-Frr Convergence
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.MonitorConvergence, self).__init__()

                                self.yang_name = "monitor-convergence"
                                self.yang_parent_name = "topology-name"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.prefix_list = YLeaf(YType.str, "prefix-list")

                                self.track_ip_frr = YLeaf(YType.empty, "track-ip-frr")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "prefix_list",
                                                "track_ip_frr") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.MonitorConvergence, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.MonitorConvergence, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.prefix_list.is_set or
                                    self.track_ip_frr.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.prefix_list.yfilter != YFilter.not_set or
                                    self.track_ip_frr.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "monitor-convergence" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_list.get_name_leafdata())
                                if (self.track_ip_frr.is_set or self.track_ip_frr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.track_ip_frr.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "prefix-list" or name == "track-ip-frr"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-list"):
                                    self.prefix_list = value
                                    self.prefix_list.value_namespace = name_space
                                    self.prefix_list.value_namespace_prefix = name_space_prefix
                                if(value_path == "track-ip-frr"):
                                    self.track_ip_frr = value
                                    self.track_ip_frr.value_namespace = name_space
                                    self.track_ip_frr.value_namespace_prefix = name_space_prefix


                        class DefaultInformation(Entity):
                            """
                            Control origination of a default route with
                            the option of using a policy.  If no policy
                            is specified the default route is
                            advertised with zero cost in level 2 only.
                            
                            .. attribute:: external
                            
                            	Flag to indicate that the default prefix should be originated as an external route
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: policy_name
                            
                            	Policy name
                            	**type**\:  str
                            
                            .. attribute:: use_policy
                            
                            	Flag to indicate whether default origination is controlled using a policy
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.DefaultInformation, self).__init__()

                                self.yang_name = "default-information"
                                self.yang_parent_name = "topology-name"

                                self.external = YLeaf(YType.empty, "external")

                                self.policy_name = YLeaf(YType.str, "policy-name")

                                self.use_policy = YLeaf(YType.boolean, "use-policy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("external",
                                                "policy_name",
                                                "use_policy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.DefaultInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.DefaultInformation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.external.is_set or
                                    self.policy_name.is_set or
                                    self.use_policy.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.external.yfilter != YFilter.not_set or
                                    self.policy_name.yfilter != YFilter.not_set or
                                    self.use_policy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "default-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.external.is_set or self.external.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external.get_name_leafdata())
                                if (self.policy_name.is_set or self.policy_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.policy_name.get_name_leafdata())
                                if (self.use_policy.is_set or self.use_policy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.use_policy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "external" or name == "policy-name" or name == "use-policy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "external"):
                                    self.external = value
                                    self.external.value_namespace = name_space
                                    self.external.value_namespace_prefix = name_space_prefix
                                if(value_path == "policy-name"):
                                    self.policy_name = value
                                    self.policy_name.value_namespace = name_space
                                    self.policy_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "use-policy"):
                                    self.use_policy = value
                                    self.use_policy.value_namespace = name_space
                                    self.use_policy.value_namespace_prefix = name_space_prefix


                        class AdminDistances(Entity):
                            """
                            Per\-route administrative
                            distanceconfiguration
                            
                            .. attribute:: admin_distance
                            
                            	Administrative distance configuration. The supplied distance is applied to all routes discovered from the specified source, or only those that match the supplied prefix list if this is specified
                            	**type**\: list of    :py:class:`AdminDistance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances.AdminDistance>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances, self).__init__()

                                self.yang_name = "admin-distances"
                                self.yang_parent_name = "topology-name"

                                self.admin_distance = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances, self).__setattr__(name, value)


                            class AdminDistance(Entity):
                                """
                                Administrative distance configuration. The
                                supplied distance is applied to all routes
                                discovered from the specified source, or
                                only those that match the supplied prefix
                                list if this is specified
                                
                                .. attribute:: address_prefix  <key>
                                
                                	IP route source prefix
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                
                                
                                ----
                                .. attribute:: distance
                                
                                	Administrative distance
                                	**type**\:  int
                                
                                	**range:** 1..255
                                
                                	**mandatory**\: True
                                
                                .. attribute:: prefix_list
                                
                                	List of prefixes to which this distance applies
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances.AdminDistance, self).__init__()

                                    self.yang_name = "admin-distance"
                                    self.yang_parent_name = "admin-distances"

                                    self.address_prefix = YLeaf(YType.str, "address-prefix")

                                    self.distance = YLeaf(YType.uint32, "distance")

                                    self.prefix_list = YLeaf(YType.str, "prefix-list")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address_prefix",
                                                    "distance",
                                                    "prefix_list") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances.AdminDistance, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances.AdminDistance, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address_prefix.is_set or
                                        self.distance.is_set or
                                        self.prefix_list.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address_prefix.yfilter != YFilter.not_set or
                                        self.distance.yfilter != YFilter.not_set or
                                        self.prefix_list.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "admin-distance" + "[address-prefix='" + self.address_prefix.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address_prefix.is_set or self.address_prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address_prefix.get_name_leafdata())
                                    if (self.distance.is_set or self.distance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.distance.get_name_leafdata())
                                    if (self.prefix_list.is_set or self.prefix_list.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_list.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address-prefix" or name == "distance" or name == "prefix-list"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address-prefix"):
                                        self.address_prefix = value
                                        self.address_prefix.value_namespace = name_space
                                        self.address_prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "distance"):
                                        self.distance = value
                                        self.distance.value_namespace = name_space
                                        self.distance.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-list"):
                                        self.prefix_list = value
                                        self.prefix_list.value_namespace = name_space
                                        self.prefix_list.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.admin_distance:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.admin_distance:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "admin-distances" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "admin-distance"):
                                    for c in self.admin_distance:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances.AdminDistance()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.admin_distance.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "admin-distance"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Ispf(Entity):
                            """
                            ISPF configuration
                            
                            .. attribute:: states
                            
                            	ISPF state (enable/disable)
                            	**type**\:   :py:class:`States <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Ispf, self).__init__()

                                self.yang_name = "ispf"
                                self.yang_parent_name = "topology-name"

                                self.states = Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States()
                                self.states.parent = self
                                self._children_name_map["states"] = "states"
                                self._children_yang_names.add("states")


                            class States(Entity):
                                """
                                ISPF state (enable/disable)
                                
                                .. attribute:: state
                                
                                	Enable/disable ISPF
                                	**type**\: list of    :py:class:`State <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States.State>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States, self).__init__()

                                    self.yang_name = "states"
                                    self.yang_parent_name = "ispf"

                                    self.state = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States, self).__setattr__(name, value)


                                class State(Entity):
                                    """
                                    Enable/disable ISPF
                                    
                                    .. attribute:: level  <key>
                                    
                                    	Level to which configuration applies
                                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                    
                                    .. attribute:: state
                                    
                                    	State
                                    	**type**\:   :py:class:`IsisispfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisispfState>`
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States.State, self).__init__()

                                        self.yang_name = "state"
                                        self.yang_parent_name = "states"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.state = YLeaf(YType.enumeration, "state")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "state") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States.State, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States.State, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.state.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.state.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "state" + "[level='" + self.level.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.state.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "state"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "state"):
                                            self.state = value
                                            self.state.value_namespace = name_space
                                            self.state.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.state:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.state:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "states" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "state"):
                                        for c in self.state:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States.State()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.state.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "state"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (self.states is not None and self.states.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.states is not None and self.states.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ispf" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "states"):
                                    if (self.states is None):
                                        self.states = Isis.Instances.Instance.Afs.Af.TopologyName.Ispf.States()
                                        self.states.parent = self
                                        self._children_name_map["states"] = "states"
                                    return self.states

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "states"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MplsLdpGlobal(Entity):
                            """
                            MPLS LDP configuration. MPLS LDP
                            configuration will only be applied for the
                            IPv4\-unicast address\-family.
                            
                            .. attribute:: auto_config
                            
                            	If TRUE, LDP will be enabled onall IS\-IS interfaces enabled for this address\-family
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.MplsLdpGlobal, self).__init__()

                                self.yang_name = "mpls-ldp-global"
                                self.yang_parent_name = "topology-name"

                                self.auto_config = YLeaf(YType.boolean, "auto-config")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("auto_config") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.MplsLdpGlobal, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.MplsLdpGlobal, self).__setattr__(name, value)

                            def has_data(self):
                                return self.auto_config.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.auto_config.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-ldp-global" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.auto_config.is_set or self.auto_config.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_config.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto-config"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "auto-config"):
                                    self.auto_config = value
                                    self.auto_config.value_namespace = name_space
                                    self.auto_config.value_namespace_prefix = name_space_prefix


                        class Mpls(Entity):
                            """
                            MPLS configuration. MPLS configuration will
                            only be applied for the IPv4\-unicast
                            address\-family.
                            
                            .. attribute:: igp_intact
                            
                            	Install TE and non\-TE nexthops in the RIB
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: level
                            
                            	Enable MPLS for an IS\-IS at the given levels
                            	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                            
                            .. attribute:: multicast_intact
                            
                            	Install non\-TE nexthops in the RIB for use by multicast
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: router_id
                            
                            	Traffic Engineering stable IP address for system
                            	**type**\:   :py:class:`RouterId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Mpls.RouterId>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Mpls, self).__init__()

                                self.yang_name = "mpls"
                                self.yang_parent_name = "topology-name"

                                self.igp_intact = YLeaf(YType.empty, "igp-intact")

                                self.level = YLeaf(YType.enumeration, "level")

                                self.multicast_intact = YLeaf(YType.empty, "multicast-intact")

                                self.router_id = Isis.Instances.Instance.Afs.Af.TopologyName.Mpls.RouterId()
                                self.router_id.parent = self
                                self._children_name_map["router_id"] = "router-id"
                                self._children_yang_names.add("router-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("igp_intact",
                                                "level",
                                                "multicast_intact") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Mpls, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Mpls, self).__setattr__(name, value)


                            class RouterId(Entity):
                                """
                                Traffic Engineering stable IP address for
                                system
                                
                                .. attribute:: address
                                
                                	IPv4 address to be used as a router ID. Precisely one of Address and Interface must be specified
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: interface_name
                                
                                	Interface with designated stable IP address to be used as a router ID. This must be a Loopback interface. Precisely one of Address and Interface must be specified
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Mpls.RouterId, self).__init__()

                                    self.yang_name = "router-id"
                                    self.yang_parent_name = "mpls"

                                    self.address = YLeaf(YType.str, "address")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address",
                                                    "interface_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Mpls.RouterId, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Mpls.RouterId, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address.is_set or
                                        self.interface_name.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "router-id" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address" or name == "interface-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address"):
                                        self.address = value
                                        self.address.value_namespace = name_space
                                        self.address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.igp_intact.is_set or
                                    self.level.is_set or
                                    self.multicast_intact.is_set or
                                    (self.router_id is not None and self.router_id.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.igp_intact.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.multicast_intact.yfilter != YFilter.not_set or
                                    (self.router_id is not None and self.router_id.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.igp_intact.is_set or self.igp_intact.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.igp_intact.get_name_leafdata())
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.multicast_intact.is_set or self.multicast_intact.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_intact.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "router-id"):
                                    if (self.router_id is None):
                                        self.router_id = Isis.Instances.Instance.Afs.Af.TopologyName.Mpls.RouterId()
                                        self.router_id.parent = self
                                        self._children_name_map["router_id"] = "router-id"
                                    return self.router_id

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "router-id" or name == "igp-intact" or name == "level" or name == "multicast-intact"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "igp-intact"):
                                    self.igp_intact = value
                                    self.igp_intact.value_namespace = name_space
                                    self.igp_intact.value_namespace_prefix = name_space_prefix
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-intact"):
                                    self.multicast_intact = value
                                    self.multicast_intact.value_namespace = name_space
                                    self.multicast_intact.value_namespace_prefix = name_space_prefix


                        class Metrics(Entity):
                            """
                            Metric configuration
                            
                            .. attribute:: metric
                            
                            	Metric configuration. Legal value depends on the metric\-style specified for the topology. If the metric\-style defined is narrow, then only a value between <1\-63> is allowed and if the metric\-style is defined as wide, then a value between <1\-16777215> is allowed as the metric value.  All routers exclude links with the maximum wide metric (16777215) from their SPF
                            	**type**\: list of    :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Metrics.Metric>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Metrics, self).__init__()

                                self.yang_name = "metrics"
                                self.yang_parent_name = "topology-name"

                                self.metric = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Metrics, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Metrics, self).__setattr__(name, value)


                            class Metric(Entity):
                                """
                                Metric configuration. Legal value depends on
                                the metric\-style specified for the topology. If
                                the metric\-style defined is narrow, then only a
                                value between <1\-63> is allowed and if the
                                metric\-style is defined as wide, then a value
                                between <1\-16777215> is allowed as the metric
                                value.  All routers exclude links with the
                                maximum wide metric (16777215) from their SPF
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: metric
                                
                                	Allowed metric\: <1\-63> for narrow, <1\-16777215> for wide
                                	**type**\: one of the below types:
                                
                                	**type**\:   :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric.Metric>`
                                
                                	**mandatory**\: True
                                
                                
                                ----
                                	**type**\:  int
                                
                                	**range:** 1..16777215
                                
                                	**mandatory**\: True
                                
                                
                                ----
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Metrics.Metric, self).__init__()

                                    self.yang_name = "metric"
                                    self.yang_parent_name = "metrics"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.metric = YLeaf(YType.str, "metric")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "metric") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Metrics.Metric, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Metrics.Metric, self).__setattr__(name, value)

                                class Metric(Enum):
                                    """
                                    Metric

                                    Allowed metric\: <1\-63> for narrow,

                                    <1\-16777215> for wide

                                    .. data:: maximum = 16777215

                                    	Maximum wide metric.  All routers will

                                    	exclude this link from their SPF

                                    """

                                    maximum = Enum.YLeaf(16777215, "maximum")


                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.metric.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.metric.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "metric" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "metric"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric"):
                                        self.metric = value
                                        self.metric.value_namespace = name_space
                                        self.metric.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.metric:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.metric:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "metrics" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "metric"):
                                    for c in self.metric:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.Metrics.Metric()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.metric.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Weights(Entity):
                            """
                            Weight configuration
                            
                            .. attribute:: weight
                            
                            	Weight configuration under interface for load balancing
                            	**type**\: list of    :py:class:`Weight <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Afs.Af.TopologyName.Weights.Weight>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Weights, self).__init__()

                                self.yang_name = "weights"
                                self.yang_parent_name = "topology-name"

                                self.weight = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Weights, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Afs.Af.TopologyName.Weights, self).__setattr__(name, value)


                            class Weight(Entity):
                                """
                                Weight configuration under interface for load
                                balancing
                                
                                .. attribute:: level  <key>
                                
                                	Level to which configuration applies
                                	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                
                                .. attribute:: weight
                                
                                	Weight to be configured under interface for Load Balancing. Allowed weight\: <1\-16777215>
                                	**type**\:  int
                                
                                	**range:** 1..16777214
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Afs.Af.TopologyName.Weights.Weight, self).__init__()

                                    self.yang_name = "weight"
                                    self.yang_parent_name = "weights"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.weight = YLeaf(YType.uint32, "weight")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "weight") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Afs.Af.TopologyName.Weights.Weight, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Afs.Af.TopologyName.Weights.Weight, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.level.is_set or
                                        self.weight.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.weight.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "weight" + "[level='" + self.level.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.weight.is_set or self.weight.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.weight.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "level" or name == "weight"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "weight"):
                                        self.weight = value
                                        self.weight.value_namespace = name_space
                                        self.weight.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.weight:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.weight:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "weights" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "weight"):
                                    for c in self.weight:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Afs.Af.TopologyName.Weights.Weight()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.weight.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "weight"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.topology_name.is_set or
                                self.adjacency_check.is_set or
                                self.advertise_link_attributes.is_set or
                                self.advertise_passive_only.is_set or
                                self.apply_weight.is_set or
                                self.attached_bit.is_set or
                                self.default_admin_distance.is_set or
                                self.ignore_attached_bit.is_set or
                                self.maximum_paths.is_set or
                                self.route_source_first_hop.is_set or
                                self.single_topology.is_set or
                                self.topology_id.is_set or
                                (self.admin_distances is not None and self.admin_distances.has_data()) or
                                (self.default_information is not None and self.default_information.has_data()) or
                                (self.frr_table is not None and self.frr_table.has_data()) or
                                (self.ispf is not None and self.ispf.has_data()) or
                                (self.max_redist_prefixes is not None and self.max_redist_prefixes.has_data()) or
                                (self.metric_styles is not None and self.metric_styles.has_data()) or
                                (self.metrics is not None and self.metrics.has_data()) or
                                (self.micro_loop_avoidance is not None and self.micro_loop_avoidance.has_data()) or
                                (self.monitor_convergence is not None and self.monitor_convergence.has_data()) or
                                (self.mpls is not None and self.mpls.has_data()) or
                                (self.mpls_ldp_global is not None and self.mpls_ldp_global.has_data()) or
                                (self.propagations is not None and self.propagations.has_data()) or
                                (self.redistributions is not None and self.redistributions.has_data()) or
                                (self.router_id is not None and self.router_id.has_data()) or
                                (self.segment_routing is not None and self.segment_routing.has_data()) or
                                (self.spf_intervals is not None and self.spf_intervals.has_data()) or
                                (self.spf_periodic_intervals is not None and self.spf_periodic_intervals.has_data()) or
                                (self.spf_prefix_priorities is not None and self.spf_prefix_priorities.has_data()) or
                                (self.summary_prefixes is not None and self.summary_prefixes.has_data()) or
                                (self.ucmp is not None and self.ucmp.has_data()) or
                                (self.weights is not None and self.weights.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.topology_name.yfilter != YFilter.not_set or
                                self.adjacency_check.yfilter != YFilter.not_set or
                                self.advertise_link_attributes.yfilter != YFilter.not_set or
                                self.advertise_passive_only.yfilter != YFilter.not_set or
                                self.apply_weight.yfilter != YFilter.not_set or
                                self.attached_bit.yfilter != YFilter.not_set or
                                self.default_admin_distance.yfilter != YFilter.not_set or
                                self.ignore_attached_bit.yfilter != YFilter.not_set or
                                self.maximum_paths.yfilter != YFilter.not_set or
                                self.route_source_first_hop.yfilter != YFilter.not_set or
                                self.single_topology.yfilter != YFilter.not_set or
                                self.topology_id.yfilter != YFilter.not_set or
                                (self.admin_distances is not None and self.admin_distances.has_operation()) or
                                (self.default_information is not None and self.default_information.has_operation()) or
                                (self.frr_table is not None and self.frr_table.has_operation()) or
                                (self.ispf is not None and self.ispf.has_operation()) or
                                (self.max_redist_prefixes is not None and self.max_redist_prefixes.has_operation()) or
                                (self.metric_styles is not None and self.metric_styles.has_operation()) or
                                (self.metrics is not None and self.metrics.has_operation()) or
                                (self.micro_loop_avoidance is not None and self.micro_loop_avoidance.has_operation()) or
                                (self.monitor_convergence is not None and self.monitor_convergence.has_operation()) or
                                (self.mpls is not None and self.mpls.has_operation()) or
                                (self.mpls_ldp_global is not None and self.mpls_ldp_global.has_operation()) or
                                (self.propagations is not None and self.propagations.has_operation()) or
                                (self.redistributions is not None and self.redistributions.has_operation()) or
                                (self.router_id is not None and self.router_id.has_operation()) or
                                (self.segment_routing is not None and self.segment_routing.has_operation()) or
                                (self.spf_intervals is not None and self.spf_intervals.has_operation()) or
                                (self.spf_periodic_intervals is not None and self.spf_periodic_intervals.has_operation()) or
                                (self.spf_prefix_priorities is not None and self.spf_prefix_priorities.has_operation()) or
                                (self.summary_prefixes is not None and self.summary_prefixes.has_operation()) or
                                (self.ucmp is not None and self.ucmp.has_operation()) or
                                (self.weights is not None and self.weights.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "topology-name" + "[topology-name='" + self.topology_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.topology_name.is_set or self.topology_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.topology_name.get_name_leafdata())
                            if (self.adjacency_check.is_set or self.adjacency_check.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.adjacency_check.get_name_leafdata())
                            if (self.advertise_link_attributes.is_set or self.advertise_link_attributes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_link_attributes.get_name_leafdata())
                            if (self.advertise_passive_only.is_set or self.advertise_passive_only.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.advertise_passive_only.get_name_leafdata())
                            if (self.apply_weight.is_set or self.apply_weight.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.apply_weight.get_name_leafdata())
                            if (self.attached_bit.is_set or self.attached_bit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.attached_bit.get_name_leafdata())
                            if (self.default_admin_distance.is_set or self.default_admin_distance.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.default_admin_distance.get_name_leafdata())
                            if (self.ignore_attached_bit.is_set or self.ignore_attached_bit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ignore_attached_bit.get_name_leafdata())
                            if (self.maximum_paths.is_set or self.maximum_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.maximum_paths.get_name_leafdata())
                            if (self.route_source_first_hop.is_set or self.route_source_first_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_source_first_hop.get_name_leafdata())
                            if (self.single_topology.is_set or self.single_topology.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.single_topology.get_name_leafdata())
                            if (self.topology_id.is_set or self.topology_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.topology_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "admin-distances"):
                                if (self.admin_distances is None):
                                    self.admin_distances = Isis.Instances.Instance.Afs.Af.TopologyName.AdminDistances()
                                    self.admin_distances.parent = self
                                    self._children_name_map["admin_distances"] = "admin-distances"
                                return self.admin_distances

                            if (child_yang_name == "default-information"):
                                if (self.default_information is None):
                                    self.default_information = Isis.Instances.Instance.Afs.Af.TopologyName.DefaultInformation()
                                    self.default_information.parent = self
                                    self._children_name_map["default_information"] = "default-information"
                                return self.default_information

                            if (child_yang_name == "frr-table"):
                                if (self.frr_table is None):
                                    self.frr_table = Isis.Instances.Instance.Afs.Af.TopologyName.FrrTable()
                                    self.frr_table.parent = self
                                    self._children_name_map["frr_table"] = "frr-table"
                                return self.frr_table

                            if (child_yang_name == "ispf"):
                                if (self.ispf is None):
                                    self.ispf = Isis.Instances.Instance.Afs.Af.TopologyName.Ispf()
                                    self.ispf.parent = self
                                    self._children_name_map["ispf"] = "ispf"
                                return self.ispf

                            if (child_yang_name == "max-redist-prefixes"):
                                if (self.max_redist_prefixes is None):
                                    self.max_redist_prefixes = Isis.Instances.Instance.Afs.Af.TopologyName.MaxRedistPrefixes()
                                    self.max_redist_prefixes.parent = self
                                    self._children_name_map["max_redist_prefixes"] = "max-redist-prefixes"
                                return self.max_redist_prefixes

                            if (child_yang_name == "metric-styles"):
                                if (self.metric_styles is None):
                                    self.metric_styles = Isis.Instances.Instance.Afs.Af.TopologyName.MetricStyles()
                                    self.metric_styles.parent = self
                                    self._children_name_map["metric_styles"] = "metric-styles"
                                return self.metric_styles

                            if (child_yang_name == "metrics"):
                                if (self.metrics is None):
                                    self.metrics = Isis.Instances.Instance.Afs.Af.TopologyName.Metrics()
                                    self.metrics.parent = self
                                    self._children_name_map["metrics"] = "metrics"
                                return self.metrics

                            if (child_yang_name == "micro-loop-avoidance"):
                                if (self.micro_loop_avoidance is None):
                                    self.micro_loop_avoidance = Isis.Instances.Instance.Afs.Af.TopologyName.MicroLoopAvoidance()
                                    self.micro_loop_avoidance.parent = self
                                    self._children_name_map["micro_loop_avoidance"] = "micro-loop-avoidance"
                                return self.micro_loop_avoidance

                            if (child_yang_name == "monitor-convergence"):
                                if (self.monitor_convergence is None):
                                    self.monitor_convergence = Isis.Instances.Instance.Afs.Af.TopologyName.MonitorConvergence()
                                    self.monitor_convergence.parent = self
                                    self._children_name_map["monitor_convergence"] = "monitor-convergence"
                                return self.monitor_convergence

                            if (child_yang_name == "mpls"):
                                if (self.mpls is None):
                                    self.mpls = Isis.Instances.Instance.Afs.Af.TopologyName.Mpls()
                                    self.mpls.parent = self
                                    self._children_name_map["mpls"] = "mpls"
                                return self.mpls

                            if (child_yang_name == "mpls-ldp-global"):
                                if (self.mpls_ldp_global is None):
                                    self.mpls_ldp_global = Isis.Instances.Instance.Afs.Af.TopologyName.MplsLdpGlobal()
                                    self.mpls_ldp_global.parent = self
                                    self._children_name_map["mpls_ldp_global"] = "mpls-ldp-global"
                                return self.mpls_ldp_global

                            if (child_yang_name == "propagations"):
                                if (self.propagations is None):
                                    self.propagations = Isis.Instances.Instance.Afs.Af.TopologyName.Propagations()
                                    self.propagations.parent = self
                                    self._children_name_map["propagations"] = "propagations"
                                return self.propagations

                            if (child_yang_name == "redistributions"):
                                if (self.redistributions is None):
                                    self.redistributions = Isis.Instances.Instance.Afs.Af.TopologyName.Redistributions()
                                    self.redistributions.parent = self
                                    self._children_name_map["redistributions"] = "redistributions"
                                return self.redistributions

                            if (child_yang_name == "router-id"):
                                if (self.router_id is None):
                                    self.router_id = Isis.Instances.Instance.Afs.Af.TopologyName.RouterId()
                                    self.router_id.parent = self
                                    self._children_name_map["router_id"] = "router-id"
                                return self.router_id

                            if (child_yang_name == "segment-routing"):
                                if (self.segment_routing is None):
                                    self.segment_routing = Isis.Instances.Instance.Afs.Af.TopologyName.SegmentRouting()
                                    self.segment_routing.parent = self
                                    self._children_name_map["segment_routing"] = "segment-routing"
                                return self.segment_routing

                            if (child_yang_name == "spf-intervals"):
                                if (self.spf_intervals is None):
                                    self.spf_intervals = Isis.Instances.Instance.Afs.Af.TopologyName.SpfIntervals()
                                    self.spf_intervals.parent = self
                                    self._children_name_map["spf_intervals"] = "spf-intervals"
                                return self.spf_intervals

                            if (child_yang_name == "spf-periodic-intervals"):
                                if (self.spf_periodic_intervals is None):
                                    self.spf_periodic_intervals = Isis.Instances.Instance.Afs.Af.TopologyName.SpfPeriodicIntervals()
                                    self.spf_periodic_intervals.parent = self
                                    self._children_name_map["spf_periodic_intervals"] = "spf-periodic-intervals"
                                return self.spf_periodic_intervals

                            if (child_yang_name == "spf-prefix-priorities"):
                                if (self.spf_prefix_priorities is None):
                                    self.spf_prefix_priorities = Isis.Instances.Instance.Afs.Af.TopologyName.SpfPrefixPriorities()
                                    self.spf_prefix_priorities.parent = self
                                    self._children_name_map["spf_prefix_priorities"] = "spf-prefix-priorities"
                                return self.spf_prefix_priorities

                            if (child_yang_name == "summary-prefixes"):
                                if (self.summary_prefixes is None):
                                    self.summary_prefixes = Isis.Instances.Instance.Afs.Af.TopologyName.SummaryPrefixes()
                                    self.summary_prefixes.parent = self
                                    self._children_name_map["summary_prefixes"] = "summary-prefixes"
                                return self.summary_prefixes

                            if (child_yang_name == "ucmp"):
                                if (self.ucmp is None):
                                    self.ucmp = Isis.Instances.Instance.Afs.Af.TopologyName.Ucmp()
                                    self.ucmp.parent = self
                                    self._children_name_map["ucmp"] = "ucmp"
                                return self.ucmp

                            if (child_yang_name == "weights"):
                                if (self.weights is None):
                                    self.weights = Isis.Instances.Instance.Afs.Af.TopologyName.Weights()
                                    self.weights.parent = self
                                    self._children_name_map["weights"] = "weights"
                                return self.weights

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "admin-distances" or name == "default-information" or name == "frr-table" or name == "ispf" or name == "max-redist-prefixes" or name == "metric-styles" or name == "metrics" or name == "micro-loop-avoidance" or name == "monitor-convergence" or name == "mpls" or name == "mpls-ldp-global" or name == "propagations" or name == "redistributions" or name == "router-id" or name == "segment-routing" or name == "spf-intervals" or name == "spf-periodic-intervals" or name == "spf-prefix-priorities" or name == "summary-prefixes" or name == "ucmp" or name == "weights" or name == "topology-name" or name == "adjacency-check" or name == "advertise-link-attributes" or name == "advertise-passive-only" or name == "apply-weight" or name == "attached-bit" or name == "default-admin-distance" or name == "ignore-attached-bit" or name == "maximum-paths" or name == "route-source-first-hop" or name == "single-topology" or name == "topology-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "topology-name"):
                                self.topology_name = value
                                self.topology_name.value_namespace = name_space
                                self.topology_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "adjacency-check"):
                                self.adjacency_check = value
                                self.adjacency_check.value_namespace = name_space
                                self.adjacency_check.value_namespace_prefix = name_space_prefix
                            if(value_path == "advertise-link-attributes"):
                                self.advertise_link_attributes = value
                                self.advertise_link_attributes.value_namespace = name_space
                                self.advertise_link_attributes.value_namespace_prefix = name_space_prefix
                            if(value_path == "advertise-passive-only"):
                                self.advertise_passive_only = value
                                self.advertise_passive_only.value_namespace = name_space
                                self.advertise_passive_only.value_namespace_prefix = name_space_prefix
                            if(value_path == "apply-weight"):
                                self.apply_weight = value
                                self.apply_weight.value_namespace = name_space
                                self.apply_weight.value_namespace_prefix = name_space_prefix
                            if(value_path == "attached-bit"):
                                self.attached_bit = value
                                self.attached_bit.value_namespace = name_space
                                self.attached_bit.value_namespace_prefix = name_space_prefix
                            if(value_path == "default-admin-distance"):
                                self.default_admin_distance = value
                                self.default_admin_distance.value_namespace = name_space
                                self.default_admin_distance.value_namespace_prefix = name_space_prefix
                            if(value_path == "ignore-attached-bit"):
                                self.ignore_attached_bit = value
                                self.ignore_attached_bit.value_namespace = name_space
                                self.ignore_attached_bit.value_namespace_prefix = name_space_prefix
                            if(value_path == "maximum-paths"):
                                self.maximum_paths = value
                                self.maximum_paths.value_namespace = name_space
                                self.maximum_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-source-first-hop"):
                                self.route_source_first_hop = value
                                self.route_source_first_hop.value_namespace = name_space
                                self.route_source_first_hop.value_namespace_prefix = name_space_prefix
                            if(value_path == "single-topology"):
                                self.single_topology = value
                                self.single_topology.value_namespace = name_space
                                self.single_topology.value_namespace_prefix = name_space_prefix
                            if(value_path == "topology-id"):
                                self.topology_id = value
                                self.topology_id.value_namespace = name_space
                                self.topology_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.topology_name:
                            if (c.has_data()):
                                return True
                        return (
                            self.af_name.is_set or
                            self.saf_name.is_set or
                            (self.af_data is not None))

                    def has_operation(self):
                        for c in self.topology_name:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.af_name.yfilter != YFilter.not_set or
                            self.saf_name.yfilter != YFilter.not_set or
                            (self.af_data is not None and self.af_data.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "af" + "[af-name='" + self.af_name.get() + "']" + "[saf-name='" + self.saf_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.af_name.get_name_leafdata())
                        if (self.saf_name.is_set or self.saf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.saf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "af-data"):
                            if (self.af_data is None):
                                self.af_data = Isis.Instances.Instance.Afs.Af.AfData()
                                self.af_data.parent = self
                                self._children_name_map["af_data"] = "af-data"
                            return self.af_data

                        if (child_yang_name == "topology-name"):
                            for c in self.topology_name:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Isis.Instances.Instance.Afs.Af.TopologyName()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.topology_name.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "af-data" or name == "topology-name" or name == "af-name" or name == "saf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "af-name"):
                            self.af_name = value
                            self.af_name.value_namespace = name_space
                            self.af_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "saf-name"):
                            self.saf_name = value
                            self.saf_name.value_namespace = name_space
                            self.saf_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.af:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.af:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "afs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "af"):
                        for c in self.af:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.Afs.Af()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.af.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "af"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LspRefreshIntervals(Entity):
                """
                LSP refresh\-interval configuration
                
                .. attribute:: lsp_refresh_interval
                
                	Interval between re\-flooding of unchanged LSPs
                	**type**\: list of    :py:class:`LspRefreshInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspRefreshIntervals.LspRefreshInterval>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspRefreshIntervals, self).__init__()

                    self.yang_name = "lsp-refresh-intervals"
                    self.yang_parent_name = "instance"

                    self.lsp_refresh_interval = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspRefreshIntervals, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspRefreshIntervals, self).__setattr__(name, value)


                class LspRefreshInterval(Entity):
                    """
                    Interval between re\-flooding of unchanged
                    LSPs
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: interval
                    
                    	Seconds
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**mandatory**\: True
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspRefreshIntervals.LspRefreshInterval, self).__init__()

                        self.yang_name = "lsp-refresh-interval"
                        self.yang_parent_name = "lsp-refresh-intervals"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.interval = YLeaf(YType.uint32, "interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspRefreshIntervals.LspRefreshInterval, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspRefreshIntervals.LspRefreshInterval, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-refresh-interval" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_refresh_interval:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_refresh_interval:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-refresh-intervals" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-refresh-interval"):
                        for c in self.lsp_refresh_interval:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspRefreshIntervals.LspRefreshInterval()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_refresh_interval.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-refresh-interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Distribute(Entity):
                """
                IS\-IS Distribute BGP\-LS configuration
                
                .. attribute:: dist_inst_id
                
                	Instance ID
                	**type**\:  int
                
                	**range:** 1..65535
                
                .. attribute:: dist_throttle
                
                	Seconds
                	**type**\:  int
                
                	**range:** 1..20
                
                	**units**\: second
                
                .. attribute:: level
                
                	Level
                	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                
                

                This class is a :ref:`presence class<presence-class>`

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.Distribute, self).__init__()

                    self.yang_name = "distribute"
                    self.yang_parent_name = "instance"
                    self.is_presence_container = True

                    self.dist_inst_id = YLeaf(YType.uint32, "dist-inst-id")

                    self.dist_throttle = YLeaf(YType.uint32, "dist-throttle")

                    self.level = YLeaf(YType.enumeration, "level")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("dist_inst_id",
                                    "dist_throttle",
                                    "level") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.Distribute, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.Distribute, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.dist_inst_id.is_set or
                        self.dist_throttle.is_set or
                        self.level.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.dist_inst_id.yfilter != YFilter.not_set or
                        self.dist_throttle.yfilter != YFilter.not_set or
                        self.level.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "distribute" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.dist_inst_id.is_set or self.dist_inst_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.dist_inst_id.get_name_leafdata())
                    if (self.dist_throttle.is_set or self.dist_throttle.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.dist_throttle.get_name_leafdata())
                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.level.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "dist-inst-id" or name == "dist-throttle" or name == "level"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "dist-inst-id"):
                        self.dist_inst_id = value
                        self.dist_inst_id.value_namespace = name_space
                        self.dist_inst_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "dist-throttle"):
                        self.dist_throttle = value
                        self.dist_throttle.value_namespace = name_space
                        self.dist_throttle.value_namespace_prefix = name_space_prefix
                    if(value_path == "level"):
                        self.level = value
                        self.level.value_namespace = name_space
                        self.level.value_namespace_prefix = name_space_prefix


            class LspAcceptPasswords(Entity):
                """
                LSP/SNP accept password configuration
                
                .. attribute:: lsp_accept_password
                
                	LSP/SNP accept passwords. This requires the existence of an LSPPassword of the same level 
                	**type**\: list of    :py:class:`LspAcceptPassword <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspAcceptPasswords.LspAcceptPassword>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspAcceptPasswords, self).__init__()

                    self.yang_name = "lsp-accept-passwords"
                    self.yang_parent_name = "instance"

                    self.lsp_accept_password = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspAcceptPasswords, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspAcceptPasswords, self).__setattr__(name, value)


                class LspAcceptPassword(Entity):
                    """
                    LSP/SNP accept passwords. This requires the
                    existence of an LSPPassword of the same level
                    .
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: password
                    
                    	Password
                    	**type**\:  str
                    
                    	**pattern:** (!.+)\|([^!].+)
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspAcceptPasswords.LspAcceptPassword, self).__init__()

                        self.yang_name = "lsp-accept-password"
                        self.yang_parent_name = "lsp-accept-passwords"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.password = YLeaf(YType.str, "password")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "password") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspAcceptPasswords.LspAcceptPassword, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspAcceptPasswords.LspAcceptPassword, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.password.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.password.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-accept-password" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.password.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "password"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "password"):
                            self.password = value
                            self.password.value_namespace = name_space
                            self.password.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_accept_password:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_accept_password:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-accept-passwords" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-accept-password"):
                        for c in self.lsp_accept_password:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspAcceptPasswords.LspAcceptPassword()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_accept_password.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-accept-password"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LspMtus(Entity):
                """
                LSP MTU configuration
                
                .. attribute:: lsp_mtu
                
                	LSP MTU
                	**type**\: list of    :py:class:`LspMtu <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspMtus.LspMtu>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspMtus, self).__init__()

                    self.yang_name = "lsp-mtus"
                    self.yang_parent_name = "instance"

                    self.lsp_mtu = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspMtus, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspMtus, self).__setattr__(name, value)


                class LspMtu(Entity):
                    """
                    LSP MTU
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: mtu
                    
                    	Bytes
                    	**type**\:  int
                    
                    	**range:** 128..4352
                    
                    	**mandatory**\: True
                    
                    	**units**\: byte
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspMtus.LspMtu, self).__init__()

                        self.yang_name = "lsp-mtu"
                        self.yang_parent_name = "lsp-mtus"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.mtu = YLeaf(YType.uint32, "mtu")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "mtu") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspMtus.LspMtu, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspMtus.LspMtu, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.mtu.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.mtu.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-mtu" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mtu.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "mtu"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "mtu"):
                            self.mtu = value
                            self.mtu.value_namespace = name_space
                            self.mtu.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_mtu:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_mtu:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-mtus" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-mtu"):
                        for c in self.lsp_mtu:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspMtus.LspMtu()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_mtu.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-mtu"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Nsf(Entity):
                """
                IS\-IS NSF configuration
                
                .. attribute:: flavor
                
                	NSF not configured if item is deleted
                	**type**\:   :py:class:`IsisNsfFlavor <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisNsfFlavor>`
                
                .. attribute:: interface_timer
                
                	Per\-interface time period to wait for a restart ACK during an IETF\-NSF restart. This configuration has no effect if IETF\-NSF is not configured
                	**type**\:  int
                
                	**range:** 1..20
                
                	**units**\: second
                
                	**default value**\: 1
                
                .. attribute:: lifetime
                
                	Maximum route lifetime following restart. When this lifetime expires, old routes will be purged from the RIB
                	**type**\:  int
                
                	**range:** 5..300
                
                	**units**\: second
                
                	**default value**\: 90
                
                .. attribute:: max_interface_timer_expiry
                
                	Maximum number of times an interface timer may expire during an IETF\-NSF restart before the NSF restart is aborted. This configuration has no effect if IETF NSF is not configured
                	**type**\:  int
                
                	**range:** 1..10
                
                	**default value**\: 10
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.Nsf, self).__init__()

                    self.yang_name = "nsf"
                    self.yang_parent_name = "instance"

                    self.flavor = YLeaf(YType.enumeration, "flavor")

                    self.interface_timer = YLeaf(YType.uint32, "interface-timer")

                    self.lifetime = YLeaf(YType.uint32, "lifetime")

                    self.max_interface_timer_expiry = YLeaf(YType.uint32, "max-interface-timer-expiry")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("flavor",
                                    "interface_timer",
                                    "lifetime",
                                    "max_interface_timer_expiry") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.Nsf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.Nsf, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.flavor.is_set or
                        self.interface_timer.is_set or
                        self.lifetime.is_set or
                        self.max_interface_timer_expiry.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.flavor.yfilter != YFilter.not_set or
                        self.interface_timer.yfilter != YFilter.not_set or
                        self.lifetime.yfilter != YFilter.not_set or
                        self.max_interface_timer_expiry.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nsf" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.flavor.is_set or self.flavor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.flavor.get_name_leafdata())
                    if (self.interface_timer.is_set or self.interface_timer.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_timer.get_name_leafdata())
                    if (self.lifetime.is_set or self.lifetime.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lifetime.get_name_leafdata())
                    if (self.max_interface_timer_expiry.is_set or self.max_interface_timer_expiry.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.max_interface_timer_expiry.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "flavor" or name == "interface-timer" or name == "lifetime" or name == "max-interface-timer-expiry"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "flavor"):
                        self.flavor = value
                        self.flavor.value_namespace = name_space
                        self.flavor.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-timer"):
                        self.interface_timer = value
                        self.interface_timer.value_namespace = name_space
                        self.interface_timer.value_namespace_prefix = name_space_prefix
                    if(value_path == "lifetime"):
                        self.lifetime = value
                        self.lifetime.value_namespace = name_space
                        self.lifetime.value_namespace_prefix = name_space_prefix
                    if(value_path == "max-interface-timer-expiry"):
                        self.max_interface_timer_expiry = value
                        self.max_interface_timer_expiry.value_namespace = name_space
                        self.max_interface_timer_expiry.value_namespace_prefix = name_space_prefix


            class LinkGroups(Entity):
                """
                Link Group
                
                .. attribute:: link_group
                
                	Configuration for link group name
                	**type**\: list of    :py:class:`LinkGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LinkGroups.LinkGroup>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LinkGroups, self).__init__()

                    self.yang_name = "link-groups"
                    self.yang_parent_name = "instance"

                    self.link_group = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LinkGroups, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LinkGroups, self).__setattr__(name, value)


                class LinkGroup(Entity):
                    """
                    Configuration for link group name
                    
                    .. attribute:: link_group_name  <key>
                    
                    	Link Group Name
                    	**type**\:  str
                    
                    	**length:** 1..40
                    
                    .. attribute:: enable
                    
                    	Flag to indicate that linkgroup should be running.  This must be the first object created when a linkgroup is configured, and the last object deleted when it is deconfigured.  When this object is deleted, the IS\-IS linkgroup will be removed
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: metric_offset
                    
                    	Metric for redistributed routes\: <0\-63> for narrow, <0\-16777215> for wide
                    	**type**\:  int
                    
                    	**range:** 0..16777215
                    
                    .. attribute:: minimum_members
                    
                    	Minimum Members
                    	**type**\:  int
                    
                    	**range:** 2..64
                    
                    	**default value**\: 2
                    
                    .. attribute:: revert_members
                    
                    	Revert Members
                    	**type**\:  int
                    
                    	**range:** 2..64
                    
                    	**default value**\: 2
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LinkGroups.LinkGroup, self).__init__()

                        self.yang_name = "link-group"
                        self.yang_parent_name = "link-groups"

                        self.link_group_name = YLeaf(YType.str, "link-group-name")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.metric_offset = YLeaf(YType.uint32, "metric-offset")

                        self.minimum_members = YLeaf(YType.uint32, "minimum-members")

                        self.revert_members = YLeaf(YType.uint32, "revert-members")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("link_group_name",
                                        "enable",
                                        "metric_offset",
                                        "minimum_members",
                                        "revert_members") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LinkGroups.LinkGroup, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LinkGroups.LinkGroup, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.link_group_name.is_set or
                            self.enable.is_set or
                            self.metric_offset.is_set or
                            self.minimum_members.is_set or
                            self.revert_members.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.link_group_name.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.metric_offset.yfilter != YFilter.not_set or
                            self.minimum_members.yfilter != YFilter.not_set or
                            self.revert_members.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "link-group" + "[link-group-name='" + self.link_group_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.link_group_name.is_set or self.link_group_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.link_group_name.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.metric_offset.is_set or self.metric_offset.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.metric_offset.get_name_leafdata())
                        if (self.minimum_members.is_set or self.minimum_members.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum_members.get_name_leafdata())
                        if (self.revert_members.is_set or self.revert_members.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.revert_members.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "link-group-name" or name == "enable" or name == "metric-offset" or name == "minimum-members" or name == "revert-members"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "link-group-name"):
                            self.link_group_name = value
                            self.link_group_name.value_namespace = name_space
                            self.link_group_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "metric-offset"):
                            self.metric_offset = value
                            self.metric_offset.value_namespace = name_space
                            self.metric_offset.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum-members"):
                            self.minimum_members = value
                            self.minimum_members.value_namespace = name_space
                            self.minimum_members.value_namespace_prefix = name_space_prefix
                        if(value_path == "revert-members"):
                            self.revert_members = value
                            self.revert_members.value_namespace = name_space
                            self.revert_members.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.link_group:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.link_group:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "link-groups" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "link-group"):
                        for c in self.link_group:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LinkGroups.LinkGroup()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.link_group.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "link-group"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LspCheckIntervals(Entity):
                """
                LSP checksum check interval configuration
                
                .. attribute:: lsp_check_interval
                
                	LSP checksum check interval parameters
                	**type**\: list of    :py:class:`LspCheckInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspCheckIntervals.LspCheckInterval>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspCheckIntervals, self).__init__()

                    self.yang_name = "lsp-check-intervals"
                    self.yang_parent_name = "instance"

                    self.lsp_check_interval = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspCheckIntervals, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspCheckIntervals, self).__setattr__(name, value)


                class LspCheckInterval(Entity):
                    """
                    LSP checksum check interval parameters
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: interval
                    
                    	LSP checksum check interval time in seconds
                    	**type**\:  int
                    
                    	**range:** 10..65535
                    
                    	**mandatory**\: True
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspCheckIntervals.LspCheckInterval, self).__init__()

                        self.yang_name = "lsp-check-interval"
                        self.yang_parent_name = "lsp-check-intervals"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.interval = YLeaf(YType.uint32, "interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspCheckIntervals.LspCheckInterval, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspCheckIntervals.LspCheckInterval, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-check-interval" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_check_interval:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_check_interval:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-check-intervals" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-check-interval"):
                        for c in self.lsp_check_interval:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspCheckIntervals.LspCheckInterval()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_check_interval.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-check-interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LspPasswords(Entity):
                """
                LSP/SNP password configuration
                
                .. attribute:: lsp_password
                
                	LSP/SNP passwords. This must exist if an LSPAcceptPassword of the same level exists
                	**type**\: list of    :py:class:`LspPassword <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspPasswords.LspPassword>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspPasswords, self).__init__()

                    self.yang_name = "lsp-passwords"
                    self.yang_parent_name = "instance"

                    self.lsp_password = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspPasswords, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspPasswords, self).__setattr__(name, value)


                class LspPassword(Entity):
                    """
                    LSP/SNP passwords. This must exist if an
                    LSPAcceptPassword of the same level exists.
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: algorithm
                    
                    	Algorithm
                    	**type**\:   :py:class:`IsisAuthenticationAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAuthenticationAlgorithm>`
                    
                    	**mandatory**\: True
                    
                    .. attribute:: authentication_type
                    
                    	SNP packet authentication mode
                    	**type**\:   :py:class:`IsisSnpAuth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisSnpAuth>`
                    
                    	**mandatory**\: True
                    
                    .. attribute:: failure_mode
                    
                    	Failure Mode
                    	**type**\:   :py:class:`IsisAuthenticationFailureMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAuthenticationFailureMode>`
                    
                    	**mandatory**\: True
                    
                    .. attribute:: password
                    
                    	Password or unencrypted Key Chain name
                    	**type**\:  str
                    
                    	**pattern:** (!.+)\|([^!].+)
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspPasswords.LspPassword, self).__init__()

                        self.yang_name = "lsp-password"
                        self.yang_parent_name = "lsp-passwords"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.algorithm = YLeaf(YType.enumeration, "algorithm")

                        self.authentication_type = YLeaf(YType.enumeration, "authentication-type")

                        self.failure_mode = YLeaf(YType.enumeration, "failure-mode")

                        self.password = YLeaf(YType.str, "password")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "algorithm",
                                        "authentication_type",
                                        "failure_mode",
                                        "password") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspPasswords.LspPassword, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspPasswords.LspPassword, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.algorithm.is_set or
                            self.authentication_type.is_set or
                            self.failure_mode.is_set or
                            self.password.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.algorithm.yfilter != YFilter.not_set or
                            self.authentication_type.yfilter != YFilter.not_set or
                            self.failure_mode.yfilter != YFilter.not_set or
                            self.password.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-password" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.algorithm.get_name_leafdata())
                        if (self.authentication_type.is_set or self.authentication_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_type.get_name_leafdata())
                        if (self.failure_mode.is_set or self.failure_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.failure_mode.get_name_leafdata())
                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.password.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "algorithm" or name == "authentication-type" or name == "failure-mode" or name == "password"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "algorithm"):
                            self.algorithm = value
                            self.algorithm.value_namespace = name_space
                            self.algorithm.value_namespace_prefix = name_space_prefix
                        if(value_path == "authentication-type"):
                            self.authentication_type = value
                            self.authentication_type.value_namespace = name_space
                            self.authentication_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "failure-mode"):
                            self.failure_mode = value
                            self.failure_mode.value_namespace = name_space
                            self.failure_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "password"):
                            self.password = value
                            self.password.value_namespace = name_space
                            self.password.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_password:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_password:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-passwords" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-password"):
                        for c in self.lsp_password:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspPasswords.LspPassword()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_password.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-password"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Nets(Entity):
                """
                NET configuration
                
                .. attribute:: net
                
                	Network Entity Title (NET)
                	**type**\: list of    :py:class:`Net <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Nets.Net>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.Nets, self).__init__()

                    self.yang_name = "nets"
                    self.yang_parent_name = "instance"

                    self.net = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.Nets, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.Nets, self).__setattr__(name, value)


                class Net(Entity):
                    """
                    Network Entity Title (NET)
                    
                    .. attribute:: net_name  <key>
                    
                    	Network Entity Title
                    	**type**\:  str
                    
                    	**pattern:** [a\-fA\-F0\-9]{2}(\\.[a\-fA\-F0\-9]{4}){3,9}\\.[a\-fA\-F0\-9]{2}
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.Nets.Net, self).__init__()

                        self.yang_name = "net"
                        self.yang_parent_name = "nets"

                        self.net_name = YLeaf(YType.str, "net-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("net_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.Nets.Net, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.Nets.Net, self).__setattr__(name, value)

                    def has_data(self):
                        return self.net_name.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.net_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "net" + "[net-name='" + self.net_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.net_name.is_set or self.net_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.net_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "net-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "net-name"):
                            self.net_name = value
                            self.net_name.value_namespace = name_space
                            self.net_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.net:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.net:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nets" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "net"):
                        for c in self.net:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.Nets.Net()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.net.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "net"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LspLifetimes(Entity):
                """
                LSP lifetime configuration
                
                .. attribute:: lsp_lifetime
                
                	Maximum LSP lifetime
                	**type**\: list of    :py:class:`LspLifetime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.LspLifetimes.LspLifetime>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.LspLifetimes, self).__init__()

                    self.yang_name = "lsp-lifetimes"
                    self.yang_parent_name = "instance"

                    self.lsp_lifetime = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.LspLifetimes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.LspLifetimes, self).__setattr__(name, value)


                class LspLifetime(Entity):
                    """
                    Maximum LSP lifetime
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: lifetime
                    
                    	Seconds
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**mandatory**\: True
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.LspLifetimes.LspLifetime, self).__init__()

                        self.yang_name = "lsp-lifetime"
                        self.yang_parent_name = "lsp-lifetimes"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.lifetime = YLeaf(YType.uint32, "lifetime")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "lifetime") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.LspLifetimes.LspLifetime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.LspLifetimes.LspLifetime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.lifetime.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.lifetime.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-lifetime" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.lifetime.is_set or self.lifetime.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lifetime.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "lifetime"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "lifetime"):
                            self.lifetime = value
                            self.lifetime.value_namespace = name_space
                            self.lifetime.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.lsp_lifetime:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.lsp_lifetime:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-lifetimes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-lifetime"):
                        for c in self.lsp_lifetime:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.LspLifetimes.LspLifetime()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.lsp_lifetime.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-lifetime"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class OverloadBits(Entity):
                """
                LSP overload\-bit configuration
                
                .. attribute:: overload_bit
                
                	Set the overload bit in the System LSP so that other routers avoid this one in SPF calculations. This may be done either unconditionally, or on startup until either a set time has passed or IS\-IS is informed that BGP has converged. This is an Object with a union discriminated on an integer value of the ISISOverloadBitModeType
                	**type**\: list of    :py:class:`OverloadBit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.OverloadBits.OverloadBit>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.OverloadBits, self).__init__()

                    self.yang_name = "overload-bits"
                    self.yang_parent_name = "instance"

                    self.overload_bit = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.OverloadBits, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.OverloadBits, self).__setattr__(name, value)


                class OverloadBit(Entity):
                    """
                    Set the overload bit in the System LSP so
                    that other routers avoid this one in SPF
                    calculations. This may be done either
                    unconditionally, or on startup until either a
                    set time has passed or IS\-IS is informed that
                    BGP has converged. This is an Object with a
                    union discriminated on an integer value of
                    the ISISOverloadBitModeType.
                    
                    .. attribute:: level  <key>
                    
                    	Level to which configuration applies
                    	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                    
                    .. attribute:: external_adv_type
                    
                    	Advertise prefixes from other protocols
                    	**type**\:   :py:class:`IsisAdvTypeExternal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAdvTypeExternal>`
                    
                    .. attribute:: hippity_period
                    
                    	Time in seconds to advertise ourself as overloaded after process startup
                    	**type**\:  int
                    
                    	**range:** 5..86400
                    
                    	**units**\: second
                    
                    .. attribute:: inter_level_adv_type
                    
                    	Advertise prefixes across ISIS levels
                    	**type**\:   :py:class:`IsisAdvTypeInterLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAdvTypeInterLevel>`
                    
                    .. attribute:: overload_bit_mode
                    
                    	Circumstances under which the overload bit is set in the system LSP
                    	**type**\:   :py:class:`IsisOverloadBitMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisOverloadBitMode>`
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.OverloadBits.OverloadBit, self).__init__()

                        self.yang_name = "overload-bit"
                        self.yang_parent_name = "overload-bits"

                        self.level = YLeaf(YType.enumeration, "level")

                        self.external_adv_type = YLeaf(YType.enumeration, "external-adv-type")

                        self.hippity_period = YLeaf(YType.uint32, "hippity-period")

                        self.inter_level_adv_type = YLeaf(YType.enumeration, "inter-level-adv-type")

                        self.overload_bit_mode = YLeaf(YType.enumeration, "overload-bit-mode")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("level",
                                        "external_adv_type",
                                        "hippity_period",
                                        "inter_level_adv_type",
                                        "overload_bit_mode") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.OverloadBits.OverloadBit, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.OverloadBits.OverloadBit, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.level.is_set or
                            self.external_adv_type.is_set or
                            self.hippity_period.is_set or
                            self.inter_level_adv_type.is_set or
                            self.overload_bit_mode.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.level.yfilter != YFilter.not_set or
                            self.external_adv_type.yfilter != YFilter.not_set or
                            self.hippity_period.yfilter != YFilter.not_set or
                            self.inter_level_adv_type.yfilter != YFilter.not_set or
                            self.overload_bit_mode.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "overload-bit" + "[level='" + self.level.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.level.get_name_leafdata())
                        if (self.external_adv_type.is_set or self.external_adv_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_adv_type.get_name_leafdata())
                        if (self.hippity_period.is_set or self.hippity_period.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hippity_period.get_name_leafdata())
                        if (self.inter_level_adv_type.is_set or self.inter_level_adv_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_level_adv_type.get_name_leafdata())
                        if (self.overload_bit_mode.is_set or self.overload_bit_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.overload_bit_mode.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "level" or name == "external-adv-type" or name == "hippity-period" or name == "inter-level-adv-type" or name == "overload-bit-mode"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "level"):
                            self.level = value
                            self.level.value_namespace = name_space
                            self.level.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-adv-type"):
                            self.external_adv_type = value
                            self.external_adv_type.value_namespace = name_space
                            self.external_adv_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "hippity-period"):
                            self.hippity_period = value
                            self.hippity_period.value_namespace = name_space
                            self.hippity_period.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-level-adv-type"):
                            self.inter_level_adv_type = value
                            self.inter_level_adv_type.value_namespace = name_space
                            self.inter_level_adv_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "overload-bit-mode"):
                            self.overload_bit_mode = value
                            self.overload_bit_mode.value_namespace = name_space
                            self.overload_bit_mode.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.overload_bit:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.overload_bit:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "overload-bits" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "overload-bit"):
                        for c in self.overload_bit:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.OverloadBits.OverloadBit()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.overload_bit.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "overload-bit"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Interfaces(Entity):
                """
                Per\-interface configuration
                
                .. attribute:: interface
                
                	Configuration for an IS\-IS interface
                	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface>`
                
                

                """

                _prefix = 'clns-isis-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Isis.Instances.Instance.Interfaces, self).__init__()

                    self.yang_name = "interfaces"
                    self.yang_parent_name = "instance"

                    self.interface = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Isis.Instances.Instance.Interfaces, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Isis.Instances.Instance.Interfaces, self).__setattr__(name, value)


                class Interface(Entity):
                    """
                    Configuration for an IS\-IS interface
                    
                    .. attribute:: interface_name  <key>
                    
                    	Interface name
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: bfd
                    
                    	BFD configuration
                    	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.Bfd>`
                    
                    .. attribute:: circuit_type
                    
                    	Configure circuit type for interface
                    	**type**\:   :py:class:`IsisConfigurableLevels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisConfigurableLevels>`
                    
                    	**default value**\: level1-and2
                    
                    .. attribute:: csnp_intervals
                    
                    	CSNP\-interval configuration
                    	**type**\:   :py:class:`CsnpIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals>`
                    
                    .. attribute:: hello_accept_passwords
                    
                    	IIH accept password configuration
                    	**type**\:   :py:class:`HelloAcceptPasswords <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords>`
                    
                    .. attribute:: hello_intervals
                    
                    	Hello\-interval configuration
                    	**type**\:   :py:class:`HelloIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloIntervals>`
                    
                    .. attribute:: hello_multipliers
                    
                    	Hello\-multiplier configuration
                    	**type**\:   :py:class:`HelloMultipliers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers>`
                    
                    .. attribute:: hello_paddings
                    
                    	Hello\-padding configuration
                    	**type**\:   :py:class:`HelloPaddings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloPaddings>`
                    
                    .. attribute:: hello_passwords
                    
                    	IIH password configuration
                    	**type**\:   :py:class:`HelloPasswords <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloPasswords>`
                    
                    .. attribute:: interface_afs
                    
                    	Per\-interface address\-family configuration
                    	**type**\:   :py:class:`InterfaceAfs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs>`
                    
                    .. attribute:: link_down_fast_detect
                    
                    	Configure high priority detection of interface down event
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: lsp_fast_flood_thresholds
                    
                    	LSP fast flood threshold configuration
                    	**type**\:   :py:class:`LspFastFloodThresholds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds>`
                    
                    .. attribute:: lsp_intervals
                    
                    	LSP\-interval configuration
                    	**type**\:   :py:class:`LspIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspIntervals>`
                    
                    .. attribute:: lsp_retransmit_intervals
                    
                    	LSP\-retransmission\-interval configuration
                    	**type**\:   :py:class:`LspRetransmitIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals>`
                    
                    .. attribute:: lsp_retransmit_throttle_intervals
                    
                    	LSP\-retransmission\-throttle\-interval configuration
                    	**type**\:   :py:class:`LspRetransmitThrottleIntervals <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals>`
                    
                    .. attribute:: mesh_group
                    
                    	Mesh\-group configuration
                    	**type**\: one of the below types:
                    
                    	**type**\:   :py:class:`MeshGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.MeshGroup>`
                    
                    
                    ----
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    .. attribute:: point_to_point
                    
                    	IS\-IS will attempt to form point\-to\-point over LAN adjacencies over this interface
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: prefix_attribute_n_flag_clears
                    
                    	Prefix attribute N flag clear configuration
                    	**type**\:   :py:class:`PrefixAttributeNFlagClears <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears>`
                    
                    .. attribute:: priorities
                    
                    	DIS\-election priority configuration
                    	**type**\:   :py:class:`Priorities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.Priorities>`
                    
                    .. attribute:: running
                    
                    	This object must be set before any other configuration is supplied for an interface, and must be the last per\-interface configuration object to be removed
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: state
                    
                    	Enable/Disable routing
                    	**type**\:   :py:class:`IsisInterfaceState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisInterfaceState>`
                    
                    

                    """

                    _prefix = 'clns-isis-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Isis.Instances.Instance.Interfaces.Interface, self).__init__()

                        self.yang_name = "interface"
                        self.yang_parent_name = "interfaces"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.circuit_type = YLeaf(YType.enumeration, "circuit-type")

                        self.link_down_fast_detect = YLeaf(YType.empty, "link-down-fast-detect")

                        self.mesh_group = YLeaf(YType.str, "mesh-group")

                        self.point_to_point = YLeaf(YType.empty, "point-to-point")

                        self.running = YLeaf(YType.empty, "running")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.bfd = Isis.Instances.Instance.Interfaces.Interface.Bfd()
                        self.bfd.parent = self
                        self._children_name_map["bfd"] = "bfd"
                        self._children_yang_names.add("bfd")

                        self.csnp_intervals = Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals()
                        self.csnp_intervals.parent = self
                        self._children_name_map["csnp_intervals"] = "csnp-intervals"
                        self._children_yang_names.add("csnp-intervals")

                        self.hello_accept_passwords = Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords()
                        self.hello_accept_passwords.parent = self
                        self._children_name_map["hello_accept_passwords"] = "hello-accept-passwords"
                        self._children_yang_names.add("hello-accept-passwords")

                        self.hello_intervals = Isis.Instances.Instance.Interfaces.Interface.HelloIntervals()
                        self.hello_intervals.parent = self
                        self._children_name_map["hello_intervals"] = "hello-intervals"
                        self._children_yang_names.add("hello-intervals")

                        self.hello_multipliers = Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers()
                        self.hello_multipliers.parent = self
                        self._children_name_map["hello_multipliers"] = "hello-multipliers"
                        self._children_yang_names.add("hello-multipliers")

                        self.hello_paddings = Isis.Instances.Instance.Interfaces.Interface.HelloPaddings()
                        self.hello_paddings.parent = self
                        self._children_name_map["hello_paddings"] = "hello-paddings"
                        self._children_yang_names.add("hello-paddings")

                        self.hello_passwords = Isis.Instances.Instance.Interfaces.Interface.HelloPasswords()
                        self.hello_passwords.parent = self
                        self._children_name_map["hello_passwords"] = "hello-passwords"
                        self._children_yang_names.add("hello-passwords")

                        self.interface_afs = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs()
                        self.interface_afs.parent = self
                        self._children_name_map["interface_afs"] = "interface-afs"
                        self._children_yang_names.add("interface-afs")

                        self.lsp_fast_flood_thresholds = Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds()
                        self.lsp_fast_flood_thresholds.parent = self
                        self._children_name_map["lsp_fast_flood_thresholds"] = "lsp-fast-flood-thresholds"
                        self._children_yang_names.add("lsp-fast-flood-thresholds")

                        self.lsp_intervals = Isis.Instances.Instance.Interfaces.Interface.LspIntervals()
                        self.lsp_intervals.parent = self
                        self._children_name_map["lsp_intervals"] = "lsp-intervals"
                        self._children_yang_names.add("lsp-intervals")

                        self.lsp_retransmit_intervals = Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals()
                        self.lsp_retransmit_intervals.parent = self
                        self._children_name_map["lsp_retransmit_intervals"] = "lsp-retransmit-intervals"
                        self._children_yang_names.add("lsp-retransmit-intervals")

                        self.lsp_retransmit_throttle_intervals = Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals()
                        self.lsp_retransmit_throttle_intervals.parent = self
                        self._children_name_map["lsp_retransmit_throttle_intervals"] = "lsp-retransmit-throttle-intervals"
                        self._children_yang_names.add("lsp-retransmit-throttle-intervals")

                        self.prefix_attribute_n_flag_clears = Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears()
                        self.prefix_attribute_n_flag_clears.parent = self
                        self._children_name_map["prefix_attribute_n_flag_clears"] = "prefix-attribute-n-flag-clears"
                        self._children_yang_names.add("prefix-attribute-n-flag-clears")

                        self.priorities = Isis.Instances.Instance.Interfaces.Interface.Priorities()
                        self.priorities.parent = self
                        self._children_name_map["priorities"] = "priorities"
                        self._children_yang_names.add("priorities")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name",
                                        "circuit_type",
                                        "link_down_fast_detect",
                                        "mesh_group",
                                        "point_to_point",
                                        "running",
                                        "state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Isis.Instances.Instance.Interfaces.Interface, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Isis.Instances.Instance.Interfaces.Interface, self).__setattr__(name, value)

                    class MeshGroup(Enum):
                        """
                        MeshGroup

                        Mesh\-group configuration

                        .. data:: blocked = 0

                        	Blocked mesh group.  Changed LSPs are not

                        	flooded over blocked interfaces

                        """

                        blocked = Enum.YLeaf(0, "blocked")



                    class LspRetransmitThrottleIntervals(Entity):
                        """
                        LSP\-retransmission\-throttle\-interval
                        configuration
                        
                        .. attribute:: lsp_retransmit_throttle_interval
                        
                        	Minimum interval betwen retransissions of different LSPs
                        	**type**\: list of    :py:class:`LspRetransmitThrottleInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals.LspRetransmitThrottleInterval>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals, self).__init__()

                            self.yang_name = "lsp-retransmit-throttle-intervals"
                            self.yang_parent_name = "interface"

                            self.lsp_retransmit_throttle_interval = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals, self).__setattr__(name, value)


                        class LspRetransmitThrottleInterval(Entity):
                            """
                            Minimum interval betwen retransissions of
                            different LSPs
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: interval
                            
                            	Milliseconds
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            	**mandatory**\: True
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals.LspRetransmitThrottleInterval, self).__init__()

                                self.yang_name = "lsp-retransmit-throttle-interval"
                                self.yang_parent_name = "lsp-retransmit-throttle-intervals"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals.LspRetransmitThrottleInterval, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals.LspRetransmitThrottleInterval, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-retransmit-throttle-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsp_retransmit_throttle_interval:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.lsp_retransmit_throttle_interval:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "lsp-retransmit-throttle-intervals" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsp-retransmit-throttle-interval"):
                                for c in self.lsp_retransmit_throttle_interval:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals.LspRetransmitThrottleInterval()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_retransmit_throttle_interval.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsp-retransmit-throttle-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class LspRetransmitIntervals(Entity):
                        """
                        LSP\-retransmission\-interval configuration
                        
                        .. attribute:: lsp_retransmit_interval
                        
                        	Interval between retransmissions of the same LSP
                        	**type**\: list of    :py:class:`LspRetransmitInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals.LspRetransmitInterval>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals, self).__init__()

                            self.yang_name = "lsp-retransmit-intervals"
                            self.yang_parent_name = "interface"

                            self.lsp_retransmit_interval = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals, self).__setattr__(name, value)


                        class LspRetransmitInterval(Entity):
                            """
                            Interval between retransmissions of the
                            same LSP
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: interval
                            
                            	Seconds
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            	**mandatory**\: True
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals.LspRetransmitInterval, self).__init__()

                                self.yang_name = "lsp-retransmit-interval"
                                self.yang_parent_name = "lsp-retransmit-intervals"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals.LspRetransmitInterval, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals.LspRetransmitInterval, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-retransmit-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsp_retransmit_interval:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.lsp_retransmit_interval:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "lsp-retransmit-intervals" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsp-retransmit-interval"):
                                for c in self.lsp_retransmit_interval:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals.LspRetransmitInterval()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_retransmit_interval.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsp-retransmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Bfd(Entity):
                        """
                        BFD configuration
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection multiplier for BFD sessions created by isis
                        	**type**\:  int
                        
                        	**range:** 2..50
                        
                        .. attribute:: enable_ipv4
                        
                        	TRUE to enable BFD. FALSE to disable and to prevent inheritance from a parent
                        	**type**\:  bool
                        
                        .. attribute:: enable_ipv6
                        
                        	TRUE to enable BFD. FALSE to disable and to prevent inheritance from a parent
                        	**type**\:  bool
                        
                        .. attribute:: interval
                        
                        	Hello interval for BFD sessions created by isis
                        	**type**\:  int
                        
                        	**range:** 3..30000
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.Bfd, self).__init__()

                            self.yang_name = "bfd"
                            self.yang_parent_name = "interface"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.enable_ipv4 = YLeaf(YType.boolean, "enable-ipv4")

                            self.enable_ipv6 = YLeaf(YType.boolean, "enable-ipv6")

                            self.interval = YLeaf(YType.uint32, "interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "enable_ipv4",
                                            "enable_ipv6",
                                            "interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.Bfd, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.Bfd, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.enable_ipv4.is_set or
                                self.enable_ipv6.is_set or
                                self.interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.enable_ipv4.yfilter != YFilter.not_set or
                                self.enable_ipv6.yfilter != YFilter.not_set or
                                self.interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfd" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.enable_ipv4.is_set or self.enable_ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable_ipv4.get_name_leafdata())
                            if (self.enable_ipv6.is_set or self.enable_ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable_ipv6.get_name_leafdata())
                            if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "enable-ipv4" or name == "enable-ipv6" or name == "interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable-ipv4"):
                                self.enable_ipv4 = value
                                self.enable_ipv4.value_namespace = name_space
                                self.enable_ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable-ipv6"):
                                self.enable_ipv6 = value
                                self.enable_ipv6.value_namespace = name_space
                                self.enable_ipv6.value_namespace_prefix = name_space_prefix
                            if(value_path == "interval"):
                                self.interval = value
                                self.interval.value_namespace = name_space
                                self.interval.value_namespace_prefix = name_space_prefix


                    class Priorities(Entity):
                        """
                        DIS\-election priority configuration
                        
                        .. attribute:: priority
                        
                        	DIS\-election priority
                        	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.Priorities.Priority>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.Priorities, self).__init__()

                            self.yang_name = "priorities"
                            self.yang_parent_name = "interface"

                            self.priority = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.Priorities, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.Priorities, self).__setattr__(name, value)


                        class Priority(Entity):
                            """
                            DIS\-election priority
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: priority_value
                            
                            	Priority
                            	**type**\:  int
                            
                            	**range:** 0..127
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.Priorities.Priority, self).__init__()

                                self.yang_name = "priority"
                                self.yang_parent_name = "priorities"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.priority_value = YLeaf(YType.uint32, "priority-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "priority_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.Priorities.Priority, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.Priorities.Priority, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.priority_value.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.priority_value.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "priority" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.priority_value.is_set or self.priority_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "priority-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority-value"):
                                    self.priority_value = value
                                    self.priority_value.value_namespace = name_space
                                    self.priority_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.priority:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.priority:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "priorities" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "priority"):
                                for c in self.priority:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.Priorities.Priority()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.priority.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class HelloAcceptPasswords(Entity):
                        """
                        IIH accept password configuration
                        
                        .. attribute:: hello_accept_password
                        
                        	IIH accept passwords. This requires the existence of a HelloPassword of the same level
                        	**type**\: list of    :py:class:`HelloAcceptPassword <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords.HelloAcceptPassword>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords, self).__init__()

                            self.yang_name = "hello-accept-passwords"
                            self.yang_parent_name = "interface"

                            self.hello_accept_password = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords, self).__setattr__(name, value)


                        class HelloAcceptPassword(Entity):
                            """
                            IIH accept passwords. This requires the
                            existence of a HelloPassword of the same
                            level.
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: password
                            
                            	Password
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords.HelloAcceptPassword, self).__init__()

                                self.yang_name = "hello-accept-password"
                                self.yang_parent_name = "hello-accept-passwords"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.password = YLeaf(YType.str, "password")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "password") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords.HelloAcceptPassword, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords.HelloAcceptPassword, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.password.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.password.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "hello-accept-password" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.password.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "password"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "password"):
                                    self.password = value
                                    self.password.value_namespace = name_space
                                    self.password.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.hello_accept_password:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.hello_accept_password:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hello-accept-passwords" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "hello-accept-password"):
                                for c in self.hello_accept_password:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords.HelloAcceptPassword()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.hello_accept_password.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hello-accept-password"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class HelloPasswords(Entity):
                        """
                        IIH password configuration
                        
                        .. attribute:: hello_password
                        
                        	IIH passwords. This must exist if a HelloAcceptPassword of the same level exists
                        	**type**\: list of    :py:class:`HelloPassword <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloPasswords.HelloPassword>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.HelloPasswords, self).__init__()

                            self.yang_name = "hello-passwords"
                            self.yang_parent_name = "interface"

                            self.hello_password = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloPasswords, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.HelloPasswords, self).__setattr__(name, value)


                        class HelloPassword(Entity):
                            """
                            IIH passwords. This must exist if a
                            HelloAcceptPassword of the same level
                            exists.
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: algorithm
                            
                            	Algorithm
                            	**type**\:   :py:class:`IsisAuthenticationAlgorithm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAuthenticationAlgorithm>`
                            
                            	**mandatory**\: True
                            
                            .. attribute:: failure_mode
                            
                            	Failure Mode
                            	**type**\:   :py:class:`IsisAuthenticationFailureMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisAuthenticationFailureMode>`
                            
                            	**mandatory**\: True
                            
                            .. attribute:: password
                            
                            	Password or unencrypted Key Chain name
                            	**type**\:  str
                            
                            	**pattern:** (!.+)\|([^!].+)
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.HelloPasswords.HelloPassword, self).__init__()

                                self.yang_name = "hello-password"
                                self.yang_parent_name = "hello-passwords"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.algorithm = YLeaf(YType.enumeration, "algorithm")

                                self.failure_mode = YLeaf(YType.enumeration, "failure-mode")

                                self.password = YLeaf(YType.str, "password")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "algorithm",
                                                "failure_mode",
                                                "password") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.HelloPasswords.HelloPassword, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloPasswords.HelloPassword, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.algorithm.is_set or
                                    self.failure_mode.is_set or
                                    self.password.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.algorithm.yfilter != YFilter.not_set or
                                    self.failure_mode.yfilter != YFilter.not_set or
                                    self.password.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "hello-password" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.algorithm.is_set or self.algorithm.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.algorithm.get_name_leafdata())
                                if (self.failure_mode.is_set or self.failure_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.failure_mode.get_name_leafdata())
                                if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.password.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "algorithm" or name == "failure-mode" or name == "password"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "algorithm"):
                                    self.algorithm = value
                                    self.algorithm.value_namespace = name_space
                                    self.algorithm.value_namespace_prefix = name_space_prefix
                                if(value_path == "failure-mode"):
                                    self.failure_mode = value
                                    self.failure_mode.value_namespace = name_space
                                    self.failure_mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "password"):
                                    self.password = value
                                    self.password.value_namespace = name_space
                                    self.password.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.hello_password:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.hello_password:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hello-passwords" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "hello-password"):
                                for c in self.hello_password:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.HelloPasswords.HelloPassword()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.hello_password.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hello-password"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class HelloPaddings(Entity):
                        """
                        Hello\-padding configuration
                        
                        .. attribute:: hello_padding
                        
                        	Pad IIHs to the interface MTU
                        	**type**\: list of    :py:class:`HelloPadding <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloPaddings.HelloPadding>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.HelloPaddings, self).__init__()

                            self.yang_name = "hello-paddings"
                            self.yang_parent_name = "interface"

                            self.hello_padding = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloPaddings, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.HelloPaddings, self).__setattr__(name, value)


                        class HelloPadding(Entity):
                            """
                            Pad IIHs to the interface MTU
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: padding_type
                            
                            	Hello padding type value
                            	**type**\:   :py:class:`IsisHelloPadding <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisHelloPadding>`
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.HelloPaddings.HelloPadding, self).__init__()

                                self.yang_name = "hello-padding"
                                self.yang_parent_name = "hello-paddings"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.padding_type = YLeaf(YType.enumeration, "padding-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "padding_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.HelloPaddings.HelloPadding, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloPaddings.HelloPadding, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.padding_type.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.padding_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "hello-padding" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.padding_type.is_set or self.padding_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.padding_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "padding-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "padding-type"):
                                    self.padding_type = value
                                    self.padding_type.value_namespace = name_space
                                    self.padding_type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.hello_padding:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.hello_padding:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hello-paddings" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "hello-padding"):
                                for c in self.hello_padding:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.HelloPaddings.HelloPadding()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.hello_padding.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hello-padding"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class HelloMultipliers(Entity):
                        """
                        Hello\-multiplier configuration
                        
                        .. attribute:: hello_multiplier
                        
                        	Hello\-multiplier configuration. The number of successive IIHs that may be missed on an adjacency before it is considered down
                        	**type**\: list of    :py:class:`HelloMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers.HelloMultiplier>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers, self).__init__()

                            self.yang_name = "hello-multipliers"
                            self.yang_parent_name = "interface"

                            self.hello_multiplier = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers, self).__setattr__(name, value)


                        class HelloMultiplier(Entity):
                            """
                            Hello\-multiplier configuration. The number
                            of successive IIHs that may be missed on an
                            adjacency before it is considered down.
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: multiplier
                            
                            	Hello multiplier value
                            	**type**\:  int
                            
                            	**range:** 3..1000
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers.HelloMultiplier, self).__init__()

                                self.yang_name = "hello-multiplier"
                                self.yang_parent_name = "hello-multipliers"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.multiplier = YLeaf(YType.uint32, "multiplier")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "multiplier") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers.HelloMultiplier, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers.HelloMultiplier, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.multiplier.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.multiplier.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "hello-multiplier" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.multiplier.is_set or self.multiplier.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multiplier.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "multiplier"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "multiplier"):
                                    self.multiplier = value
                                    self.multiplier.value_namespace = name_space
                                    self.multiplier.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.hello_multiplier:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.hello_multiplier:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hello-multipliers" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "hello-multiplier"):
                                for c in self.hello_multiplier:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers.HelloMultiplier()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.hello_multiplier.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hello-multiplier"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class LspFastFloodThresholds(Entity):
                        """
                        LSP fast flood threshold configuration
                        
                        .. attribute:: lsp_fast_flood_threshold
                        
                        	Number of LSPs to send back to back on an interface
                        	**type**\: list of    :py:class:`LspFastFloodThreshold <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds.LspFastFloodThreshold>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds, self).__init__()

                            self.yang_name = "lsp-fast-flood-thresholds"
                            self.yang_parent_name = "interface"

                            self.lsp_fast_flood_threshold = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds, self).__setattr__(name, value)


                        class LspFastFloodThreshold(Entity):
                            """
                            Number of LSPs to send back to back on an
                            interface.
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: count
                            
                            	Count
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds.LspFastFloodThreshold, self).__init__()

                                self.yang_name = "lsp-fast-flood-threshold"
                                self.yang_parent_name = "lsp-fast-flood-thresholds"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.count = YLeaf(YType.uint32, "count")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds.LspFastFloodThreshold, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds.LspFastFloodThreshold, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.count.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-fast-flood-threshold" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.count.is_set or self.count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "count"):
                                    self.count = value
                                    self.count.value_namespace = name_space
                                    self.count.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsp_fast_flood_threshold:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.lsp_fast_flood_threshold:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "lsp-fast-flood-thresholds" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsp-fast-flood-threshold"):
                                for c in self.lsp_fast_flood_threshold:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds.LspFastFloodThreshold()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_fast_flood_threshold.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsp-fast-flood-threshold"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class PrefixAttributeNFlagClears(Entity):
                        """
                        Prefix attribute N flag clear configuration
                        
                        .. attribute:: prefix_attribute_n_flag_clear
                        
                        	Clear the N flag in prefix attribute flags sub\-TLV
                        	**type**\: list of    :py:class:`PrefixAttributeNFlagClear <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears.PrefixAttributeNFlagClear>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears, self).__init__()

                            self.yang_name = "prefix-attribute-n-flag-clears"
                            self.yang_parent_name = "interface"

                            self.prefix_attribute_n_flag_clear = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears, self).__setattr__(name, value)


                        class PrefixAttributeNFlagClear(Entity):
                            """
                            Clear the N flag in prefix attribute flags
                            sub\-TLV
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears.PrefixAttributeNFlagClear, self).__init__()

                                self.yang_name = "prefix-attribute-n-flag-clear"
                                self.yang_parent_name = "prefix-attribute-n-flag-clears"

                                self.level = YLeaf(YType.enumeration, "level")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears.PrefixAttributeNFlagClear, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears.PrefixAttributeNFlagClear, self).__setattr__(name, value)

                            def has_data(self):
                                return self.level.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "prefix-attribute-n-flag-clear" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.prefix_attribute_n_flag_clear:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.prefix_attribute_n_flag_clear:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-attribute-n-flag-clears" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "prefix-attribute-n-flag-clear"):
                                for c in self.prefix_attribute_n_flag_clear:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears.PrefixAttributeNFlagClear()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.prefix_attribute_n_flag_clear.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-attribute-n-flag-clear"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class HelloIntervals(Entity):
                        """
                        Hello\-interval configuration
                        
                        .. attribute:: hello_interval
                        
                        	Hello\-interval configuration. The interval at which IIH packets will be sent. This will be three times quicker on a LAN interface which has been electted DIS
                        	**type**\: list of    :py:class:`HelloInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.HelloIntervals.HelloInterval>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.HelloIntervals, self).__init__()

                            self.yang_name = "hello-intervals"
                            self.yang_parent_name = "interface"

                            self.hello_interval = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloIntervals, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.HelloIntervals, self).__setattr__(name, value)


                        class HelloInterval(Entity):
                            """
                            Hello\-interval configuration. The interval
                            at which IIH packets will be sent. This
                            will be three times quicker on a LAN
                            interface which has been electted DIS.
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: interval
                            
                            	Seconds
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**mandatory**\: True
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.HelloIntervals.HelloInterval, self).__init__()

                                self.yang_name = "hello-interval"
                                self.yang_parent_name = "hello-intervals"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.HelloIntervals.HelloInterval, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.HelloIntervals.HelloInterval, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "hello-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.hello_interval:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.hello_interval:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hello-intervals" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "hello-interval"):
                                for c in self.hello_interval:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.HelloIntervals.HelloInterval()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.hello_interval.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hello-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class InterfaceAfs(Entity):
                        """
                        Per\-interface address\-family configuration
                        
                        .. attribute:: interface_af
                        
                        	Configuration for an IS\-IS address\-family on a single interface. If a named (non\-default) topology is being created it must be multicast. Also the topology ID mustbe set first and delete last in the router configuration
                        	**type**\: list of    :py:class:`InterfaceAf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs, self).__init__()

                            self.yang_name = "interface-afs"
                            self.yang_parent_name = "interface"

                            self.interface_af = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs, self).__setattr__(name, value)


                        class InterfaceAf(Entity):
                            """
                            Configuration for an IS\-IS address\-family
                            on a single interface. If a named
                            (non\-default) topology is being created it
                            must be multicast. Also the topology ID
                            mustbe set first and delete last in the
                            router configuration.
                            
                            .. attribute:: af_name  <key>
                            
                            	Address family
                            	**type**\:   :py:class:`IsisAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisAddressFamily>`
                            
                            .. attribute:: saf_name  <key>
                            
                            	Sub address family
                            	**type**\:   :py:class:`IsisSubAddressFamily <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisSubAddressFamily>`
                            
                            .. attribute:: interface_af_data
                            
                            	Data container
                            	**type**\:   :py:class:`InterfaceAfData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData>`
                            
                            .. attribute:: topology_name
                            
                            	keys\: topology\-name
                            	**type**\: list of    :py:class:`TopologyName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName>`
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf, self).__init__()

                                self.yang_name = "interface-af"
                                self.yang_parent_name = "interface-afs"

                                self.af_name = YLeaf(YType.enumeration, "af-name")

                                self.saf_name = YLeaf(YType.enumeration, "saf-name")

                                self.interface_af_data = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData()
                                self.interface_af_data.parent = self
                                self._children_name_map["interface_af_data"] = "interface-af-data"
                                self._children_yang_names.add("interface-af-data")

                                self.topology_name = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("af_name",
                                                "saf_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf, self).__setattr__(name, value)


                            class InterfaceAfData(Entity):
                                """
                                Data container.
                                
                                .. attribute:: admin_tags
                                
                                	admin\-tag configuration
                                	**type**\:   :py:class:`AdminTags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags>`
                                
                                .. attribute:: auto_metrics
                                
                                	AutoMetric configuration
                                	**type**\:   :py:class:`AutoMetrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics>`
                                
                                .. attribute:: interface_af_state
                                
                                	Interface state
                                	**type**\:   :py:class:`IsisInterfaceAfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisInterfaceAfState>`
                                
                                .. attribute:: interface_frr_table
                                
                                	Fast\-ReRoute configuration
                                	**type**\:   :py:class:`InterfaceFrrTable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable>`
                                
                                .. attribute:: interface_link_group
                                
                                	Provide link group name and level
                                	**type**\:   :py:class:`InterfaceLinkGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceLinkGroup>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: metrics
                                
                                	Metric configuration
                                	**type**\:   :py:class:`Metrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics>`
                                
                                .. attribute:: mpls_ldp
                                
                                	MPLS LDP configuration
                                	**type**\:   :py:class:`MplsLdp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.MplsLdp>`
                                
                                .. attribute:: prefix_sid
                                
                                	Assign prefix SID to an interface, ISISPHPFlag will be rejected if set to disable, ISISEXPLICITNULLFlag will override the value of ISISPHPFlag
                                	**type**\:   :py:class:`PrefixSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSid>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: prefix_sspfsid
                                
                                	Assign prefix SSPF SID to an interface, ISISPHPFlag will be rejected if set to disable, ISISEXPLICITNULLFlag will override the value of ISISPHPFlag
                                	**type**\:   :py:class:`PrefixSspfsid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSspfsid>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: running
                                
                                	The presence of this object allows an address\-family to be run over the interface in question.This must be the first object created under the InterfaceAddressFamily container, and the last one deleted
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: weights
                                
                                	Weight configuration
                                	**type**\:   :py:class:`Weights <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData, self).__init__()

                                    self.yang_name = "interface-af-data"
                                    self.yang_parent_name = "interface-af"

                                    self.interface_af_state = YLeaf(YType.enumeration, "interface-af-state")

                                    self.running = YLeaf(YType.empty, "running")

                                    self.admin_tags = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags()
                                    self.admin_tags.parent = self
                                    self._children_name_map["admin_tags"] = "admin-tags"
                                    self._children_yang_names.add("admin-tags")

                                    self.auto_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics()
                                    self.auto_metrics.parent = self
                                    self._children_name_map["auto_metrics"] = "auto-metrics"
                                    self._children_yang_names.add("auto-metrics")

                                    self.interface_frr_table = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable()
                                    self.interface_frr_table.parent = self
                                    self._children_name_map["interface_frr_table"] = "interface-frr-table"
                                    self._children_yang_names.add("interface-frr-table")

                                    self.interface_link_group = None
                                    self._children_name_map["interface_link_group"] = "interface-link-group"
                                    self._children_yang_names.add("interface-link-group")

                                    self.metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics()
                                    self.metrics.parent = self
                                    self._children_name_map["metrics"] = "metrics"
                                    self._children_yang_names.add("metrics")

                                    self.mpls_ldp = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.MplsLdp()
                                    self.mpls_ldp.parent = self
                                    self._children_name_map["mpls_ldp"] = "mpls-ldp"
                                    self._children_yang_names.add("mpls-ldp")

                                    self.prefix_sid = None
                                    self._children_name_map["prefix_sid"] = "prefix-sid"
                                    self._children_yang_names.add("prefix-sid")

                                    self.prefix_sspfsid = None
                                    self._children_name_map["prefix_sspfsid"] = "prefix-sspfsid"
                                    self._children_yang_names.add("prefix-sspfsid")

                                    self.weights = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights()
                                    self.weights.parent = self
                                    self._children_name_map["weights"] = "weights"
                                    self._children_yang_names.add("weights")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_af_state",
                                                    "running") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData, self).__setattr__(name, value)


                                class PrefixSid(Entity):
                                    """
                                    Assign prefix SID to an interface,
                                    ISISPHPFlag will be rejected if set to
                                    disable, ISISEXPLICITNULLFlag will
                                    override the value of ISISPHPFlag
                                    
                                    .. attribute:: explicit_null
                                    
                                    	Enable/Disable Explicit\-NULL flag
                                    	**type**\:   :py:class:`IsisexplicitNullFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisexplicitNullFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: nflag_clear
                                    
                                    	Clear N\-flag for the prefix\-SID
                                    	**type**\:   :py:class:`NflagClear <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.NflagClear>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: php
                                    
                                    	Enable/Disable Penultimate Hop Popping
                                    	**type**\:   :py:class:`IsisphpFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisphpFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: type
                                    
                                    	SID type for the interface
                                    	**type**\:   :py:class:`Isissid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isissid>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: value
                                    
                                    	SID value for the interface
                                    	**type**\:  int
                                    
                                    	**range:** 0..1048575
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSid, self).__init__()

                                        self.yang_name = "prefix-sid"
                                        self.yang_parent_name = "interface-af-data"
                                        self.is_presence_container = True

                                        self.explicit_null = YLeaf(YType.enumeration, "explicit-null")

                                        self.nflag_clear = YLeaf(YType.enumeration, "nflag-clear")

                                        self.php = YLeaf(YType.enumeration, "php")

                                        self.type = YLeaf(YType.enumeration, "type")

                                        self.value = YLeaf(YType.uint32, "value")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("explicit_null",
                                                        "nflag_clear",
                                                        "php",
                                                        "type",
                                                        "value") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSid, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSid, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.explicit_null.is_set or
                                            self.nflag_clear.is_set or
                                            self.php.is_set or
                                            self.type.is_set or
                                            self.value.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.explicit_null.yfilter != YFilter.not_set or
                                            self.nflag_clear.yfilter != YFilter.not_set or
                                            self.php.yfilter != YFilter.not_set or
                                            self.type.yfilter != YFilter.not_set or
                                            self.value.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "prefix-sid" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.explicit_null.is_set or self.explicit_null.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.explicit_null.get_name_leafdata())
                                        if (self.nflag_clear.is_set or self.nflag_clear.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nflag_clear.get_name_leafdata())
                                        if (self.php.is_set or self.php.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.php.get_name_leafdata())
                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type.get_name_leafdata())
                                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.value.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "explicit-null" or name == "nflag-clear" or name == "php" or name == "type" or name == "value"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "explicit-null"):
                                            self.explicit_null = value
                                            self.explicit_null.value_namespace = name_space
                                            self.explicit_null.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nflag-clear"):
                                            self.nflag_clear = value
                                            self.nflag_clear.value_namespace = name_space
                                            self.nflag_clear.value_namespace_prefix = name_space_prefix
                                        if(value_path == "php"):
                                            self.php = value
                                            self.php.value_namespace = name_space
                                            self.php.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type"):
                                            self.type = value
                                            self.type.value_namespace = name_space
                                            self.type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "value"):
                                            self.value = value
                                            self.value.value_namespace = name_space
                                            self.value.value_namespace_prefix = name_space_prefix


                                class InterfaceFrrTable(Entity):
                                    """
                                    Fast\-ReRoute configuration
                                    
                                    .. attribute:: frr_exclude_interfaces
                                    
                                    	FRR exclusion configuration
                                    	**type**\:   :py:class:`FrrExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces>`
                                    
                                    .. attribute:: frr_remote_lfa_max_metrics
                                    
                                    	Remote LFA maxmimum metric
                                    	**type**\:   :py:class:`FrrRemoteLfaMaxMetrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics>`
                                    
                                    .. attribute:: frr_remote_lfa_types
                                    
                                    	Remote LFA Enable
                                    	**type**\:   :py:class:`FrrRemoteLfaTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes>`
                                    
                                    .. attribute:: frr_types
                                    
                                    	Type of FRR computation per level
                                    	**type**\:   :py:class:`FrrTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes>`
                                    
                                    .. attribute:: frrlfa_candidate_interfaces
                                    
                                    	FRR LFA candidate configuration
                                    	**type**\:   :py:class:`FrrlfaCandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces>`
                                    
                                    .. attribute:: frrtilfa_types
                                    
                                    	TI LFA Enable
                                    	**type**\:   :py:class:`FrrtilfaTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes>`
                                    
                                    .. attribute:: interface_frr_tiebreaker_defaults
                                    
                                    	Interface FRR Default tiebreaker configuration
                                    	**type**\:   :py:class:`InterfaceFrrTiebreakerDefaults <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults>`
                                    
                                    .. attribute:: interface_frr_tiebreakers
                                    
                                    	Interface FRR tiebreakers configuration
                                    	**type**\:   :py:class:`InterfaceFrrTiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable, self).__init__()

                                        self.yang_name = "interface-frr-table"
                                        self.yang_parent_name = "interface-af-data"

                                        self.frr_exclude_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces()
                                        self.frr_exclude_interfaces.parent = self
                                        self._children_name_map["frr_exclude_interfaces"] = "frr-exclude-interfaces"
                                        self._children_yang_names.add("frr-exclude-interfaces")

                                        self.frr_remote_lfa_max_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics()
                                        self.frr_remote_lfa_max_metrics.parent = self
                                        self._children_name_map["frr_remote_lfa_max_metrics"] = "frr-remote-lfa-max-metrics"
                                        self._children_yang_names.add("frr-remote-lfa-max-metrics")

                                        self.frr_remote_lfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes()
                                        self.frr_remote_lfa_types.parent = self
                                        self._children_name_map["frr_remote_lfa_types"] = "frr-remote-lfa-types"
                                        self._children_yang_names.add("frr-remote-lfa-types")

                                        self.frr_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes()
                                        self.frr_types.parent = self
                                        self._children_name_map["frr_types"] = "frr-types"
                                        self._children_yang_names.add("frr-types")

                                        self.frrlfa_candidate_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces()
                                        self.frrlfa_candidate_interfaces.parent = self
                                        self._children_name_map["frrlfa_candidate_interfaces"] = "frrlfa-candidate-interfaces"
                                        self._children_yang_names.add("frrlfa-candidate-interfaces")

                                        self.frrtilfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes()
                                        self.frrtilfa_types.parent = self
                                        self._children_name_map["frrtilfa_types"] = "frrtilfa-types"
                                        self._children_yang_names.add("frrtilfa-types")

                                        self.interface_frr_tiebreaker_defaults = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults()
                                        self.interface_frr_tiebreaker_defaults.parent = self
                                        self._children_name_map["interface_frr_tiebreaker_defaults"] = "interface-frr-tiebreaker-defaults"
                                        self._children_yang_names.add("interface-frr-tiebreaker-defaults")

                                        self.interface_frr_tiebreakers = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers()
                                        self.interface_frr_tiebreakers.parent = self
                                        self._children_name_map["interface_frr_tiebreakers"] = "interface-frr-tiebreakers"
                                        self._children_yang_names.add("interface-frr-tiebreakers")


                                    class FrrlfaCandidateInterfaces(Entity):
                                        """
                                        FRR LFA candidate configuration
                                        
                                        .. attribute:: frrlfa_candidate_interface
                                        
                                        	Include an interface to LFA candidate in computation
                                        	**type**\: list of    :py:class:`FrrlfaCandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces, self).__init__()

                                            self.yang_name = "frrlfa-candidate-interfaces"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frrlfa_candidate_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces, self).__setattr__(name, value)


                                        class FrrlfaCandidateInterface(Entity):
                                            """
                                            Include an interface to LFA candidate
                                            in computation
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: frr_type  <key>
                                            
                                            	Computation Type
                                            	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                            
                                            .. attribute:: level
                                            
                                            	Level
                                            	**type**\:  int
                                            
                                            	**range:** 0..2
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface, self).__init__()

                                                self.yang_name = "frrlfa-candidate-interface"
                                                self.yang_parent_name = "frrlfa-candidate-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                                self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                                self.level = YLeaf(YType.uint32, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name",
                                                                "frr_type",
                                                                "level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.interface_name.is_set or
                                                    self.frr_type.is_set or
                                                    self.level.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set or
                                                    self.frr_type.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frrlfa-candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                                if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.frr_type.get_name_leafdata())
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name" or name == "frr-type" or name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "frr-type"):
                                                    self.frr_type = value
                                                    self.frr_type.value_namespace = name_space
                                                    self.frr_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frrlfa_candidate_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frrlfa_candidate_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frrlfa-candidate-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frrlfa-candidate-interface"):
                                                for c in self.frrlfa_candidate_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frrlfa_candidate_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frrlfa-candidate-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrRemoteLfaMaxMetrics(Entity):
                                        """
                                        Remote LFA maxmimum metric
                                        
                                        .. attribute:: frr_remote_lfa_max_metric
                                        
                                        	Configure the maximum metric for selecting a remote LFA node
                                        	**type**\: list of    :py:class:`FrrRemoteLfaMaxMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics, self).__init__()

                                            self.yang_name = "frr-remote-lfa-max-metrics"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_remote_lfa_max_metric = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics, self).__setattr__(name, value)


                                        class FrrRemoteLfaMaxMetric(Entity):
                                            """
                                            Configure the maximum metric for
                                            selecting a remote LFA node
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: max_metric
                                            
                                            	Value of the metric
                                            	**type**\:  int
                                            
                                            	**range:** 1..16777215
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric, self).__init__()

                                                self.yang_name = "frr-remote-lfa-max-metric"
                                                self.yang_parent_name = "frr-remote-lfa-max-metrics"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.max_metric = YLeaf(YType.uint32, "max-metric")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "max_metric") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.max_metric.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.max_metric.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-remote-lfa-max-metric" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.max_metric.is_set or self.max_metric.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.max_metric.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "max-metric"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "max-metric"):
                                                    self.max_metric = value
                                                    self.max_metric.value_namespace = name_space
                                                    self.max_metric.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_remote_lfa_max_metric:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_remote_lfa_max_metric:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-remote-lfa-max-metrics" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-remote-lfa-max-metric"):
                                                for c in self.frr_remote_lfa_max_metric:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_remote_lfa_max_metric.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-remote-lfa-max-metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrTypes(Entity):
                                        """
                                        Type of FRR computation per level
                                        
                                        .. attribute:: frr_type
                                        
                                        	Type of computation for prefixes reachable via interface
                                        	**type**\: list of    :py:class:`FrrType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes.FrrType>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes, self).__init__()

                                            self.yang_name = "frr-types"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_type = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes, self).__setattr__(name, value)


                                        class FrrType(Entity):
                                            """
                                            Type of computation for prefixes
                                            reachable via interface
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: type
                                            
                                            	Computation Type
                                            	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes.FrrType, self).__init__()

                                                self.yang_name = "frr-type"
                                                self.yang_parent_name = "frr-types"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.type = YLeaf(YType.enumeration, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes.FrrType, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes.FrrType, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-type" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_type:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_type:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-types" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-type"):
                                                for c in self.frr_type:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes.FrrType()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_type.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrRemoteLfaTypes(Entity):
                                        """
                                        Remote LFA Enable
                                        
                                        .. attribute:: frr_remote_lfa_type
                                        
                                        	Enable remote lfa for a particular level
                                        	**type**\: list of    :py:class:`FrrRemoteLfaType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes, self).__init__()

                                            self.yang_name = "frr-remote-lfa-types"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_remote_lfa_type = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes, self).__setattr__(name, value)


                                        class FrrRemoteLfaType(Entity):
                                            """
                                            Enable remote lfa for a particular
                                            level
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: type
                                            
                                            	Remote LFA Type
                                            	**type**\:   :py:class:`IsisRemoteLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisRemoteLfa>`
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType, self).__init__()

                                                self.yang_name = "frr-remote-lfa-type"
                                                self.yang_parent_name = "frr-remote-lfa-types"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.type = YLeaf(YType.enumeration, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-remote-lfa-type" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_remote_lfa_type:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_remote_lfa_type:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-remote-lfa-types" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-remote-lfa-type"):
                                                for c in self.frr_remote_lfa_type:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_remote_lfa_type.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-remote-lfa-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class InterfaceFrrTiebreakerDefaults(Entity):
                                        """
                                        Interface FRR Default tiebreaker
                                        configuration
                                        
                                        .. attribute:: interface_frr_tiebreaker_default
                                        
                                        	Configure default tiebreaker
                                        	**type**\: list of    :py:class:`InterfaceFrrTiebreakerDefault <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults, self).__init__()

                                            self.yang_name = "interface-frr-tiebreaker-defaults"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.interface_frr_tiebreaker_default = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults, self).__setattr__(name, value)


                                        class InterfaceFrrTiebreakerDefault(Entity):
                                            """
                                            Configure default tiebreaker
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault, self).__init__()

                                                self.yang_name = "interface-frr-tiebreaker-default"
                                                self.yang_parent_name = "interface-frr-tiebreaker-defaults"

                                                self.level = YLeaf(YType.enumeration, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.level.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "interface-frr-tiebreaker-default" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.interface_frr_tiebreaker_default:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.interface_frr_tiebreaker_default:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-frr-tiebreaker-defaults" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "interface-frr-tiebreaker-default"):
                                                for c in self.interface_frr_tiebreaker_default:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.interface_frr_tiebreaker_default.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-frr-tiebreaker-default"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrtilfaTypes(Entity):
                                        """
                                        TI LFA Enable
                                        
                                        .. attribute:: frrtilfa_type
                                        
                                        	Enable TI lfa for a particular level
                                        	**type**\: list of    :py:class:`FrrtilfaType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes, self).__init__()

                                            self.yang_name = "frrtilfa-types"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frrtilfa_type = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes, self).__setattr__(name, value)


                                        class FrrtilfaType(Entity):
                                            """
                                            Enable TI lfa for a particular level
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType, self).__init__()

                                                self.yang_name = "frrtilfa-type"
                                                self.yang_parent_name = "frrtilfa-types"

                                                self.level = YLeaf(YType.enumeration, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.level.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frrtilfa-type" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frrtilfa_type:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frrtilfa_type:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frrtilfa-types" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frrtilfa-type"):
                                                for c in self.frrtilfa_type:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frrtilfa_type.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frrtilfa-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrExcludeInterfaces(Entity):
                                        """
                                        FRR exclusion configuration
                                        
                                        .. attribute:: frr_exclude_interface
                                        
                                        	Exclude an interface from computation
                                        	**type**\: list of    :py:class:`FrrExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces, self).__init__()

                                            self.yang_name = "frr-exclude-interfaces"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_exclude_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces, self).__setattr__(name, value)


                                        class FrrExcludeInterface(Entity):
                                            """
                                            Exclude an interface from computation
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: frr_type  <key>
                                            
                                            	Computation Type
                                            	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                            
                                            .. attribute:: level
                                            
                                            	Level
                                            	**type**\:  int
                                            
                                            	**range:** 0..2
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface, self).__init__()

                                                self.yang_name = "frr-exclude-interface"
                                                self.yang_parent_name = "frr-exclude-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                                self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                                self.level = YLeaf(YType.uint32, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name",
                                                                "frr_type",
                                                                "level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.interface_name.is_set or
                                                    self.frr_type.is_set or
                                                    self.level.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set or
                                                    self.frr_type.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                                if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.frr_type.get_name_leafdata())
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name" or name == "frr-type" or name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "frr-type"):
                                                    self.frr_type = value
                                                    self.frr_type.value_namespace = name_space
                                                    self.frr_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_exclude_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_exclude_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-exclude-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-exclude-interface"):
                                                for c in self.frr_exclude_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_exclude_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-exclude-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class InterfaceFrrTiebreakers(Entity):
                                        """
                                        Interface FRR tiebreakers configuration
                                        
                                        .. attribute:: interface_frr_tiebreaker
                                        
                                        	Configure tiebreaker for multiple backups
                                        	**type**\: list of    :py:class:`InterfaceFrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers, self).__init__()

                                            self.yang_name = "interface-frr-tiebreakers"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.interface_frr_tiebreaker = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers, self).__setattr__(name, value)


                                        class InterfaceFrrTiebreaker(Entity):
                                            """
                                            Configure tiebreaker for multiple
                                            backups
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: tiebreaker  <key>
                                            
                                            	Tiebreaker for which configuration applies
                                            	**type**\:   :py:class:`IsisInterfaceFrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisInterfaceFrrTiebreaker>`
                                            
                                            .. attribute:: index
                                            
                                            	Preference order among tiebreakers
                                            	**type**\:  int
                                            
                                            	**range:** 1..255
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker, self).__init__()

                                                self.yang_name = "interface-frr-tiebreaker"
                                                self.yang_parent_name = "interface-frr-tiebreakers"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.tiebreaker = YLeaf(YType.enumeration, "tiebreaker")

                                                self.index = YLeaf(YType.uint32, "index")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "tiebreaker",
                                                                "index") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.tiebreaker.is_set or
                                                    self.index.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.tiebreaker.yfilter != YFilter.not_set or
                                                    self.index.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "interface-frr-tiebreaker" + "[level='" + self.level.get() + "']" + "[tiebreaker='" + self.tiebreaker.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.tiebreaker.is_set or self.tiebreaker.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.tiebreaker.get_name_leafdata())
                                                if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.index.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "tiebreaker" or name == "index"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "tiebreaker"):
                                                    self.tiebreaker = value
                                                    self.tiebreaker.value_namespace = name_space
                                                    self.tiebreaker.value_namespace_prefix = name_space_prefix
                                                if(value_path == "index"):
                                                    self.index = value
                                                    self.index.value_namespace = name_space
                                                    self.index.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.interface_frr_tiebreaker:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.interface_frr_tiebreaker:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-frr-tiebreakers" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "interface-frr-tiebreaker"):
                                                for c in self.interface_frr_tiebreaker:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.interface_frr_tiebreaker.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-frr-tiebreaker"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            (self.frr_exclude_interfaces is not None and self.frr_exclude_interfaces.has_data()) or
                                            (self.frr_remote_lfa_max_metrics is not None and self.frr_remote_lfa_max_metrics.has_data()) or
                                            (self.frr_remote_lfa_types is not None and self.frr_remote_lfa_types.has_data()) or
                                            (self.frr_types is not None and self.frr_types.has_data()) or
                                            (self.frrlfa_candidate_interfaces is not None and self.frrlfa_candidate_interfaces.has_data()) or
                                            (self.frrtilfa_types is not None and self.frrtilfa_types.has_data()) or
                                            (self.interface_frr_tiebreaker_defaults is not None and self.interface_frr_tiebreaker_defaults.has_data()) or
                                            (self.interface_frr_tiebreakers is not None and self.interface_frr_tiebreakers.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.frr_exclude_interfaces is not None and self.frr_exclude_interfaces.has_operation()) or
                                            (self.frr_remote_lfa_max_metrics is not None and self.frr_remote_lfa_max_metrics.has_operation()) or
                                            (self.frr_remote_lfa_types is not None and self.frr_remote_lfa_types.has_operation()) or
                                            (self.frr_types is not None and self.frr_types.has_operation()) or
                                            (self.frrlfa_candidate_interfaces is not None and self.frrlfa_candidate_interfaces.has_operation()) or
                                            (self.frrtilfa_types is not None and self.frrtilfa_types.has_operation()) or
                                            (self.interface_frr_tiebreaker_defaults is not None and self.interface_frr_tiebreaker_defaults.has_operation()) or
                                            (self.interface_frr_tiebreakers is not None and self.interface_frr_tiebreakers.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-frr-table" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "frr-exclude-interfaces"):
                                            if (self.frr_exclude_interfaces is None):
                                                self.frr_exclude_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrExcludeInterfaces()
                                                self.frr_exclude_interfaces.parent = self
                                                self._children_name_map["frr_exclude_interfaces"] = "frr-exclude-interfaces"
                                            return self.frr_exclude_interfaces

                                        if (child_yang_name == "frr-remote-lfa-max-metrics"):
                                            if (self.frr_remote_lfa_max_metrics is None):
                                                self.frr_remote_lfa_max_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaMaxMetrics()
                                                self.frr_remote_lfa_max_metrics.parent = self
                                                self._children_name_map["frr_remote_lfa_max_metrics"] = "frr-remote-lfa-max-metrics"
                                            return self.frr_remote_lfa_max_metrics

                                        if (child_yang_name == "frr-remote-lfa-types"):
                                            if (self.frr_remote_lfa_types is None):
                                                self.frr_remote_lfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrRemoteLfaTypes()
                                                self.frr_remote_lfa_types.parent = self
                                                self._children_name_map["frr_remote_lfa_types"] = "frr-remote-lfa-types"
                                            return self.frr_remote_lfa_types

                                        if (child_yang_name == "frr-types"):
                                            if (self.frr_types is None):
                                                self.frr_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrTypes()
                                                self.frr_types.parent = self
                                                self._children_name_map["frr_types"] = "frr-types"
                                            return self.frr_types

                                        if (child_yang_name == "frrlfa-candidate-interfaces"):
                                            if (self.frrlfa_candidate_interfaces is None):
                                                self.frrlfa_candidate_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrlfaCandidateInterfaces()
                                                self.frrlfa_candidate_interfaces.parent = self
                                                self._children_name_map["frrlfa_candidate_interfaces"] = "frrlfa-candidate-interfaces"
                                            return self.frrlfa_candidate_interfaces

                                        if (child_yang_name == "frrtilfa-types"):
                                            if (self.frrtilfa_types is None):
                                                self.frrtilfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.FrrtilfaTypes()
                                                self.frrtilfa_types.parent = self
                                                self._children_name_map["frrtilfa_types"] = "frrtilfa-types"
                                            return self.frrtilfa_types

                                        if (child_yang_name == "interface-frr-tiebreaker-defaults"):
                                            if (self.interface_frr_tiebreaker_defaults is None):
                                                self.interface_frr_tiebreaker_defaults = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults()
                                                self.interface_frr_tiebreaker_defaults.parent = self
                                                self._children_name_map["interface_frr_tiebreaker_defaults"] = "interface-frr-tiebreaker-defaults"
                                            return self.interface_frr_tiebreaker_defaults

                                        if (child_yang_name == "interface-frr-tiebreakers"):
                                            if (self.interface_frr_tiebreakers is None):
                                                self.interface_frr_tiebreakers = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable.InterfaceFrrTiebreakers()
                                                self.interface_frr_tiebreakers.parent = self
                                                self._children_name_map["interface_frr_tiebreakers"] = "interface-frr-tiebreakers"
                                            return self.interface_frr_tiebreakers

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "frr-exclude-interfaces" or name == "frr-remote-lfa-max-metrics" or name == "frr-remote-lfa-types" or name == "frr-types" or name == "frrlfa-candidate-interfaces" or name == "frrtilfa-types" or name == "interface-frr-tiebreaker-defaults" or name == "interface-frr-tiebreakers"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class MplsLdp(Entity):
                                    """
                                    MPLS LDP configuration
                                    
                                    .. attribute:: sync_level
                                    
                                    	Enable MPLS LDP Synchronization for an IS\-IS level
                                    	**type**\:  int
                                    
                                    	**range:** 0..2
                                    
                                    	**default value**\: 0
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.MplsLdp, self).__init__()

                                        self.yang_name = "mpls-ldp"
                                        self.yang_parent_name = "interface-af-data"

                                        self.sync_level = YLeaf(YType.uint32, "sync-level")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("sync_level") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.MplsLdp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.MplsLdp, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.sync_level.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.sync_level.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-ldp" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.sync_level.is_set or self.sync_level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.sync_level.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "sync-level"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "sync-level"):
                                            self.sync_level = value
                                            self.sync_level.value_namespace = name_space
                                            self.sync_level.value_namespace_prefix = name_space_prefix


                                class PrefixSspfsid(Entity):
                                    """
                                    Assign prefix SSPF SID to an interface,
                                    ISISPHPFlag will be rejected if set to
                                    disable, ISISEXPLICITNULLFlag will
                                    override the value of ISISPHPFlag
                                    
                                    .. attribute:: explicit_null
                                    
                                    	Enable/Disable Explicit\-NULL flag
                                    	**type**\:   :py:class:`IsisexplicitNullFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisexplicitNullFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: nflag_clear
                                    
                                    	Clear N\-flag for the prefix\-SID
                                    	**type**\:   :py:class:`NflagClear <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.NflagClear>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: php
                                    
                                    	Enable/Disable Penultimate Hop Popping
                                    	**type**\:   :py:class:`IsisphpFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisphpFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: type
                                    
                                    	SID type for the interface
                                    	**type**\:   :py:class:`Isissid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isissid>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: value
                                    
                                    	SID value for the interface
                                    	**type**\:  int
                                    
                                    	**range:** 0..1048575
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSspfsid, self).__init__()

                                        self.yang_name = "prefix-sspfsid"
                                        self.yang_parent_name = "interface-af-data"
                                        self.is_presence_container = True

                                        self.explicit_null = YLeaf(YType.enumeration, "explicit-null")

                                        self.nflag_clear = YLeaf(YType.enumeration, "nflag-clear")

                                        self.php = YLeaf(YType.enumeration, "php")

                                        self.type = YLeaf(YType.enumeration, "type")

                                        self.value = YLeaf(YType.uint32, "value")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("explicit_null",
                                                        "nflag_clear",
                                                        "php",
                                                        "type",
                                                        "value") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSspfsid, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSspfsid, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.explicit_null.is_set or
                                            self.nflag_clear.is_set or
                                            self.php.is_set or
                                            self.type.is_set or
                                            self.value.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.explicit_null.yfilter != YFilter.not_set or
                                            self.nflag_clear.yfilter != YFilter.not_set or
                                            self.php.yfilter != YFilter.not_set or
                                            self.type.yfilter != YFilter.not_set or
                                            self.value.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "prefix-sspfsid" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.explicit_null.is_set or self.explicit_null.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.explicit_null.get_name_leafdata())
                                        if (self.nflag_clear.is_set or self.nflag_clear.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nflag_clear.get_name_leafdata())
                                        if (self.php.is_set or self.php.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.php.get_name_leafdata())
                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type.get_name_leafdata())
                                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.value.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "explicit-null" or name == "nflag-clear" or name == "php" or name == "type" or name == "value"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "explicit-null"):
                                            self.explicit_null = value
                                            self.explicit_null.value_namespace = name_space
                                            self.explicit_null.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nflag-clear"):
                                            self.nflag_clear = value
                                            self.nflag_clear.value_namespace = name_space
                                            self.nflag_clear.value_namespace_prefix = name_space_prefix
                                        if(value_path == "php"):
                                            self.php = value
                                            self.php.value_namespace = name_space
                                            self.php.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type"):
                                            self.type = value
                                            self.type.value_namespace = name_space
                                            self.type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "value"):
                                            self.value = value
                                            self.value.value_namespace = name_space
                                            self.value.value_namespace_prefix = name_space_prefix


                                class AutoMetrics(Entity):
                                    """
                                    AutoMetric configuration
                                    
                                    .. attribute:: auto_metric
                                    
                                    	AutoMetric Proactive\-Protect configuration. Legal value depends on the metric\-style specified for the topology. If the metric\-style defined is narrow, then only a value between <1\-63> is allowed and if the metric\-style is defined as wide, then a value between <1\-16777214> is allowed as the auto\-metric value
                                    	**type**\: list of    :py:class:`AutoMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics.AutoMetric>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics, self).__init__()

                                        self.yang_name = "auto-metrics"
                                        self.yang_parent_name = "interface-af-data"

                                        self.auto_metric = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics, self).__setattr__(name, value)


                                    class AutoMetric(Entity):
                                        """
                                        AutoMetric Proactive\-Protect
                                        configuration. Legal value depends on
                                        the metric\-style specified for the
                                        topology. If the metric\-style defined is
                                        narrow, then only a value between <1\-63>
                                        is allowed and if the metric\-style is
                                        defined as wide, then a value between
                                        <1\-16777214> is allowed as the
                                        auto\-metric value.
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: proactive_protect
                                        
                                        	Allowed auto metric\:<1\-63> for narrow ,<1\-16777214> for wide
                                        	**type**\:  int
                                        
                                        	**range:** 1..16777214
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics.AutoMetric, self).__init__()

                                            self.yang_name = "auto-metric"
                                            self.yang_parent_name = "auto-metrics"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.proactive_protect = YLeaf(YType.uint32, "proactive-protect")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "proactive_protect") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics.AutoMetric, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics.AutoMetric, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.proactive_protect.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.proactive_protect.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "auto-metric" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.proactive_protect.is_set or self.proactive_protect.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.proactive_protect.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "proactive-protect"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "proactive-protect"):
                                                self.proactive_protect = value
                                                self.proactive_protect.value_namespace = name_space
                                                self.proactive_protect.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.auto_metric:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.auto_metric:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "auto-metrics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "auto-metric"):
                                            for c in self.auto_metric:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics.AutoMetric()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.auto_metric.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "auto-metric"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class AdminTags(Entity):
                                    """
                                    admin\-tag configuration
                                    
                                    .. attribute:: admin_tag
                                    
                                    	Admin tag for advertised interface connected routes
                                    	**type**\: list of    :py:class:`AdminTag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags.AdminTag>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags, self).__init__()

                                        self.yang_name = "admin-tags"
                                        self.yang_parent_name = "interface-af-data"

                                        self.admin_tag = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags, self).__setattr__(name, value)


                                    class AdminTag(Entity):
                                        """
                                        Admin tag for advertised interface
                                        connected routes
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: admin_tag
                                        
                                        	Tag to associate with connected routes
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags.AdminTag, self).__init__()

                                            self.yang_name = "admin-tag"
                                            self.yang_parent_name = "admin-tags"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.admin_tag = YLeaf(YType.uint32, "admin-tag")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "admin_tag") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags.AdminTag, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags.AdminTag, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.admin_tag.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.admin_tag.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "admin-tag" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.admin_tag.is_set or self.admin_tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.admin_tag.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "admin-tag"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "admin-tag"):
                                                self.admin_tag = value
                                                self.admin_tag.value_namespace = name_space
                                                self.admin_tag.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.admin_tag:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.admin_tag:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "admin-tags" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "admin-tag"):
                                            for c in self.admin_tag:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags.AdminTag()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.admin_tag.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "admin-tag"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class InterfaceLinkGroup(Entity):
                                    """
                                    Provide link group name and level
                                    
                                    .. attribute:: level
                                    
                                    	Level in which link group will be effective
                                    	**type**\:  int
                                    
                                    	**range:** 0..2
                                    
                                    	**default value**\: 0
                                    
                                    .. attribute:: link_group
                                    
                                    	Link Group
                                    	**type**\:  str
                                    
                                    	**length:** 1..40
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceLinkGroup, self).__init__()

                                        self.yang_name = "interface-link-group"
                                        self.yang_parent_name = "interface-af-data"
                                        self.is_presence_container = True

                                        self.level = YLeaf(YType.uint32, "level")

                                        self.link_group = YLeaf(YType.str, "link-group")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "link_group") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceLinkGroup, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceLinkGroup, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.link_group.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.link_group.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-link-group" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.link_group.is_set or self.link_group.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.link_group.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "link-group"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "link-group"):
                                            self.link_group = value
                                            self.link_group.value_namespace = name_space
                                            self.link_group.value_namespace_prefix = name_space_prefix


                                class Metrics(Entity):
                                    """
                                    Metric configuration
                                    
                                    .. attribute:: metric
                                    
                                    	Metric configuration. Legal value depends on the metric\-style specified for the topology. If the metric\-style defined is narrow, then only a value between <1\-63> is allowed and if the metric\-style is defined as wide, then a value between <1\-16777215> is allowed as the metric value.  All routers exclude links with the maximum wide metric (16777215) from their SPF
                                    	**type**\: list of    :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics.Metric>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics, self).__init__()

                                        self.yang_name = "metrics"
                                        self.yang_parent_name = "interface-af-data"

                                        self.metric = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics, self).__setattr__(name, value)


                                    class Metric(Entity):
                                        """
                                        Metric configuration. Legal value depends on
                                        the metric\-style specified for the topology. If
                                        the metric\-style defined is narrow, then only a
                                        value between <1\-63> is allowed and if the
                                        metric\-style is defined as wide, then a value
                                        between <1\-16777215> is allowed as the metric
                                        value.  All routers exclude links with the
                                        maximum wide metric (16777215) from their SPF
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: metric
                                        
                                        	Allowed metric\: <1\-63> for narrow, <1\-16777215> for wide
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:   :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric.Metric>`
                                        
                                        	**mandatory**\: True
                                        
                                        
                                        ----
                                        	**type**\:  int
                                        
                                        	**range:** 1..16777215
                                        
                                        	**mandatory**\: True
                                        
                                        
                                        ----
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics.Metric, self).__init__()

                                            self.yang_name = "metric"
                                            self.yang_parent_name = "metrics"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.metric = YLeaf(YType.str, "metric")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "metric") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics.Metric, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics.Metric, self).__setattr__(name, value)

                                        class Metric(Enum):
                                            """
                                            Metric

                                            Allowed metric\: <1\-63> for narrow,

                                            <1\-16777215> for wide

                                            .. data:: maximum = 16777215

                                            	Maximum wide metric.  All routers will

                                            	exclude this link from their SPF

                                            """

                                            maximum = Enum.YLeaf(16777215, "maximum")


                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.metric.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.metric.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "metric" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "metric"):
                                                self.metric = value
                                                self.metric.value_namespace = name_space
                                                self.metric.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.metric:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.metric:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "metrics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "metric"):
                                            for c in self.metric:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics.Metric()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.metric.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "metric"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class Weights(Entity):
                                    """
                                    Weight configuration
                                    
                                    .. attribute:: weight
                                    
                                    	Weight configuration under interface for load balancing
                                    	**type**\: list of    :py:class:`Weight <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights.Weight>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights, self).__init__()

                                        self.yang_name = "weights"
                                        self.yang_parent_name = "interface-af-data"

                                        self.weight = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights, self).__setattr__(name, value)


                                    class Weight(Entity):
                                        """
                                        Weight configuration under interface for load
                                        balancing
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: weight
                                        
                                        	Weight to be configured under interface for Load Balancing. Allowed weight\: <1\-16777215>
                                        	**type**\:  int
                                        
                                        	**range:** 1..16777214
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights.Weight, self).__init__()

                                            self.yang_name = "weight"
                                            self.yang_parent_name = "weights"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.weight = YLeaf(YType.uint32, "weight")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "weight") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights.Weight, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights.Weight, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.weight.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.weight.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "weight" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.weight.is_set or self.weight.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.weight.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "weight"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "weight"):
                                                self.weight = value
                                                self.weight.value_namespace = name_space
                                                self.weight.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.weight:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.weight:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "weights" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "weight"):
                                            for c in self.weight:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights.Weight()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.weight.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "weight"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.interface_af_state.is_set or
                                        self.running.is_set or
                                        (self.admin_tags is not None and self.admin_tags.has_data()) or
                                        (self.auto_metrics is not None and self.auto_metrics.has_data()) or
                                        (self.interface_frr_table is not None and self.interface_frr_table.has_data()) or
                                        (self.metrics is not None and self.metrics.has_data()) or
                                        (self.mpls_ldp is not None and self.mpls_ldp.has_data()) or
                                        (self.weights is not None and self.weights.has_data()) or
                                        (self.interface_link_group is not None) or
                                        (self.prefix_sid is not None) or
                                        (self.prefix_sspfsid is not None))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_af_state.yfilter != YFilter.not_set or
                                        self.running.yfilter != YFilter.not_set or
                                        (self.admin_tags is not None and self.admin_tags.has_operation()) or
                                        (self.auto_metrics is not None and self.auto_metrics.has_operation()) or
                                        (self.interface_frr_table is not None and self.interface_frr_table.has_operation()) or
                                        (self.interface_link_group is not None and self.interface_link_group.has_operation()) or
                                        (self.metrics is not None and self.metrics.has_operation()) or
                                        (self.mpls_ldp is not None and self.mpls_ldp.has_operation()) or
                                        (self.prefix_sid is not None and self.prefix_sid.has_operation()) or
                                        (self.prefix_sspfsid is not None and self.prefix_sspfsid.has_operation()) or
                                        (self.weights is not None and self.weights.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interface-af-data" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_af_state.is_set or self.interface_af_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_af_state.get_name_leafdata())
                                    if (self.running.is_set or self.running.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.running.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "admin-tags"):
                                        if (self.admin_tags is None):
                                            self.admin_tags = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AdminTags()
                                            self.admin_tags.parent = self
                                            self._children_name_map["admin_tags"] = "admin-tags"
                                        return self.admin_tags

                                    if (child_yang_name == "auto-metrics"):
                                        if (self.auto_metrics is None):
                                            self.auto_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.AutoMetrics()
                                            self.auto_metrics.parent = self
                                            self._children_name_map["auto_metrics"] = "auto-metrics"
                                        return self.auto_metrics

                                    if (child_yang_name == "interface-frr-table"):
                                        if (self.interface_frr_table is None):
                                            self.interface_frr_table = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceFrrTable()
                                            self.interface_frr_table.parent = self
                                            self._children_name_map["interface_frr_table"] = "interface-frr-table"
                                        return self.interface_frr_table

                                    if (child_yang_name == "interface-link-group"):
                                        if (self.interface_link_group is None):
                                            self.interface_link_group = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.InterfaceLinkGroup()
                                            self.interface_link_group.parent = self
                                            self._children_name_map["interface_link_group"] = "interface-link-group"
                                        return self.interface_link_group

                                    if (child_yang_name == "metrics"):
                                        if (self.metrics is None):
                                            self.metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Metrics()
                                            self.metrics.parent = self
                                            self._children_name_map["metrics"] = "metrics"
                                        return self.metrics

                                    if (child_yang_name == "mpls-ldp"):
                                        if (self.mpls_ldp is None):
                                            self.mpls_ldp = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.MplsLdp()
                                            self.mpls_ldp.parent = self
                                            self._children_name_map["mpls_ldp"] = "mpls-ldp"
                                        return self.mpls_ldp

                                    if (child_yang_name == "prefix-sid"):
                                        if (self.prefix_sid is None):
                                            self.prefix_sid = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSid()
                                            self.prefix_sid.parent = self
                                            self._children_name_map["prefix_sid"] = "prefix-sid"
                                        return self.prefix_sid

                                    if (child_yang_name == "prefix-sspfsid"):
                                        if (self.prefix_sspfsid is None):
                                            self.prefix_sspfsid = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.PrefixSspfsid()
                                            self.prefix_sspfsid.parent = self
                                            self._children_name_map["prefix_sspfsid"] = "prefix-sspfsid"
                                        return self.prefix_sspfsid

                                    if (child_yang_name == "weights"):
                                        if (self.weights is None):
                                            self.weights = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData.Weights()
                                            self.weights.parent = self
                                            self._children_name_map["weights"] = "weights"
                                        return self.weights

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "admin-tags" or name == "auto-metrics" or name == "interface-frr-table" or name == "interface-link-group" or name == "metrics" or name == "mpls-ldp" or name == "prefix-sid" or name == "prefix-sspfsid" or name == "weights" or name == "interface-af-state" or name == "running"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-af-state"):
                                        self.interface_af_state = value
                                        self.interface_af_state.value_namespace = name_space
                                        self.interface_af_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "running"):
                                        self.running = value
                                        self.running.value_namespace = name_space
                                        self.running.value_namespace_prefix = name_space_prefix


                            class TopologyName(Entity):
                                """
                                keys\: topology\-name
                                
                                .. attribute:: topology_name  <key>
                                
                                	Topology Name
                                	**type**\:  str
                                
                                	**length:** 1..32
                                
                                .. attribute:: admin_tags
                                
                                	admin\-tag configuration
                                	**type**\:   :py:class:`AdminTags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags>`
                                
                                .. attribute:: auto_metrics
                                
                                	AutoMetric configuration
                                	**type**\:   :py:class:`AutoMetrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics>`
                                
                                .. attribute:: interface_af_state
                                
                                	Interface state
                                	**type**\:   :py:class:`IsisInterfaceAfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisInterfaceAfState>`
                                
                                .. attribute:: interface_frr_table
                                
                                	Fast\-ReRoute configuration
                                	**type**\:   :py:class:`InterfaceFrrTable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable>`
                                
                                .. attribute:: interface_link_group
                                
                                	Provide link group name and level
                                	**type**\:   :py:class:`InterfaceLinkGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceLinkGroup>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: metrics
                                
                                	Metric configuration
                                	**type**\:   :py:class:`Metrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics>`
                                
                                .. attribute:: mpls_ldp
                                
                                	MPLS LDP configuration
                                	**type**\:   :py:class:`MplsLdp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.MplsLdp>`
                                
                                .. attribute:: prefix_sid
                                
                                	Assign prefix SID to an interface, ISISPHPFlag will be rejected if set to disable, ISISEXPLICITNULLFlag will override the value of ISISPHPFlag
                                	**type**\:   :py:class:`PrefixSid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSid>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: prefix_sspfsid
                                
                                	Assign prefix SSPF SID to an interface, ISISPHPFlag will be rejected if set to disable, ISISEXPLICITNULLFlag will override the value of ISISPHPFlag
                                	**type**\:   :py:class:`PrefixSspfsid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSspfsid>`
                                
                                	**presence node**\: True
                                
                                .. attribute:: running
                                
                                	The presence of this object allows an address\-family to be run over the interface in question.This must be the first object created under the InterfaceAddressFamily container, and the last one deleted
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: weights
                                
                                	Weight configuration
                                	**type**\:   :py:class:`Weights <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights>`
                                
                                

                                """

                                _prefix = 'clns-isis-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName, self).__init__()

                                    self.yang_name = "topology-name"
                                    self.yang_parent_name = "interface-af"

                                    self.topology_name = YLeaf(YType.str, "topology-name")

                                    self.interface_af_state = YLeaf(YType.enumeration, "interface-af-state")

                                    self.running = YLeaf(YType.empty, "running")

                                    self.admin_tags = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags()
                                    self.admin_tags.parent = self
                                    self._children_name_map["admin_tags"] = "admin-tags"
                                    self._children_yang_names.add("admin-tags")

                                    self.auto_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics()
                                    self.auto_metrics.parent = self
                                    self._children_name_map["auto_metrics"] = "auto-metrics"
                                    self._children_yang_names.add("auto-metrics")

                                    self.interface_frr_table = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable()
                                    self.interface_frr_table.parent = self
                                    self._children_name_map["interface_frr_table"] = "interface-frr-table"
                                    self._children_yang_names.add("interface-frr-table")

                                    self.interface_link_group = None
                                    self._children_name_map["interface_link_group"] = "interface-link-group"
                                    self._children_yang_names.add("interface-link-group")

                                    self.metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics()
                                    self.metrics.parent = self
                                    self._children_name_map["metrics"] = "metrics"
                                    self._children_yang_names.add("metrics")

                                    self.mpls_ldp = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.MplsLdp()
                                    self.mpls_ldp.parent = self
                                    self._children_name_map["mpls_ldp"] = "mpls-ldp"
                                    self._children_yang_names.add("mpls-ldp")

                                    self.prefix_sid = None
                                    self._children_name_map["prefix_sid"] = "prefix-sid"
                                    self._children_yang_names.add("prefix-sid")

                                    self.prefix_sspfsid = None
                                    self._children_name_map["prefix_sspfsid"] = "prefix-sspfsid"
                                    self._children_yang_names.add("prefix-sspfsid")

                                    self.weights = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights()
                                    self.weights.parent = self
                                    self._children_name_map["weights"] = "weights"
                                    self._children_yang_names.add("weights")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("topology_name",
                                                    "interface_af_state",
                                                    "running") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName, self).__setattr__(name, value)


                                class PrefixSid(Entity):
                                    """
                                    Assign prefix SID to an interface,
                                    ISISPHPFlag will be rejected if set to
                                    disable, ISISEXPLICITNULLFlag will
                                    override the value of ISISPHPFlag
                                    
                                    .. attribute:: explicit_null
                                    
                                    	Enable/Disable Explicit\-NULL flag
                                    	**type**\:   :py:class:`IsisexplicitNullFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisexplicitNullFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: nflag_clear
                                    
                                    	Clear N\-flag for the prefix\-SID
                                    	**type**\:   :py:class:`NflagClear <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.NflagClear>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: php
                                    
                                    	Enable/Disable Penultimate Hop Popping
                                    	**type**\:   :py:class:`IsisphpFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisphpFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: type
                                    
                                    	SID type for the interface
                                    	**type**\:   :py:class:`Isissid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isissid>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: value
                                    
                                    	SID value for the interface
                                    	**type**\:  int
                                    
                                    	**range:** 0..1048575
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSid, self).__init__()

                                        self.yang_name = "prefix-sid"
                                        self.yang_parent_name = "topology-name"
                                        self.is_presence_container = True

                                        self.explicit_null = YLeaf(YType.enumeration, "explicit-null")

                                        self.nflag_clear = YLeaf(YType.enumeration, "nflag-clear")

                                        self.php = YLeaf(YType.enumeration, "php")

                                        self.type = YLeaf(YType.enumeration, "type")

                                        self.value = YLeaf(YType.uint32, "value")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("explicit_null",
                                                        "nflag_clear",
                                                        "php",
                                                        "type",
                                                        "value") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSid, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSid, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.explicit_null.is_set or
                                            self.nflag_clear.is_set or
                                            self.php.is_set or
                                            self.type.is_set or
                                            self.value.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.explicit_null.yfilter != YFilter.not_set or
                                            self.nflag_clear.yfilter != YFilter.not_set or
                                            self.php.yfilter != YFilter.not_set or
                                            self.type.yfilter != YFilter.not_set or
                                            self.value.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "prefix-sid" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.explicit_null.is_set or self.explicit_null.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.explicit_null.get_name_leafdata())
                                        if (self.nflag_clear.is_set or self.nflag_clear.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nflag_clear.get_name_leafdata())
                                        if (self.php.is_set or self.php.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.php.get_name_leafdata())
                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type.get_name_leafdata())
                                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.value.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "explicit-null" or name == "nflag-clear" or name == "php" or name == "type" or name == "value"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "explicit-null"):
                                            self.explicit_null = value
                                            self.explicit_null.value_namespace = name_space
                                            self.explicit_null.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nflag-clear"):
                                            self.nflag_clear = value
                                            self.nflag_clear.value_namespace = name_space
                                            self.nflag_clear.value_namespace_prefix = name_space_prefix
                                        if(value_path == "php"):
                                            self.php = value
                                            self.php.value_namespace = name_space
                                            self.php.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type"):
                                            self.type = value
                                            self.type.value_namespace = name_space
                                            self.type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "value"):
                                            self.value = value
                                            self.value.value_namespace = name_space
                                            self.value.value_namespace_prefix = name_space_prefix


                                class InterfaceFrrTable(Entity):
                                    """
                                    Fast\-ReRoute configuration
                                    
                                    .. attribute:: frr_exclude_interfaces
                                    
                                    	FRR exclusion configuration
                                    	**type**\:   :py:class:`FrrExcludeInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces>`
                                    
                                    .. attribute:: frr_remote_lfa_max_metrics
                                    
                                    	Remote LFA maxmimum metric
                                    	**type**\:   :py:class:`FrrRemoteLfaMaxMetrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics>`
                                    
                                    .. attribute:: frr_remote_lfa_types
                                    
                                    	Remote LFA Enable
                                    	**type**\:   :py:class:`FrrRemoteLfaTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes>`
                                    
                                    .. attribute:: frr_types
                                    
                                    	Type of FRR computation per level
                                    	**type**\:   :py:class:`FrrTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes>`
                                    
                                    .. attribute:: frrlfa_candidate_interfaces
                                    
                                    	FRR LFA candidate configuration
                                    	**type**\:   :py:class:`FrrlfaCandidateInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces>`
                                    
                                    .. attribute:: frrtilfa_types
                                    
                                    	TI LFA Enable
                                    	**type**\:   :py:class:`FrrtilfaTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes>`
                                    
                                    .. attribute:: interface_frr_tiebreaker_defaults
                                    
                                    	Interface FRR Default tiebreaker configuration
                                    	**type**\:   :py:class:`InterfaceFrrTiebreakerDefaults <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults>`
                                    
                                    .. attribute:: interface_frr_tiebreakers
                                    
                                    	Interface FRR tiebreakers configuration
                                    	**type**\:   :py:class:`InterfaceFrrTiebreakers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable, self).__init__()

                                        self.yang_name = "interface-frr-table"
                                        self.yang_parent_name = "topology-name"

                                        self.frr_exclude_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces()
                                        self.frr_exclude_interfaces.parent = self
                                        self._children_name_map["frr_exclude_interfaces"] = "frr-exclude-interfaces"
                                        self._children_yang_names.add("frr-exclude-interfaces")

                                        self.frr_remote_lfa_max_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics()
                                        self.frr_remote_lfa_max_metrics.parent = self
                                        self._children_name_map["frr_remote_lfa_max_metrics"] = "frr-remote-lfa-max-metrics"
                                        self._children_yang_names.add("frr-remote-lfa-max-metrics")

                                        self.frr_remote_lfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes()
                                        self.frr_remote_lfa_types.parent = self
                                        self._children_name_map["frr_remote_lfa_types"] = "frr-remote-lfa-types"
                                        self._children_yang_names.add("frr-remote-lfa-types")

                                        self.frr_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes()
                                        self.frr_types.parent = self
                                        self._children_name_map["frr_types"] = "frr-types"
                                        self._children_yang_names.add("frr-types")

                                        self.frrlfa_candidate_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces()
                                        self.frrlfa_candidate_interfaces.parent = self
                                        self._children_name_map["frrlfa_candidate_interfaces"] = "frrlfa-candidate-interfaces"
                                        self._children_yang_names.add("frrlfa-candidate-interfaces")

                                        self.frrtilfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes()
                                        self.frrtilfa_types.parent = self
                                        self._children_name_map["frrtilfa_types"] = "frrtilfa-types"
                                        self._children_yang_names.add("frrtilfa-types")

                                        self.interface_frr_tiebreaker_defaults = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults()
                                        self.interface_frr_tiebreaker_defaults.parent = self
                                        self._children_name_map["interface_frr_tiebreaker_defaults"] = "interface-frr-tiebreaker-defaults"
                                        self._children_yang_names.add("interface-frr-tiebreaker-defaults")

                                        self.interface_frr_tiebreakers = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers()
                                        self.interface_frr_tiebreakers.parent = self
                                        self._children_name_map["interface_frr_tiebreakers"] = "interface-frr-tiebreakers"
                                        self._children_yang_names.add("interface-frr-tiebreakers")


                                    class FrrlfaCandidateInterfaces(Entity):
                                        """
                                        FRR LFA candidate configuration
                                        
                                        .. attribute:: frrlfa_candidate_interface
                                        
                                        	Include an interface to LFA candidate in computation
                                        	**type**\: list of    :py:class:`FrrlfaCandidateInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces, self).__init__()

                                            self.yang_name = "frrlfa-candidate-interfaces"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frrlfa_candidate_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces, self).__setattr__(name, value)


                                        class FrrlfaCandidateInterface(Entity):
                                            """
                                            Include an interface to LFA candidate
                                            in computation
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: frr_type  <key>
                                            
                                            	Computation Type
                                            	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                            
                                            .. attribute:: level
                                            
                                            	Level
                                            	**type**\:  int
                                            
                                            	**range:** 0..2
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface, self).__init__()

                                                self.yang_name = "frrlfa-candidate-interface"
                                                self.yang_parent_name = "frrlfa-candidate-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                                self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                                self.level = YLeaf(YType.uint32, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name",
                                                                "frr_type",
                                                                "level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.interface_name.is_set or
                                                    self.frr_type.is_set or
                                                    self.level.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set or
                                                    self.frr_type.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frrlfa-candidate-interface" + "[interface-name='" + self.interface_name.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                                if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.frr_type.get_name_leafdata())
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name" or name == "frr-type" or name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "frr-type"):
                                                    self.frr_type = value
                                                    self.frr_type.value_namespace = name_space
                                                    self.frr_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frrlfa_candidate_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frrlfa_candidate_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frrlfa-candidate-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frrlfa-candidate-interface"):
                                                for c in self.frrlfa_candidate_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces.FrrlfaCandidateInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frrlfa_candidate_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frrlfa-candidate-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrRemoteLfaMaxMetrics(Entity):
                                        """
                                        Remote LFA maxmimum metric
                                        
                                        .. attribute:: frr_remote_lfa_max_metric
                                        
                                        	Configure the maximum metric for selecting a remote LFA node
                                        	**type**\: list of    :py:class:`FrrRemoteLfaMaxMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics, self).__init__()

                                            self.yang_name = "frr-remote-lfa-max-metrics"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_remote_lfa_max_metric = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics, self).__setattr__(name, value)


                                        class FrrRemoteLfaMaxMetric(Entity):
                                            """
                                            Configure the maximum metric for
                                            selecting a remote LFA node
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: max_metric
                                            
                                            	Value of the metric
                                            	**type**\:  int
                                            
                                            	**range:** 1..16777215
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric, self).__init__()

                                                self.yang_name = "frr-remote-lfa-max-metric"
                                                self.yang_parent_name = "frr-remote-lfa-max-metrics"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.max_metric = YLeaf(YType.uint32, "max-metric")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "max_metric") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.max_metric.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.max_metric.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-remote-lfa-max-metric" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.max_metric.is_set or self.max_metric.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.max_metric.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "max-metric"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "max-metric"):
                                                    self.max_metric = value
                                                    self.max_metric.value_namespace = name_space
                                                    self.max_metric.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_remote_lfa_max_metric:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_remote_lfa_max_metric:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-remote-lfa-max-metrics" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-remote-lfa-max-metric"):
                                                for c in self.frr_remote_lfa_max_metric:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics.FrrRemoteLfaMaxMetric()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_remote_lfa_max_metric.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-remote-lfa-max-metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrTypes(Entity):
                                        """
                                        Type of FRR computation per level
                                        
                                        .. attribute:: frr_type
                                        
                                        	Type of computation for prefixes reachable via interface
                                        	**type**\: list of    :py:class:`FrrType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes.FrrType>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes, self).__init__()

                                            self.yang_name = "frr-types"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_type = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes, self).__setattr__(name, value)


                                        class FrrType(Entity):
                                            """
                                            Type of computation for prefixes
                                            reachable via interface
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: type
                                            
                                            	Computation Type
                                            	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes.FrrType, self).__init__()

                                                self.yang_name = "frr-type"
                                                self.yang_parent_name = "frr-types"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.type = YLeaf(YType.enumeration, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes.FrrType, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes.FrrType, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-type" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_type:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_type:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-types" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-type"):
                                                for c in self.frr_type:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes.FrrType()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_type.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrRemoteLfaTypes(Entity):
                                        """
                                        Remote LFA Enable
                                        
                                        .. attribute:: frr_remote_lfa_type
                                        
                                        	Enable remote lfa for a particular level
                                        	**type**\: list of    :py:class:`FrrRemoteLfaType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes, self).__init__()

                                            self.yang_name = "frr-remote-lfa-types"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_remote_lfa_type = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes, self).__setattr__(name, value)


                                        class FrrRemoteLfaType(Entity):
                                            """
                                            Enable remote lfa for a particular
                                            level
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: type
                                            
                                            	Remote LFA Type
                                            	**type**\:   :py:class:`IsisRemoteLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisRemoteLfa>`
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType, self).__init__()

                                                self.yang_name = "frr-remote-lfa-type"
                                                self.yang_parent_name = "frr-remote-lfa-types"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.type = YLeaf(YType.enumeration, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-remote-lfa-type" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_remote_lfa_type:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_remote_lfa_type:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-remote-lfa-types" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-remote-lfa-type"):
                                                for c in self.frr_remote_lfa_type:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes.FrrRemoteLfaType()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_remote_lfa_type.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-remote-lfa-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class InterfaceFrrTiebreakerDefaults(Entity):
                                        """
                                        Interface FRR Default tiebreaker
                                        configuration
                                        
                                        .. attribute:: interface_frr_tiebreaker_default
                                        
                                        	Configure default tiebreaker
                                        	**type**\: list of    :py:class:`InterfaceFrrTiebreakerDefault <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults, self).__init__()

                                            self.yang_name = "interface-frr-tiebreaker-defaults"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.interface_frr_tiebreaker_default = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults, self).__setattr__(name, value)


                                        class InterfaceFrrTiebreakerDefault(Entity):
                                            """
                                            Configure default tiebreaker
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault, self).__init__()

                                                self.yang_name = "interface-frr-tiebreaker-default"
                                                self.yang_parent_name = "interface-frr-tiebreaker-defaults"

                                                self.level = YLeaf(YType.enumeration, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.level.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "interface-frr-tiebreaker-default" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.interface_frr_tiebreaker_default:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.interface_frr_tiebreaker_default:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-frr-tiebreaker-defaults" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "interface-frr-tiebreaker-default"):
                                                for c in self.interface_frr_tiebreaker_default:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults.InterfaceFrrTiebreakerDefault()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.interface_frr_tiebreaker_default.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-frr-tiebreaker-default"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrtilfaTypes(Entity):
                                        """
                                        TI LFA Enable
                                        
                                        .. attribute:: frrtilfa_type
                                        
                                        	Enable TI lfa for a particular level
                                        	**type**\: list of    :py:class:`FrrtilfaType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes, self).__init__()

                                            self.yang_name = "frrtilfa-types"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frrtilfa_type = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes, self).__setattr__(name, value)


                                        class FrrtilfaType(Entity):
                                            """
                                            Enable TI lfa for a particular level
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType, self).__init__()

                                                self.yang_name = "frrtilfa-type"
                                                self.yang_parent_name = "frrtilfa-types"

                                                self.level = YLeaf(YType.enumeration, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.level.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frrtilfa-type" + "[level='" + self.level.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frrtilfa_type:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frrtilfa_type:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frrtilfa-types" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frrtilfa-type"):
                                                for c in self.frrtilfa_type:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes.FrrtilfaType()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frrtilfa_type.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frrtilfa-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class FrrExcludeInterfaces(Entity):
                                        """
                                        FRR exclusion configuration
                                        
                                        .. attribute:: frr_exclude_interface
                                        
                                        	Exclude an interface from computation
                                        	**type**\: list of    :py:class:`FrrExcludeInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces, self).__init__()

                                            self.yang_name = "frr-exclude-interfaces"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.frr_exclude_interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces, self).__setattr__(name, value)


                                        class FrrExcludeInterface(Entity):
                                            """
                                            Exclude an interface from computation
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: frr_type  <key>
                                            
                                            	Computation Type
                                            	**type**\:   :py:class:`Isisfrr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isisfrr>`
                                            
                                            .. attribute:: level
                                            
                                            	Level
                                            	**type**\:  int
                                            
                                            	**range:** 0..2
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface, self).__init__()

                                                self.yang_name = "frr-exclude-interface"
                                                self.yang_parent_name = "frr-exclude-interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                                self.frr_type = YLeaf(YType.enumeration, "frr-type")

                                                self.level = YLeaf(YType.uint32, "level")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name",
                                                                "frr_type",
                                                                "level") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.interface_name.is_set or
                                                    self.frr_type.is_set or
                                                    self.level.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set or
                                                    self.frr_type.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-exclude-interface" + "[interface-name='" + self.interface_name.get() + "']" + "[frr-type='" + self.frr_type.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                                if (self.frr_type.is_set or self.frr_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.frr_type.get_name_leafdata())
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "interface-name" or name == "frr-type" or name == "level"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "frr-type"):
                                                    self.frr_type = value
                                                    self.frr_type.value_namespace = name_space
                                                    self.frr_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.frr_exclude_interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.frr_exclude_interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-exclude-interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-exclude-interface"):
                                                for c in self.frr_exclude_interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces.FrrExcludeInterface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.frr_exclude_interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-exclude-interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class InterfaceFrrTiebreakers(Entity):
                                        """
                                        Interface FRR tiebreakers configuration
                                        
                                        .. attribute:: interface_frr_tiebreaker
                                        
                                        	Configure tiebreaker for multiple backups
                                        	**type**\: list of    :py:class:`InterfaceFrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker>`
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers, self).__init__()

                                            self.yang_name = "interface-frr-tiebreakers"
                                            self.yang_parent_name = "interface-frr-table"

                                            self.interface_frr_tiebreaker = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers, self).__setattr__(name, value)


                                        class InterfaceFrrTiebreaker(Entity):
                                            """
                                            Configure tiebreaker for multiple
                                            backups
                                            
                                            .. attribute:: level  <key>
                                            
                                            	Level to which configuration applies
                                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                            
                                            .. attribute:: tiebreaker  <key>
                                            
                                            	Tiebreaker for which configuration applies
                                            	**type**\:   :py:class:`IsisInterfaceFrrTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisInterfaceFrrTiebreaker>`
                                            
                                            .. attribute:: index
                                            
                                            	Preference order among tiebreakers
                                            	**type**\:  int
                                            
                                            	**range:** 1..255
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'clns-isis-cfg'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker, self).__init__()

                                                self.yang_name = "interface-frr-tiebreaker"
                                                self.yang_parent_name = "interface-frr-tiebreakers"

                                                self.level = YLeaf(YType.enumeration, "level")

                                                self.tiebreaker = YLeaf(YType.enumeration, "tiebreaker")

                                                self.index = YLeaf(YType.uint32, "index")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("level",
                                                                "tiebreaker",
                                                                "index") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.level.is_set or
                                                    self.tiebreaker.is_set or
                                                    self.index.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.level.yfilter != YFilter.not_set or
                                                    self.tiebreaker.yfilter != YFilter.not_set or
                                                    self.index.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "interface-frr-tiebreaker" + "[level='" + self.level.get() + "']" + "[tiebreaker='" + self.tiebreaker.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.level.get_name_leafdata())
                                                if (self.tiebreaker.is_set or self.tiebreaker.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.tiebreaker.get_name_leafdata())
                                                if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.index.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "level" or name == "tiebreaker" or name == "index"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "level"):
                                                    self.level = value
                                                    self.level.value_namespace = name_space
                                                    self.level.value_namespace_prefix = name_space_prefix
                                                if(value_path == "tiebreaker"):
                                                    self.tiebreaker = value
                                                    self.tiebreaker.value_namespace = name_space
                                                    self.tiebreaker.value_namespace_prefix = name_space_prefix
                                                if(value_path == "index"):
                                                    self.index = value
                                                    self.index.value_namespace = name_space
                                                    self.index.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.interface_frr_tiebreaker:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.interface_frr_tiebreaker:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interface-frr-tiebreakers" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "interface-frr-tiebreaker"):
                                                for c in self.interface_frr_tiebreaker:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers.InterfaceFrrTiebreaker()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.interface_frr_tiebreaker.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface-frr-tiebreaker"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            (self.frr_exclude_interfaces is not None and self.frr_exclude_interfaces.has_data()) or
                                            (self.frr_remote_lfa_max_metrics is not None and self.frr_remote_lfa_max_metrics.has_data()) or
                                            (self.frr_remote_lfa_types is not None and self.frr_remote_lfa_types.has_data()) or
                                            (self.frr_types is not None and self.frr_types.has_data()) or
                                            (self.frrlfa_candidate_interfaces is not None and self.frrlfa_candidate_interfaces.has_data()) or
                                            (self.frrtilfa_types is not None and self.frrtilfa_types.has_data()) or
                                            (self.interface_frr_tiebreaker_defaults is not None and self.interface_frr_tiebreaker_defaults.has_data()) or
                                            (self.interface_frr_tiebreakers is not None and self.interface_frr_tiebreakers.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.frr_exclude_interfaces is not None and self.frr_exclude_interfaces.has_operation()) or
                                            (self.frr_remote_lfa_max_metrics is not None and self.frr_remote_lfa_max_metrics.has_operation()) or
                                            (self.frr_remote_lfa_types is not None and self.frr_remote_lfa_types.has_operation()) or
                                            (self.frr_types is not None and self.frr_types.has_operation()) or
                                            (self.frrlfa_candidate_interfaces is not None and self.frrlfa_candidate_interfaces.has_operation()) or
                                            (self.frrtilfa_types is not None and self.frrtilfa_types.has_operation()) or
                                            (self.interface_frr_tiebreaker_defaults is not None and self.interface_frr_tiebreaker_defaults.has_operation()) or
                                            (self.interface_frr_tiebreakers is not None and self.interface_frr_tiebreakers.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-frr-table" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "frr-exclude-interfaces"):
                                            if (self.frr_exclude_interfaces is None):
                                                self.frr_exclude_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrExcludeInterfaces()
                                                self.frr_exclude_interfaces.parent = self
                                                self._children_name_map["frr_exclude_interfaces"] = "frr-exclude-interfaces"
                                            return self.frr_exclude_interfaces

                                        if (child_yang_name == "frr-remote-lfa-max-metrics"):
                                            if (self.frr_remote_lfa_max_metrics is None):
                                                self.frr_remote_lfa_max_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaMaxMetrics()
                                                self.frr_remote_lfa_max_metrics.parent = self
                                                self._children_name_map["frr_remote_lfa_max_metrics"] = "frr-remote-lfa-max-metrics"
                                            return self.frr_remote_lfa_max_metrics

                                        if (child_yang_name == "frr-remote-lfa-types"):
                                            if (self.frr_remote_lfa_types is None):
                                                self.frr_remote_lfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrRemoteLfaTypes()
                                                self.frr_remote_lfa_types.parent = self
                                                self._children_name_map["frr_remote_lfa_types"] = "frr-remote-lfa-types"
                                            return self.frr_remote_lfa_types

                                        if (child_yang_name == "frr-types"):
                                            if (self.frr_types is None):
                                                self.frr_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrTypes()
                                                self.frr_types.parent = self
                                                self._children_name_map["frr_types"] = "frr-types"
                                            return self.frr_types

                                        if (child_yang_name == "frrlfa-candidate-interfaces"):
                                            if (self.frrlfa_candidate_interfaces is None):
                                                self.frrlfa_candidate_interfaces = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrlfaCandidateInterfaces()
                                                self.frrlfa_candidate_interfaces.parent = self
                                                self._children_name_map["frrlfa_candidate_interfaces"] = "frrlfa-candidate-interfaces"
                                            return self.frrlfa_candidate_interfaces

                                        if (child_yang_name == "frrtilfa-types"):
                                            if (self.frrtilfa_types is None):
                                                self.frrtilfa_types = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.FrrtilfaTypes()
                                                self.frrtilfa_types.parent = self
                                                self._children_name_map["frrtilfa_types"] = "frrtilfa-types"
                                            return self.frrtilfa_types

                                        if (child_yang_name == "interface-frr-tiebreaker-defaults"):
                                            if (self.interface_frr_tiebreaker_defaults is None):
                                                self.interface_frr_tiebreaker_defaults = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakerDefaults()
                                                self.interface_frr_tiebreaker_defaults.parent = self
                                                self._children_name_map["interface_frr_tiebreaker_defaults"] = "interface-frr-tiebreaker-defaults"
                                            return self.interface_frr_tiebreaker_defaults

                                        if (child_yang_name == "interface-frr-tiebreakers"):
                                            if (self.interface_frr_tiebreakers is None):
                                                self.interface_frr_tiebreakers = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable.InterfaceFrrTiebreakers()
                                                self.interface_frr_tiebreakers.parent = self
                                                self._children_name_map["interface_frr_tiebreakers"] = "interface-frr-tiebreakers"
                                            return self.interface_frr_tiebreakers

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "frr-exclude-interfaces" or name == "frr-remote-lfa-max-metrics" or name == "frr-remote-lfa-types" or name == "frr-types" or name == "frrlfa-candidate-interfaces" or name == "frrtilfa-types" or name == "interface-frr-tiebreaker-defaults" or name == "interface-frr-tiebreakers"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class MplsLdp(Entity):
                                    """
                                    MPLS LDP configuration
                                    
                                    .. attribute:: sync_level
                                    
                                    	Enable MPLS LDP Synchronization for an IS\-IS level
                                    	**type**\:  int
                                    
                                    	**range:** 0..2
                                    
                                    	**default value**\: 0
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.MplsLdp, self).__init__()

                                        self.yang_name = "mpls-ldp"
                                        self.yang_parent_name = "topology-name"

                                        self.sync_level = YLeaf(YType.uint32, "sync-level")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("sync_level") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.MplsLdp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.MplsLdp, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.sync_level.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.sync_level.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-ldp" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.sync_level.is_set or self.sync_level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.sync_level.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "sync-level"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "sync-level"):
                                            self.sync_level = value
                                            self.sync_level.value_namespace = name_space
                                            self.sync_level.value_namespace_prefix = name_space_prefix


                                class PrefixSspfsid(Entity):
                                    """
                                    Assign prefix SSPF SID to an interface,
                                    ISISPHPFlag will be rejected if set to
                                    disable, ISISEXPLICITNULLFlag will
                                    override the value of ISISPHPFlag
                                    
                                    .. attribute:: explicit_null
                                    
                                    	Enable/Disable Explicit\-NULL flag
                                    	**type**\:   :py:class:`IsisexplicitNullFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisexplicitNullFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: nflag_clear
                                    
                                    	Clear N\-flag for the prefix\-SID
                                    	**type**\:   :py:class:`NflagClear <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.NflagClear>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: php
                                    
                                    	Enable/Disable Penultimate Hop Popping
                                    	**type**\:   :py:class:`IsisphpFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.IsisphpFlag>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: type
                                    
                                    	SID type for the interface
                                    	**type**\:   :py:class:`Isissid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isissid>`
                                    
                                    	**mandatory**\: True
                                    
                                    .. attribute:: value
                                    
                                    	SID value for the interface
                                    	**type**\:  int
                                    
                                    	**range:** 0..1048575
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSspfsid, self).__init__()

                                        self.yang_name = "prefix-sspfsid"
                                        self.yang_parent_name = "topology-name"
                                        self.is_presence_container = True

                                        self.explicit_null = YLeaf(YType.enumeration, "explicit-null")

                                        self.nflag_clear = YLeaf(YType.enumeration, "nflag-clear")

                                        self.php = YLeaf(YType.enumeration, "php")

                                        self.type = YLeaf(YType.enumeration, "type")

                                        self.value = YLeaf(YType.uint32, "value")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("explicit_null",
                                                        "nflag_clear",
                                                        "php",
                                                        "type",
                                                        "value") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSspfsid, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSspfsid, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.explicit_null.is_set or
                                            self.nflag_clear.is_set or
                                            self.php.is_set or
                                            self.type.is_set or
                                            self.value.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.explicit_null.yfilter != YFilter.not_set or
                                            self.nflag_clear.yfilter != YFilter.not_set or
                                            self.php.yfilter != YFilter.not_set or
                                            self.type.yfilter != YFilter.not_set or
                                            self.value.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "prefix-sspfsid" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.explicit_null.is_set or self.explicit_null.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.explicit_null.get_name_leafdata())
                                        if (self.nflag_clear.is_set or self.nflag_clear.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nflag_clear.get_name_leafdata())
                                        if (self.php.is_set or self.php.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.php.get_name_leafdata())
                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type.get_name_leafdata())
                                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.value.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "explicit-null" or name == "nflag-clear" or name == "php" or name == "type" or name == "value"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "explicit-null"):
                                            self.explicit_null = value
                                            self.explicit_null.value_namespace = name_space
                                            self.explicit_null.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nflag-clear"):
                                            self.nflag_clear = value
                                            self.nflag_clear.value_namespace = name_space
                                            self.nflag_clear.value_namespace_prefix = name_space_prefix
                                        if(value_path == "php"):
                                            self.php = value
                                            self.php.value_namespace = name_space
                                            self.php.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type"):
                                            self.type = value
                                            self.type.value_namespace = name_space
                                            self.type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "value"):
                                            self.value = value
                                            self.value.value_namespace = name_space
                                            self.value.value_namespace_prefix = name_space_prefix


                                class AutoMetrics(Entity):
                                    """
                                    AutoMetric configuration
                                    
                                    .. attribute:: auto_metric
                                    
                                    	AutoMetric Proactive\-Protect configuration. Legal value depends on the metric\-style specified for the topology. If the metric\-style defined is narrow, then only a value between <1\-63> is allowed and if the metric\-style is defined as wide, then a value between <1\-16777214> is allowed as the auto\-metric value
                                    	**type**\: list of    :py:class:`AutoMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics.AutoMetric>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics, self).__init__()

                                        self.yang_name = "auto-metrics"
                                        self.yang_parent_name = "topology-name"

                                        self.auto_metric = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics, self).__setattr__(name, value)


                                    class AutoMetric(Entity):
                                        """
                                        AutoMetric Proactive\-Protect
                                        configuration. Legal value depends on
                                        the metric\-style specified for the
                                        topology. If the metric\-style defined is
                                        narrow, then only a value between <1\-63>
                                        is allowed and if the metric\-style is
                                        defined as wide, then a value between
                                        <1\-16777214> is allowed as the
                                        auto\-metric value.
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: proactive_protect
                                        
                                        	Allowed auto metric\:<1\-63> for narrow ,<1\-16777214> for wide
                                        	**type**\:  int
                                        
                                        	**range:** 1..16777214
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics.AutoMetric, self).__init__()

                                            self.yang_name = "auto-metric"
                                            self.yang_parent_name = "auto-metrics"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.proactive_protect = YLeaf(YType.uint32, "proactive-protect")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "proactive_protect") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics.AutoMetric, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics.AutoMetric, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.proactive_protect.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.proactive_protect.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "auto-metric" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.proactive_protect.is_set or self.proactive_protect.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.proactive_protect.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "proactive-protect"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "proactive-protect"):
                                                self.proactive_protect = value
                                                self.proactive_protect.value_namespace = name_space
                                                self.proactive_protect.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.auto_metric:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.auto_metric:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "auto-metrics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "auto-metric"):
                                            for c in self.auto_metric:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics.AutoMetric()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.auto_metric.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "auto-metric"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class AdminTags(Entity):
                                    """
                                    admin\-tag configuration
                                    
                                    .. attribute:: admin_tag
                                    
                                    	Admin tag for advertised interface connected routes
                                    	**type**\: list of    :py:class:`AdminTag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags.AdminTag>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags, self).__init__()

                                        self.yang_name = "admin-tags"
                                        self.yang_parent_name = "topology-name"

                                        self.admin_tag = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags, self).__setattr__(name, value)


                                    class AdminTag(Entity):
                                        """
                                        Admin tag for advertised interface
                                        connected routes
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: admin_tag
                                        
                                        	Tag to associate with connected routes
                                        	**type**\:  int
                                        
                                        	**range:** 1..4294967295
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags.AdminTag, self).__init__()

                                            self.yang_name = "admin-tag"
                                            self.yang_parent_name = "admin-tags"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.admin_tag = YLeaf(YType.uint32, "admin-tag")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "admin_tag") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags.AdminTag, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags.AdminTag, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.admin_tag.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.admin_tag.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "admin-tag" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.admin_tag.is_set or self.admin_tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.admin_tag.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "admin-tag"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "admin-tag"):
                                                self.admin_tag = value
                                                self.admin_tag.value_namespace = name_space
                                                self.admin_tag.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.admin_tag:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.admin_tag:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "admin-tags" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "admin-tag"):
                                            for c in self.admin_tag:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags.AdminTag()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.admin_tag.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "admin-tag"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class InterfaceLinkGroup(Entity):
                                    """
                                    Provide link group name and level
                                    
                                    .. attribute:: level
                                    
                                    	Level in which link group will be effective
                                    	**type**\:  int
                                    
                                    	**range:** 0..2
                                    
                                    	**default value**\: 0
                                    
                                    .. attribute:: link_group
                                    
                                    	Link Group
                                    	**type**\:  str
                                    
                                    	**length:** 1..40
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    This class is a :ref:`presence class<presence-class>`

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceLinkGroup, self).__init__()

                                        self.yang_name = "interface-link-group"
                                        self.yang_parent_name = "topology-name"
                                        self.is_presence_container = True

                                        self.level = YLeaf(YType.uint32, "level")

                                        self.link_group = YLeaf(YType.str, "link-group")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "link_group") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceLinkGroup, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceLinkGroup, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.link_group.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.link_group.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-link-group" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.link_group.is_set or self.link_group.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.link_group.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "level" or name == "link-group"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "link-group"):
                                            self.link_group = value
                                            self.link_group.value_namespace = name_space
                                            self.link_group.value_namespace_prefix = name_space_prefix


                                class Metrics(Entity):
                                    """
                                    Metric configuration
                                    
                                    .. attribute:: metric
                                    
                                    	Metric configuration. Legal value depends on the metric\-style specified for the topology. If the metric\-style defined is narrow, then only a value between <1\-63> is allowed and if the metric\-style is defined as wide, then a value between <1\-16777215> is allowed as the metric value.  All routers exclude links with the maximum wide metric (16777215) from their SPF
                                    	**type**\: list of    :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics, self).__init__()

                                        self.yang_name = "metrics"
                                        self.yang_parent_name = "topology-name"

                                        self.metric = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics, self).__setattr__(name, value)


                                    class Metric(Entity):
                                        """
                                        Metric configuration. Legal value depends on
                                        the metric\-style specified for the topology. If
                                        the metric\-style defined is narrow, then only a
                                        value between <1\-63> is allowed and if the
                                        metric\-style is defined as wide, then a value
                                        between <1\-16777215> is allowed as the metric
                                        value.  All routers exclude links with the
                                        maximum wide metric (16777215) from their SPF
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: metric
                                        
                                        	Allowed metric\: <1\-63> for narrow, <1\-16777215> for wide
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:   :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric.Metric>`
                                        
                                        	**mandatory**\: True
                                        
                                        
                                        ----
                                        	**type**\:  int
                                        
                                        	**range:** 1..16777215
                                        
                                        	**mandatory**\: True
                                        
                                        
                                        ----
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric, self).__init__()

                                            self.yang_name = "metric"
                                            self.yang_parent_name = "metrics"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.metric = YLeaf(YType.str, "metric")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "metric") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric, self).__setattr__(name, value)

                                        class Metric(Enum):
                                            """
                                            Metric

                                            Allowed metric\: <1\-63> for narrow,

                                            <1\-16777215> for wide

                                            .. data:: maximum = 16777215

                                            	Maximum wide metric.  All routers will

                                            	exclude this link from their SPF

                                            """

                                            maximum = Enum.YLeaf(16777215, "maximum")


                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.metric.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.metric.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "metric" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "metric"):
                                                self.metric = value
                                                self.metric.value_namespace = name_space
                                                self.metric.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.metric:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.metric:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "metrics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "metric"):
                                            for c in self.metric:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics.Metric()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.metric.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "metric"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class Weights(Entity):
                                    """
                                    Weight configuration
                                    
                                    .. attribute:: weight
                                    
                                    	Weight configuration under interface for load balancing
                                    	**type**\: list of    :py:class:`Weight <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights.Weight>`
                                    
                                    

                                    """

                                    _prefix = 'clns-isis-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights, self).__init__()

                                        self.yang_name = "weights"
                                        self.yang_parent_name = "topology-name"

                                        self.weight = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights, self).__setattr__(name, value)


                                    class Weight(Entity):
                                        """
                                        Weight configuration under interface for load
                                        balancing
                                        
                                        .. attribute:: level  <key>
                                        
                                        	Level to which configuration applies
                                        	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                                        
                                        .. attribute:: weight
                                        
                                        	Weight to be configured under interface for Load Balancing. Allowed weight\: <1\-16777215>
                                        	**type**\:  int
                                        
                                        	**range:** 1..16777214
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'clns-isis-cfg'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights.Weight, self).__init__()

                                            self.yang_name = "weight"
                                            self.yang_parent_name = "weights"

                                            self.level = YLeaf(YType.enumeration, "level")

                                            self.weight = YLeaf(YType.uint32, "weight")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("level",
                                                            "weight") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights.Weight, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights.Weight, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.level.is_set or
                                                self.weight.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.level.yfilter != YFilter.not_set or
                                                self.weight.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "weight" + "[level='" + self.level.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.level.get_name_leafdata())
                                            if (self.weight.is_set or self.weight.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.weight.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "level" or name == "weight"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "level"):
                                                self.level = value
                                                self.level.value_namespace = name_space
                                                self.level.value_namespace_prefix = name_space_prefix
                                            if(value_path == "weight"):
                                                self.weight = value
                                                self.weight.value_namespace = name_space
                                                self.weight.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.weight:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.weight:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "weights" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "weight"):
                                            for c in self.weight:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights.Weight()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.weight.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "weight"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.topology_name.is_set or
                                        self.interface_af_state.is_set or
                                        self.running.is_set or
                                        (self.admin_tags is not None and self.admin_tags.has_data()) or
                                        (self.auto_metrics is not None and self.auto_metrics.has_data()) or
                                        (self.interface_frr_table is not None and self.interface_frr_table.has_data()) or
                                        (self.metrics is not None and self.metrics.has_data()) or
                                        (self.mpls_ldp is not None and self.mpls_ldp.has_data()) or
                                        (self.weights is not None and self.weights.has_data()) or
                                        (self.interface_link_group is not None) or
                                        (self.prefix_sid is not None) or
                                        (self.prefix_sspfsid is not None))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.topology_name.yfilter != YFilter.not_set or
                                        self.interface_af_state.yfilter != YFilter.not_set or
                                        self.running.yfilter != YFilter.not_set or
                                        (self.admin_tags is not None and self.admin_tags.has_operation()) or
                                        (self.auto_metrics is not None and self.auto_metrics.has_operation()) or
                                        (self.interface_frr_table is not None and self.interface_frr_table.has_operation()) or
                                        (self.interface_link_group is not None and self.interface_link_group.has_operation()) or
                                        (self.metrics is not None and self.metrics.has_operation()) or
                                        (self.mpls_ldp is not None and self.mpls_ldp.has_operation()) or
                                        (self.prefix_sid is not None and self.prefix_sid.has_operation()) or
                                        (self.prefix_sspfsid is not None and self.prefix_sspfsid.has_operation()) or
                                        (self.weights is not None and self.weights.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "topology-name" + "[topology-name='" + self.topology_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.topology_name.is_set or self.topology_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.topology_name.get_name_leafdata())
                                    if (self.interface_af_state.is_set or self.interface_af_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_af_state.get_name_leafdata())
                                    if (self.running.is_set or self.running.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.running.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "admin-tags"):
                                        if (self.admin_tags is None):
                                            self.admin_tags = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AdminTags()
                                            self.admin_tags.parent = self
                                            self._children_name_map["admin_tags"] = "admin-tags"
                                        return self.admin_tags

                                    if (child_yang_name == "auto-metrics"):
                                        if (self.auto_metrics is None):
                                            self.auto_metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.AutoMetrics()
                                            self.auto_metrics.parent = self
                                            self._children_name_map["auto_metrics"] = "auto-metrics"
                                        return self.auto_metrics

                                    if (child_yang_name == "interface-frr-table"):
                                        if (self.interface_frr_table is None):
                                            self.interface_frr_table = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceFrrTable()
                                            self.interface_frr_table.parent = self
                                            self._children_name_map["interface_frr_table"] = "interface-frr-table"
                                        return self.interface_frr_table

                                    if (child_yang_name == "interface-link-group"):
                                        if (self.interface_link_group is None):
                                            self.interface_link_group = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.InterfaceLinkGroup()
                                            self.interface_link_group.parent = self
                                            self._children_name_map["interface_link_group"] = "interface-link-group"
                                        return self.interface_link_group

                                    if (child_yang_name == "metrics"):
                                        if (self.metrics is None):
                                            self.metrics = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Metrics()
                                            self.metrics.parent = self
                                            self._children_name_map["metrics"] = "metrics"
                                        return self.metrics

                                    if (child_yang_name == "mpls-ldp"):
                                        if (self.mpls_ldp is None):
                                            self.mpls_ldp = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.MplsLdp()
                                            self.mpls_ldp.parent = self
                                            self._children_name_map["mpls_ldp"] = "mpls-ldp"
                                        return self.mpls_ldp

                                    if (child_yang_name == "prefix-sid"):
                                        if (self.prefix_sid is None):
                                            self.prefix_sid = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSid()
                                            self.prefix_sid.parent = self
                                            self._children_name_map["prefix_sid"] = "prefix-sid"
                                        return self.prefix_sid

                                    if (child_yang_name == "prefix-sspfsid"):
                                        if (self.prefix_sspfsid is None):
                                            self.prefix_sspfsid = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.PrefixSspfsid()
                                            self.prefix_sspfsid.parent = self
                                            self._children_name_map["prefix_sspfsid"] = "prefix-sspfsid"
                                        return self.prefix_sspfsid

                                    if (child_yang_name == "weights"):
                                        if (self.weights is None):
                                            self.weights = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName.Weights()
                                            self.weights.parent = self
                                            self._children_name_map["weights"] = "weights"
                                        return self.weights

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "admin-tags" or name == "auto-metrics" or name == "interface-frr-table" or name == "interface-link-group" or name == "metrics" or name == "mpls-ldp" or name == "prefix-sid" or name == "prefix-sspfsid" or name == "weights" or name == "topology-name" or name == "interface-af-state" or name == "running"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "topology-name"):
                                        self.topology_name = value
                                        self.topology_name.value_namespace = name_space
                                        self.topology_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-af-state"):
                                        self.interface_af_state = value
                                        self.interface_af_state.value_namespace = name_space
                                        self.interface_af_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "running"):
                                        self.running = value
                                        self.running.value_namespace = name_space
                                        self.running.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.topology_name:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.af_name.is_set or
                                    self.saf_name.is_set or
                                    (self.interface_af_data is not None and self.interface_af_data.has_data()))

                            def has_operation(self):
                                for c in self.topology_name:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.af_name.yfilter != YFilter.not_set or
                                    self.saf_name.yfilter != YFilter.not_set or
                                    (self.interface_af_data is not None and self.interface_af_data.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interface-af" + "[af-name='" + self.af_name.get() + "']" + "[saf-name='" + self.saf_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.af_name.get_name_leafdata())
                                if (self.saf_name.is_set or self.saf_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.saf_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "interface-af-data"):
                                    if (self.interface_af_data is None):
                                        self.interface_af_data = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.InterfaceAfData()
                                        self.interface_af_data.parent = self
                                        self._children_name_map["interface_af_data"] = "interface-af-data"
                                    return self.interface_af_data

                                if (child_yang_name == "topology-name"):
                                    for c in self.topology_name:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf.TopologyName()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.topology_name.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface-af-data" or name == "topology-name" or name == "af-name" or name == "saf-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "af-name"):
                                    self.af_name = value
                                    self.af_name.value_namespace = name_space
                                    self.af_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "saf-name"):
                                    self.saf_name = value
                                    self.saf_name.value_namespace = name_space
                                    self.saf_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.interface_af:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.interface_af:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "interface-afs" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "interface-af"):
                                for c in self.interface_af:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs.InterfaceAf()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.interface_af.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "interface-af"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class CsnpIntervals(Entity):
                        """
                        CSNP\-interval configuration
                        
                        .. attribute:: csnp_interval
                        
                        	CSNP\-interval configuration. No fixed default value as this depends on the media type of the interface
                        	**type**\: list of    :py:class:`CsnpInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals.CsnpInterval>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals, self).__init__()

                            self.yang_name = "csnp-intervals"
                            self.yang_parent_name = "interface"

                            self.csnp_interval = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals, self).__setattr__(name, value)


                        class CsnpInterval(Entity):
                            """
                            CSNP\-interval configuration. No fixed
                            default value as this depends on the media
                            type of the interface.
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: interval
                            
                            	Seconds
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            	**mandatory**\: True
                            
                            	**units**\: second
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals.CsnpInterval, self).__init__()

                                self.yang_name = "csnp-interval"
                                self.yang_parent_name = "csnp-intervals"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals.CsnpInterval, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals.CsnpInterval, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "csnp-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.csnp_interval:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.csnp_interval:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "csnp-intervals" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "csnp-interval"):
                                for c in self.csnp_interval:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals.CsnpInterval()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.csnp_interval.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "csnp-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class LspIntervals(Entity):
                        """
                        LSP\-interval configuration
                        
                        .. attribute:: lsp_interval
                        
                        	Interval between transmission of LSPs on interface
                        	**type**\: list of    :py:class:`LspInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_cfg.Isis.Instances.Instance.Interfaces.Interface.LspIntervals.LspInterval>`
                        
                        

                        """

                        _prefix = 'clns-isis-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Isis.Instances.Instance.Interfaces.Interface.LspIntervals, self).__init__()

                            self.yang_name = "lsp-intervals"
                            self.yang_parent_name = "interface"

                            self.lsp_interval = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspIntervals, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Isis.Instances.Instance.Interfaces.Interface.LspIntervals, self).__setattr__(name, value)


                        class LspInterval(Entity):
                            """
                            Interval between transmission of LSPs on
                            interface.
                            
                            .. attribute:: level  <key>
                            
                            	Level to which configuration applies
                            	**type**\:   :py:class:`IsisInternalLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_clns_isis_datatypes.IsisInternalLevel>`
                            
                            .. attribute:: interval
                            
                            	Milliseconds
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            	**mandatory**\: True
                            
                            	**units**\: millisecond
                            
                            

                            """

                            _prefix = 'clns-isis-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Isis.Instances.Instance.Interfaces.Interface.LspIntervals.LspInterval, self).__init__()

                                self.yang_name = "lsp-interval"
                                self.yang_parent_name = "lsp-intervals"

                                self.level = YLeaf(YType.enumeration, "level")

                                self.interval = YLeaf(YType.uint32, "interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("level",
                                                "interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Isis.Instances.Instance.Interfaces.Interface.LspIntervals.LspInterval, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Isis.Instances.Instance.Interfaces.Interface.LspIntervals.LspInterval, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.level.is_set or
                                    self.interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.level.yfilter != YFilter.not_set or
                                    self.interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-interval" + "[level='" + self.level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.level.get_name_leafdata())
                                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "level" or name == "interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "level"):
                                    self.level = value
                                    self.level.value_namespace = name_space
                                    self.level.value_namespace_prefix = name_space_prefix
                                if(value_path == "interval"):
                                    self.interval = value
                                    self.interval.value_namespace = name_space
                                    self.interval.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsp_interval:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.lsp_interval:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "lsp-intervals" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsp-interval"):
                                for c in self.lsp_interval:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Isis.Instances.Instance.Interfaces.Interface.LspIntervals.LspInterval()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_interval.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsp-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            self.circuit_type.is_set or
                            self.link_down_fast_detect.is_set or
                            self.mesh_group.is_set or
                            self.point_to_point.is_set or
                            self.running.is_set or
                            self.state.is_set or
                            (self.bfd is not None and self.bfd.has_data()) or
                            (self.csnp_intervals is not None and self.csnp_intervals.has_data()) or
                            (self.hello_accept_passwords is not None and self.hello_accept_passwords.has_data()) or
                            (self.hello_intervals is not None and self.hello_intervals.has_data()) or
                            (self.hello_multipliers is not None and self.hello_multipliers.has_data()) or
                            (self.hello_paddings is not None and self.hello_paddings.has_data()) or
                            (self.hello_passwords is not None and self.hello_passwords.has_data()) or
                            (self.interface_afs is not None and self.interface_afs.has_data()) or
                            (self.lsp_fast_flood_thresholds is not None and self.lsp_fast_flood_thresholds.has_data()) or
                            (self.lsp_intervals is not None and self.lsp_intervals.has_data()) or
                            (self.lsp_retransmit_intervals is not None and self.lsp_retransmit_intervals.has_data()) or
                            (self.lsp_retransmit_throttle_intervals is not None and self.lsp_retransmit_throttle_intervals.has_data()) or
                            (self.prefix_attribute_n_flag_clears is not None and self.prefix_attribute_n_flag_clears.has_data()) or
                            (self.priorities is not None and self.priorities.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.circuit_type.yfilter != YFilter.not_set or
                            self.link_down_fast_detect.yfilter != YFilter.not_set or
                            self.mesh_group.yfilter != YFilter.not_set or
                            self.point_to_point.yfilter != YFilter.not_set or
                            self.running.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            (self.bfd is not None and self.bfd.has_operation()) or
                            (self.csnp_intervals is not None and self.csnp_intervals.has_operation()) or
                            (self.hello_accept_passwords is not None and self.hello_accept_passwords.has_operation()) or
                            (self.hello_intervals is not None and self.hello_intervals.has_operation()) or
                            (self.hello_multipliers is not None and self.hello_multipliers.has_operation()) or
                            (self.hello_paddings is not None and self.hello_paddings.has_operation()) or
                            (self.hello_passwords is not None and self.hello_passwords.has_operation()) or
                            (self.interface_afs is not None and self.interface_afs.has_operation()) or
                            (self.lsp_fast_flood_thresholds is not None and self.lsp_fast_flood_thresholds.has_operation()) or
                            (self.lsp_intervals is not None and self.lsp_intervals.has_operation()) or
                            (self.lsp_retransmit_intervals is not None and self.lsp_retransmit_intervals.has_operation()) or
                            (self.lsp_retransmit_throttle_intervals is not None and self.lsp_retransmit_throttle_intervals.has_operation()) or
                            (self.prefix_attribute_n_flag_clears is not None and self.prefix_attribute_n_flag_clears.has_operation()) or
                            (self.priorities is not None and self.priorities.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.circuit_type.is_set or self.circuit_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.circuit_type.get_name_leafdata())
                        if (self.link_down_fast_detect.is_set or self.link_down_fast_detect.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.link_down_fast_detect.get_name_leafdata())
                        if (self.mesh_group.is_set or self.mesh_group.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mesh_group.get_name_leafdata())
                        if (self.point_to_point.is_set or self.point_to_point.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.point_to_point.get_name_leafdata())
                        if (self.running.is_set or self.running.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.running.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfd"):
                            if (self.bfd is None):
                                self.bfd = Isis.Instances.Instance.Interfaces.Interface.Bfd()
                                self.bfd.parent = self
                                self._children_name_map["bfd"] = "bfd"
                            return self.bfd

                        if (child_yang_name == "csnp-intervals"):
                            if (self.csnp_intervals is None):
                                self.csnp_intervals = Isis.Instances.Instance.Interfaces.Interface.CsnpIntervals()
                                self.csnp_intervals.parent = self
                                self._children_name_map["csnp_intervals"] = "csnp-intervals"
                            return self.csnp_intervals

                        if (child_yang_name == "hello-accept-passwords"):
                            if (self.hello_accept_passwords is None):
                                self.hello_accept_passwords = Isis.Instances.Instance.Interfaces.Interface.HelloAcceptPasswords()
                                self.hello_accept_passwords.parent = self
                                self._children_name_map["hello_accept_passwords"] = "hello-accept-passwords"
                            return self.hello_accept_passwords

                        if (child_yang_name == "hello-intervals"):
                            if (self.hello_intervals is None):
                                self.hello_intervals = Isis.Instances.Instance.Interfaces.Interface.HelloIntervals()
                                self.hello_intervals.parent = self
                                self._children_name_map["hello_intervals"] = "hello-intervals"
                            return self.hello_intervals

                        if (child_yang_name == "hello-multipliers"):
                            if (self.hello_multipliers is None):
                                self.hello_multipliers = Isis.Instances.Instance.Interfaces.Interface.HelloMultipliers()
                                self.hello_multipliers.parent = self
                                self._children_name_map["hello_multipliers"] = "hello-multipliers"
                            return self.hello_multipliers

                        if (child_yang_name == "hello-paddings"):
                            if (self.hello_paddings is None):
                                self.hello_paddings = Isis.Instances.Instance.Interfaces.Interface.HelloPaddings()
                                self.hello_paddings.parent = self
                                self._children_name_map["hello_paddings"] = "hello-paddings"
                            return self.hello_paddings

                        if (child_yang_name == "hello-passwords"):
                            if (self.hello_passwords is None):
                                self.hello_passwords = Isis.Instances.Instance.Interfaces.Interface.HelloPasswords()
                                self.hello_passwords.parent = self
                                self._children_name_map["hello_passwords"] = "hello-passwords"
                            return self.hello_passwords

                        if (child_yang_name == "interface-afs"):
                            if (self.interface_afs is None):
                                self.interface_afs = Isis.Instances.Instance.Interfaces.Interface.InterfaceAfs()
                                self.interface_afs.parent = self
                                self._children_name_map["interface_afs"] = "interface-afs"
                            return self.interface_afs

                        if (child_yang_name == "lsp-fast-flood-thresholds"):
                            if (self.lsp_fast_flood_thresholds is None):
                                self.lsp_fast_flood_thresholds = Isis.Instances.Instance.Interfaces.Interface.LspFastFloodThresholds()
                                self.lsp_fast_flood_thresholds.parent = self
                                self._children_name_map["lsp_fast_flood_thresholds"] = "lsp-fast-flood-thresholds"
                            return self.lsp_fast_flood_thresholds

                        if (child_yang_name == "lsp-intervals"):
                            if (self.lsp_intervals is None):
                                self.lsp_intervals = Isis.Instances.Instance.Interfaces.Interface.LspIntervals()
                                self.lsp_intervals.parent = self
                                self._children_name_map["lsp_intervals"] = "lsp-intervals"
                            return self.lsp_intervals

                        if (child_yang_name == "lsp-retransmit-intervals"):
                            if (self.lsp_retransmit_intervals is None):
                                self.lsp_retransmit_intervals = Isis.Instances.Instance.Interfaces.Interface.LspRetransmitIntervals()
                                self.lsp_retransmit_intervals.parent = self
                                self._children_name_map["lsp_retransmit_intervals"] = "lsp-retransmit-intervals"
                            return self.lsp_retransmit_intervals

                        if (child_yang_name == "lsp-retransmit-throttle-intervals"):
                            if (self.lsp_retransmit_throttle_intervals is None):
                                self.lsp_retransmit_throttle_intervals = Isis.Instances.Instance.Interfaces.Interface.LspRetransmitThrottleIntervals()
                                self.lsp_retransmit_throttle_intervals.parent = self
                                self._children_name_map["lsp_retransmit_throttle_intervals"] = "lsp-retransmit-throttle-intervals"
                            return self.lsp_retransmit_throttle_intervals

                        if (child_yang_name == "prefix-attribute-n-flag-clears"):
                            if (self.prefix_attribute_n_flag_clears is None):
                                self.prefix_attribute_n_flag_clears = Isis.Instances.Instance.Interfaces.Interface.PrefixAttributeNFlagClears()
                                self.prefix_attribute_n_flag_clears.parent = self
                                self._children_name_map["prefix_attribute_n_flag_clears"] = "prefix-attribute-n-flag-clears"
                            return self.prefix_attribute_n_flag_clears

                        if (child_yang_name == "priorities"):
                            if (self.priorities is None):
                                self.priorities = Isis.Instances.Instance.Interfaces.Interface.Priorities()
                                self.priorities.parent = self
                                self._children_name_map["priorities"] = "priorities"
                            return self.priorities

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfd" or name == "csnp-intervals" or name == "hello-accept-passwords" or name == "hello-intervals" or name == "hello-multipliers" or name == "hello-paddings" or name == "hello-passwords" or name == "interface-afs" or name == "lsp-fast-flood-thresholds" or name == "lsp-intervals" or name == "lsp-retransmit-intervals" or name == "lsp-retransmit-throttle-intervals" or name == "prefix-attribute-n-flag-clears" or name == "priorities" or name == "interface-name" or name == "circuit-type" or name == "link-down-fast-detect" or name == "mesh-group" or name == "point-to-point" or name == "running" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "circuit-type"):
                            self.circuit_type = value
                            self.circuit_type.value_namespace = name_space
                            self.circuit_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "link-down-fast-detect"):
                            self.link_down_fast_detect = value
                            self.link_down_fast_detect.value_namespace = name_space
                            self.link_down_fast_detect.value_namespace_prefix = name_space_prefix
                        if(value_path == "mesh-group"):
                            self.mesh_group = value
                            self.mesh_group.value_namespace = name_space
                            self.mesh_group.value_namespace_prefix = name_space_prefix
                        if(value_path == "point-to-point"):
                            self.point_to_point = value
                            self.point_to_point.value_namespace = name_space
                            self.point_to_point.value_namespace_prefix = name_space_prefix
                        if(value_path == "running"):
                            self.running = value
                            self.running.value_namespace = name_space
                            self.running.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.interface:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.interface:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interfaces" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface"):
                        for c in self.interface:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Isis.Instances.Instance.Interfaces.Interface()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.interface.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.instance_name.is_set or
                    self.dynamic_host_name.is_set or
                    self.ignore_lsp_errors.is_set or
                    self.instance_id.is_set or
                    self.is_type.is_set or
                    self.log_adjacency_changes.is_set or
                    self.log_pdu_drops.is_set or
                    self.nsr.is_set or
                    self.running.is_set or
                    self.tracing_mode.is_set or
                    (self.afs is not None and self.afs.has_data()) or
                    (self.interfaces is not None and self.interfaces.has_data()) or
                    (self.link_groups is not None and self.link_groups.has_data()) or
                    (self.lsp_accept_passwords is not None and self.lsp_accept_passwords.has_data()) or
                    (self.lsp_arrival_times is not None and self.lsp_arrival_times.has_data()) or
                    (self.lsp_check_intervals is not None and self.lsp_check_intervals.has_data()) or
                    (self.lsp_generation_intervals is not None and self.lsp_generation_intervals.has_data()) or
                    (self.lsp_lifetimes is not None and self.lsp_lifetimes.has_data()) or
                    (self.lsp_mtus is not None and self.lsp_mtus.has_data()) or
                    (self.lsp_passwords is not None and self.lsp_passwords.has_data()) or
                    (self.lsp_refresh_intervals is not None and self.lsp_refresh_intervals.has_data()) or
                    (self.max_link_metrics is not None and self.max_link_metrics.has_data()) or
                    (self.nets is not None and self.nets.has_data()) or
                    (self.nsf is not None and self.nsf.has_data()) or
                    (self.overload_bits is not None and self.overload_bits.has_data()) or
                    (self.trace_buffer_size is not None and self.trace_buffer_size.has_data()) or
                    (self.adjacency_stagger is not None) or
                    (self.distribute is not None) or
                    (self.srgb is not None))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.instance_name.yfilter != YFilter.not_set or
                    self.dynamic_host_name.yfilter != YFilter.not_set or
                    self.ignore_lsp_errors.yfilter != YFilter.not_set or
                    self.instance_id.yfilter != YFilter.not_set or
                    self.is_type.yfilter != YFilter.not_set or
                    self.log_adjacency_changes.yfilter != YFilter.not_set or
                    self.log_pdu_drops.yfilter != YFilter.not_set or
                    self.nsr.yfilter != YFilter.not_set or
                    self.running.yfilter != YFilter.not_set or
                    self.tracing_mode.yfilter != YFilter.not_set or
                    (self.adjacency_stagger is not None and self.adjacency_stagger.has_operation()) or
                    (self.afs is not None and self.afs.has_operation()) or
                    (self.distribute is not None and self.distribute.has_operation()) or
                    (self.interfaces is not None and self.interfaces.has_operation()) or
                    (self.link_groups is not None and self.link_groups.has_operation()) or
                    (self.lsp_accept_passwords is not None and self.lsp_accept_passwords.has_operation()) or
                    (self.lsp_arrival_times is not None and self.lsp_arrival_times.has_operation()) or
                    (self.lsp_check_intervals is not None and self.lsp_check_intervals.has_operation()) or
                    (self.lsp_generation_intervals is not None and self.lsp_generation_intervals.has_operation()) or
                    (self.lsp_lifetimes is not None and self.lsp_lifetimes.has_operation()) or
                    (self.lsp_mtus is not None and self.lsp_mtus.has_operation()) or
                    (self.lsp_passwords is not None and self.lsp_passwords.has_operation()) or
                    (self.lsp_refresh_intervals is not None and self.lsp_refresh_intervals.has_operation()) or
                    (self.max_link_metrics is not None and self.max_link_metrics.has_operation()) or
                    (self.nets is not None and self.nets.has_operation()) or
                    (self.nsf is not None and self.nsf.has_operation()) or
                    (self.overload_bits is not None and self.overload_bits.has_operation()) or
                    (self.srgb is not None and self.srgb.has_operation()) or
                    (self.trace_buffer_size is not None and self.trace_buffer_size.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "instance" + "[instance-name='" + self.instance_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-clns-isis-cfg:isis/instances/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.instance_name.is_set or self.instance_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.instance_name.get_name_leafdata())
                if (self.dynamic_host_name.is_set or self.dynamic_host_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.dynamic_host_name.get_name_leafdata())
                if (self.ignore_lsp_errors.is_set or self.ignore_lsp_errors.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ignore_lsp_errors.get_name_leafdata())
                if (self.instance_id.is_set or self.instance_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.instance_id.get_name_leafdata())
                if (self.is_type.is_set or self.is_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_type.get_name_leafdata())
                if (self.log_adjacency_changes.is_set or self.log_adjacency_changes.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.log_adjacency_changes.get_name_leafdata())
                if (self.log_pdu_drops.is_set or self.log_pdu_drops.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.log_pdu_drops.get_name_leafdata())
                if (self.nsr.is_set or self.nsr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr.get_name_leafdata())
                if (self.running.is_set or self.running.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.running.get_name_leafdata())
                if (self.tracing_mode.is_set or self.tracing_mode.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tracing_mode.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "adjacency-stagger"):
                    if (self.adjacency_stagger is None):
                        self.adjacency_stagger = Isis.Instances.Instance.AdjacencyStagger()
                        self.adjacency_stagger.parent = self
                        self._children_name_map["adjacency_stagger"] = "adjacency-stagger"
                    return self.adjacency_stagger

                if (child_yang_name == "afs"):
                    if (self.afs is None):
                        self.afs = Isis.Instances.Instance.Afs()
                        self.afs.parent = self
                        self._children_name_map["afs"] = "afs"
                    return self.afs

                if (child_yang_name == "distribute"):
                    if (self.distribute is None):
                        self.distribute = Isis.Instances.Instance.Distribute()
                        self.distribute.parent = self
                        self._children_name_map["distribute"] = "distribute"
                    return self.distribute

                if (child_yang_name == "interfaces"):
                    if (self.interfaces is None):
                        self.interfaces = Isis.Instances.Instance.Interfaces()
                        self.interfaces.parent = self
                        self._children_name_map["interfaces"] = "interfaces"
                    return self.interfaces

                if (child_yang_name == "link-groups"):
                    if (self.link_groups is None):
                        self.link_groups = Isis.Instances.Instance.LinkGroups()
                        self.link_groups.parent = self
                        self._children_name_map["link_groups"] = "link-groups"
                    return self.link_groups

                if (child_yang_name == "lsp-accept-passwords"):
                    if (self.lsp_accept_passwords is None):
                        self.lsp_accept_passwords = Isis.Instances.Instance.LspAcceptPasswords()
                        self.lsp_accept_passwords.parent = self
                        self._children_name_map["lsp_accept_passwords"] = "lsp-accept-passwords"
                    return self.lsp_accept_passwords

                if (child_yang_name == "lsp-arrival-times"):
                    if (self.lsp_arrival_times is None):
                        self.lsp_arrival_times = Isis.Instances.Instance.LspArrivalTimes()
                        self.lsp_arrival_times.parent = self
                        self._children_name_map["lsp_arrival_times"] = "lsp-arrival-times"
                    return self.lsp_arrival_times

                if (child_yang_name == "lsp-check-intervals"):
                    if (self.lsp_check_intervals is None):
                        self.lsp_check_intervals = Isis.Instances.Instance.LspCheckIntervals()
                        self.lsp_check_intervals.parent = self
                        self._children_name_map["lsp_check_intervals"] = "lsp-check-intervals"
                    return self.lsp_check_intervals

                if (child_yang_name == "lsp-generation-intervals"):
                    if (self.lsp_generation_intervals is None):
                        self.lsp_generation_intervals = Isis.Instances.Instance.LspGenerationIntervals()
                        self.lsp_generation_intervals.parent = self
                        self._children_name_map["lsp_generation_intervals"] = "lsp-generation-intervals"
                    return self.lsp_generation_intervals

                if (child_yang_name == "lsp-lifetimes"):
                    if (self.lsp_lifetimes is None):
                        self.lsp_lifetimes = Isis.Instances.Instance.LspLifetimes()
                        self.lsp_lifetimes.parent = self
                        self._children_name_map["lsp_lifetimes"] = "lsp-lifetimes"
                    return self.lsp_lifetimes

                if (child_yang_name == "lsp-mtus"):
                    if (self.lsp_mtus is None):
                        self.lsp_mtus = Isis.Instances.Instance.LspMtus()
                        self.lsp_mtus.parent = self
                        self._children_name_map["lsp_mtus"] = "lsp-mtus"
                    return self.lsp_mtus

                if (child_yang_name == "lsp-passwords"):
                    if (self.lsp_passwords is None):
                        self.lsp_passwords = Isis.Instances.Instance.LspPasswords()
                        self.lsp_passwords.parent = self
                        self._children_name_map["lsp_passwords"] = "lsp-passwords"
                    return self.lsp_passwords

                if (child_yang_name == "lsp-refresh-intervals"):
                    if (self.lsp_refresh_intervals is None):
                        self.lsp_refresh_intervals = Isis.Instances.Instance.LspRefreshIntervals()
                        self.lsp_refresh_intervals.parent = self
                        self._children_name_map["lsp_refresh_intervals"] = "lsp-refresh-intervals"
                    return self.lsp_refresh_intervals

                if (child_yang_name == "max-link-metrics"):
                    if (self.max_link_metrics is None):
                        self.max_link_metrics = Isis.Instances.Instance.MaxLinkMetrics()
                        self.max_link_metrics.parent = self
                        self._children_name_map["max_link_metrics"] = "max-link-metrics"
                    return self.max_link_metrics

                if (child_yang_name == "nets"):
                    if (self.nets is None):
                        self.nets = Isis.Instances.Instance.Nets()
                        self.nets.parent = self
                        self._children_name_map["nets"] = "nets"
                    return self.nets

                if (child_yang_name == "nsf"):
                    if (self.nsf is None):
                        self.nsf = Isis.Instances.Instance.Nsf()
                        self.nsf.parent = self
                        self._children_name_map["nsf"] = "nsf"
                    return self.nsf

                if (child_yang_name == "overload-bits"):
                    if (self.overload_bits is None):
                        self.overload_bits = Isis.Instances.Instance.OverloadBits()
                        self.overload_bits.parent = self
                        self._children_name_map["overload_bits"] = "overload-bits"
                    return self.overload_bits

                if (child_yang_name == "srgb"):
                    if (self.srgb is None):
                        self.srgb = Isis.Instances.Instance.Srgb()
                        self.srgb.parent = self
                        self._children_name_map["srgb"] = "srgb"
                    return self.srgb

                if (child_yang_name == "trace-buffer-size"):
                    if (self.trace_buffer_size is None):
                        self.trace_buffer_size = Isis.Instances.Instance.TraceBufferSize()
                        self.trace_buffer_size.parent = self
                        self._children_name_map["trace_buffer_size"] = "trace-buffer-size"
                    return self.trace_buffer_size

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "adjacency-stagger" or name == "afs" or name == "distribute" or name == "interfaces" or name == "link-groups" or name == "lsp-accept-passwords" or name == "lsp-arrival-times" or name == "lsp-check-intervals" or name == "lsp-generation-intervals" or name == "lsp-lifetimes" or name == "lsp-mtus" or name == "lsp-passwords" or name == "lsp-refresh-intervals" or name == "max-link-metrics" or name == "nets" or name == "nsf" or name == "overload-bits" or name == "srgb" or name == "trace-buffer-size" or name == "instance-name" or name == "dynamic-host-name" or name == "ignore-lsp-errors" or name == "instance-id" or name == "is-type" or name == "log-adjacency-changes" or name == "log-pdu-drops" or name == "nsr" or name == "running" or name == "tracing-mode"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "instance-name"):
                    self.instance_name = value
                    self.instance_name.value_namespace = name_space
                    self.instance_name.value_namespace_prefix = name_space_prefix
                if(value_path == "dynamic-host-name"):
                    self.dynamic_host_name = value
                    self.dynamic_host_name.value_namespace = name_space
                    self.dynamic_host_name.value_namespace_prefix = name_space_prefix
                if(value_path == "ignore-lsp-errors"):
                    self.ignore_lsp_errors = value
                    self.ignore_lsp_errors.value_namespace = name_space
                    self.ignore_lsp_errors.value_namespace_prefix = name_space_prefix
                if(value_path == "instance-id"):
                    self.instance_id = value
                    self.instance_id.value_namespace = name_space
                    self.instance_id.value_namespace_prefix = name_space_prefix
                if(value_path == "is-type"):
                    self.is_type = value
                    self.is_type.value_namespace = name_space
                    self.is_type.value_namespace_prefix = name_space_prefix
                if(value_path == "log-adjacency-changes"):
                    self.log_adjacency_changes = value
                    self.log_adjacency_changes.value_namespace = name_space
                    self.log_adjacency_changes.value_namespace_prefix = name_space_prefix
                if(value_path == "log-pdu-drops"):
                    self.log_pdu_drops = value
                    self.log_pdu_drops.value_namespace = name_space
                    self.log_pdu_drops.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr"):
                    self.nsr = value
                    self.nsr.value_namespace = name_space
                    self.nsr.value_namespace_prefix = name_space_prefix
                if(value_path == "running"):
                    self.running = value
                    self.running.value_namespace = name_space
                    self.running.value_namespace_prefix = name_space_prefix
                if(value_path == "tracing-mode"):
                    self.tracing_mode = value
                    self.tracing_mode.value_namespace = name_space
                    self.tracing_mode.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.instance:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.instance:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "instances" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-clns-isis-cfg:isis/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "instance"):
                for c in self.instance:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Isis.Instances.Instance()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.instance.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "instance"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (self.instances is not None and self.instances.has_data())

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.instances is not None and self.instances.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-clns-isis-cfg:isis" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "instances"):
            if (self.instances is None):
                self.instances = Isis.Instances()
                self.instances.parent = self
                self._children_name_map["instances"] = "instances"
            return self.instances

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "instances"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Isis()
        return self._top_entity

