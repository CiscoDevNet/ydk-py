""" Cisco_IOS_XR_pfi_im_cmd_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR pfi\-im\-cmd package operational data.

This module contains definitions
for the following management objects\:
  interfaces\: Interface operational data

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class BmMbrStateReason(Enum):
    """
    BmMbrStateReason

    Bm mbr state reason

    .. data:: bm_mbr_state_reason_unknown = 0

    	Reason unavailable (diagnostics error)

    .. data:: bm_mbr_state_reason_unselectable_unknown = 1

    	Link cannot be used (unknown reason)

    .. data:: bm_mbr_state_reason_link_down = 2

    	Link is down

    .. data:: bm_mbr_state_reason_link_deleting = 3

    	Link is being removed from the bundle

    .. data:: bm_mbr_state_reason_creating = 4

    	Link is in the process of being created

    .. data:: bm_mbr_state_reason_bundle_creating = 5

    	Bundle is in the process of being created

    .. data:: bm_mbr_state_reason_bundle_deleting = 6

    	Bundle is in the process of being deleted

    .. data:: bm_mbr_state_reason_bundle_admin_down = 7

    	Bundle has been shut down

    .. data:: bm_mbr_state_reason_replicating = 8

    	Bundle is in the process of being replicated to

    	this location

    .. data:: bm_mbr_state_reason_bandwidth = 9

    	Incompatible with other links in the bundle

    	(bandwidth out of range)

    .. data:: bm_mbr_state_reason_loop_back = 10

    	Loopback: Actor and Partner have the same

    	System ID and Key

    .. data:: bm_mbr_state_reason_activity_type = 11

    	Incompatible with other links in the bundle

    	(LACP vs non-LACP)

    .. data:: bm_mbr_state_reason_bundle_shutdown = 12

    	Bundle shutdown is configured for the bundle

    .. data:: bm_mbr_state_reason_min_selected = 13

    	Not enough links available to meet

    	minimum-active threshold

    .. data:: bm_mbr_state_reason_max_selected = 14

    	Link is Standby due to maximum-active links

    	configuration

    .. data:: bm_mbr_state_reason_link_limit = 15

    	Bundle has too many member links configured

    .. data:: bm_mbr_state_reason_active_limit = 16

    	Bundle has reached maximum supported number of

    	active links

    .. data:: bm_mbr_state_reason_standby_unknown = 17

    	Link is Standby (unknown reason)

    .. data:: bm_mbr_state_reason_expired = 18

    	Link is Expired; LACPDUs are not being received

    	from the partner

    .. data:: bm_mbr_state_reason_defaulted = 19

    	Link is Defaulted; LACPDUs are not being

    	received from the partner

    .. data:: bm_mbr_state_reason_act_or_not_agg = 20

    	Link is Not Aggregatable (unknown reason)

    .. data:: bm_mbr_state_reason_partner_not_agg = 21

    	Partner has marked the link as Not Aggregatable

    .. data:: bm_mbr_state_reason_lagid = 22

    	Partner System ID/Key do not match that of the

    	Selected links

    .. data:: bm_mbr_state_reason_bundle_not_cfgd = 23

    	Bundle interface is not present in

    	configuration

    .. data:: bm_mbr_state_reason_bundle_not_ready = 24

    	Wait-while timer is running

    .. data:: bm_mbr_state_reason_partner_ood = 25

    	Partner has not echoed the correct parameters

    	for this link

    .. data:: bm_mbr_state_reason_partner_not_in_sync = 26

    	Partner is not Synchronized (Waiting, Standby,

    	or LAG ID mismatch)

    .. data:: bm_mbr_state_reason_foreign_partner_oos = 27

    	Partner is not Synchronized (Waiting, not

    	Selected, or out-of-date)

    .. data:: bm_mbr_state_reason_attach_unknown = 28

    	Link is Attached and has not gone Collecting

    	(unknown reason)

    .. data:: bm_mbr_state_reason_partner_not_collecting = 29

    	Partner has not advertized that it is

    	Collecting

    .. data:: bm_mbr_state_reason_collect_unknown = 30

    	Link is Collecting and has not gone

    	Distributing (unknown reason)

    .. data:: bm_mbr_state_reason_standby_foreign = 31

    	Link is marked as Standby by mLACP peer

    .. data:: bm_mbr_state_reason_bfd_starting = 32

    	Link is waiting for BFD session to start

    .. data:: bm_mbr_state_reason_bfd_down = 33

    	BFD state of this link is Down

    .. data:: bm_mbr_state_reason_bfd_nbr_unconfig = 34

    	BFD session is unconfigured on the remote end

    .. data:: bm_mbr_state_reason_mlacp = 35

    	Link is not operational as a result of mLACP

    	negotiations

    .. data:: bm_mbr_state_reason_pe_isolated = 36

    	ICCP group is isolated from the core network

    .. data:: bm_mbr_state_reason_forced_switchover = 37

    	Forced switchover to the mLACP peer

    .. data:: bm_mbr_state_reason_errdis_unknown = 38

    	Link is error disabled (unknown reason)

    .. data:: bm_mbr_state_reason_mlacp_no_mbr_state_info = 39

    	Waiting for member state information from mLACP

    	peer

    .. data:: bm_mbr_state_reason_active = 40

    	Link is Active

    .. data:: bm_mbr_state_reason_mlacp_no_bdl_state_info = 41

    	Waiting for bundle state information from mLACP

    	peer

    .. data:: bm_mbr_state_reason_mlacp_no_bdl_config_info = 42

    	Waiting for bundle configuration information

    	from mLACP peer

    .. data:: bm_mbr_state_reason_mlacp_no_bdl_sync = 43

    	Waiting for bundle to complete initial

    	synchronization with mLACP peer

    .. data:: bm_mbr_state_reason_mlacp_bdl_has_no_peer = 44

    	mLACP bundle does not have a peer device

    .. data:: bm_mbr_state_reason_mlacp_nak = 45

    	Link is being ignored due to an inconsistency

    	with mLACP peer

    .. data:: bm_mbr_state_reason_mlacp_transport_unavailable = 46

    	ICCP transport is unavailable

    .. data:: bm_mbr_state_reason_mlacp_not_configured = 47

    	ICCP Group is not fully configured

    .. data:: bm_mbr_state_reason_recovery_timer = 48

    	mLACP recovery delay timer is running

    .. data:: bm_mbr_state_reason_mlacp_standby = 49

    	mLACP peer is active

    .. data:: bm_mbr_state_reason_maximized_out = 50

    	mLACP peer has more links/bandwidth available

    .. data:: bm_mbr_state_reason_mlacp_peer_selected = 51

    	mLACP peer has one or more links Selected

    .. data:: bm_mbr_state_reason_mlacp_connect_timer_running = 52

    	mLACP bundle does not have a peer device

    	(connect timer running)

    .. data:: bm_mbr_state_reason_bundle_not_mlacp = 53

    	Bundle is not configured to run mLACP

    .. data:: bm_mbr_state_reason_no_lon = 54

    	Bundle has too many working links configured

    	(more than the maximum-active limit)

    .. data:: bm_mbr_state_reason_cumul_rel_bw_limit = 55

    	Additional bandwidth from link would exceed

    	load balancing capabilities

    .. data:: bm_mbr_state_reason_no_mac = 56

    	No MAC address available for the bundle

    .. data:: bm_mbr_state_reason_no_system_id = 57

    	No system ID available for use by this bundle

    .. data:: bm_mbr_state_reason_link_shutdown = 58

    	Link is shutdown

    .. data:: bm_mbr_state_reason_activity_mlacp = 59

    	Non-LACP link in mLACP bundle

    .. data:: bm_mbr_state_reason_activity_iccp = 60

    	LACP link in inter-chassis bundle

    .. data:: bm_mbr_state_reason_bundle_icpe_mlacp = 61

    	Parent bundle is both inter-chassis and

    	configured for mLACP

    .. data:: bm_mbr_state_reason_no_link_num = 62

    	Too many bundle members in system; no link

    	number available

    .. data:: bm_mbr_state_reason_standby_peer_higher_prio = 63

    	mLACP peer has a higher priority link

    .. data:: bm_mbr_state_reason_red_state_standby = 64

    	Link is in standby redundancy state

    .. data:: bm_mbr_state_reason_other_red_state_standby = 65

    	One or more links in the bundle are in standby

    	redundancy state

    .. data:: bm_mbr_state_reason_hold_ing = 66

    	Holding down temporary to avoid churn after

    	restart

    .. data:: bm_mbr_state_reason_bundle_error_disabled = 67

    	Bundle has been error-disabled

    .. data:: bm_mbr_state_reason_bundle_efd_disabled = 68

    	Bundle has been disabled by EFD

    .. data:: bm_mbr_state_reason_singleton_pe_isolated = 69

    	Singleton ICCP group is isolated from the core

    	network

    .. data:: bm_mbr_state_reason_bfd_ipv6_starting = 70

    	Link is waiting for BFDv6 session to start

    .. data:: bm_mbr_state_reason_bfd_ipv6_down = 71

    	BFDv6 state of this link is Down

    .. data:: bm_mbr_state_reason_bfd_ipv6_nbr_unconfig = 72

    	BFDv6 session is unconfigured on the remote end

    .. data:: bm_mbr_state_reason_timer_running = 73

    	LACP delay timer is running

    .. data:: bm_mbr_state_reason_client_bundle_ctrl = 74

    	Client has configured the bundle state Down

    .. data:: bm_mbr_state_reason_count = 75

    	Enumeration maximum value

    """

    bm_mbr_state_reason_unknown = Enum.YLeaf(0, "bm-mbr-state-reason-unknown")

    bm_mbr_state_reason_unselectable_unknown = Enum.YLeaf(1, "bm-mbr-state-reason-unselectable-unknown")

    bm_mbr_state_reason_link_down = Enum.YLeaf(2, "bm-mbr-state-reason-link-down")

    bm_mbr_state_reason_link_deleting = Enum.YLeaf(3, "bm-mbr-state-reason-link-deleting")

    bm_mbr_state_reason_creating = Enum.YLeaf(4, "bm-mbr-state-reason-creating")

    bm_mbr_state_reason_bundle_creating = Enum.YLeaf(5, "bm-mbr-state-reason-bundle-creating")

    bm_mbr_state_reason_bundle_deleting = Enum.YLeaf(6, "bm-mbr-state-reason-bundle-deleting")

    bm_mbr_state_reason_bundle_admin_down = Enum.YLeaf(7, "bm-mbr-state-reason-bundle-admin-down")

    bm_mbr_state_reason_replicating = Enum.YLeaf(8, "bm-mbr-state-reason-replicating")

    bm_mbr_state_reason_bandwidth = Enum.YLeaf(9, "bm-mbr-state-reason-bandwidth")

    bm_mbr_state_reason_loop_back = Enum.YLeaf(10, "bm-mbr-state-reason-loop-back")

    bm_mbr_state_reason_activity_type = Enum.YLeaf(11, "bm-mbr-state-reason-activity-type")

    bm_mbr_state_reason_bundle_shutdown = Enum.YLeaf(12, "bm-mbr-state-reason-bundle-shutdown")

    bm_mbr_state_reason_min_selected = Enum.YLeaf(13, "bm-mbr-state-reason-min-selected")

    bm_mbr_state_reason_max_selected = Enum.YLeaf(14, "bm-mbr-state-reason-max-selected")

    bm_mbr_state_reason_link_limit = Enum.YLeaf(15, "bm-mbr-state-reason-link-limit")

    bm_mbr_state_reason_active_limit = Enum.YLeaf(16, "bm-mbr-state-reason-active-limit")

    bm_mbr_state_reason_standby_unknown = Enum.YLeaf(17, "bm-mbr-state-reason-standby-unknown")

    bm_mbr_state_reason_expired = Enum.YLeaf(18, "bm-mbr-state-reason-expired")

    bm_mbr_state_reason_defaulted = Enum.YLeaf(19, "bm-mbr-state-reason-defaulted")

    bm_mbr_state_reason_act_or_not_agg = Enum.YLeaf(20, "bm-mbr-state-reason-act-or-not-agg")

    bm_mbr_state_reason_partner_not_agg = Enum.YLeaf(21, "bm-mbr-state-reason-partner-not-agg")

    bm_mbr_state_reason_lagid = Enum.YLeaf(22, "bm-mbr-state-reason-lagid")

    bm_mbr_state_reason_bundle_not_cfgd = Enum.YLeaf(23, "bm-mbr-state-reason-bundle-not-cfgd")

    bm_mbr_state_reason_bundle_not_ready = Enum.YLeaf(24, "bm-mbr-state-reason-bundle-not-ready")

    bm_mbr_state_reason_partner_ood = Enum.YLeaf(25, "bm-mbr-state-reason-partner-ood")

    bm_mbr_state_reason_partner_not_in_sync = Enum.YLeaf(26, "bm-mbr-state-reason-partner-not-in-sync")

    bm_mbr_state_reason_foreign_partner_oos = Enum.YLeaf(27, "bm-mbr-state-reason-foreign-partner-oos")

    bm_mbr_state_reason_attach_unknown = Enum.YLeaf(28, "bm-mbr-state-reason-attach-unknown")

    bm_mbr_state_reason_partner_not_collecting = Enum.YLeaf(29, "bm-mbr-state-reason-partner-not-collecting")

    bm_mbr_state_reason_collect_unknown = Enum.YLeaf(30, "bm-mbr-state-reason-collect-unknown")

    bm_mbr_state_reason_standby_foreign = Enum.YLeaf(31, "bm-mbr-state-reason-standby-foreign")

    bm_mbr_state_reason_bfd_starting = Enum.YLeaf(32, "bm-mbr-state-reason-bfd-starting")

    bm_mbr_state_reason_bfd_down = Enum.YLeaf(33, "bm-mbr-state-reason-bfd-down")

    bm_mbr_state_reason_bfd_nbr_unconfig = Enum.YLeaf(34, "bm-mbr-state-reason-bfd-nbr-unconfig")

    bm_mbr_state_reason_mlacp = Enum.YLeaf(35, "bm-mbr-state-reason-mlacp")

    bm_mbr_state_reason_pe_isolated = Enum.YLeaf(36, "bm-mbr-state-reason-pe-isolated")

    bm_mbr_state_reason_forced_switchover = Enum.YLeaf(37, "bm-mbr-state-reason-forced-switchover")

    bm_mbr_state_reason_errdis_unknown = Enum.YLeaf(38, "bm-mbr-state-reason-errdis-unknown")

    bm_mbr_state_reason_mlacp_no_mbr_state_info = Enum.YLeaf(39, "bm-mbr-state-reason-mlacp-no-mbr-state-info")

    bm_mbr_state_reason_active = Enum.YLeaf(40, "bm-mbr-state-reason-active")

    bm_mbr_state_reason_mlacp_no_bdl_state_info = Enum.YLeaf(41, "bm-mbr-state-reason-mlacp-no-bdl-state-info")

    bm_mbr_state_reason_mlacp_no_bdl_config_info = Enum.YLeaf(42, "bm-mbr-state-reason-mlacp-no-bdl-config-info")

    bm_mbr_state_reason_mlacp_no_bdl_sync = Enum.YLeaf(43, "bm-mbr-state-reason-mlacp-no-bdl-sync")

    bm_mbr_state_reason_mlacp_bdl_has_no_peer = Enum.YLeaf(44, "bm-mbr-state-reason-mlacp-bdl-has-no-peer")

    bm_mbr_state_reason_mlacp_nak = Enum.YLeaf(45, "bm-mbr-state-reason-mlacp-nak")

    bm_mbr_state_reason_mlacp_transport_unavailable = Enum.YLeaf(46, "bm-mbr-state-reason-mlacp-transport-unavailable")

    bm_mbr_state_reason_mlacp_not_configured = Enum.YLeaf(47, "bm-mbr-state-reason-mlacp-not-configured")

    bm_mbr_state_reason_recovery_timer = Enum.YLeaf(48, "bm-mbr-state-reason-recovery-timer")

    bm_mbr_state_reason_mlacp_standby = Enum.YLeaf(49, "bm-mbr-state-reason-mlacp-standby")

    bm_mbr_state_reason_maximized_out = Enum.YLeaf(50, "bm-mbr-state-reason-maximized-out")

    bm_mbr_state_reason_mlacp_peer_selected = Enum.YLeaf(51, "bm-mbr-state-reason-mlacp-peer-selected")

    bm_mbr_state_reason_mlacp_connect_timer_running = Enum.YLeaf(52, "bm-mbr-state-reason-mlacp-connect-timer-running")

    bm_mbr_state_reason_bundle_not_mlacp = Enum.YLeaf(53, "bm-mbr-state-reason-bundle-not-mlacp")

    bm_mbr_state_reason_no_lon = Enum.YLeaf(54, "bm-mbr-state-reason-no-lon")

    bm_mbr_state_reason_cumul_rel_bw_limit = Enum.YLeaf(55, "bm-mbr-state-reason-cumul-rel-bw-limit")

    bm_mbr_state_reason_no_mac = Enum.YLeaf(56, "bm-mbr-state-reason-no-mac")

    bm_mbr_state_reason_no_system_id = Enum.YLeaf(57, "bm-mbr-state-reason-no-system-id")

    bm_mbr_state_reason_link_shutdown = Enum.YLeaf(58, "bm-mbr-state-reason-link-shutdown")

    bm_mbr_state_reason_activity_mlacp = Enum.YLeaf(59, "bm-mbr-state-reason-activity-mlacp")

    bm_mbr_state_reason_activity_iccp = Enum.YLeaf(60, "bm-mbr-state-reason-activity-iccp")

    bm_mbr_state_reason_bundle_icpe_mlacp = Enum.YLeaf(61, "bm-mbr-state-reason-bundle-icpe-mlacp")

    bm_mbr_state_reason_no_link_num = Enum.YLeaf(62, "bm-mbr-state-reason-no-link-num")

    bm_mbr_state_reason_standby_peer_higher_prio = Enum.YLeaf(63, "bm-mbr-state-reason-standby-peer-higher-prio")

    bm_mbr_state_reason_red_state_standby = Enum.YLeaf(64, "bm-mbr-state-reason-red-state-standby")

    bm_mbr_state_reason_other_red_state_standby = Enum.YLeaf(65, "bm-mbr-state-reason-other-red-state-standby")

    bm_mbr_state_reason_hold_ing = Enum.YLeaf(66, "bm-mbr-state-reason-hold-ing")

    bm_mbr_state_reason_bundle_error_disabled = Enum.YLeaf(67, "bm-mbr-state-reason-bundle-error-disabled")

    bm_mbr_state_reason_bundle_efd_disabled = Enum.YLeaf(68, "bm-mbr-state-reason-bundle-efd-disabled")

    bm_mbr_state_reason_singleton_pe_isolated = Enum.YLeaf(69, "bm-mbr-state-reason-singleton-pe-isolated")

    bm_mbr_state_reason_bfd_ipv6_starting = Enum.YLeaf(70, "bm-mbr-state-reason-bfd-ipv6-starting")

    bm_mbr_state_reason_bfd_ipv6_down = Enum.YLeaf(71, "bm-mbr-state-reason-bfd-ipv6-down")

    bm_mbr_state_reason_bfd_ipv6_nbr_unconfig = Enum.YLeaf(72, "bm-mbr-state-reason-bfd-ipv6-nbr-unconfig")

    bm_mbr_state_reason_timer_running = Enum.YLeaf(73, "bm-mbr-state-reason-timer-running")

    bm_mbr_state_reason_client_bundle_ctrl = Enum.YLeaf(74, "bm-mbr-state-reason-client-bundle-ctrl")

    bm_mbr_state_reason_count = Enum.YLeaf(75, "bm-mbr-state-reason-count")


class BmMuxreason(Enum):
    """
    BmMuxreason

    Bm muxreason

    .. data:: bm_mux_reason_no_reason = 0

    	Selection logic has not yet been run for the

    	bundle this link is a member of

    .. data:: bm_mux_reason_link_down = 1

    	Link is down

    .. data:: bm_mux_reason_link_deleted = 2

    	Link is being removed from the bundle

    .. data:: bm_mux_reason_duplex = 3

    	Link has wrong duplexity

    .. data:: bm_mux_reason_bandwidth = 4

    	Link has wrong bandwidth

    .. data:: bm_mux_reason_loop_back = 5

    	Link is a loopback interface

    .. data:: bm_mux_reason_activity_type = 6

    	Link has wrong activity type

    .. data:: bm_mux_reason_link_limit = 7

    	Link's bundle already has maximum number of

    	members allowed

    .. data:: bm_mux_reason_shared = 8

    	Link is attached to a shared medium

    .. data:: bm_mux_reason_lagid = 9

    	Link has wrong LAG ID

    .. data:: bm_mux_reason_no_bundle = 10

    	Link's bundle does not exist

    .. data:: bm_mux_reason_no_primary = 11

    	Link's bundle has no primary link

    .. data:: bm_mux_reason_bundle_down = 12

    	Link's bundle is shut down

    .. data:: bm_mux_reason_individual = 13

    	Link is marked individual by partner

    .. data:: bm_mux_reason_defaulted = 14

    	Link is Defaulted, suggesting it is not

    	receiving LACPDUs from the peer

    .. data:: bm_mux_reason_in_sync = 15

    	Link is in InSync state

    .. data:: bm_mux_reason_collecting = 16

    	Link is in Collecting state

    .. data:: bm_mux_reason_active_link_limit = 17

    	Link exceeds maximum active limit

    .. data:: bm_mux_reason_distributing = 18

    	Link is in Distributing state

    .. data:: bm_mux_reason_count = 19

    	Enumeration maximum value

    """

    bm_mux_reason_no_reason = Enum.YLeaf(0, "bm-mux-reason-no-reason")

    bm_mux_reason_link_down = Enum.YLeaf(1, "bm-mux-reason-link-down")

    bm_mux_reason_link_deleted = Enum.YLeaf(2, "bm-mux-reason-link-deleted")

    bm_mux_reason_duplex = Enum.YLeaf(3, "bm-mux-reason-duplex")

    bm_mux_reason_bandwidth = Enum.YLeaf(4, "bm-mux-reason-bandwidth")

    bm_mux_reason_loop_back = Enum.YLeaf(5, "bm-mux-reason-loop-back")

    bm_mux_reason_activity_type = Enum.YLeaf(6, "bm-mux-reason-activity-type")

    bm_mux_reason_link_limit = Enum.YLeaf(7, "bm-mux-reason-link-limit")

    bm_mux_reason_shared = Enum.YLeaf(8, "bm-mux-reason-shared")

    bm_mux_reason_lagid = Enum.YLeaf(9, "bm-mux-reason-lagid")

    bm_mux_reason_no_bundle = Enum.YLeaf(10, "bm-mux-reason-no-bundle")

    bm_mux_reason_no_primary = Enum.YLeaf(11, "bm-mux-reason-no-primary")

    bm_mux_reason_bundle_down = Enum.YLeaf(12, "bm-mux-reason-bundle-down")

    bm_mux_reason_individual = Enum.YLeaf(13, "bm-mux-reason-individual")

    bm_mux_reason_defaulted = Enum.YLeaf(14, "bm-mux-reason-defaulted")

    bm_mux_reason_in_sync = Enum.YLeaf(15, "bm-mux-reason-in-sync")

    bm_mux_reason_collecting = Enum.YLeaf(16, "bm-mux-reason-collecting")

    bm_mux_reason_active_link_limit = Enum.YLeaf(17, "bm-mux-reason-active-link-limit")

    bm_mux_reason_distributing = Enum.YLeaf(18, "bm-mux-reason-distributing")

    bm_mux_reason_count = Enum.YLeaf(19, "bm-mux-reason-count")


class BmMuxstate(Enum):
    """
    BmMuxstate

    Bm muxstate

    .. data:: detached = 1

    	Port is not attached to a bundle

    .. data:: waiting = 2

    	Port has chosen bundle and is waiting to join

    .. data:: attached = 3

    	Port is attached to the bundle but not active

    .. data:: collecting = 4

    	Port is ready to receive data

    .. data:: distributing = 5

    	Port is distributing data

    .. data:: collecting_distributing = 6

    	Port is active and can send and receive data

    """

    detached = Enum.YLeaf(1, "detached")

    waiting = Enum.YLeaf(2, "waiting")

    attached = Enum.YLeaf(3, "attached")

    collecting = Enum.YLeaf(4, "collecting")

    distributing = Enum.YLeaf(5, "distributing")

    collecting_distributing = Enum.YLeaf(6, "collecting-distributing")


class BmSeverity(Enum):
    """
    BmSeverity

    Severity of the member state reason

    .. data:: ok = 0

    	OK

    .. data:: information = 1

    	Information

    .. data:: misconfiguration = 2

    	Misconfiguration

    .. data:: warning = 3

    	Warning

    .. data:: error = 5

    	Error

    """

    ok = Enum.YLeaf(0, "ok")

    information = Enum.YLeaf(1, "information")

    misconfiguration = Enum.YLeaf(2, "misconfiguration")

    warning = Enum.YLeaf(3, "warning")

    error = Enum.YLeaf(5, "error")


class BmStateReasonTarget(Enum):
    """
    BmStateReasonTarget

    Scope of the state reason

    .. data:: member_reason = 0

    	Member applicable reason

    .. data:: bundle_reason = 1

    	Bundle applicable reason

    """

    member_reason = Enum.YLeaf(0, "member-reason")

    bundle_reason = Enum.YLeaf(1, "bundle-reason")


class BmdMemberState(Enum):
    """
    BmdMemberState

    Bmd member state

    .. data:: bmd_mbr_state_configured = 1

    	Member is configured

    .. data:: bmd_mbr_state_standby = 2

    	Member is standby

    .. data:: bmd_mbr_state_hot_standby = 3

    	Member is hot standby

    .. data:: bmd_mbr_state_negotiating = 4

    	Member is negotiating

    .. data:: bmd_mbr_state_bfd_running = 5

    	Member has a BFD session running

    .. data:: bmd_mbr_state_active = 6

    	Member is active

    """

    bmd_mbr_state_configured = Enum.YLeaf(1, "bmd-mbr-state-configured")

    bmd_mbr_state_standby = Enum.YLeaf(2, "bmd-mbr-state-standby")

    bmd_mbr_state_hot_standby = Enum.YLeaf(3, "bmd-mbr-state-hot-standby")

    bmd_mbr_state_negotiating = Enum.YLeaf(4, "bmd-mbr-state-negotiating")

    bmd_mbr_state_bfd_running = Enum.YLeaf(5, "bmd-mbr-state-bfd-running")

    bmd_mbr_state_active = Enum.YLeaf(6, "bmd-mbr-state-active")


class BmdMemberTypeEnum(Enum):
    """
    BmdMemberTypeEnum

    Bmd member type enum

    .. data:: bmd_mbr_local = 0

    	Member has been configured on the local device

    .. data:: bmd_mbr_foreign = 1

    	Member has been configured on an mLACP peer

    	device

    .. data:: bmd_mbr_unknown = 2

    	Member's type is unknown

    """

    bmd_mbr_local = Enum.YLeaf(0, "bmd-mbr-local")

    bmd_mbr_foreign = Enum.YLeaf(1, "bmd-mbr-foreign")

    bmd_mbr_unknown = Enum.YLeaf(2, "bmd-mbr-unknown")


class EfpPayloadEtype(Enum):
    """
    EfpPayloadEtype

    Payload ethertype match

    .. data:: payload_ethertype_any = 0

    	Any

    .. data:: payload_ethertype_ip = 1

    	IP

    .. data:: payload_ethertype_pppoe = 2

    	PPPoE

    """

    payload_ethertype_any = Enum.YLeaf(0, "payload-ethertype-any")

    payload_ethertype_ip = Enum.YLeaf(1, "payload-ethertype-ip")

    payload_ethertype_pppoe = Enum.YLeaf(2, "payload-ethertype-pppoe")


class EfpTagEtype(Enum):
    """
    EfpTagEtype

    Tag ethertype

    .. data:: untagged = 0

    	Untagged

    .. data:: dot1q = 33024

    	Dot1Q

    .. data:: dot1ad = 34984

    	Dot1ad

    """

    untagged = Enum.YLeaf(0, "untagged")

    dot1q = Enum.YLeaf(33024, "dot1q")

    dot1ad = Enum.YLeaf(34984, "dot1ad")


class EfpTagPriority(Enum):
    """
    EfpTagPriority

    Priority

    .. data:: priority0 = 0

    	Priority 0

    .. data:: priority1 = 1

    	Priority 1

    .. data:: priority2 = 2

    	Priority 2

    .. data:: priority3 = 3

    	Priority 3

    .. data:: priority4 = 4

    	Priority 4

    .. data:: priority5 = 5

    	Priority 5

    .. data:: priority6 = 6

    	Priority 6

    .. data:: priority7 = 7

    	Priority 7

    .. data:: priority_any = 8

    	Any priority

    """

    priority0 = Enum.YLeaf(0, "priority0")

    priority1 = Enum.YLeaf(1, "priority1")

    priority2 = Enum.YLeaf(2, "priority2")

    priority3 = Enum.YLeaf(3, "priority3")

    priority4 = Enum.YLeaf(4, "priority4")

    priority5 = Enum.YLeaf(5, "priority5")

    priority6 = Enum.YLeaf(6, "priority6")

    priority7 = Enum.YLeaf(7, "priority7")

    priority_any = Enum.YLeaf(8, "priority-any")


class GccDerState(Enum):
    """
    GccDerState

    Gcc der state

    .. data:: in_service = 0

    	In Service

    .. data:: out_of_service = 1

    	Out Of Service

    .. data:: maintainance = 2

    	Maintainance

    .. data:: ais = 3

    	Automatic In Service

    """

    in_service = Enum.YLeaf(0, "in-service")

    out_of_service = Enum.YLeaf(1, "out-of-service")

    maintainance = Enum.YLeaf(2, "maintainance")

    ais = Enum.YLeaf(3, "ais")


class GccSecState(Enum):
    """
    GccSecState

    Gcc sec state

    .. data:: normal = 0

    	Normal

    .. data:: maintainance = 1

    	Maintainance

    .. data:: ais = 2

    	Automatic In Service

    """

    normal = Enum.YLeaf(0, "normal")

    maintainance = Enum.YLeaf(1, "maintainance")

    ais = Enum.YLeaf(2, "ais")


class ImAttrDuplex(Enum):
    """
    ImAttrDuplex

    Im attr duplex

    .. data:: im_attr_duplex_unknown = 0

    	im attr duplex unknown

    .. data:: im_attr_duplex_half = 1

    	im attr duplex half

    .. data:: im_attr_duplex_full = 2

    	im attr duplex full

    """

    im_attr_duplex_unknown = Enum.YLeaf(0, "im-attr-duplex-unknown")

    im_attr_duplex_half = Enum.YLeaf(1, "im-attr-duplex-half")

    im_attr_duplex_full = Enum.YLeaf(2, "im-attr-duplex-full")


class ImAttrFlowControl(Enum):
    """
    ImAttrFlowControl

    Im attr flow control

    .. data:: im_attr_flow_control_off = 0

    	im attr flow control off

    .. data:: im_attr_flow_control_on = 1

    	im attr flow control on

    .. data:: im_attr_flow_control_not_sup = 2

    	im attr flow control not sup

    .. data:: im_attr_flow_control_priority = 3

    	im attr flow control priority

    """

    im_attr_flow_control_off = Enum.YLeaf(0, "im-attr-flow-control-off")

    im_attr_flow_control_on = Enum.YLeaf(1, "im-attr-flow-control-on")

    im_attr_flow_control_not_sup = Enum.YLeaf(2, "im-attr-flow-control-not-sup")

    im_attr_flow_control_priority = Enum.YLeaf(3, "im-attr-flow-control-priority")


class ImAttrLink(Enum):
    """
    ImAttrLink

    Im attr link

    .. data:: im_attr_link_type_auto = 0

    	im attr link type auto

    .. data:: im_attr_link_type_force = 1

    	im attr link type force

    """

    im_attr_link_type_auto = Enum.YLeaf(0, "im-attr-link-type-auto")

    im_attr_link_type_force = Enum.YLeaf(1, "im-attr-link-type-force")


class ImAttrMedia(Enum):
    """
    ImAttrMedia

    Im attr media

    .. data:: im_attr_media_other = 0

    	im attr media other

    .. data:: im_attr_media_unknown = 1

    	im attr media unknown

    .. data:: im_attr_media_aui = 2

    	im attr media aui

    .. data:: im_attr_media_10base5 = 3

    	im attr media 10base5

    .. data:: im_attr_media_foirl = 4

    	im attr media foirl

    .. data:: im_attr_media_10base2 = 5

    	im attr media 10base2

    .. data:: im_attr_media_10broad36 = 6

    	im attr media 10broad36

    .. data:: im_attr_media_10base = 7

    	im attr media 10base

    .. data:: im_attr_media_10base_thd = 8

    	im attr media 10base thd

    .. data:: im_attr_media_10base_tfd = 9

    	im attr media 10base tfd

    .. data:: im_attr_media_10base_fp = 10

    	im attr media 10base fp

    .. data:: im_attr_media_10base_fb = 11

    	im attr media 10base fb

    .. data:: im_attr_media_10base_fl = 12

    	im attr media 10base fl

    .. data:: im_attr_media_10base_flhd = 13

    	im attr media 10base flhd

    .. data:: im_attr_media_10base_flfd = 14

    	im attr media 10base flfd

    .. data:: im_attr_media_100base_t4 = 15

    	im attr media 100base t4

    .. data:: im_attr_media_100base_tx = 16

    	im attr media 100base tx

    .. data:: im_attr_media_100base_txhd = 17

    	im attr media 100base txhd

    .. data:: im_attr_media_100base_txfd = 18

    	im attr media 100base txfd

    .. data:: im_attr_media_100base_fx = 19

    	im attr media 100base fx

    .. data:: im_attr_media_100base_fxhd = 20

    	im attr media 100base fxhd

    .. data:: im_attr_media_100base_fxfd = 21

    	im attr media 100base fxfd

    .. data:: im_attr_media_100base_ex = 22

    	im attr media 100base ex

    .. data:: im_attr_media_100base_exhd = 23

    	im attr media 100base exhd

    .. data:: im_attr_media_100base_exfd = 24

    	im attr media 100base exfd

    .. data:: im_attr_media_100base_t2 = 25

    	im attr media 100base t2

    .. data:: im_attr_media_100base_t2hd = 26

    	im attr media 100base t2hd

    .. data:: im_attr_media_100base_t2fd = 27

    	im attr media 100base t2fd

    .. data:: im_attr_media_1000base_x = 28

    	im attr media 1000base x

    .. data:: im_attr_media_1000base_xhdx = 29

    	im attr media 1000base xhdx

    .. data:: im_attr_media_1000base_xfd = 30

    	im attr media 1000base xfd

    .. data:: im_attr_media_1000base_lx = 31

    	im attr media 1000base lx

    .. data:: im_attr_media_1000base_lxhd = 32

    	im attr media 1000base lxhd

    .. data:: im_attr_media_1000base_lxfdx = 33

    	im attr media 1000base lxfdx

    .. data:: im_attr_media_1000base_sx = 34

    	im attr media 1000base sx

    .. data:: im_attr_media_1000base_sxhd = 35

    	im attr media 1000base sxhd

    .. data:: im_attr_media_1000base_sxfd = 36

    	im attr media 1000base sxfd

    .. data:: im_attr_media_1000base_cx = 37

    	im attr media 1000base cx

    .. data:: im_attr_media_1000base_cxhdx = 38

    	im attr media 1000base cxhdx

    .. data:: im_attr_media_1000base_cxfd = 39

    	im attr media 1000base cxfd

    .. data:: im_attr_media_1000base = 40

    	im attr media 1000base

    .. data:: im_attr_media_1000base_thd = 41

    	im attr media 1000base thd

    .. data:: im_attr_media_1000base_tfd = 42

    	im attr media 1000base tfd

    .. data:: im_attr_media_10gbase_x = 43

    	im attr media 10gbase x

    .. data:: im_attr_media_10gbase_lx4 = 44

    	im attr media 10gbase lx4

    .. data:: im_attr_media_10gbase_r = 45

    	im attr media 10gbase r

    .. data:: im_attr_media_10gbase_er = 46

    	im attr media 10gbase er

    .. data:: im_attr_media_10gbase_lr = 47

    	im attr media 10gbase lr

    .. data:: im_attr_media_10gbase_sr = 48

    	im attr media 10gbase sr

    .. data:: im_attr_media_10gbase_w = 49

    	im attr media 10gbase w

    .. data:: im_attr_media_10gbase_ew = 50

    	im attr media 10gbase ew

    .. data:: im_attr_media_10gbase_lw = 51

    	im attr media 10gbase lw

    .. data:: im_attr_media_10gbase_sw = 52

    	im attr media 10gbase sw

    .. data:: im_attr_media_10gbase_zr = 53

    	im attr media 10gbase zr

    .. data:: im_attr_media_802_9a = 54

    	im attr media 802 9a

    .. data:: im_attr_media_rj45 = 55

    	im attr media rj45

    .. data:: im_attr_media_1000base_zx = 56

    	im attr media 1000base zx

    .. data:: im_attr_media_1000base_cwdm = 57

    	im attr media 1000base cwdm

    .. data:: im_attr_media_1000base_cwdm_1470 = 58

    	im attr media 1000base cwdm 1470

    .. data:: im_attr_media_1000base_cwdm_1490 = 59

    	im attr media 1000base cwdm 1490

    .. data:: im_attr_media_1000base_cwdm_1510 = 60

    	im attr media 1000base cwdm 1510

    .. data:: im_attr_media_1000base_cwdm_1530 = 61

    	im attr media 1000base cwdm 1530

    .. data:: im_attr_media_1000base_cwdm_1550 = 62

    	im attr media 1000base cwdm 1550

    .. data:: im_attr_media_1000base_cwdm_1570 = 63

    	im attr media 1000base cwdm 1570

    .. data:: im_attr_media_1000base_cwdm_1590 = 64

    	im attr media 1000base cwdm 1590

    .. data:: im_attr_media_1000base_cwdm_1610 = 65

    	im attr media 1000base cwdm 1610

    .. data:: im_attr_media_10gbase_dwdm = 66

    	im attr media 10gbase dwdm

    .. data:: im_attr_media_100gbase_lr4 = 67

    	im attr media 100gbase lr4

    .. data:: im_attr_media_1000base_dwdm = 68

    	im attr media 1000base dwdm

    .. data:: im_attr_media_1000base_dwdm_1533 = 69

    	im attr media 1000base dwdm 1533

    .. data:: im_attr_media_1000base_dwdm_1537 = 70

    	im attr media 1000base dwdm 1537

    .. data:: im_attr_media_1000base_dwdm_1541 = 71

    	im attr media 1000base dwdm 1541

    .. data:: im_attr_media_1000base_dwdm_1545 = 72

    	im attr media 1000base dwdm 1545

    .. data:: im_attr_media_1000base_dwdm_1549 = 73

    	im attr media 1000base dwdm 1549

    .. data:: im_attr_media_1000base_dwdm_1553 = 74

    	im attr media 1000base dwdm 1553

    .. data:: im_attr_media_1000base_dwdm_1557 = 75

    	im attr media 1000base dwdm 1557

    .. data:: im_attr_media_1000base_dwdm_1561 = 76

    	im attr media 1000base dwdm 1561

    .. data:: im_attr_media_40gbase_lr4 = 77

    	im attr media 40gbase lr4

    .. data:: im_attr_media_40gbase_er4 = 78

    	im attr media 40gbase er4

    .. data:: im_attr_media_100gbase_er4 = 79

    	im attr media 100gbase er4

    .. data:: im_attr_media_1000base_ex = 80

    	im attr media 1000base ex

    .. data:: im_attr_media_1000base_bx10_d = 81

    	im attr media 1000base bx10 d

    .. data:: im_attr_media_1000base_bx10_u = 82

    	im attr media 1000base bx10 u

    .. data:: im_attr_media_1000base_dwdm_1561_42 = 83

    	im attr media 1000base dwdm 1561 42

    .. data:: im_attr_media_1000base_dwdm_1560_61 = 84

    	im attr media 1000base dwdm 1560 61

    .. data:: im_attr_media_1000base_dwdm_1559_79 = 85

    	im attr media 1000base dwdm 1559 79

    .. data:: im_attr_media_1000base_dwdm_1558_98 = 86

    	im attr media 1000base dwdm 1558 98

    .. data:: im_attr_media_1000base_dwdm_1558_17 = 87

    	im attr media 1000base dwdm 1558 17

    .. data:: im_attr_media_1000base_dwdm_1557_36 = 88

    	im attr media 1000base dwdm 1557 36

    .. data:: im_attr_media_1000base_dwdm_1556_55 = 89

    	im attr media 1000base dwdm 1556 55

    .. data:: im_attr_media_1000base_dwdm_1555_75 = 90

    	im attr media 1000base dwdm 1555 75

    .. data:: im_attr_media_1000base_dwdm_1554_94 = 91

    	im attr media 1000base dwdm 1554 94

    .. data:: im_attr_media_1000base_dwdm_1554_13 = 92

    	im attr media 1000base dwdm 1554 13

    .. data:: im_attr_media_1000base_dwdm_1553_33 = 93

    	im attr media 1000base dwdm 1553 33

    .. data:: im_attr_media_1000base_dwdm_1552_52 = 94

    	im attr media 1000base dwdm 1552 52

    .. data:: im_attr_media_1000base_dwdm_1551_72 = 95

    	im attr media 1000base dwdm 1551 72

    .. data:: im_attr_media_1000base_dwdm_1550_92 = 96

    	im attr media 1000base dwdm 1550 92

    .. data:: im_attr_media_1000base_dwdm_1550_12 = 97

    	im attr media 1000base dwdm 1550 12

    .. data:: im_attr_media_1000base_dwdm_1549_32 = 98

    	im attr media 1000base dwdm 1549 32

    .. data:: im_attr_media_1000base_dwdm_1548_51 = 99

    	im attr media 1000base dwdm 1548 51

    .. data:: im_attr_media_1000base_dwdm_1547_72 = 100

    	im attr media 1000base dwdm 1547 72

    .. data:: im_attr_media_1000base_dwdm_1546_92 = 101

    	im attr media 1000base dwdm 1546 92

    .. data:: im_attr_media_1000base_dwdm_1546_12 = 102

    	im attr media 1000base dwdm 1546 12

    .. data:: im_attr_media_1000base_dwdm_1545_32 = 103

    	im attr media 1000base dwdm 1545 32

    .. data:: im_attr_media_1000base_dwdm_1544_53 = 104

    	im attr media 1000base dwdm 1544 53

    .. data:: im_attr_media_1000base_dwdm_1543_73 = 105

    	im attr media 1000base dwdm 1543 73

    .. data:: im_attr_media_1000base_dwdm_1542_94 = 106

    	im attr media 1000base dwdm 1542 94

    .. data:: im_attr_media_1000base_dwdm_1542_14 = 107

    	im attr media 1000base dwdm 1542 14

    .. data:: im_attr_media_1000base_dwdm_1541_35 = 108

    	im attr media 1000base dwdm 1541 35

    .. data:: im_attr_media_1000base_dwdm_1540_56 = 109

    	im attr media 1000base dwdm 1540 56

    .. data:: im_attr_media_1000base_dwdm_1539_77 = 110

    	im attr media 1000base dwdm 1539 77

    .. data:: im_attr_media_1000base_dwdm_1538_98 = 111

    	im attr media 1000base dwdm 1538 98

    .. data:: im_attr_media_1000base_dwdm_1538_19 = 112

    	im attr media 1000base dwdm 1538 19

    .. data:: im_attr_media_1000base_dwdm_1537_40 = 113

    	im attr media 1000base dwdm 1537 40

    .. data:: im_attr_media_1000base_dwdm_1536_61 = 114

    	im attr media 1000base dwdm 1536 61

    .. data:: im_attr_media_1000base_dwdm_1535_82 = 115

    	im attr media 1000base dwdm 1535 82

    .. data:: im_attr_media_1000base_dwdm_1535_04 = 116

    	im attr media 1000base dwdm 1535 04

    .. data:: im_attr_media_1000base_dwdm_1534_25 = 117

    	im attr media 1000base dwdm 1534 25

    .. data:: im_attr_media_1000base_dwdm_1533_47 = 118

    	im attr media 1000base dwdm 1533 47

    .. data:: im_attr_media_1000base_dwdm_1532_68 = 119

    	im attr media 1000base dwdm 1532 68

    .. data:: im_attr_media_1000base_dwdm_1531_90 = 120

    	im attr media 1000base dwdm 1531 90

    .. data:: im_attr_media_1000base_dwdm_1531_12 = 121

    	im attr media 1000base dwdm 1531 12

    .. data:: im_attr_media_1000base_dwdm_1530_33 = 122

    	im attr media 1000base dwdm 1530 33

    .. data:: im_attr_media_1000base_dwdm_tunable = 123

    	im attr media 1000base dwdm tunable

    .. data:: im_attr_media_10gbase_dwdm_1561_42 = 124

    	im attr media 10gbase dwdm 1561 42

    .. data:: im_attr_media_10gbase_dwdm_1560_61 = 125

    	im attr media 10gbase dwdm 1560 61

    .. data:: im_attr_media_10gbase_dwdm_1559_79 = 126

    	im attr media 10gbase dwdm 1559 79

    .. data:: im_attr_media_10gbase_dwdm_1558_98 = 127

    	im attr media 10gbase dwdm 1558 98

    .. data:: im_attr_media_10gbase_dwdm_1558_17 = 128

    	im attr media 10gbase dwdm 1558 17

    .. data:: im_attr_media_10gbase_dwdm_1557_36 = 129

    	im attr media 10gbase dwdm 1557 36

    .. data:: im_attr_media_10gbase_dwdm_1556_55 = 130

    	im attr media 10gbase dwdm 1556 55

    .. data:: im_attr_media_10gbase_dwdm_1555_75 = 131

    	im attr media 10gbase dwdm 1555 75

    .. data:: im_attr_media_10gbase_dwdm_1554_94 = 132

    	im attr media 10gbase dwdm 1554 94

    .. data:: im_attr_media_10gbase_dwdm_1554_13 = 133

    	im attr media 10gbase dwdm 1554 13

    .. data:: im_attr_media_10gbase_dwdm_1553_33 = 134

    	im attr media 10gbase dwdm 1553 33

    .. data:: im_attr_media_10gbase_dwdm_1552_52 = 135

    	im attr media 10gbase dwdm 1552 52

    .. data:: im_attr_media_10gbase_dwdm_1551_72 = 136

    	im attr media 10gbase dwdm 1551 72

    .. data:: im_attr_media_10gbase_dwdm_1550_92 = 137

    	im attr media 10gbase dwdm 1550 92

    .. data:: im_attr_media_10gbase_dwdm_1550_12 = 138

    	im attr media 10gbase dwdm 1550 12

    .. data:: im_attr_media_10gbase_dwdm_1549_32 = 139

    	im attr media 10gbase dwdm 1549 32

    .. data:: im_attr_media_10gbase_dwdm_1548_51 = 140

    	im attr media 10gbase dwdm 1548 51

    .. data:: im_attr_media_10gbase_dwdm_1547_72 = 141

    	im attr media 10gbase dwdm 1547 72

    .. data:: im_attr_media_10gbase_dwdm_1546_92 = 142

    	im attr media 10gbase dwdm 1546 92

    .. data:: im_attr_media_10gbase_dwdm_1546_12 = 143

    	im attr media 10gbase dwdm 1546 12

    .. data:: im_attr_media_10gbase_dwdm_1545_32 = 144

    	im attr media 10gbase dwdm 1545 32

    .. data:: im_attr_media_10gbase_dwdm_1544_53 = 145

    	im attr media 10gbase dwdm 1544 53

    .. data:: im_attr_media_10gbase_dwdm_1543_73 = 146

    	im attr media 10gbase dwdm 1543 73

    .. data:: im_attr_media_10gbase_dwdm_1542_94 = 147

    	im attr media 10gbase dwdm 1542 94

    .. data:: im_attr_media_10gbase_dwdm_1542_14 = 148

    	im attr media 10gbase dwdm 1542 14

    .. data:: im_attr_media_10gbase_dwdm_1541_35 = 149

    	im attr media 10gbase dwdm 1541 35

    .. data:: im_attr_media_10gbase_dwdm_1540_56 = 150

    	im attr media 10gbase dwdm 1540 56

    .. data:: im_attr_media_10gbase_dwdm_1539_77 = 151

    	im attr media 10gbase dwdm 1539 77

    .. data:: im_attr_media_10gbase_dwdm_1538_98 = 152

    	im attr media 10gbase dwdm 1538 98

    .. data:: im_attr_media_10gbase_dwdm_1538_19 = 153

    	im attr media 10gbase dwdm 1538 19

    .. data:: im_attr_media_10gbase_dwdm_1537_40 = 154

    	im attr media 10gbase dwdm 1537 40

    .. data:: im_attr_media_10gbase_dwdm_1536_61 = 155

    	im attr media 10gbase dwdm 1536 61

    .. data:: im_attr_media_10gbase_dwdm_1535_82 = 156

    	im attr media 10gbase dwdm 1535 82

    .. data:: im_attr_media_10gbase_dwdm_1535_04 = 157

    	im attr media 10gbase dwdm 1535 04

    .. data:: im_attr_media_10gbase_dwdm_1534_25 = 158

    	im attr media 10gbase dwdm 1534 25

    .. data:: im_attr_media_10gbase_dwdm_1533_47 = 159

    	im attr media 10gbase dwdm 1533 47

    .. data:: im_attr_media_10gbase_dwdm_1532_68 = 160

    	im attr media 10gbase dwdm 1532 68

    .. data:: im_attr_media_10gbase_dwdm_1531_90 = 161

    	im attr media 10gbase dwdm 1531 90

    .. data:: im_attr_media_10gbase_dwdm_1531_12 = 162

    	im attr media 10gbase dwdm 1531 12

    .. data:: im_attr_media_10gbase_dwdm_1530_33 = 163

    	im attr media 10gbase dwdm 1530 33

    .. data:: im_attr_media_10gbase_dwdm_tunable = 164

    	im attr media 10gbase dwdm tunable

    .. data:: im_attr_media_40gbase_dwdm_1561_42 = 165

    	im attr media 40gbase dwdm 1561 42

    .. data:: im_attr_media_40gbase_dwdm_1560_61 = 166

    	im attr media 40gbase dwdm 1560 61

    .. data:: im_attr_media_40gbase_dwdm_1559_79 = 167

    	im attr media 40gbase dwdm 1559 79

    .. data:: im_attr_media_40gbase_dwdm_1558_98 = 168

    	im attr media 40gbase dwdm 1558 98

    .. data:: im_attr_media_40gbase_dwdm_1558_17 = 169

    	im attr media 40gbase dwdm 1558 17

    .. data:: im_attr_media_40gbase_dwdm_1557_36 = 170

    	im attr media 40gbase dwdm 1557 36

    .. data:: im_attr_media_40gbase_dwdm_1556_55 = 171

    	im attr media 40gbase dwdm 1556 55

    .. data:: im_attr_media_40gbase_dwdm_1555_75 = 172

    	im attr media 40gbase dwdm 1555 75

    .. data:: im_attr_media_40gbase_dwdm_1554_94 = 173

    	im attr media 40gbase dwdm 1554 94

    .. data:: im_attr_media_40gbase_dwdm_1554_13 = 174

    	im attr media 40gbase dwdm 1554 13

    .. data:: im_attr_media_40gbase_dwdm_1553_33 = 175

    	im attr media 40gbase dwdm 1553 33

    .. data:: im_attr_media_40gbase_dwdm_1552_52 = 176

    	im attr media 40gbase dwdm 1552 52

    .. data:: im_attr_media_40gbase_dwdm_1551_72 = 177

    	im attr media 40gbase dwdm 1551 72

    .. data:: im_attr_media_40gbase_dwdm_1550_92 = 178

    	im attr media 40gbase dwdm 1550 92

    .. data:: im_attr_media_40gbase_dwdm_1550_12 = 179

    	im attr media 40gbase dwdm 1550 12

    .. data:: im_attr_media_40gbase_dwdm_1549_32 = 180

    	im attr media 40gbase dwdm 1549 32

    .. data:: im_attr_media_40gbase_dwdm_1548_51 = 181

    	im attr media 40gbase dwdm 1548 51

    .. data:: im_attr_media_40gbase_dwdm_1547_72 = 182

    	im attr media 40gbase dwdm 1547 72

    .. data:: im_attr_media_40gbase_dwdm_1546_92 = 183

    	im attr media 40gbase dwdm 1546 92

    .. data:: im_attr_media_40gbase_dwdm_1546_12 = 184

    	im attr media 40gbase dwdm 1546 12

    .. data:: im_attr_media_40gbase_dwdm_1545_32 = 185

    	im attr media 40gbase dwdm 1545 32

    .. data:: im_attr_media_40gbase_dwdm_1544_53 = 186

    	im attr media 40gbase dwdm 1544 53

    .. data:: im_attr_media_40gbase_dwdm_1543_73 = 187

    	im attr media 40gbase dwdm 1543 73

    .. data:: im_attr_media_40gbase_dwdm_1542_94 = 188

    	im attr media 40gbase dwdm 1542 94

    .. data:: im_attr_media_40gbase_dwdm_1542_14 = 189

    	im attr media 40gbase dwdm 1542 14

    .. data:: im_attr_media_40gbase_dwdm_1541_35 = 190

    	im attr media 40gbase dwdm 1541 35

    .. data:: im_attr_media_40gbase_dwdm_1540_56 = 191

    	im attr media 40gbase dwdm 1540 56

    .. data:: im_attr_media_40gbase_dwdm_1539_77 = 192

    	im attr media 40gbase dwdm 1539 77

    .. data:: im_attr_media_40gbase_dwdm_1538_98 = 193

    	im attr media 40gbase dwdm 1538 98

    .. data:: im_attr_media_40gbase_dwdm_1538_19 = 194

    	im attr media 40gbase dwdm 1538 19

    .. data:: im_attr_media_40gbase_dwdm_1537_40 = 195

    	im attr media 40gbase dwdm 1537 40

    .. data:: im_attr_media_40gbase_dwdm_1536_61 = 196

    	im attr media 40gbase dwdm 1536 61

    .. data:: im_attr_media_40gbase_dwdm_1535_82 = 197

    	im attr media 40gbase dwdm 1535 82

    .. data:: im_attr_media_40gbase_dwdm_1535_04 = 198

    	im attr media 40gbase dwdm 1535 04

    .. data:: im_attr_media_40gbase_dwdm_1534_25 = 199

    	im attr media 40gbase dwdm 1534 25

    .. data:: im_attr_media_40gbase_dwdm_1533_47 = 200

    	im attr media 40gbase dwdm 1533 47

    .. data:: im_attr_media_40gbase_dwdm_1532_68 = 201

    	im attr media 40gbase dwdm 1532 68

    .. data:: im_attr_media_40gbase_dwdm_1531_90 = 202

    	im attr media 40gbase dwdm 1531 90

    .. data:: im_attr_media_40gbase_dwdm_1531_12 = 203

    	im attr media 40gbase dwdm 1531 12

    .. data:: im_attr_media_40gbase_dwdm_1530_33 = 204

    	im attr media 40gbase dwdm 1530 33

    .. data:: im_attr_media_40gbase_dwdm_tunable = 205

    	im attr media 40gbase dwdm tunable

    .. data:: im_attr_media_100gbase_dwdm_1561_42 = 206

    	im attr media 100gbase dwdm 1561 42

    .. data:: im_attr_media_100gbase_dwdm_1560_61 = 207

    	im attr media 100gbase dwdm 1560 61

    .. data:: im_attr_media_100gbase_dwdm_1559_79 = 208

    	im attr media 100gbase dwdm 1559 79

    .. data:: im_attr_media_100gbase_dwdm_1558_98 = 209

    	im attr media 100gbase dwdm 1558 98

    .. data:: im_attr_media_100gbase_dwdm_1558_17 = 210

    	im attr media 100gbase dwdm 1558 17

    .. data:: im_attr_media_100gbase_dwdm_1557_36 = 211

    	im attr media 100gbase dwdm 1557 36

    .. data:: im_attr_media_100gbase_dwdm_1556_55 = 212

    	im attr media 100gbase dwdm 1556 55

    .. data:: im_attr_media_100gbase_dwdm_1555_75 = 213

    	im attr media 100gbase dwdm 1555 75

    .. data:: im_attr_media_100gbase_dwdm_1554_94 = 214

    	im attr media 100gbase dwdm 1554 94

    .. data:: im_attr_media_100gbase_dwdm_1554_13 = 215

    	im attr media 100gbase dwdm 1554 13

    .. data:: im_attr_media_100gbase_dwdm_1553_33 = 216

    	im attr media 100gbase dwdm 1553 33

    .. data:: im_attr_media_100gbase_dwdm_1552_52 = 217

    	im attr media 100gbase dwdm 1552 52

    .. data:: im_attr_media_100gbase_dwdm_1551_72 = 218

    	im attr media 100gbase dwdm 1551 72

    .. data:: im_attr_media_100gbase_dwdm_1550_92 = 219

    	im attr media 100gbase dwdm 1550 92

    .. data:: im_attr_media_100gbase_dwdm_1550_12 = 220

    	im attr media 100gbase dwdm 1550 12

    .. data:: im_attr_media_100gbase_dwdm_1549_32 = 221

    	im attr media 100gbase dwdm 1549 32

    .. data:: im_attr_media_100gbase_dwdm_1548_51 = 222

    	im attr media 100gbase dwdm 1548 51

    .. data:: im_attr_media_100gbase_dwdm_1547_72 = 223

    	im attr media 100gbase dwdm 1547 72

    .. data:: im_attr_media_100gbase_dwdm_1546_92 = 224

    	im attr media 100gbase dwdm 1546 92

    .. data:: im_attr_media_100gbase_dwdm_1546_12 = 225

    	im attr media 100gbase dwdm 1546 12

    .. data:: im_attr_media_100gbase_dwdm_1545_32 = 226

    	im attr media 100gbase dwdm 1545 32

    .. data:: im_attr_media_100gbase_dwdm_1544_53 = 227

    	im attr media 100gbase dwdm 1544 53

    .. data:: im_attr_media_100gbase_dwdm_1543_73 = 228

    	im attr media 100gbase dwdm 1543 73

    .. data:: im_attr_media_100gbase_dwdm_1542_94 = 229

    	im attr media 100gbase dwdm 1542 94

    .. data:: im_attr_media_100gbase_dwdm_1542_14 = 230

    	im attr media 100gbase dwdm 1542 14

    .. data:: im_attr_media_100gbase_dwdm_1541_35 = 231

    	im attr media 100gbase dwdm 1541 35

    .. data:: im_attr_media_100gbase_dwdm_1540_56 = 232

    	im attr media 100gbase dwdm 1540 56

    .. data:: im_attr_media_100gbase_dwdm_1539_77 = 233

    	im attr media 100gbase dwdm 1539 77

    .. data:: im_attr_media_100gbase_dwdm_1538_98 = 234

    	im attr media 100gbase dwdm 1538 98

    .. data:: im_attr_media_100gbase_dwdm_1538_19 = 235

    	im attr media 100gbase dwdm 1538 19

    .. data:: im_attr_media_100gbase_dwdm_1537_40 = 236

    	im attr media 100gbase dwdm 1537 40

    .. data:: im_attr_media_100gbase_dwdm_1536_61 = 237

    	im attr media 100gbase dwdm 1536 61

    .. data:: im_attr_media_100gbase_dwdm_1535_82 = 238

    	im attr media 100gbase dwdm 1535 82

    .. data:: im_attr_media_100gbase_dwdm_1535_04 = 239

    	im attr media 100gbase dwdm 1535 04

    .. data:: im_attr_media_100gbase_dwdm_1534_25 = 240

    	im attr media 100gbase dwdm 1534 25

    .. data:: im_attr_media_100gbase_dwdm_1533_47 = 241

    	im attr media 100gbase dwdm 1533 47

    .. data:: im_attr_media_100gbase_dwdm_1532_68 = 242

    	im attr media 100gbase dwdm 1532 68

    .. data:: im_attr_media_100gbase_dwdm_1531_90 = 243

    	im attr media 100gbase dwdm 1531 90

    .. data:: im_attr_media_100gbase_dwdm_1531_12 = 244

    	im attr media 100gbase dwdm 1531 12

    .. data:: im_attr_media_100gbase_dwdm_1530_33 = 245

    	im attr media 100gbase dwdm 1530 33

    .. data:: im_attr_media_100gbase_dwdm_tunable = 246

    	im attr media 100gbase dwdm tunable

    .. data:: im_attr_media_40gbase_kr4 = 247

    	im attr media 40gbase kr4

    .. data:: im_attr_media_40gbase_cr4 = 248

    	im attr media 40gbase cr4

    .. data:: im_attr_media_40gbase_sr4 = 249

    	im attr media 40gbase sr4

    .. data:: im_attr_media_40gbase_fr = 250

    	im attr media 40gbase fr

    .. data:: im_attr_media_100gbase_cr10 = 251

    	im attr media 100gbase cr10

    .. data:: im_attr_media_100gbase_sr10 = 252

    	im attr media 100gbase sr10

    .. data:: im_attr_media_40gbase_csr4 = 253

    	im attr media 40gbase csr4

    .. data:: im_attr_media_10gbase_cwdm = 254

    	im attr media 10gbase cwdm

    .. data:: im_attr_media_10gbase_cwdm_tunable = 255

    	im attr media 10gbase cwdm tunable

    .. data:: im_attr_media_10gbase_cwdm_1470 = 256

    	im attr media 10gbase cwdm 1470

    .. data:: im_attr_media_10gbase_cwdm_1490 = 257

    	im attr media 10gbase cwdm 1490

    .. data:: im_attr_media_10gbase_cwdm_1510 = 258

    	im attr media 10gbase cwdm 1510

    .. data:: im_attr_media_10gbase_cwdm_1530 = 259

    	im attr media 10gbase cwdm 1530

    .. data:: im_attr_media_10gbase_cwdm_1550 = 260

    	im attr media 10gbase cwdm 1550

    .. data:: im_attr_media_10gbase_cwdm_1570 = 261

    	im attr media 10gbase cwdm 1570

    .. data:: im_attr_media_10gbase_cwdm_1590 = 262

    	im attr media 10gbase cwdm 1590

    .. data:: im_attr_media_10gbase_cwdm_1610 = 263

    	im attr media 10gbase cwdm 1610

    .. data:: im_attr_media_40gbase_cwdm = 264

    	im attr media 40gbase cwdm

    .. data:: im_attr_media_40gbase_cwdm_tunable = 265

    	im attr media 40gbase cwdm tunable

    .. data:: im_attr_media_40gbase_cwdm_1470 = 266

    	im attr media 40gbase cwdm 1470

    .. data:: im_attr_media_40gbase_cwdm_1490 = 267

    	im attr media 40gbase cwdm 1490

    .. data:: im_attr_media_40gbase_cwdm_1510 = 268

    	im attr media 40gbase cwdm 1510

    .. data:: im_attr_media_40gbase_cwdm_1530 = 269

    	im attr media 40gbase cwdm 1530

    .. data:: im_attr_media_40gbase_cwdm_1550 = 270

    	im attr media 40gbase cwdm 1550

    .. data:: im_attr_media_40gbase_cwdm_1570 = 271

    	im attr media 40gbase cwdm 1570

    .. data:: im_attr_media_40gbase_cwdm_1590 = 272

    	im attr media 40gbase cwdm 1590

    .. data:: im_attr_media_40gbase_cwdm_1610 = 273

    	im attr media 40gbase cwdm 1610

    .. data:: im_attr_media_100gbase_cwdm = 274

    	im attr media 100gbase cwdm

    .. data:: im_attr_media_100gbase_cwdm_tunable = 275

    	im attr media 100gbase cwdm tunable

    .. data:: im_attr_media_100gbase_cwdm_1470 = 276

    	im attr media 100gbase cwdm 1470

    .. data:: im_attr_media_100gbase_cwdm_1490 = 277

    	im attr media 100gbase cwdm 1490

    .. data:: im_attr_media_100gbase_cwdm_1510 = 278

    	im attr media 100gbase cwdm 1510

    .. data:: im_attr_media_100gbase_cwdm_1530 = 279

    	im attr media 100gbase cwdm 1530

    .. data:: im_attr_media_100gbase_cwdm_1550 = 280

    	im attr media 100gbase cwdm 1550

    .. data:: im_attr_media_100gbase_cwdm_1570 = 281

    	im attr media 100gbase cwdm 1570

    .. data:: im_attr_media_100gbase_cwdm_1590 = 282

    	im attr media 100gbase cwdm 1590

    .. data:: im_attr_media_100gbase_cwdm_1610 = 283

    	im attr media 100gbase cwdm 1610

    .. data:: im_attr_media_40gbase_elpb = 284

    	im attr media 40gbase elpb

    .. data:: im_attr_media_100gbase_elpb = 285

    	im attr media 100gbase elpb

    .. data:: im_attr_media_100gbase_lr10 = 286

    	im attr media 100gbase lr10

    .. data:: im_attr_media_40gbase = 287

    	im attr media 40gbase

    .. data:: im_attr_media_100gbase_kp4 = 288

    	im attr media 100gbase kp4

    .. data:: im_attr_media_100gbase_kr4 = 289

    	im attr media 100gbase kr4

    .. data:: im_attr_media_10gbase_lrm = 290

    	im attr media 10gbase lrm

    .. data:: im_attr_media_10gbase_cx4 = 291

    	im attr media 10gbase cx4

    .. data:: im_attr_media_10gbase = 292

    	im attr media 10gbase

    .. data:: im_attr_media_10gbase_kx4 = 293

    	im attr media 10gbase kx4

    .. data:: im_attr_media_10gbase_kr = 294

    	im attr media 10gbase kr

    .. data:: im_attr_media_10gbase_pr = 295

    	im attr media 10gbase pr

    .. data:: im_attr_media_100base_lx = 296

    	im attr media 100base lx

    .. data:: im_attr_media_100base_zx = 297

    	im attr media 100base zx

    .. data:: im_attr_media_1000base_bx_d = 298

    	im attr media 1000base bx d

    .. data:: im_attr_media_1000base_bx_u = 299

    	im attr media 1000base bx u

    .. data:: im_attr_media_1000base_bx20_d = 300

    	im attr media 1000base bx20 d

    .. data:: im_attr_media_1000base_bx20_u = 301

    	im attr media 1000base bx20 u

    .. data:: im_attr_media_1000base_bx40_d = 302

    	im attr media 1000base bx40 d

    .. data:: im_attr_media_1000base_bx40_da = 303

    	im attr media 1000base bx40 da

    .. data:: im_attr_media_1000base_bx40_u = 304

    	im attr media 1000base bx40 u

    .. data:: im_attr_media_1000base_bx80_d = 305

    	im attr media 1000base bx80 d

    .. data:: im_attr_media_1000base_bx80_u = 306

    	im attr media 1000base bx80 u

    .. data:: im_attr_media_1000base_bx120_d = 307

    	im attr media 1000base bx120 d

    .. data:: im_attr_media_1000base_bx120_u = 308

    	im attr media 1000base bx120 u

    .. data:: im_attr_media_10gbase_bx_d = 309

    	im attr media 10gbase bx d

    .. data:: im_attr_media_10gbase_bx_u = 310

    	im attr media 10gbase bx u

    .. data:: im_attr_media_10gbase_bx10_d = 311

    	im attr media 10gbase bx10 d

    .. data:: im_attr_media_10gbase_bx10_u = 312

    	im attr media 10gbase bx10 u

    .. data:: im_attr_media_10gbase_bx20_d = 313

    	im attr media 10gbase bx20 d

    .. data:: im_attr_media_10gbase_bx20_u = 314

    	im attr media 10gbase bx20 u

    .. data:: im_attr_media_10gbase_bx40_d = 315

    	im attr media 10gbase bx40 d

    .. data:: im_attr_media_10gbase_bx40_u = 316

    	im attr media 10gbase bx40 u

    .. data:: im_attr_media_10gbase_bx80_d = 317

    	im attr media 10gbase bx80 d

    .. data:: im_attr_media_10gbase_bx80_u = 318

    	im attr media 10gbase bx80 u

    .. data:: im_attr_media_10gbase_bx120_d = 319

    	im attr media 10gbase bx120 d

    .. data:: im_attr_media_10gbase_bx120_u = 320

    	im attr media 10gbase bx120 u

    .. data:: im_attr_media_1000base_dr_lx = 321

    	im attr media 1000base dr lx

    .. data:: im_attr_media_100gbase_er4l = 322

    	im attr media 100gbase er4l

    .. data:: im_attr_media_100gbase_sr4 = 323

    	im attr media 100gbase sr4

    .. data:: im_attr_media_40gbase_sr_bd = 324

    	im attr media 40gbase sr bd

    .. data:: im_attr_media_25gbase_cr = 325

    	im attr media 25gbase cr

    .. data:: im_attr_media_25gbase_cr_s = 326

    	im attr media 25gbase cr s

    .. data:: im_attr_media_25gbase_kr = 327

    	im attr media 25gbase kr

    .. data:: im_attr_media_25gbase_kr_s = 328

    	im attr media 25gbase kr s

    .. data:: im_attr_media_25gbase_r = 329

    	im attr media 25gbase r

    .. data:: im_attr_media_25gbase_sr = 330

    	im attr media 25gbase sr

    .. data:: im_attr_media_25gbase_dwdm = 331

    	im attr media 25gbase dwdm

    .. data:: im_attr_media_25gbase_dwdm_tunable = 332

    	im attr media 25gbase dwdm tunable

    .. data:: im_attr_media_25gbase_cwdm = 333

    	im attr media 25gbase cwdm

    .. data:: im_attr_media_25gbase_cwdm_tunable = 334

    	im attr media 25gbase cwdm tunable

    .. data:: im_attr_media_100gbase_psm4 = 335

    	im attr media 100gbase psm4

    .. data:: im_attr_media_100gbase_er10 = 336

    	im attr media 100gbase er10

    .. data:: im_attr_media_100gbase_er10l = 337

    	im attr media 100gbase er10l

    .. data:: im_attr_media_100gbase_acc = 338

    	im attr media 100gbase acc

    .. data:: im_attr_media_100gbase_aoc = 339

    	im attr media 100gbase aoc

    .. data:: im_attr_media_100gbase_cwdm4 = 340

    	im attr media 100gbase cwdm4

    .. data:: im_attr_media_40gbase_psm4 = 341

    	im attr media 40gbase psm4

    .. data:: im_attr_media_100gbase_cr4 = 342

    	im attr media 100gbase cr4

    .. data:: im_attr_media_100gbase_act_loop = 343

    	im attr media 100gbase act loop

    .. data:: im_attr_media_100gbase_pas_loop = 344

    	im attr media 100gbase pas loop

    """

    im_attr_media_other = Enum.YLeaf(0, "im-attr-media-other")

    im_attr_media_unknown = Enum.YLeaf(1, "im-attr-media-unknown")

    im_attr_media_aui = Enum.YLeaf(2, "im-attr-media-aui")

    im_attr_media_10base5 = Enum.YLeaf(3, "im-attr-media-10base5")

    im_attr_media_foirl = Enum.YLeaf(4, "im-attr-media-foirl")

    im_attr_media_10base2 = Enum.YLeaf(5, "im-attr-media-10base2")

    im_attr_media_10broad36 = Enum.YLeaf(6, "im-attr-media-10broad36")

    im_attr_media_10base = Enum.YLeaf(7, "im-attr-media-10base")

    im_attr_media_10base_thd = Enum.YLeaf(8, "im-attr-media-10base-thd")

    im_attr_media_10base_tfd = Enum.YLeaf(9, "im-attr-media-10base-tfd")

    im_attr_media_10base_fp = Enum.YLeaf(10, "im-attr-media-10base-fp")

    im_attr_media_10base_fb = Enum.YLeaf(11, "im-attr-media-10base-fb")

    im_attr_media_10base_fl = Enum.YLeaf(12, "im-attr-media-10base-fl")

    im_attr_media_10base_flhd = Enum.YLeaf(13, "im-attr-media-10base-flhd")

    im_attr_media_10base_flfd = Enum.YLeaf(14, "im-attr-media-10base-flfd")

    im_attr_media_100base_t4 = Enum.YLeaf(15, "im-attr-media-100base-t4")

    im_attr_media_100base_tx = Enum.YLeaf(16, "im-attr-media-100base-tx")

    im_attr_media_100base_txhd = Enum.YLeaf(17, "im-attr-media-100base-txhd")

    im_attr_media_100base_txfd = Enum.YLeaf(18, "im-attr-media-100base-txfd")

    im_attr_media_100base_fx = Enum.YLeaf(19, "im-attr-media-100base-fx")

    im_attr_media_100base_fxhd = Enum.YLeaf(20, "im-attr-media-100base-fxhd")

    im_attr_media_100base_fxfd = Enum.YLeaf(21, "im-attr-media-100base-fxfd")

    im_attr_media_100base_ex = Enum.YLeaf(22, "im-attr-media-100base-ex")

    im_attr_media_100base_exhd = Enum.YLeaf(23, "im-attr-media-100base-exhd")

    im_attr_media_100base_exfd = Enum.YLeaf(24, "im-attr-media-100base-exfd")

    im_attr_media_100base_t2 = Enum.YLeaf(25, "im-attr-media-100base-t2")

    im_attr_media_100base_t2hd = Enum.YLeaf(26, "im-attr-media-100base-t2hd")

    im_attr_media_100base_t2fd = Enum.YLeaf(27, "im-attr-media-100base-t2fd")

    im_attr_media_1000base_x = Enum.YLeaf(28, "im-attr-media-1000base-x")

    im_attr_media_1000base_xhdx = Enum.YLeaf(29, "im-attr-media-1000base-xhdx")

    im_attr_media_1000base_xfd = Enum.YLeaf(30, "im-attr-media-1000base-xfd")

    im_attr_media_1000base_lx = Enum.YLeaf(31, "im-attr-media-1000base-lx")

    im_attr_media_1000base_lxhd = Enum.YLeaf(32, "im-attr-media-1000base-lxhd")

    im_attr_media_1000base_lxfdx = Enum.YLeaf(33, "im-attr-media-1000base-lxfdx")

    im_attr_media_1000base_sx = Enum.YLeaf(34, "im-attr-media-1000base-sx")

    im_attr_media_1000base_sxhd = Enum.YLeaf(35, "im-attr-media-1000base-sxhd")

    im_attr_media_1000base_sxfd = Enum.YLeaf(36, "im-attr-media-1000base-sxfd")

    im_attr_media_1000base_cx = Enum.YLeaf(37, "im-attr-media-1000base-cx")

    im_attr_media_1000base_cxhdx = Enum.YLeaf(38, "im-attr-media-1000base-cxhdx")

    im_attr_media_1000base_cxfd = Enum.YLeaf(39, "im-attr-media-1000base-cxfd")

    im_attr_media_1000base = Enum.YLeaf(40, "im-attr-media-1000base")

    im_attr_media_1000base_thd = Enum.YLeaf(41, "im-attr-media-1000base-thd")

    im_attr_media_1000base_tfd = Enum.YLeaf(42, "im-attr-media-1000base-tfd")

    im_attr_media_10gbase_x = Enum.YLeaf(43, "im-attr-media-10gbase-x")

    im_attr_media_10gbase_lx4 = Enum.YLeaf(44, "im-attr-media-10gbase-lx4")

    im_attr_media_10gbase_r = Enum.YLeaf(45, "im-attr-media-10gbase-r")

    im_attr_media_10gbase_er = Enum.YLeaf(46, "im-attr-media-10gbase-er")

    im_attr_media_10gbase_lr = Enum.YLeaf(47, "im-attr-media-10gbase-lr")

    im_attr_media_10gbase_sr = Enum.YLeaf(48, "im-attr-media-10gbase-sr")

    im_attr_media_10gbase_w = Enum.YLeaf(49, "im-attr-media-10gbase-w")

    im_attr_media_10gbase_ew = Enum.YLeaf(50, "im-attr-media-10gbase-ew")

    im_attr_media_10gbase_lw = Enum.YLeaf(51, "im-attr-media-10gbase-lw")

    im_attr_media_10gbase_sw = Enum.YLeaf(52, "im-attr-media-10gbase-sw")

    im_attr_media_10gbase_zr = Enum.YLeaf(53, "im-attr-media-10gbase-zr")

    im_attr_media_802_9a = Enum.YLeaf(54, "im-attr-media-802-9a")

    im_attr_media_rj45 = Enum.YLeaf(55, "im-attr-media-rj45")

    im_attr_media_1000base_zx = Enum.YLeaf(56, "im-attr-media-1000base-zx")

    im_attr_media_1000base_cwdm = Enum.YLeaf(57, "im-attr-media-1000base-cwdm")

    im_attr_media_1000base_cwdm_1470 = Enum.YLeaf(58, "im-attr-media-1000base-cwdm-1470")

    im_attr_media_1000base_cwdm_1490 = Enum.YLeaf(59, "im-attr-media-1000base-cwdm-1490")

    im_attr_media_1000base_cwdm_1510 = Enum.YLeaf(60, "im-attr-media-1000base-cwdm-1510")

    im_attr_media_1000base_cwdm_1530 = Enum.YLeaf(61, "im-attr-media-1000base-cwdm-1530")

    im_attr_media_1000base_cwdm_1550 = Enum.YLeaf(62, "im-attr-media-1000base-cwdm-1550")

    im_attr_media_1000base_cwdm_1570 = Enum.YLeaf(63, "im-attr-media-1000base-cwdm-1570")

    im_attr_media_1000base_cwdm_1590 = Enum.YLeaf(64, "im-attr-media-1000base-cwdm-1590")

    im_attr_media_1000base_cwdm_1610 = Enum.YLeaf(65, "im-attr-media-1000base-cwdm-1610")

    im_attr_media_10gbase_dwdm = Enum.YLeaf(66, "im-attr-media-10gbase-dwdm")

    im_attr_media_100gbase_lr4 = Enum.YLeaf(67, "im-attr-media-100gbase-lr4")

    im_attr_media_1000base_dwdm = Enum.YLeaf(68, "im-attr-media-1000base-dwdm")

    im_attr_media_1000base_dwdm_1533 = Enum.YLeaf(69, "im-attr-media-1000base-dwdm-1533")

    im_attr_media_1000base_dwdm_1537 = Enum.YLeaf(70, "im-attr-media-1000base-dwdm-1537")

    im_attr_media_1000base_dwdm_1541 = Enum.YLeaf(71, "im-attr-media-1000base-dwdm-1541")

    im_attr_media_1000base_dwdm_1545 = Enum.YLeaf(72, "im-attr-media-1000base-dwdm-1545")

    im_attr_media_1000base_dwdm_1549 = Enum.YLeaf(73, "im-attr-media-1000base-dwdm-1549")

    im_attr_media_1000base_dwdm_1553 = Enum.YLeaf(74, "im-attr-media-1000base-dwdm-1553")

    im_attr_media_1000base_dwdm_1557 = Enum.YLeaf(75, "im-attr-media-1000base-dwdm-1557")

    im_attr_media_1000base_dwdm_1561 = Enum.YLeaf(76, "im-attr-media-1000base-dwdm-1561")

    im_attr_media_40gbase_lr4 = Enum.YLeaf(77, "im-attr-media-40gbase-lr4")

    im_attr_media_40gbase_er4 = Enum.YLeaf(78, "im-attr-media-40gbase-er4")

    im_attr_media_100gbase_er4 = Enum.YLeaf(79, "im-attr-media-100gbase-er4")

    im_attr_media_1000base_ex = Enum.YLeaf(80, "im-attr-media-1000base-ex")

    im_attr_media_1000base_bx10_d = Enum.YLeaf(81, "im-attr-media-1000base-bx10-d")

    im_attr_media_1000base_bx10_u = Enum.YLeaf(82, "im-attr-media-1000base-bx10-u")

    im_attr_media_1000base_dwdm_1561_42 = Enum.YLeaf(83, "im-attr-media-1000base-dwdm-1561-42")

    im_attr_media_1000base_dwdm_1560_61 = Enum.YLeaf(84, "im-attr-media-1000base-dwdm-1560-61")

    im_attr_media_1000base_dwdm_1559_79 = Enum.YLeaf(85, "im-attr-media-1000base-dwdm-1559-79")

    im_attr_media_1000base_dwdm_1558_98 = Enum.YLeaf(86, "im-attr-media-1000base-dwdm-1558-98")

    im_attr_media_1000base_dwdm_1558_17 = Enum.YLeaf(87, "im-attr-media-1000base-dwdm-1558-17")

    im_attr_media_1000base_dwdm_1557_36 = Enum.YLeaf(88, "im-attr-media-1000base-dwdm-1557-36")

    im_attr_media_1000base_dwdm_1556_55 = Enum.YLeaf(89, "im-attr-media-1000base-dwdm-1556-55")

    im_attr_media_1000base_dwdm_1555_75 = Enum.YLeaf(90, "im-attr-media-1000base-dwdm-1555-75")

    im_attr_media_1000base_dwdm_1554_94 = Enum.YLeaf(91, "im-attr-media-1000base-dwdm-1554-94")

    im_attr_media_1000base_dwdm_1554_13 = Enum.YLeaf(92, "im-attr-media-1000base-dwdm-1554-13")

    im_attr_media_1000base_dwdm_1553_33 = Enum.YLeaf(93, "im-attr-media-1000base-dwdm-1553-33")

    im_attr_media_1000base_dwdm_1552_52 = Enum.YLeaf(94, "im-attr-media-1000base-dwdm-1552-52")

    im_attr_media_1000base_dwdm_1551_72 = Enum.YLeaf(95, "im-attr-media-1000base-dwdm-1551-72")

    im_attr_media_1000base_dwdm_1550_92 = Enum.YLeaf(96, "im-attr-media-1000base-dwdm-1550-92")

    im_attr_media_1000base_dwdm_1550_12 = Enum.YLeaf(97, "im-attr-media-1000base-dwdm-1550-12")

    im_attr_media_1000base_dwdm_1549_32 = Enum.YLeaf(98, "im-attr-media-1000base-dwdm-1549-32")

    im_attr_media_1000base_dwdm_1548_51 = Enum.YLeaf(99, "im-attr-media-1000base-dwdm-1548-51")

    im_attr_media_1000base_dwdm_1547_72 = Enum.YLeaf(100, "im-attr-media-1000base-dwdm-1547-72")

    im_attr_media_1000base_dwdm_1546_92 = Enum.YLeaf(101, "im-attr-media-1000base-dwdm-1546-92")

    im_attr_media_1000base_dwdm_1546_12 = Enum.YLeaf(102, "im-attr-media-1000base-dwdm-1546-12")

    im_attr_media_1000base_dwdm_1545_32 = Enum.YLeaf(103, "im-attr-media-1000base-dwdm-1545-32")

    im_attr_media_1000base_dwdm_1544_53 = Enum.YLeaf(104, "im-attr-media-1000base-dwdm-1544-53")

    im_attr_media_1000base_dwdm_1543_73 = Enum.YLeaf(105, "im-attr-media-1000base-dwdm-1543-73")

    im_attr_media_1000base_dwdm_1542_94 = Enum.YLeaf(106, "im-attr-media-1000base-dwdm-1542-94")

    im_attr_media_1000base_dwdm_1542_14 = Enum.YLeaf(107, "im-attr-media-1000base-dwdm-1542-14")

    im_attr_media_1000base_dwdm_1541_35 = Enum.YLeaf(108, "im-attr-media-1000base-dwdm-1541-35")

    im_attr_media_1000base_dwdm_1540_56 = Enum.YLeaf(109, "im-attr-media-1000base-dwdm-1540-56")

    im_attr_media_1000base_dwdm_1539_77 = Enum.YLeaf(110, "im-attr-media-1000base-dwdm-1539-77")

    im_attr_media_1000base_dwdm_1538_98 = Enum.YLeaf(111, "im-attr-media-1000base-dwdm-1538-98")

    im_attr_media_1000base_dwdm_1538_19 = Enum.YLeaf(112, "im-attr-media-1000base-dwdm-1538-19")

    im_attr_media_1000base_dwdm_1537_40 = Enum.YLeaf(113, "im-attr-media-1000base-dwdm-1537-40")

    im_attr_media_1000base_dwdm_1536_61 = Enum.YLeaf(114, "im-attr-media-1000base-dwdm-1536-61")

    im_attr_media_1000base_dwdm_1535_82 = Enum.YLeaf(115, "im-attr-media-1000base-dwdm-1535-82")

    im_attr_media_1000base_dwdm_1535_04 = Enum.YLeaf(116, "im-attr-media-1000base-dwdm-1535-04")

    im_attr_media_1000base_dwdm_1534_25 = Enum.YLeaf(117, "im-attr-media-1000base-dwdm-1534-25")

    im_attr_media_1000base_dwdm_1533_47 = Enum.YLeaf(118, "im-attr-media-1000base-dwdm-1533-47")

    im_attr_media_1000base_dwdm_1532_68 = Enum.YLeaf(119, "im-attr-media-1000base-dwdm-1532-68")

    im_attr_media_1000base_dwdm_1531_90 = Enum.YLeaf(120, "im-attr-media-1000base-dwdm-1531-90")

    im_attr_media_1000base_dwdm_1531_12 = Enum.YLeaf(121, "im-attr-media-1000base-dwdm-1531-12")

    im_attr_media_1000base_dwdm_1530_33 = Enum.YLeaf(122, "im-attr-media-1000base-dwdm-1530-33")

    im_attr_media_1000base_dwdm_tunable = Enum.YLeaf(123, "im-attr-media-1000base-dwdm-tunable")

    im_attr_media_10gbase_dwdm_1561_42 = Enum.YLeaf(124, "im-attr-media-10gbase-dwdm-1561-42")

    im_attr_media_10gbase_dwdm_1560_61 = Enum.YLeaf(125, "im-attr-media-10gbase-dwdm-1560-61")

    im_attr_media_10gbase_dwdm_1559_79 = Enum.YLeaf(126, "im-attr-media-10gbase-dwdm-1559-79")

    im_attr_media_10gbase_dwdm_1558_98 = Enum.YLeaf(127, "im-attr-media-10gbase-dwdm-1558-98")

    im_attr_media_10gbase_dwdm_1558_17 = Enum.YLeaf(128, "im-attr-media-10gbase-dwdm-1558-17")

    im_attr_media_10gbase_dwdm_1557_36 = Enum.YLeaf(129, "im-attr-media-10gbase-dwdm-1557-36")

    im_attr_media_10gbase_dwdm_1556_55 = Enum.YLeaf(130, "im-attr-media-10gbase-dwdm-1556-55")

    im_attr_media_10gbase_dwdm_1555_75 = Enum.YLeaf(131, "im-attr-media-10gbase-dwdm-1555-75")

    im_attr_media_10gbase_dwdm_1554_94 = Enum.YLeaf(132, "im-attr-media-10gbase-dwdm-1554-94")

    im_attr_media_10gbase_dwdm_1554_13 = Enum.YLeaf(133, "im-attr-media-10gbase-dwdm-1554-13")

    im_attr_media_10gbase_dwdm_1553_33 = Enum.YLeaf(134, "im-attr-media-10gbase-dwdm-1553-33")

    im_attr_media_10gbase_dwdm_1552_52 = Enum.YLeaf(135, "im-attr-media-10gbase-dwdm-1552-52")

    im_attr_media_10gbase_dwdm_1551_72 = Enum.YLeaf(136, "im-attr-media-10gbase-dwdm-1551-72")

    im_attr_media_10gbase_dwdm_1550_92 = Enum.YLeaf(137, "im-attr-media-10gbase-dwdm-1550-92")

    im_attr_media_10gbase_dwdm_1550_12 = Enum.YLeaf(138, "im-attr-media-10gbase-dwdm-1550-12")

    im_attr_media_10gbase_dwdm_1549_32 = Enum.YLeaf(139, "im-attr-media-10gbase-dwdm-1549-32")

    im_attr_media_10gbase_dwdm_1548_51 = Enum.YLeaf(140, "im-attr-media-10gbase-dwdm-1548-51")

    im_attr_media_10gbase_dwdm_1547_72 = Enum.YLeaf(141, "im-attr-media-10gbase-dwdm-1547-72")

    im_attr_media_10gbase_dwdm_1546_92 = Enum.YLeaf(142, "im-attr-media-10gbase-dwdm-1546-92")

    im_attr_media_10gbase_dwdm_1546_12 = Enum.YLeaf(143, "im-attr-media-10gbase-dwdm-1546-12")

    im_attr_media_10gbase_dwdm_1545_32 = Enum.YLeaf(144, "im-attr-media-10gbase-dwdm-1545-32")

    im_attr_media_10gbase_dwdm_1544_53 = Enum.YLeaf(145, "im-attr-media-10gbase-dwdm-1544-53")

    im_attr_media_10gbase_dwdm_1543_73 = Enum.YLeaf(146, "im-attr-media-10gbase-dwdm-1543-73")

    im_attr_media_10gbase_dwdm_1542_94 = Enum.YLeaf(147, "im-attr-media-10gbase-dwdm-1542-94")

    im_attr_media_10gbase_dwdm_1542_14 = Enum.YLeaf(148, "im-attr-media-10gbase-dwdm-1542-14")

    im_attr_media_10gbase_dwdm_1541_35 = Enum.YLeaf(149, "im-attr-media-10gbase-dwdm-1541-35")

    im_attr_media_10gbase_dwdm_1540_56 = Enum.YLeaf(150, "im-attr-media-10gbase-dwdm-1540-56")

    im_attr_media_10gbase_dwdm_1539_77 = Enum.YLeaf(151, "im-attr-media-10gbase-dwdm-1539-77")

    im_attr_media_10gbase_dwdm_1538_98 = Enum.YLeaf(152, "im-attr-media-10gbase-dwdm-1538-98")

    im_attr_media_10gbase_dwdm_1538_19 = Enum.YLeaf(153, "im-attr-media-10gbase-dwdm-1538-19")

    im_attr_media_10gbase_dwdm_1537_40 = Enum.YLeaf(154, "im-attr-media-10gbase-dwdm-1537-40")

    im_attr_media_10gbase_dwdm_1536_61 = Enum.YLeaf(155, "im-attr-media-10gbase-dwdm-1536-61")

    im_attr_media_10gbase_dwdm_1535_82 = Enum.YLeaf(156, "im-attr-media-10gbase-dwdm-1535-82")

    im_attr_media_10gbase_dwdm_1535_04 = Enum.YLeaf(157, "im-attr-media-10gbase-dwdm-1535-04")

    im_attr_media_10gbase_dwdm_1534_25 = Enum.YLeaf(158, "im-attr-media-10gbase-dwdm-1534-25")

    im_attr_media_10gbase_dwdm_1533_47 = Enum.YLeaf(159, "im-attr-media-10gbase-dwdm-1533-47")

    im_attr_media_10gbase_dwdm_1532_68 = Enum.YLeaf(160, "im-attr-media-10gbase-dwdm-1532-68")

    im_attr_media_10gbase_dwdm_1531_90 = Enum.YLeaf(161, "im-attr-media-10gbase-dwdm-1531-90")

    im_attr_media_10gbase_dwdm_1531_12 = Enum.YLeaf(162, "im-attr-media-10gbase-dwdm-1531-12")

    im_attr_media_10gbase_dwdm_1530_33 = Enum.YLeaf(163, "im-attr-media-10gbase-dwdm-1530-33")

    im_attr_media_10gbase_dwdm_tunable = Enum.YLeaf(164, "im-attr-media-10gbase-dwdm-tunable")

    im_attr_media_40gbase_dwdm_1561_42 = Enum.YLeaf(165, "im-attr-media-40gbase-dwdm-1561-42")

    im_attr_media_40gbase_dwdm_1560_61 = Enum.YLeaf(166, "im-attr-media-40gbase-dwdm-1560-61")

    im_attr_media_40gbase_dwdm_1559_79 = Enum.YLeaf(167, "im-attr-media-40gbase-dwdm-1559-79")

    im_attr_media_40gbase_dwdm_1558_98 = Enum.YLeaf(168, "im-attr-media-40gbase-dwdm-1558-98")

    im_attr_media_40gbase_dwdm_1558_17 = Enum.YLeaf(169, "im-attr-media-40gbase-dwdm-1558-17")

    im_attr_media_40gbase_dwdm_1557_36 = Enum.YLeaf(170, "im-attr-media-40gbase-dwdm-1557-36")

    im_attr_media_40gbase_dwdm_1556_55 = Enum.YLeaf(171, "im-attr-media-40gbase-dwdm-1556-55")

    im_attr_media_40gbase_dwdm_1555_75 = Enum.YLeaf(172, "im-attr-media-40gbase-dwdm-1555-75")

    im_attr_media_40gbase_dwdm_1554_94 = Enum.YLeaf(173, "im-attr-media-40gbase-dwdm-1554-94")

    im_attr_media_40gbase_dwdm_1554_13 = Enum.YLeaf(174, "im-attr-media-40gbase-dwdm-1554-13")

    im_attr_media_40gbase_dwdm_1553_33 = Enum.YLeaf(175, "im-attr-media-40gbase-dwdm-1553-33")

    im_attr_media_40gbase_dwdm_1552_52 = Enum.YLeaf(176, "im-attr-media-40gbase-dwdm-1552-52")

    im_attr_media_40gbase_dwdm_1551_72 = Enum.YLeaf(177, "im-attr-media-40gbase-dwdm-1551-72")

    im_attr_media_40gbase_dwdm_1550_92 = Enum.YLeaf(178, "im-attr-media-40gbase-dwdm-1550-92")

    im_attr_media_40gbase_dwdm_1550_12 = Enum.YLeaf(179, "im-attr-media-40gbase-dwdm-1550-12")

    im_attr_media_40gbase_dwdm_1549_32 = Enum.YLeaf(180, "im-attr-media-40gbase-dwdm-1549-32")

    im_attr_media_40gbase_dwdm_1548_51 = Enum.YLeaf(181, "im-attr-media-40gbase-dwdm-1548-51")

    im_attr_media_40gbase_dwdm_1547_72 = Enum.YLeaf(182, "im-attr-media-40gbase-dwdm-1547-72")

    im_attr_media_40gbase_dwdm_1546_92 = Enum.YLeaf(183, "im-attr-media-40gbase-dwdm-1546-92")

    im_attr_media_40gbase_dwdm_1546_12 = Enum.YLeaf(184, "im-attr-media-40gbase-dwdm-1546-12")

    im_attr_media_40gbase_dwdm_1545_32 = Enum.YLeaf(185, "im-attr-media-40gbase-dwdm-1545-32")

    im_attr_media_40gbase_dwdm_1544_53 = Enum.YLeaf(186, "im-attr-media-40gbase-dwdm-1544-53")

    im_attr_media_40gbase_dwdm_1543_73 = Enum.YLeaf(187, "im-attr-media-40gbase-dwdm-1543-73")

    im_attr_media_40gbase_dwdm_1542_94 = Enum.YLeaf(188, "im-attr-media-40gbase-dwdm-1542-94")

    im_attr_media_40gbase_dwdm_1542_14 = Enum.YLeaf(189, "im-attr-media-40gbase-dwdm-1542-14")

    im_attr_media_40gbase_dwdm_1541_35 = Enum.YLeaf(190, "im-attr-media-40gbase-dwdm-1541-35")

    im_attr_media_40gbase_dwdm_1540_56 = Enum.YLeaf(191, "im-attr-media-40gbase-dwdm-1540-56")

    im_attr_media_40gbase_dwdm_1539_77 = Enum.YLeaf(192, "im-attr-media-40gbase-dwdm-1539-77")

    im_attr_media_40gbase_dwdm_1538_98 = Enum.YLeaf(193, "im-attr-media-40gbase-dwdm-1538-98")

    im_attr_media_40gbase_dwdm_1538_19 = Enum.YLeaf(194, "im-attr-media-40gbase-dwdm-1538-19")

    im_attr_media_40gbase_dwdm_1537_40 = Enum.YLeaf(195, "im-attr-media-40gbase-dwdm-1537-40")

    im_attr_media_40gbase_dwdm_1536_61 = Enum.YLeaf(196, "im-attr-media-40gbase-dwdm-1536-61")

    im_attr_media_40gbase_dwdm_1535_82 = Enum.YLeaf(197, "im-attr-media-40gbase-dwdm-1535-82")

    im_attr_media_40gbase_dwdm_1535_04 = Enum.YLeaf(198, "im-attr-media-40gbase-dwdm-1535-04")

    im_attr_media_40gbase_dwdm_1534_25 = Enum.YLeaf(199, "im-attr-media-40gbase-dwdm-1534-25")

    im_attr_media_40gbase_dwdm_1533_47 = Enum.YLeaf(200, "im-attr-media-40gbase-dwdm-1533-47")

    im_attr_media_40gbase_dwdm_1532_68 = Enum.YLeaf(201, "im-attr-media-40gbase-dwdm-1532-68")

    im_attr_media_40gbase_dwdm_1531_90 = Enum.YLeaf(202, "im-attr-media-40gbase-dwdm-1531-90")

    im_attr_media_40gbase_dwdm_1531_12 = Enum.YLeaf(203, "im-attr-media-40gbase-dwdm-1531-12")

    im_attr_media_40gbase_dwdm_1530_33 = Enum.YLeaf(204, "im-attr-media-40gbase-dwdm-1530-33")

    im_attr_media_40gbase_dwdm_tunable = Enum.YLeaf(205, "im-attr-media-40gbase-dwdm-tunable")

    im_attr_media_100gbase_dwdm_1561_42 = Enum.YLeaf(206, "im-attr-media-100gbase-dwdm-1561-42")

    im_attr_media_100gbase_dwdm_1560_61 = Enum.YLeaf(207, "im-attr-media-100gbase-dwdm-1560-61")

    im_attr_media_100gbase_dwdm_1559_79 = Enum.YLeaf(208, "im-attr-media-100gbase-dwdm-1559-79")

    im_attr_media_100gbase_dwdm_1558_98 = Enum.YLeaf(209, "im-attr-media-100gbase-dwdm-1558-98")

    im_attr_media_100gbase_dwdm_1558_17 = Enum.YLeaf(210, "im-attr-media-100gbase-dwdm-1558-17")

    im_attr_media_100gbase_dwdm_1557_36 = Enum.YLeaf(211, "im-attr-media-100gbase-dwdm-1557-36")

    im_attr_media_100gbase_dwdm_1556_55 = Enum.YLeaf(212, "im-attr-media-100gbase-dwdm-1556-55")

    im_attr_media_100gbase_dwdm_1555_75 = Enum.YLeaf(213, "im-attr-media-100gbase-dwdm-1555-75")

    im_attr_media_100gbase_dwdm_1554_94 = Enum.YLeaf(214, "im-attr-media-100gbase-dwdm-1554-94")

    im_attr_media_100gbase_dwdm_1554_13 = Enum.YLeaf(215, "im-attr-media-100gbase-dwdm-1554-13")

    im_attr_media_100gbase_dwdm_1553_33 = Enum.YLeaf(216, "im-attr-media-100gbase-dwdm-1553-33")

    im_attr_media_100gbase_dwdm_1552_52 = Enum.YLeaf(217, "im-attr-media-100gbase-dwdm-1552-52")

    im_attr_media_100gbase_dwdm_1551_72 = Enum.YLeaf(218, "im-attr-media-100gbase-dwdm-1551-72")

    im_attr_media_100gbase_dwdm_1550_92 = Enum.YLeaf(219, "im-attr-media-100gbase-dwdm-1550-92")

    im_attr_media_100gbase_dwdm_1550_12 = Enum.YLeaf(220, "im-attr-media-100gbase-dwdm-1550-12")

    im_attr_media_100gbase_dwdm_1549_32 = Enum.YLeaf(221, "im-attr-media-100gbase-dwdm-1549-32")

    im_attr_media_100gbase_dwdm_1548_51 = Enum.YLeaf(222, "im-attr-media-100gbase-dwdm-1548-51")

    im_attr_media_100gbase_dwdm_1547_72 = Enum.YLeaf(223, "im-attr-media-100gbase-dwdm-1547-72")

    im_attr_media_100gbase_dwdm_1546_92 = Enum.YLeaf(224, "im-attr-media-100gbase-dwdm-1546-92")

    im_attr_media_100gbase_dwdm_1546_12 = Enum.YLeaf(225, "im-attr-media-100gbase-dwdm-1546-12")

    im_attr_media_100gbase_dwdm_1545_32 = Enum.YLeaf(226, "im-attr-media-100gbase-dwdm-1545-32")

    im_attr_media_100gbase_dwdm_1544_53 = Enum.YLeaf(227, "im-attr-media-100gbase-dwdm-1544-53")

    im_attr_media_100gbase_dwdm_1543_73 = Enum.YLeaf(228, "im-attr-media-100gbase-dwdm-1543-73")

    im_attr_media_100gbase_dwdm_1542_94 = Enum.YLeaf(229, "im-attr-media-100gbase-dwdm-1542-94")

    im_attr_media_100gbase_dwdm_1542_14 = Enum.YLeaf(230, "im-attr-media-100gbase-dwdm-1542-14")

    im_attr_media_100gbase_dwdm_1541_35 = Enum.YLeaf(231, "im-attr-media-100gbase-dwdm-1541-35")

    im_attr_media_100gbase_dwdm_1540_56 = Enum.YLeaf(232, "im-attr-media-100gbase-dwdm-1540-56")

    im_attr_media_100gbase_dwdm_1539_77 = Enum.YLeaf(233, "im-attr-media-100gbase-dwdm-1539-77")

    im_attr_media_100gbase_dwdm_1538_98 = Enum.YLeaf(234, "im-attr-media-100gbase-dwdm-1538-98")

    im_attr_media_100gbase_dwdm_1538_19 = Enum.YLeaf(235, "im-attr-media-100gbase-dwdm-1538-19")

    im_attr_media_100gbase_dwdm_1537_40 = Enum.YLeaf(236, "im-attr-media-100gbase-dwdm-1537-40")

    im_attr_media_100gbase_dwdm_1536_61 = Enum.YLeaf(237, "im-attr-media-100gbase-dwdm-1536-61")

    im_attr_media_100gbase_dwdm_1535_82 = Enum.YLeaf(238, "im-attr-media-100gbase-dwdm-1535-82")

    im_attr_media_100gbase_dwdm_1535_04 = Enum.YLeaf(239, "im-attr-media-100gbase-dwdm-1535-04")

    im_attr_media_100gbase_dwdm_1534_25 = Enum.YLeaf(240, "im-attr-media-100gbase-dwdm-1534-25")

    im_attr_media_100gbase_dwdm_1533_47 = Enum.YLeaf(241, "im-attr-media-100gbase-dwdm-1533-47")

    im_attr_media_100gbase_dwdm_1532_68 = Enum.YLeaf(242, "im-attr-media-100gbase-dwdm-1532-68")

    im_attr_media_100gbase_dwdm_1531_90 = Enum.YLeaf(243, "im-attr-media-100gbase-dwdm-1531-90")

    im_attr_media_100gbase_dwdm_1531_12 = Enum.YLeaf(244, "im-attr-media-100gbase-dwdm-1531-12")

    im_attr_media_100gbase_dwdm_1530_33 = Enum.YLeaf(245, "im-attr-media-100gbase-dwdm-1530-33")

    im_attr_media_100gbase_dwdm_tunable = Enum.YLeaf(246, "im-attr-media-100gbase-dwdm-tunable")

    im_attr_media_40gbase_kr4 = Enum.YLeaf(247, "im-attr-media-40gbase-kr4")

    im_attr_media_40gbase_cr4 = Enum.YLeaf(248, "im-attr-media-40gbase-cr4")

    im_attr_media_40gbase_sr4 = Enum.YLeaf(249, "im-attr-media-40gbase-sr4")

    im_attr_media_40gbase_fr = Enum.YLeaf(250, "im-attr-media-40gbase-fr")

    im_attr_media_100gbase_cr10 = Enum.YLeaf(251, "im-attr-media-100gbase-cr10")

    im_attr_media_100gbase_sr10 = Enum.YLeaf(252, "im-attr-media-100gbase-sr10")

    im_attr_media_40gbase_csr4 = Enum.YLeaf(253, "im-attr-media-40gbase-csr4")

    im_attr_media_10gbase_cwdm = Enum.YLeaf(254, "im-attr-media-10gbase-cwdm")

    im_attr_media_10gbase_cwdm_tunable = Enum.YLeaf(255, "im-attr-media-10gbase-cwdm-tunable")

    im_attr_media_10gbase_cwdm_1470 = Enum.YLeaf(256, "im-attr-media-10gbase-cwdm-1470")

    im_attr_media_10gbase_cwdm_1490 = Enum.YLeaf(257, "im-attr-media-10gbase-cwdm-1490")

    im_attr_media_10gbase_cwdm_1510 = Enum.YLeaf(258, "im-attr-media-10gbase-cwdm-1510")

    im_attr_media_10gbase_cwdm_1530 = Enum.YLeaf(259, "im-attr-media-10gbase-cwdm-1530")

    im_attr_media_10gbase_cwdm_1550 = Enum.YLeaf(260, "im-attr-media-10gbase-cwdm-1550")

    im_attr_media_10gbase_cwdm_1570 = Enum.YLeaf(261, "im-attr-media-10gbase-cwdm-1570")

    im_attr_media_10gbase_cwdm_1590 = Enum.YLeaf(262, "im-attr-media-10gbase-cwdm-1590")

    im_attr_media_10gbase_cwdm_1610 = Enum.YLeaf(263, "im-attr-media-10gbase-cwdm-1610")

    im_attr_media_40gbase_cwdm = Enum.YLeaf(264, "im-attr-media-40gbase-cwdm")

    im_attr_media_40gbase_cwdm_tunable = Enum.YLeaf(265, "im-attr-media-40gbase-cwdm-tunable")

    im_attr_media_40gbase_cwdm_1470 = Enum.YLeaf(266, "im-attr-media-40gbase-cwdm-1470")

    im_attr_media_40gbase_cwdm_1490 = Enum.YLeaf(267, "im-attr-media-40gbase-cwdm-1490")

    im_attr_media_40gbase_cwdm_1510 = Enum.YLeaf(268, "im-attr-media-40gbase-cwdm-1510")

    im_attr_media_40gbase_cwdm_1530 = Enum.YLeaf(269, "im-attr-media-40gbase-cwdm-1530")

    im_attr_media_40gbase_cwdm_1550 = Enum.YLeaf(270, "im-attr-media-40gbase-cwdm-1550")

    im_attr_media_40gbase_cwdm_1570 = Enum.YLeaf(271, "im-attr-media-40gbase-cwdm-1570")

    im_attr_media_40gbase_cwdm_1590 = Enum.YLeaf(272, "im-attr-media-40gbase-cwdm-1590")

    im_attr_media_40gbase_cwdm_1610 = Enum.YLeaf(273, "im-attr-media-40gbase-cwdm-1610")

    im_attr_media_100gbase_cwdm = Enum.YLeaf(274, "im-attr-media-100gbase-cwdm")

    im_attr_media_100gbase_cwdm_tunable = Enum.YLeaf(275, "im-attr-media-100gbase-cwdm-tunable")

    im_attr_media_100gbase_cwdm_1470 = Enum.YLeaf(276, "im-attr-media-100gbase-cwdm-1470")

    im_attr_media_100gbase_cwdm_1490 = Enum.YLeaf(277, "im-attr-media-100gbase-cwdm-1490")

    im_attr_media_100gbase_cwdm_1510 = Enum.YLeaf(278, "im-attr-media-100gbase-cwdm-1510")

    im_attr_media_100gbase_cwdm_1530 = Enum.YLeaf(279, "im-attr-media-100gbase-cwdm-1530")

    im_attr_media_100gbase_cwdm_1550 = Enum.YLeaf(280, "im-attr-media-100gbase-cwdm-1550")

    im_attr_media_100gbase_cwdm_1570 = Enum.YLeaf(281, "im-attr-media-100gbase-cwdm-1570")

    im_attr_media_100gbase_cwdm_1590 = Enum.YLeaf(282, "im-attr-media-100gbase-cwdm-1590")

    im_attr_media_100gbase_cwdm_1610 = Enum.YLeaf(283, "im-attr-media-100gbase-cwdm-1610")

    im_attr_media_40gbase_elpb = Enum.YLeaf(284, "im-attr-media-40gbase-elpb")

    im_attr_media_100gbase_elpb = Enum.YLeaf(285, "im-attr-media-100gbase-elpb")

    im_attr_media_100gbase_lr10 = Enum.YLeaf(286, "im-attr-media-100gbase-lr10")

    im_attr_media_40gbase = Enum.YLeaf(287, "im-attr-media-40gbase")

    im_attr_media_100gbase_kp4 = Enum.YLeaf(288, "im-attr-media-100gbase-kp4")

    im_attr_media_100gbase_kr4 = Enum.YLeaf(289, "im-attr-media-100gbase-kr4")

    im_attr_media_10gbase_lrm = Enum.YLeaf(290, "im-attr-media-10gbase-lrm")

    im_attr_media_10gbase_cx4 = Enum.YLeaf(291, "im-attr-media-10gbase-cx4")

    im_attr_media_10gbase = Enum.YLeaf(292, "im-attr-media-10gbase")

    im_attr_media_10gbase_kx4 = Enum.YLeaf(293, "im-attr-media-10gbase-kx4")

    im_attr_media_10gbase_kr = Enum.YLeaf(294, "im-attr-media-10gbase-kr")

    im_attr_media_10gbase_pr = Enum.YLeaf(295, "im-attr-media-10gbase-pr")

    im_attr_media_100base_lx = Enum.YLeaf(296, "im-attr-media-100base-lx")

    im_attr_media_100base_zx = Enum.YLeaf(297, "im-attr-media-100base-zx")

    im_attr_media_1000base_bx_d = Enum.YLeaf(298, "im-attr-media-1000base-bx-d")

    im_attr_media_1000base_bx_u = Enum.YLeaf(299, "im-attr-media-1000base-bx-u")

    im_attr_media_1000base_bx20_d = Enum.YLeaf(300, "im-attr-media-1000base-bx20-d")

    im_attr_media_1000base_bx20_u = Enum.YLeaf(301, "im-attr-media-1000base-bx20-u")

    im_attr_media_1000base_bx40_d = Enum.YLeaf(302, "im-attr-media-1000base-bx40-d")

    im_attr_media_1000base_bx40_da = Enum.YLeaf(303, "im-attr-media-1000base-bx40-da")

    im_attr_media_1000base_bx40_u = Enum.YLeaf(304, "im-attr-media-1000base-bx40-u")

    im_attr_media_1000base_bx80_d = Enum.YLeaf(305, "im-attr-media-1000base-bx80-d")

    im_attr_media_1000base_bx80_u = Enum.YLeaf(306, "im-attr-media-1000base-bx80-u")

    im_attr_media_1000base_bx120_d = Enum.YLeaf(307, "im-attr-media-1000base-bx120-d")

    im_attr_media_1000base_bx120_u = Enum.YLeaf(308, "im-attr-media-1000base-bx120-u")

    im_attr_media_10gbase_bx_d = Enum.YLeaf(309, "im-attr-media-10gbase-bx-d")

    im_attr_media_10gbase_bx_u = Enum.YLeaf(310, "im-attr-media-10gbase-bx-u")

    im_attr_media_10gbase_bx10_d = Enum.YLeaf(311, "im-attr-media-10gbase-bx10-d")

    im_attr_media_10gbase_bx10_u = Enum.YLeaf(312, "im-attr-media-10gbase-bx10-u")

    im_attr_media_10gbase_bx20_d = Enum.YLeaf(313, "im-attr-media-10gbase-bx20-d")

    im_attr_media_10gbase_bx20_u = Enum.YLeaf(314, "im-attr-media-10gbase-bx20-u")

    im_attr_media_10gbase_bx40_d = Enum.YLeaf(315, "im-attr-media-10gbase-bx40-d")

    im_attr_media_10gbase_bx40_u = Enum.YLeaf(316, "im-attr-media-10gbase-bx40-u")

    im_attr_media_10gbase_bx80_d = Enum.YLeaf(317, "im-attr-media-10gbase-bx80-d")

    im_attr_media_10gbase_bx80_u = Enum.YLeaf(318, "im-attr-media-10gbase-bx80-u")

    im_attr_media_10gbase_bx120_d = Enum.YLeaf(319, "im-attr-media-10gbase-bx120-d")

    im_attr_media_10gbase_bx120_u = Enum.YLeaf(320, "im-attr-media-10gbase-bx120-u")

    im_attr_media_1000base_dr_lx = Enum.YLeaf(321, "im-attr-media-1000base-dr-lx")

    im_attr_media_100gbase_er4l = Enum.YLeaf(322, "im-attr-media-100gbase-er4l")

    im_attr_media_100gbase_sr4 = Enum.YLeaf(323, "im-attr-media-100gbase-sr4")

    im_attr_media_40gbase_sr_bd = Enum.YLeaf(324, "im-attr-media-40gbase-sr-bd")

    im_attr_media_25gbase_cr = Enum.YLeaf(325, "im-attr-media-25gbase-cr")

    im_attr_media_25gbase_cr_s = Enum.YLeaf(326, "im-attr-media-25gbase-cr-s")

    im_attr_media_25gbase_kr = Enum.YLeaf(327, "im-attr-media-25gbase-kr")

    im_attr_media_25gbase_kr_s = Enum.YLeaf(328, "im-attr-media-25gbase-kr-s")

    im_attr_media_25gbase_r = Enum.YLeaf(329, "im-attr-media-25gbase-r")

    im_attr_media_25gbase_sr = Enum.YLeaf(330, "im-attr-media-25gbase-sr")

    im_attr_media_25gbase_dwdm = Enum.YLeaf(331, "im-attr-media-25gbase-dwdm")

    im_attr_media_25gbase_dwdm_tunable = Enum.YLeaf(332, "im-attr-media-25gbase-dwdm-tunable")

    im_attr_media_25gbase_cwdm = Enum.YLeaf(333, "im-attr-media-25gbase-cwdm")

    im_attr_media_25gbase_cwdm_tunable = Enum.YLeaf(334, "im-attr-media-25gbase-cwdm-tunable")

    im_attr_media_100gbase_psm4 = Enum.YLeaf(335, "im-attr-media-100gbase-psm4")

    im_attr_media_100gbase_er10 = Enum.YLeaf(336, "im-attr-media-100gbase-er10")

    im_attr_media_100gbase_er10l = Enum.YLeaf(337, "im-attr-media-100gbase-er10l")

    im_attr_media_100gbase_acc = Enum.YLeaf(338, "im-attr-media-100gbase-acc")

    im_attr_media_100gbase_aoc = Enum.YLeaf(339, "im-attr-media-100gbase-aoc")

    im_attr_media_100gbase_cwdm4 = Enum.YLeaf(340, "im-attr-media-100gbase-cwdm4")

    im_attr_media_40gbase_psm4 = Enum.YLeaf(341, "im-attr-media-40gbase-psm4")

    im_attr_media_100gbase_cr4 = Enum.YLeaf(342, "im-attr-media-100gbase-cr4")

    im_attr_media_100gbase_act_loop = Enum.YLeaf(343, "im-attr-media-100gbase-act-loop")

    im_attr_media_100gbase_pas_loop = Enum.YLeaf(344, "im-attr-media-100gbase-pas-loop")


class ImAttrTransportMode(Enum):
    """
    ImAttrTransportMode

    Im attr transport mode

    .. data:: im_attr_transport_mode_unknown = 0

    	im attr transport mode unknown

    .. data:: im_attr_transport_mode_lan = 1

    	im attr transport mode lan

    .. data:: im_attr_transport_mode_wan = 2

    	im attr transport mode wan

    .. data:: im_attr_transport_mode_otn_bt_opu1e = 3

    	im attr transport mode otn bt opu1e

    .. data:: im_attr_transport_mode_otn_bt_opu2e = 4

    	im attr transport mode otn bt opu2e

    .. data:: im_attr_transport_mode_otn_opu3 = 5

    	im attr transport mode otn opu3

    .. data:: im_attr_transport_mode_otn_opu4 = 6

    	im attr transport mode otn opu4

    """

    im_attr_transport_mode_unknown = Enum.YLeaf(0, "im-attr-transport-mode-unknown")

    im_attr_transport_mode_lan = Enum.YLeaf(1, "im-attr-transport-mode-lan")

    im_attr_transport_mode_wan = Enum.YLeaf(2, "im-attr-transport-mode-wan")

    im_attr_transport_mode_otn_bt_opu1e = Enum.YLeaf(3, "im-attr-transport-mode-otn-bt-opu1e")

    im_attr_transport_mode_otn_bt_opu2e = Enum.YLeaf(4, "im-attr-transport-mode-otn-bt-opu2e")

    im_attr_transport_mode_otn_opu3 = Enum.YLeaf(5, "im-attr-transport-mode-otn-opu3")

    im_attr_transport_mode_otn_opu4 = Enum.YLeaf(6, "im-attr-transport-mode-otn-opu4")


class ImCmdEncapsEnum(Enum):
    """
    ImCmdEncapsEnum

    Im cmd encaps enum

    .. data:: frame_relay = 0

    	frame relay

    .. data:: vlan = 1

    	vlan

    .. data:: ppp = 2

    	ppp

    """

    frame_relay = Enum.YLeaf(0, "frame-relay")

    vlan = Enum.YLeaf(1, "vlan")

    ppp = Enum.YLeaf(2, "ppp")


class ImCmdFrTypeEnum(Enum):
    """
    ImCmdFrTypeEnum

    Im cmd fr type enum

    .. data:: frame_relay_cisco = 0

    	frame relay cisco

    .. data:: frame_relay_ietf = 1

    	frame relay ietf

    """

    frame_relay_cisco = Enum.YLeaf(0, "frame-relay-cisco")

    frame_relay_ietf = Enum.YLeaf(1, "frame-relay-ietf")


class ImCmdIntfTypeEnum(Enum):
    """
    ImCmdIntfTypeEnum

    Im cmd intf type enum

    .. data:: srp = 0

    	srp

    .. data:: tunnel = 1

    	tunnel

    .. data:: bundle = 2

    	bundle

    .. data:: serial = 3

    	serial

    .. data:: sonet_pos = 4

    	sonet pos

    .. data:: tunnel_gre = 5

    	tunnel gre

    .. data:: pseudowire_head_end = 6

    	pseudowire head end

    .. data:: cem = 7

    	cem

    .. data:: gcc = 8

    	gcc

    """

    srp = Enum.YLeaf(0, "srp")

    tunnel = Enum.YLeaf(1, "tunnel")

    bundle = Enum.YLeaf(2, "bundle")

    serial = Enum.YLeaf(3, "serial")

    sonet_pos = Enum.YLeaf(4, "sonet-pos")

    tunnel_gre = Enum.YLeaf(5, "tunnel-gre")

    pseudowire_head_end = Enum.YLeaf(6, "pseudowire-head-end")

    cem = Enum.YLeaf(7, "cem")

    gcc = Enum.YLeaf(8, "gcc")


class ImCmdLmiTypeEnum(Enum):
    """
    ImCmdLmiTypeEnum

    Im cmd lmi type enum

    .. data:: lmi_type_auto = 0

    	lmi type auto

    .. data:: lmi_type_ansi = 1

    	lmi type ansi

    .. data:: lmi_type_ccitt = 2

    	lmi type ccitt

    .. data:: lmi_type_cisco = 3

    	lmi type cisco

    """

    lmi_type_auto = Enum.YLeaf(0, "lmi-type-auto")

    lmi_type_ansi = Enum.YLeaf(1, "lmi-type-ansi")

    lmi_type_ccitt = Enum.YLeaf(2, "lmi-type-ccitt")

    lmi_type_cisco = Enum.YLeaf(3, "lmi-type-cisco")


class ImCmdLoopbackEnum(Enum):
    """
    ImCmdLoopbackEnum

    Im cmd loopback enum

    .. data:: no_loopback = 0

    	no loopback

    .. data:: internal_loopback = 1

    	internal loopback

    .. data:: external_loopback = 2

    	external loopback

    .. data:: line_loopback = 3

    	line loopback

    """

    no_loopback = Enum.YLeaf(0, "no-loopback")

    internal_loopback = Enum.YLeaf(1, "internal-loopback")

    external_loopback = Enum.YLeaf(2, "external-loopback")

    line_loopback = Enum.YLeaf(3, "line-loopback")


class ImCmdStatsEnum(Enum):
    """
    ImCmdStatsEnum

    List of different interface stats structures

    .. data:: full = 1

    	full

    .. data:: basic = 2

    	basic

    """

    full = Enum.YLeaf(1, "full")

    basic = Enum.YLeaf(2, "basic")


class ImStateEnum(Enum):
    """
    ImStateEnum

    Im state enum

    .. data:: im_state_not_ready = 0

    	im state not ready

    .. data:: im_state_admin_down = 1

    	im state admin down

    .. data:: im_state_down = 2

    	im state down

    .. data:: im_state_up = 3

    	im state up

    .. data:: im_state_shutdown = 4

    	im state shutdown

    .. data:: im_state_err_disable = 5

    	im state err disable

    .. data:: im_state_down_immediate = 6

    	im state down immediate

    .. data:: im_state_down_immediate_admin = 7

    	im state down immediate admin

    .. data:: im_state_down_graceful = 8

    	im state down graceful

    .. data:: im_state_begin_shutdown = 9

    	im state begin shutdown

    .. data:: im_state_end_shutdown = 10

    	im state end shutdown

    .. data:: im_state_begin_error_disable = 11

    	im state begin error disable

    .. data:: im_state_end_error_disable = 12

    	im state end error disable

    .. data:: im_state_begin_down_graceful = 13

    	im state begin down graceful

    .. data:: im_state_reset = 14

    	im state reset

    .. data:: im_state_operational = 15

    	im state operational

    .. data:: im_state_not_operational = 16

    	im state not operational

    .. data:: im_state_unknown = 17

    	im state unknown

    .. data:: im_state_last = 18

    	im state last

    """

    im_state_not_ready = Enum.YLeaf(0, "im-state-not-ready")

    im_state_admin_down = Enum.YLeaf(1, "im-state-admin-down")

    im_state_down = Enum.YLeaf(2, "im-state-down")

    im_state_up = Enum.YLeaf(3, "im-state-up")

    im_state_shutdown = Enum.YLeaf(4, "im-state-shutdown")

    im_state_err_disable = Enum.YLeaf(5, "im-state-err-disable")

    im_state_down_immediate = Enum.YLeaf(6, "im-state-down-immediate")

    im_state_down_immediate_admin = Enum.YLeaf(7, "im-state-down-immediate-admin")

    im_state_down_graceful = Enum.YLeaf(8, "im-state-down-graceful")

    im_state_begin_shutdown = Enum.YLeaf(9, "im-state-begin-shutdown")

    im_state_end_shutdown = Enum.YLeaf(10, "im-state-end-shutdown")

    im_state_begin_error_disable = Enum.YLeaf(11, "im-state-begin-error-disable")

    im_state_end_error_disable = Enum.YLeaf(12, "im-state-end-error-disable")

    im_state_begin_down_graceful = Enum.YLeaf(13, "im-state-begin-down-graceful")

    im_state_reset = Enum.YLeaf(14, "im-state-reset")

    im_state_operational = Enum.YLeaf(15, "im-state-operational")

    im_state_not_operational = Enum.YLeaf(16, "im-state-not-operational")

    im_state_unknown = Enum.YLeaf(17, "im-state-unknown")

    im_state_last = Enum.YLeaf(18, "im-state-last")


class InterfaceTypeSet(Enum):
    """
    InterfaceTypeSet

    Interface type set

    .. data:: hardware_interfaces = 0

    	Restrict the output to hardware interfaces only

    """

    hardware_interfaces = Enum.YLeaf(0, "hardware-interfaces")


class NcpIdent(Enum):
    """
    NcpIdent

    Ncp ident

    .. data:: cdpcp = 1

    	CDP control protocol

    .. data:: ipcp = 2

    	IPv4 control protocol

    .. data:: ipcpiw = 3

    	IPv4 Interworking control protocol

    .. data:: ipv6cp = 4

    	IPv6 control protocol

    .. data:: mplscp = 5

    	MPLS control protocol

    .. data:: osicp = 6

    	OSI (CLNS) control protocol

    """

    cdpcp = Enum.YLeaf(1, "cdpcp")

    ipcp = Enum.YLeaf(2, "ipcp")

    ipcpiw = Enum.YLeaf(3, "ipcpiw")

    ipv6cp = Enum.YLeaf(4, "ipv6cp")

    mplscp = Enum.YLeaf(5, "mplscp")

    osicp = Enum.YLeaf(6, "osicp")


class PppFsmState(Enum):
    """
    PppFsmState

    Ppp fsm state

    .. data:: ppp_fsm_state_initial_0 = 0

    	Connection Idle

    .. data:: ppp_fsm_state_starting_1 = 1

    	This layer required, but lower layer down

    .. data:: ppp_fsm_state_closed_2 = 2

    	Lower layer up, but this layer not required

    .. data:: ppp_fsm_state_stopped_3 = 3

    	Listening for a Config Request

    .. data:: ppp_fsm_state_closing_4 = 4

    	Shutting down due to local change

    .. data:: ppp_fsm_state_stopping_5 = 5

    	Shutting down due to peer's actions

    .. data:: ppp_fsm_state_req_sent_6 = 6

    	Config Request Sent

    .. data:: ppp_fsm_state_ack_rcvd_7 = 7

    	Config Ack Received

    .. data:: ppp_fsm_state_ack_sent_8 = 8

    	Config Ack Sent

    .. data:: ppp_fsm_state_opened_9 = 9

    	Connection Open

    """

    ppp_fsm_state_initial_0 = Enum.YLeaf(0, "ppp-fsm-state-initial-0")

    ppp_fsm_state_starting_1 = Enum.YLeaf(1, "ppp-fsm-state-starting-1")

    ppp_fsm_state_closed_2 = Enum.YLeaf(2, "ppp-fsm-state-closed-2")

    ppp_fsm_state_stopped_3 = Enum.YLeaf(3, "ppp-fsm-state-stopped-3")

    ppp_fsm_state_closing_4 = Enum.YLeaf(4, "ppp-fsm-state-closing-4")

    ppp_fsm_state_stopping_5 = Enum.YLeaf(5, "ppp-fsm-state-stopping-5")

    ppp_fsm_state_req_sent_6 = Enum.YLeaf(6, "ppp-fsm-state-req-sent-6")

    ppp_fsm_state_ack_rcvd_7 = Enum.YLeaf(7, "ppp-fsm-state-ack-rcvd-7")

    ppp_fsm_state_ack_sent_8 = Enum.YLeaf(8, "ppp-fsm-state-ack-sent-8")

    ppp_fsm_state_opened_9 = Enum.YLeaf(9, "ppp-fsm-state-opened-9")


class SonetApsEt(Enum):
    """
    SonetApsEt

    APS states

    .. data:: not_configured = 0

    	APS not configured on port

    .. data:: working_active = 1

    	Working port is up 

    .. data:: protect_active = 2

    	Protect port is up  

    .. data:: working_inactive = 3

    	Working port is down 

    .. data:: protect_inactive = 4

    	Protect port is down  

    """

    not_configured = Enum.YLeaf(0, "not-configured")

    working_active = Enum.YLeaf(1, "working-active")

    protect_active = Enum.YLeaf(2, "protect-active")

    working_inactive = Enum.YLeaf(3, "working-inactive")

    protect_inactive = Enum.YLeaf(4, "protect-inactive")


class SrpMgmtFailureEt(Enum):
    """
    SrpMgmtFailureEt

    SRP failure type

    .. data:: hardware_missing_failure = 0

    	Hardware missing

    .. data:: layer1_admin_state_failure = 1

    	L1 admin state

    .. data:: layer1_error_failure = 2

    	Layer 1 error

    .. data:: keepalive_missed_failure = 3

    	Keepalive missed

    .. data:: link_quality_degraded_failure = 4

    	Link quality degraded

    .. data:: mate_problem_failure = 5

    	Mate problem

    .. data:: side_mismatch_failure = 6

    	Side mismatch

    .. data:: unknown_failure = 7

    	Unknown

    """

    hardware_missing_failure = Enum.YLeaf(0, "hardware-missing-failure")

    layer1_admin_state_failure = Enum.YLeaf(1, "layer1-admin-state-failure")

    layer1_error_failure = Enum.YLeaf(2, "layer1-error-failure")

    keepalive_missed_failure = Enum.YLeaf(3, "keepalive-missed-failure")

    link_quality_degraded_failure = Enum.YLeaf(4, "link-quality-degraded-failure")

    mate_problem_failure = Enum.YLeaf(5, "mate-problem-failure")

    side_mismatch_failure = Enum.YLeaf(6, "side-mismatch-failure")

    unknown_failure = Enum.YLeaf(7, "unknown-failure")


class SrpMgmtFailureStateEt(Enum):
    """
    SrpMgmtFailureStateEt

    SRP failure state type

    .. data:: idle_failure_state = 0

    	Idle

    .. data:: wait_to_restore_failure_state = 1

    	Wait To Restore

    .. data:: manual_switch_failure_state = 2

    	Manual Switch

    .. data:: signal_degrade_failure_state = 3

    	Signal Degrade

    .. data:: signal_fail_failure_state = 4

    	Signal Fail

    .. data:: forced_switch_failure_state = 5

    	Forced Switch

    .. data:: shutdown_failure_state = 6

    	Shutdown

    .. data:: invalid_failure_state = 7

    	Invalid

    .. data:: unknown_failure_state = 8

    	Unknown

    """

    idle_failure_state = Enum.YLeaf(0, "idle-failure-state")

    wait_to_restore_failure_state = Enum.YLeaf(1, "wait-to-restore-failure-state")

    manual_switch_failure_state = Enum.YLeaf(2, "manual-switch-failure-state")

    signal_degrade_failure_state = Enum.YLeaf(3, "signal-degrade-failure-state")

    signal_fail_failure_state = Enum.YLeaf(4, "signal-fail-failure-state")

    forced_switch_failure_state = Enum.YLeaf(5, "forced-switch-failure-state")

    shutdown_failure_state = Enum.YLeaf(6, "shutdown-failure-state")

    invalid_failure_state = Enum.YLeaf(7, "invalid-failure-state")

    unknown_failure_state = Enum.YLeaf(8, "unknown-failure-state")


class SrpMgmtIpsPathInd(Enum):
    """
    SrpMgmtIpsPathInd

    SRP IPS path indication

    .. data:: short_path = 0

    	SHORT

    .. data:: long_path = 1

    	LONG

    .. data:: unknown_path = 2

    	UNKNOWN

    """

    short_path = Enum.YLeaf(0, "short-path")

    long_path = Enum.YLeaf(1, "long-path")

    unknown_path = Enum.YLeaf(2, "unknown-path")


class SrpMgmtIpsReq(Enum):
    """
    SrpMgmtIpsReq

    SRP IPS request type

    .. data:: idle_ips_request = 0

    	Idle

    .. data:: wait_to_restore_ips_request = 1

    	Wait To Restore

    .. data:: manual_switch_ips_request = 2

    	Manual Switch

    .. data:: signal_degrade_ips_request = 3

    	Signal Degrade

    .. data:: signal_fail_ips_request = 4

    	Signal Fail

    .. data:: forced_switch_ips_request = 5

    	Forced Switch

    .. data:: unknown_ips_request = 6

    	UNKNOWN

    """

    idle_ips_request = Enum.YLeaf(0, "idle-ips-request")

    wait_to_restore_ips_request = Enum.YLeaf(1, "wait-to-restore-ips-request")

    manual_switch_ips_request = Enum.YLeaf(2, "manual-switch-ips-request")

    signal_degrade_ips_request = Enum.YLeaf(3, "signal-degrade-ips-request")

    signal_fail_ips_request = Enum.YLeaf(4, "signal-fail-ips-request")

    forced_switch_ips_request = Enum.YLeaf(5, "forced-switch-ips-request")

    unknown_ips_request = Enum.YLeaf(6, "unknown-ips-request")


class SrpMgmtIpsWrapState(Enum):
    """
    SrpMgmtIpsWrapState

    SRP IPS side wrap state

    .. data:: idle_wrap_state = 0

    	Idle

    .. data:: wrapped_state = 1

    	Wrapped

    .. data:: locked_out_wrap_state = 2

    	Locked out

    .. data:: unknown_wrap_state = 3

    	UNKNOWN

    """

    idle_wrap_state = Enum.YLeaf(0, "idle-wrap-state")

    wrapped_state = Enum.YLeaf(1, "wrapped-state")

    locked_out_wrap_state = Enum.YLeaf(2, "locked-out-wrap-state")

    unknown_wrap_state = Enum.YLeaf(3, "unknown-wrap-state")


class SrpMgmtSrrFailure(Enum):
    """
    SrpMgmtSrrFailure

    SRP SRR failure type

    .. data:: idle_srr_failure = 0

    	Idle

    .. data:: wait_to_restore_srr_failure = 1

    	Wait To Restore

    .. data:: signal_fail_srr_failure = 2

    	Signal Fail

    .. data:: forced_switch_srr_failure = 3

    	Forced Switch

    .. data:: unknown_srr_failure = 4

    	UNKNOWN

    """

    idle_srr_failure = Enum.YLeaf(0, "idle-srr-failure")

    wait_to_restore_srr_failure = Enum.YLeaf(1, "wait-to-restore-srr-failure")

    signal_fail_srr_failure = Enum.YLeaf(2, "signal-fail-srr-failure")

    forced_switch_srr_failure = Enum.YLeaf(3, "forced-switch-srr-failure")

    unknown_srr_failure = Enum.YLeaf(4, "unknown-srr-failure")


class SrpMgmtSrrNodeState(Enum):
    """
    SrpMgmtSrrNodeState

    SRP SRR node state

    .. data:: idle_srr_state = 0

    	Idle

    .. data:: discovery_srr_state = 1

    	Discovery

    .. data:: unknown_srr_state = 2

    	UNKNOWN

    """

    idle_srr_state = Enum.YLeaf(0, "idle-srr-state")

    discovery_srr_state = Enum.YLeaf(1, "discovery-srr-state")

    unknown_srr_state = Enum.YLeaf(2, "unknown-srr-state")


class StatsCounter(Enum):
    """
    StatsCounter

    Stats counter

    .. data:: stats_counter_rate = 0

    	stats counter rate

    .. data:: stats_counter_uint32 = 1

    	stats counter uint32

    .. data:: stats_counter_uint64 = 2

    	stats counter uint64

    .. data:: stats_counter_generic = 3

    	stats counter generic

    .. data:: stats_counter_proto = 4

    	stats counter proto

    .. data:: stats_counter_srp = 5

    	stats counter srp

    .. data:: stats_counter_ipv4_prec = 6

    	stats counter ipv4 prec

    .. data:: stats_counter_ipv4_dscp = 7

    	stats counter ipv4 dscp

    .. data:: stats_counter_mpls_exp = 8

    	stats counter mpls exp

    .. data:: stats_counter_ipv4_bgppa = 9

    	stats counter ipv4 bgppa

    .. data:: stats_counter_src_bgppa = 10

    	stats counter src bgppa

    .. data:: stats_counter_basic = 11

    	stats counter basic

    .. data:: stats_counter_comp_generic = 12

    	stats counter comp generic

    .. data:: stats_counter_comp_proto = 13

    	stats counter comp proto

    .. data:: stats_counter_comp_basic = 14

    	stats counter comp basic

    .. data:: stats_counter_accounting = 15

    	stats counter accounting

    .. data:: stats_counter_comp_accounting = 16

    	stats counter comp accounting

    .. data:: stats_counter_flow = 17

    	stats counter flow

    .. data:: stats_counter_comp_flow = 18

    	stats counter comp flow

    """

    stats_counter_rate = Enum.YLeaf(0, "stats-counter-rate")

    stats_counter_uint32 = Enum.YLeaf(1, "stats-counter-uint32")

    stats_counter_uint64 = Enum.YLeaf(2, "stats-counter-uint64")

    stats_counter_generic = Enum.YLeaf(3, "stats-counter-generic")

    stats_counter_proto = Enum.YLeaf(4, "stats-counter-proto")

    stats_counter_srp = Enum.YLeaf(5, "stats-counter-srp")

    stats_counter_ipv4_prec = Enum.YLeaf(6, "stats-counter-ipv4-prec")

    stats_counter_ipv4_dscp = Enum.YLeaf(7, "stats-counter-ipv4-dscp")

    stats_counter_mpls_exp = Enum.YLeaf(8, "stats-counter-mpls-exp")

    stats_counter_ipv4_bgppa = Enum.YLeaf(9, "stats-counter-ipv4-bgppa")

    stats_counter_src_bgppa = Enum.YLeaf(10, "stats-counter-src-bgppa")

    stats_counter_basic = Enum.YLeaf(11, "stats-counter-basic")

    stats_counter_comp_generic = Enum.YLeaf(12, "stats-counter-comp-generic")

    stats_counter_comp_proto = Enum.YLeaf(13, "stats-counter-comp-proto")

    stats_counter_comp_basic = Enum.YLeaf(14, "stats-counter-comp-basic")

    stats_counter_accounting = Enum.YLeaf(15, "stats-counter-accounting")

    stats_counter_comp_accounting = Enum.YLeaf(16, "stats-counter-comp-accounting")

    stats_counter_flow = Enum.YLeaf(17, "stats-counter-flow")

    stats_counter_comp_flow = Enum.YLeaf(18, "stats-counter-comp-flow")


class StatsId(Enum):
    """
    StatsId

    Stats id

    .. data:: stats_id_type_unknown = 0

    	stats id type unknown

    .. data:: stats_id_type_min = 1

    	stats id type min

    .. data:: stats_id_type_spare = 2

    	stats id type spare

    .. data:: stats_id_type_node = 3

    	stats id type node

    .. data:: stats_id_type_other = 4

    	stats id type other

    .. data:: stats_id_type_feature = 5

    	stats id type feature

    .. data:: stats_id_type_max = 6

    	stats id type max

    """

    stats_id_type_unknown = Enum.YLeaf(0, "stats-id-type-unknown")

    stats_id_type_min = Enum.YLeaf(1, "stats-id-type-min")

    stats_id_type_spare = Enum.YLeaf(2, "stats-id-type-spare")

    stats_id_type_node = Enum.YLeaf(3, "stats-id-type-node")

    stats_id_type_other = Enum.YLeaf(4, "stats-id-type-other")

    stats_id_type_feature = Enum.YLeaf(5, "stats-id-type-feature")

    stats_id_type_max = Enum.YLeaf(6, "stats-id-type-max")


class StatsTypeContents(Enum):
    """
    StatsTypeContents

    Stats type contents

    .. data:: stats_type_single = 100

    	stats type single

    .. data:: stats_type_variable = 101

    	stats type variable

    """

    stats_type_single = Enum.YLeaf(100, "stats-type-single")

    stats_type_variable = Enum.YLeaf(101, "stats-type-variable")


class TunlPfiAfId(Enum):
    """
    TunlPfiAfId

    Tunl pfi af id

    .. data:: tunl_pfi_af_id_none = 0

    	Unspecified AFI

    .. data:: tunl_pfi_af_id_ipv4 = 2

    	IPv4 AFI

    .. data:: tunl_pfi_af_id_ipv6 = 10

    	IPv6 AFI

    """

    tunl_pfi_af_id_none = Enum.YLeaf(0, "tunl-pfi-af-id-none")

    tunl_pfi_af_id_ipv4 = Enum.YLeaf(2, "tunl-pfi-af-id-ipv4")

    tunl_pfi_af_id_ipv6 = Enum.YLeaf(10, "tunl-pfi-af-id-ipv6")


class TunnelGreMode(Enum):
    """
    TunnelGreMode

    Tunnel gre mode

    .. data:: unknown = 0

    	Tunnel GRE mode is Unknown

    .. data:: gr_eo_ipv4 = 1

    	Tunnel GRE Mode is IPv4

    .. data:: gr_eo_ipv6 = 2

    	Tunnel GRE Mode is IPv6

    .. data:: mgr_eo_ipv4 = 3

    	Tunnel MGRE Mode is IPv4

    .. data:: mgr_eo_ipv6 = 4

    	Tunnel MGRE Mode is IPv6

    .. data:: ipv4 = 5

    	Tunnel Mode is IPv4

    .. data:: ipv6 = 6

    	Tunnel Mode is IPv6

    """

    unknown = Enum.YLeaf(0, "unknown")

    gr_eo_ipv4 = Enum.YLeaf(1, "gr-eo-ipv4")

    gr_eo_ipv6 = Enum.YLeaf(2, "gr-eo-ipv6")

    mgr_eo_ipv4 = Enum.YLeaf(3, "mgr-eo-ipv4")

    mgr_eo_ipv6 = Enum.YLeaf(4, "mgr-eo-ipv6")

    ipv4 = Enum.YLeaf(5, "ipv4")

    ipv6 = Enum.YLeaf(6, "ipv6")


class TunnelKaDfState(Enum):
    """
    TunnelKaDfState

    Tunnel ka df state

    .. data:: disable = 0

    	Tunnel GRE KA State is Disabled

    .. data:: enable = 1

    	Tunnel GRE KA State is Enabled

    """

    disable = Enum.YLeaf(0, "disable")

    enable = Enum.YLeaf(1, "enable")


class TunnelKeyState(Enum):
    """
    TunnelKeyState

    Tunnel key state

    .. data:: absent = 0

    	Tunnel GRE Key is not present

    .. data:: present = 1

    	Tunnel GRE Key is present

    """

    absent = Enum.YLeaf(0, "absent")

    present = Enum.YLeaf(1, "present")


class VlanEncaps(Enum):
    """
    VlanEncaps

    VLAN encapsulation

    .. data:: no_encapsulation = 0

    	No encapsulation

    .. data:: dot1q = 1

    	IEEE 802.1Q encapsulation

    .. data:: qinq = 2

    	Double 802.1Q encapsulation

    .. data:: qin_any = 3

    	Double 802.1Q wildcarded encapsulation

    .. data:: dot1q_native = 4

    	IEEE 802.1Q native VLAN encapsulation

    .. data:: dot1ad = 5

    	IEEE 802.1ad encapsulation

    .. data:: dot1ad_native = 6

    	IEEE 802.1ad native VLAN encapsulation

    .. data:: service_instance = 7

    	Ethernet Service Instance

    .. data:: dot1ad_dot1q = 8

    	IEEE 802.1ad 802.1Q encapsulation

    .. data:: dot1ad_any = 9

    	IEEE 802.1ad wildcard 802.1Q encapsulation

    """

    no_encapsulation = Enum.YLeaf(0, "no-encapsulation")

    dot1q = Enum.YLeaf(1, "dot1q")

    qinq = Enum.YLeaf(2, "qinq")

    qin_any = Enum.YLeaf(3, "qin-any")

    dot1q_native = Enum.YLeaf(4, "dot1q-native")

    dot1ad = Enum.YLeaf(5, "dot1ad")

    dot1ad_native = Enum.YLeaf(6, "dot1ad-native")

    service_instance = Enum.YLeaf(7, "service-instance")

    dot1ad_dot1q = Enum.YLeaf(8, "dot1ad-dot1q")

    dot1ad_any = Enum.YLeaf(9, "dot1ad-any")



class Interfaces(Entity):
    """
    Interface operational data
    
    .. attribute:: interface_briefs
    
    	Brief operational data for interfaces
    	**type**\:   :py:class:`InterfaceBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceBriefs>`
    
    .. attribute:: interface_summary
    
    	Interface summary information
    	**type**\:   :py:class:`InterfaceSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceSummary>`
    
    .. attribute:: interface_xr
    
    	Detailed operational data for interfaces and configured features
    	**type**\:   :py:class:`InterfaceXr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr>`
    
    .. attribute:: interfaces
    
    	Descriptions for interfaces
    	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.Interfaces>`
    
    .. attribute:: inventory_summary
    
    	Inventory summary information
    	**type**\:   :py:class:`InventorySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InventorySummary>`
    
    .. attribute:: node_type_sets
    
    	Node and/or interface type specific view of interface summary data
    	**type**\:   :py:class:`NodeTypeSets <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.NodeTypeSets>`
    
    

    """

    _prefix = 'pfi-im-cmd-oper'
    _revision = '2016-12-18'

    def __init__(self):
        super(Interfaces, self).__init__()
        self._top_entity = None

        self.yang_name = "interfaces"
        self.yang_parent_name = "Cisco-IOS-XR-pfi-im-cmd-oper"

        self.interface_briefs = Interfaces.InterfaceBriefs()
        self.interface_briefs.parent = self
        self._children_name_map["interface_briefs"] = "interface-briefs"
        self._children_yang_names.add("interface-briefs")

        self.interface_summary = Interfaces.InterfaceSummary()
        self.interface_summary.parent = self
        self._children_name_map["interface_summary"] = "interface-summary"
        self._children_yang_names.add("interface-summary")

        self.interface_xr = Interfaces.InterfaceXr()
        self.interface_xr.parent = self
        self._children_name_map["interface_xr"] = "interface-xr"
        self._children_yang_names.add("interface-xr")

        self.interfaces = Interfaces.Interfaces()
        self.interfaces.parent = self
        self._children_name_map["interfaces"] = "interfaces"
        self._children_yang_names.add("interfaces")

        self.inventory_summary = Interfaces.InventorySummary()
        self.inventory_summary.parent = self
        self._children_name_map["inventory_summary"] = "inventory-summary"
        self._children_yang_names.add("inventory-summary")

        self.node_type_sets = Interfaces.NodeTypeSets()
        self.node_type_sets.parent = self
        self._children_name_map["node_type_sets"] = "node-type-sets"
        self._children_yang_names.add("node-type-sets")


    class InterfaceXr(Entity):
        """
        Detailed operational data for interfaces and
        configured features
        
        .. attribute:: interface
        
        	Detailed operational data for a particular interface
        	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface>`
        
        

        """

        _prefix = 'pfi-im-cmd-oper'
        _revision = '2016-12-18'

        def __init__(self):
            super(Interfaces.InterfaceXr, self).__init__()

            self.yang_name = "interface-xr"
            self.yang_parent_name = "interfaces"

            self.interface = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Interfaces.InterfaceXr, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Interfaces.InterfaceXr, self).__setattr__(name, value)


        class Interface(Entity):
            """
            Detailed operational data for a particular
            interface
            
            .. attribute:: interface_name  <key>
            
            	The name of the interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: arp_information
            
            	Interface ARP type and timeout
            	**type**\:   :py:class:`ArpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.ArpInformation>`
            
            .. attribute:: bandwidth
            
            	Interface bandwidth (Kb/s)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: burned_in_address
            
            	Interface burned in address
            	**type**\:   :py:class:`BurnedInAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.BurnedInAddress>`
            
            .. attribute:: carrier_delay
            
            	Carrier Delay
            	**type**\:   :py:class:`CarrierDelay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.CarrierDelay>`
            
            .. attribute:: crc_length
            
            	Cyclic Redundancy Check length
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: dampening_information
            
            	State dampening information
            	**type**\:   :py:class:`DampeningInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.DampeningInformation>`
            
            .. attribute:: data_rates
            
            	Packet and byte rates
            	**type**\:   :py:class:`DataRates <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.DataRates>`
            
            .. attribute:: description
            
            	Interface description string
            	**type**\:  str
            
            .. attribute:: duplexity
            
            	Interface duplexity
            	**type**\:   :py:class:`ImAttrDuplex <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImAttrDuplex>`
            
            .. attribute:: encapsulation
            
            	Interface encapsulation
            	**type**\:  str
            
            .. attribute:: encapsulation_information
            
            	Information specific to the encapsulation
            	**type**\:   :py:class:`EncapsulationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation>`
            
            .. attribute:: encapsulation_type_string
            
            	Interface encapsulation description string
            	**type**\:  str
            
            	**length:** 0..32
            
            .. attribute:: hardware_type_string
            
            	Hardware type description string
            	**type**\:  str
            
            	**length:** 0..64
            
            .. attribute:: if_index
            
            	This is not supposed to be used. It is a dummy attribute to support ifindex for OC model
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: in_flow_control
            
            	Input flow control configuration
            	**type**\:   :py:class:`ImAttrFlowControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImAttrFlowControl>`
            
            .. attribute:: interface_handle
            
            	Interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: interface_statistics
            
            	Packet, byte and error counters
            	**type**\:   :py:class:`InterfaceStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceStatistics>`
            
            .. attribute:: interface_type
            
            	Interface type
            	**type**\:  str
            
            .. attribute:: interface_type_information
            
            	Information specific to the interface type
            	**type**\:   :py:class:`InterfaceTypeInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation>`
            
            .. attribute:: ip_information
            
            	Interface IP address info
            	**type**\:   :py:class:`IpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.IpInformation>`
            
            .. attribute:: is_dampening_enabled
            
            	Dampening enabled flag
            	**type**\:  bool
            
            .. attribute:: is_data_inverted
            
            	Data invert flag
            	**type**\:  bool
            
            .. attribute:: is_l2_looped
            
            	Loopback detected by layer 2
            	**type**\:  bool
            
            .. attribute:: is_l2_transport_enabled
            
            	L2 transport flag
            	**type**\:  bool
            
            .. attribute:: is_maintenance_enabled
            
            	Maintenance embargo flag
            	**type**\:  bool
            
            .. attribute:: is_scramble_enabled
            
            	Interface scramble config
            	**type**\:  bool
            
            .. attribute:: keepalive
            
            	Interface keepalive time (s)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: l2_interface_statistics
            
            	L2 Protocol Statistics
            	**type**\:   :py:class:`L2InterfaceStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.L2InterfaceStatistics>`
            
            .. attribute:: last_state_transition_time
            
            	The time elasped after the last state transition
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: line_state
            
            	Line protocol state
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            .. attribute:: link_type
            
            	Interface link type
            	**type**\:   :py:class:`ImAttrLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImAttrLink>`
            
            .. attribute:: loopback_configuration
            
            	Interface loopback configuration
            	**type**\:   :py:class:`ImCmdLoopbackEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImCmdLoopbackEnum>`
            
            .. attribute:: mac_address
            
            	Interface MAC address
            	**type**\:   :py:class:`MacAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.MacAddress>`
            
            .. attribute:: max_bandwidth
            
            	Maximum Interface bandwidth (Kb/s)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: media_type
            
            	Interface media type
            	**type**\:   :py:class:`ImAttrMedia <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImAttrMedia>`
            
            .. attribute:: mtu
            
            	MTU in bytes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: byte
            
            .. attribute:: nv_optical
            
            	nV Optical Controller Information
            	**type**\:   :py:class:`NvOptical <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.NvOptical>`
            
            .. attribute:: out_flow_control
            
            	Output flow control configuration
            	**type**\:   :py:class:`ImAttrFlowControl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImAttrFlowControl>`
            
            .. attribute:: parent_interface_name
            
            	Parent interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: speed
            
            	Interface speed (Kb/s)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: state
            
            	Interface state
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            .. attribute:: state_transition_count
            
            	The number of times the state has changed
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: transport_mode
            
            	Interface transport mode
            	**type**\:   :py:class:`ImAttrTransportMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImAttrTransportMode>`
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.InterfaceXr.Interface, self).__init__()

                self.yang_name = "interface"
                self.yang_parent_name = "interface-xr"

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                self.crc_length = YLeaf(YType.uint32, "crc-length")

                self.description = YLeaf(YType.str, "description")

                self.duplexity = YLeaf(YType.enumeration, "duplexity")

                self.encapsulation = YLeaf(YType.str, "encapsulation")

                self.encapsulation_type_string = YLeaf(YType.str, "encapsulation-type-string")

                self.hardware_type_string = YLeaf(YType.str, "hardware-type-string")

                self.if_index = YLeaf(YType.uint32, "if-index")

                self.in_flow_control = YLeaf(YType.enumeration, "in-flow-control")

                self.interface_handle = YLeaf(YType.str, "interface-handle")

                self.interface_type = YLeaf(YType.str, "interface-type")

                self.is_dampening_enabled = YLeaf(YType.boolean, "is-dampening-enabled")

                self.is_data_inverted = YLeaf(YType.boolean, "is-data-inverted")

                self.is_l2_looped = YLeaf(YType.boolean, "is-l2-looped")

                self.is_l2_transport_enabled = YLeaf(YType.boolean, "is-l2-transport-enabled")

                self.is_maintenance_enabled = YLeaf(YType.boolean, "is-maintenance-enabled")

                self.is_scramble_enabled = YLeaf(YType.boolean, "is-scramble-enabled")

                self.keepalive = YLeaf(YType.uint32, "keepalive")

                self.last_state_transition_time = YLeaf(YType.uint32, "last-state-transition-time")

                self.line_state = YLeaf(YType.enumeration, "line-state")

                self.link_type = YLeaf(YType.enumeration, "link-type")

                self.loopback_configuration = YLeaf(YType.enumeration, "loopback-configuration")

                self.max_bandwidth = YLeaf(YType.uint32, "max-bandwidth")

                self.media_type = YLeaf(YType.enumeration, "media-type")

                self.mtu = YLeaf(YType.uint32, "mtu")

                self.out_flow_control = YLeaf(YType.enumeration, "out-flow-control")

                self.parent_interface_name = YLeaf(YType.str, "parent-interface-name")

                self.speed = YLeaf(YType.uint32, "speed")

                self.state = YLeaf(YType.enumeration, "state")

                self.state_transition_count = YLeaf(YType.uint32, "state-transition-count")

                self.transport_mode = YLeaf(YType.enumeration, "transport-mode")

                self.arp_information = Interfaces.InterfaceXr.Interface.ArpInformation()
                self.arp_information.parent = self
                self._children_name_map["arp_information"] = "arp-information"
                self._children_yang_names.add("arp-information")

                self.burned_in_address = Interfaces.InterfaceXr.Interface.BurnedInAddress()
                self.burned_in_address.parent = self
                self._children_name_map["burned_in_address"] = "burned-in-address"
                self._children_yang_names.add("burned-in-address")

                self.carrier_delay = Interfaces.InterfaceXr.Interface.CarrierDelay()
                self.carrier_delay.parent = self
                self._children_name_map["carrier_delay"] = "carrier-delay"
                self._children_yang_names.add("carrier-delay")

                self.dampening_information = Interfaces.InterfaceXr.Interface.DampeningInformation()
                self.dampening_information.parent = self
                self._children_name_map["dampening_information"] = "dampening-information"
                self._children_yang_names.add("dampening-information")

                self.data_rates = Interfaces.InterfaceXr.Interface.DataRates()
                self.data_rates.parent = self
                self._children_name_map["data_rates"] = "data-rates"
                self._children_yang_names.add("data-rates")

                self.encapsulation_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation()
                self.encapsulation_information.parent = self
                self._children_name_map["encapsulation_information"] = "encapsulation-information"
                self._children_yang_names.add("encapsulation-information")

                self.interface_statistics = Interfaces.InterfaceXr.Interface.InterfaceStatistics()
                self.interface_statistics.parent = self
                self._children_name_map["interface_statistics"] = "interface-statistics"
                self._children_yang_names.add("interface-statistics")

                self.interface_type_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation()
                self.interface_type_information.parent = self
                self._children_name_map["interface_type_information"] = "interface-type-information"
                self._children_yang_names.add("interface-type-information")

                self.ip_information = Interfaces.InterfaceXr.Interface.IpInformation()
                self.ip_information.parent = self
                self._children_name_map["ip_information"] = "ip-information"
                self._children_yang_names.add("ip-information")

                self.l2_interface_statistics = Interfaces.InterfaceXr.Interface.L2InterfaceStatistics()
                self.l2_interface_statistics.parent = self
                self._children_name_map["l2_interface_statistics"] = "l2-interface-statistics"
                self._children_yang_names.add("l2-interface-statistics")

                self.mac_address = Interfaces.InterfaceXr.Interface.MacAddress()
                self.mac_address.parent = self
                self._children_name_map["mac_address"] = "mac-address"
                self._children_yang_names.add("mac-address")

                self.nv_optical = Interfaces.InterfaceXr.Interface.NvOptical()
                self.nv_optical.parent = self
                self._children_name_map["nv_optical"] = "nv-optical"
                self._children_yang_names.add("nv-optical")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface_name",
                                "bandwidth",
                                "crc_length",
                                "description",
                                "duplexity",
                                "encapsulation",
                                "encapsulation_type_string",
                                "hardware_type_string",
                                "if_index",
                                "in_flow_control",
                                "interface_handle",
                                "interface_type",
                                "is_dampening_enabled",
                                "is_data_inverted",
                                "is_l2_looped",
                                "is_l2_transport_enabled",
                                "is_maintenance_enabled",
                                "is_scramble_enabled",
                                "keepalive",
                                "last_state_transition_time",
                                "line_state",
                                "link_type",
                                "loopback_configuration",
                                "max_bandwidth",
                                "media_type",
                                "mtu",
                                "out_flow_control",
                                "parent_interface_name",
                                "speed",
                                "state",
                                "state_transition_count",
                                "transport_mode") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.InterfaceXr.Interface, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.InterfaceXr.Interface, self).__setattr__(name, value)


            class DampeningInformation(Entity):
                """
                State dampening information
                
                .. attribute:: half_life
                
                	Configured decay half life in mins
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: minute
                
                .. attribute:: is_suppressed_enabled
                
                	Flag showing if state is suppressed
                	**type**\:  bool
                
                .. attribute:: maximum_suppress_time
                
                	Maximum suppress time in mins
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: minute
                
                .. attribute:: penalty
                
                	Dampening penalty of the interface
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: restart_penalty
                
                	Configured restart penalty
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: reuse_threshold
                
                	Configured reuse threshold
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: seconds_remaining
                
                	Remaining period of suppression in secs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: suppress_threshold
                
                	Value of suppress threshold
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.DampeningInformation, self).__init__()

                    self.yang_name = "dampening-information"
                    self.yang_parent_name = "interface"

                    self.half_life = YLeaf(YType.uint32, "half-life")

                    self.is_suppressed_enabled = YLeaf(YType.boolean, "is-suppressed-enabled")

                    self.maximum_suppress_time = YLeaf(YType.uint32, "maximum-suppress-time")

                    self.penalty = YLeaf(YType.uint32, "penalty")

                    self.restart_penalty = YLeaf(YType.uint32, "restart-penalty")

                    self.reuse_threshold = YLeaf(YType.uint32, "reuse-threshold")

                    self.seconds_remaining = YLeaf(YType.uint32, "seconds-remaining")

                    self.suppress_threshold = YLeaf(YType.uint32, "suppress-threshold")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("half_life",
                                    "is_suppressed_enabled",
                                    "maximum_suppress_time",
                                    "penalty",
                                    "restart_penalty",
                                    "reuse_threshold",
                                    "seconds_remaining",
                                    "suppress_threshold") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.DampeningInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.DampeningInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.half_life.is_set or
                        self.is_suppressed_enabled.is_set or
                        self.maximum_suppress_time.is_set or
                        self.penalty.is_set or
                        self.restart_penalty.is_set or
                        self.reuse_threshold.is_set or
                        self.seconds_remaining.is_set or
                        self.suppress_threshold.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.half_life.yfilter != YFilter.not_set or
                        self.is_suppressed_enabled.yfilter != YFilter.not_set or
                        self.maximum_suppress_time.yfilter != YFilter.not_set or
                        self.penalty.yfilter != YFilter.not_set or
                        self.restart_penalty.yfilter != YFilter.not_set or
                        self.reuse_threshold.yfilter != YFilter.not_set or
                        self.seconds_remaining.yfilter != YFilter.not_set or
                        self.suppress_threshold.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "dampening-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.half_life.is_set or self.half_life.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.half_life.get_name_leafdata())
                    if (self.is_suppressed_enabled.is_set or self.is_suppressed_enabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_suppressed_enabled.get_name_leafdata())
                    if (self.maximum_suppress_time.is_set or self.maximum_suppress_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.maximum_suppress_time.get_name_leafdata())
                    if (self.penalty.is_set or self.penalty.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.penalty.get_name_leafdata())
                    if (self.restart_penalty.is_set or self.restart_penalty.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.restart_penalty.get_name_leafdata())
                    if (self.reuse_threshold.is_set or self.reuse_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reuse_threshold.get_name_leafdata())
                    if (self.seconds_remaining.is_set or self.seconds_remaining.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.seconds_remaining.get_name_leafdata())
                    if (self.suppress_threshold.is_set or self.suppress_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.suppress_threshold.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "half-life" or name == "is-suppressed-enabled" or name == "maximum-suppress-time" or name == "penalty" or name == "restart-penalty" or name == "reuse-threshold" or name == "seconds-remaining" or name == "suppress-threshold"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "half-life"):
                        self.half_life = value
                        self.half_life.value_namespace = name_space
                        self.half_life.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-suppressed-enabled"):
                        self.is_suppressed_enabled = value
                        self.is_suppressed_enabled.value_namespace = name_space
                        self.is_suppressed_enabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "maximum-suppress-time"):
                        self.maximum_suppress_time = value
                        self.maximum_suppress_time.value_namespace = name_space
                        self.maximum_suppress_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "penalty"):
                        self.penalty = value
                        self.penalty.value_namespace = name_space
                        self.penalty.value_namespace_prefix = name_space_prefix
                    if(value_path == "restart-penalty"):
                        self.restart_penalty = value
                        self.restart_penalty.value_namespace = name_space
                        self.restart_penalty.value_namespace_prefix = name_space_prefix
                    if(value_path == "reuse-threshold"):
                        self.reuse_threshold = value
                        self.reuse_threshold.value_namespace = name_space
                        self.reuse_threshold.value_namespace_prefix = name_space_prefix
                    if(value_path == "seconds-remaining"):
                        self.seconds_remaining = value
                        self.seconds_remaining.value_namespace = name_space
                        self.seconds_remaining.value_namespace_prefix = name_space_prefix
                    if(value_path == "suppress-threshold"):
                        self.suppress_threshold = value
                        self.suppress_threshold.value_namespace = name_space
                        self.suppress_threshold.value_namespace_prefix = name_space_prefix


            class MacAddress(Entity):
                """
                Interface MAC address
                
                .. attribute:: address
                
                	MAC Address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.MacAddress, self).__init__()

                    self.yang_name = "mac-address"
                    self.yang_parent_name = "interface"

                    self.address = YLeaf(YType.str, "address")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("address") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.MacAddress, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.MacAddress, self).__setattr__(name, value)

                def has_data(self):
                    return self.address.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.address.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mac-address" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "address"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "address"):
                        self.address = value
                        self.address.value_namespace = name_space
                        self.address.value_namespace_prefix = name_space_prefix


            class BurnedInAddress(Entity):
                """
                Interface burned in address
                
                .. attribute:: address
                
                	MAC Address
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.BurnedInAddress, self).__init__()

                    self.yang_name = "burned-in-address"
                    self.yang_parent_name = "interface"

                    self.address = YLeaf(YType.str, "address")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("address") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.BurnedInAddress, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.BurnedInAddress, self).__setattr__(name, value)

                def has_data(self):
                    return self.address.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.address.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "burned-in-address" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "address"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "address"):
                        self.address = value
                        self.address.value_namespace = name_space
                        self.address.value_namespace_prefix = name_space_prefix


            class CarrierDelay(Entity):
                """
                Carrier Delay
                
                .. attribute:: carrier_delay_down
                
                	Carrier delay on state down (ms)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: carrier_delay_up
                
                	Carrier delay on state up (ms)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.CarrierDelay, self).__init__()

                    self.yang_name = "carrier-delay"
                    self.yang_parent_name = "interface"

                    self.carrier_delay_down = YLeaf(YType.uint32, "carrier-delay-down")

                    self.carrier_delay_up = YLeaf(YType.uint32, "carrier-delay-up")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("carrier_delay_down",
                                    "carrier_delay_up") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.CarrierDelay, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.CarrierDelay, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.carrier_delay_down.is_set or
                        self.carrier_delay_up.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.carrier_delay_down.yfilter != YFilter.not_set or
                        self.carrier_delay_up.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "carrier-delay" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.carrier_delay_down.is_set or self.carrier_delay_down.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.carrier_delay_down.get_name_leafdata())
                    if (self.carrier_delay_up.is_set or self.carrier_delay_up.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.carrier_delay_up.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "carrier-delay-down" or name == "carrier-delay-up"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "carrier-delay-down"):
                        self.carrier_delay_down = value
                        self.carrier_delay_down.value_namespace = name_space
                        self.carrier_delay_down.value_namespace_prefix = name_space_prefix
                    if(value_path == "carrier-delay-up"):
                        self.carrier_delay_up = value
                        self.carrier_delay_up.value_namespace = name_space
                        self.carrier_delay_up.value_namespace_prefix = name_space_prefix


            class ArpInformation(Entity):
                """
                Interface ARP type and timeout
                
                .. attribute:: arp_is_learning_disabled
                
                	Whether the interface has dynamic learning disabled
                	**type**\:  bool
                
                .. attribute:: arp_timeout
                
                	ARP timeout in seconds. Only valid if 'ARPIsLearningDisabled' is 'false'
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                .. attribute:: arp_type_name
                
                	ARP type name
                	**type**\:  str
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.ArpInformation, self).__init__()

                    self.yang_name = "arp-information"
                    self.yang_parent_name = "interface"

                    self.arp_is_learning_disabled = YLeaf(YType.boolean, "arp-is-learning-disabled")

                    self.arp_timeout = YLeaf(YType.uint32, "arp-timeout")

                    self.arp_type_name = YLeaf(YType.str, "arp-type-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("arp_is_learning_disabled",
                                    "arp_timeout",
                                    "arp_type_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.ArpInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.ArpInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.arp_is_learning_disabled.is_set or
                        self.arp_timeout.is_set or
                        self.arp_type_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.arp_is_learning_disabled.yfilter != YFilter.not_set or
                        self.arp_timeout.yfilter != YFilter.not_set or
                        self.arp_type_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "arp-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.arp_is_learning_disabled.is_set or self.arp_is_learning_disabled.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.arp_is_learning_disabled.get_name_leafdata())
                    if (self.arp_timeout.is_set or self.arp_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.arp_timeout.get_name_leafdata())
                    if (self.arp_type_name.is_set or self.arp_type_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.arp_type_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "arp-is-learning-disabled" or name == "arp-timeout" or name == "arp-type-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "arp-is-learning-disabled"):
                        self.arp_is_learning_disabled = value
                        self.arp_is_learning_disabled.value_namespace = name_space
                        self.arp_is_learning_disabled.value_namespace_prefix = name_space_prefix
                    if(value_path == "arp-timeout"):
                        self.arp_timeout = value
                        self.arp_timeout.value_namespace = name_space
                        self.arp_timeout.value_namespace_prefix = name_space_prefix
                    if(value_path == "arp-type-name"):
                        self.arp_type_name = value
                        self.arp_type_name.value_namespace = name_space
                        self.arp_type_name.value_namespace_prefix = name_space_prefix


            class IpInformation(Entity):
                """
                Interface IP address info
                
                .. attribute:: ip_address
                
                	Interface IPv4 address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: subnet_mask_length
                
                	Interface subnet mask length
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.IpInformation, self).__init__()

                    self.yang_name = "ip-information"
                    self.yang_parent_name = "interface"

                    self.ip_address = YLeaf(YType.str, "ip-address")

                    self.subnet_mask_length = YLeaf(YType.uint32, "subnet-mask-length")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ip_address",
                                    "subnet_mask_length") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.IpInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.IpInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.ip_address.is_set or
                        self.subnet_mask_length.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ip_address.yfilter != YFilter.not_set or
                        self.subnet_mask_length.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ip-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ip_address.is_set or self.ip_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ip_address.get_name_leafdata())
                    if (self.subnet_mask_length.is_set or self.subnet_mask_length.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.subnet_mask_length.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ip-address" or name == "subnet-mask-length"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ip-address"):
                        self.ip_address = value
                        self.ip_address.value_namespace = name_space
                        self.ip_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "subnet-mask-length"):
                        self.subnet_mask_length = value
                        self.subnet_mask_length.value_namespace = name_space
                        self.subnet_mask_length.value_namespace_prefix = name_space_prefix


            class EncapsulationInformation(Entity):
                """
                Information specific to the encapsulation
                
                .. attribute:: dot1q_information
                
                	VLAN 802.1q information
                	**type**\:   :py:class:`Dot1QInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation>`
                
                .. attribute:: encapsulation_type
                
                	EncapsulationType
                	**type**\:   :py:class:`ImCmdEncapsEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImCmdEncapsEnum>`
                
                .. attribute:: frame_relay_information
                
                	Frame Relay information
                	**type**\:   :py:class:`FrameRelayInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.FrameRelayInformation>`
                
                .. attribute:: ppp_information
                
                	PPP information
                	**type**\:   :py:class:`PppInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation>`
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation, self).__init__()

                    self.yang_name = "encapsulation-information"
                    self.yang_parent_name = "interface"

                    self.encapsulation_type = YLeaf(YType.enumeration, "encapsulation-type")

                    self.dot1q_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation()
                    self.dot1q_information.parent = self
                    self._children_name_map["dot1q_information"] = "dot1q-information"
                    self._children_yang_names.add("dot1q-information")

                    self.frame_relay_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation.FrameRelayInformation()
                    self.frame_relay_information.parent = self
                    self._children_name_map["frame_relay_information"] = "frame-relay-information"
                    self._children_yang_names.add("frame-relay-information")

                    self.ppp_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation()
                    self.ppp_information.parent = self
                    self._children_name_map["ppp_information"] = "ppp-information"
                    self._children_yang_names.add("ppp-information")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("encapsulation_type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation, self).__setattr__(name, value)


                class FrameRelayInformation(Entity):
                    """
                    Frame Relay information
                    
                    .. attribute:: enquiries_received
                    
                    	Number of enquiry messages received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: enquiries_sent
                    
                    	Number of enquiry messages sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: fr_encapsulation_type
                    
                    	Frame Relay encapsulation type
                    	**type**\:   :py:class:`ImCmdFrTypeEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImCmdFrTypeEnum>`
                    
                    .. attribute:: is_dte
                    
                    	The DTE/DCE LMI interface type
                    	**type**\:  bool
                    
                    .. attribute:: is_lmi_enabled
                    
                    	The status of FR LMI for an interface
                    	**type**\:  bool
                    
                    .. attribute:: is_lmi_nni_dce_up
                    
                    	Flag indicating whether the LMI  NNI\-DCE state is UP
                    	**type**\:  bool
                    
                    .. attribute:: is_lmi_up
                    
                    	Flag indicating whether the LMI  DTE/DCE/NNI\-DTE state is UP
                    	**type**\:  bool
                    
                    .. attribute:: is_nni
                    
                    	The NNI LMI interface type
                    	**type**\:  bool
                    
                    .. attribute:: lmi_type
                    
                    	The LMI type\: Autosense, ANSI, CCITT or CISCO
                    	**type**\:   :py:class:`ImCmdLmiTypeEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImCmdLmiTypeEnum>`
                    
                    .. attribute:: lmidlci
                    
                    	LMI DLCI
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: status_received
                    
                    	Number of status messages received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: status_sent
                    
                    	Number of status messages sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: update_status_received
                    
                    	Number of update status messages received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: update_status_sent
                    
                    	Number of update status messages sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.FrameRelayInformation, self).__init__()

                        self.yang_name = "frame-relay-information"
                        self.yang_parent_name = "encapsulation-information"

                        self.enquiries_received = YLeaf(YType.uint32, "enquiries-received")

                        self.enquiries_sent = YLeaf(YType.uint32, "enquiries-sent")

                        self.fr_encapsulation_type = YLeaf(YType.enumeration, "fr-encapsulation-type")

                        self.is_dte = YLeaf(YType.boolean, "is-dte")

                        self.is_lmi_enabled = YLeaf(YType.boolean, "is-lmi-enabled")

                        self.is_lmi_nni_dce_up = YLeaf(YType.boolean, "is-lmi-nni-dce-up")

                        self.is_lmi_up = YLeaf(YType.boolean, "is-lmi-up")

                        self.is_nni = YLeaf(YType.boolean, "is-nni")

                        self.lmi_type = YLeaf(YType.enumeration, "lmi-type")

                        self.lmidlci = YLeaf(YType.uint32, "lmidlci")

                        self.status_received = YLeaf(YType.uint32, "status-received")

                        self.status_sent = YLeaf(YType.uint32, "status-sent")

                        self.update_status_received = YLeaf(YType.uint32, "update-status-received")

                        self.update_status_sent = YLeaf(YType.uint32, "update-status-sent")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enquiries_received",
                                        "enquiries_sent",
                                        "fr_encapsulation_type",
                                        "is_dte",
                                        "is_lmi_enabled",
                                        "is_lmi_nni_dce_up",
                                        "is_lmi_up",
                                        "is_nni",
                                        "lmi_type",
                                        "lmidlci",
                                        "status_received",
                                        "status_sent",
                                        "update_status_received",
                                        "update_status_sent") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.FrameRelayInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.FrameRelayInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enquiries_received.is_set or
                            self.enquiries_sent.is_set or
                            self.fr_encapsulation_type.is_set or
                            self.is_dte.is_set or
                            self.is_lmi_enabled.is_set or
                            self.is_lmi_nni_dce_up.is_set or
                            self.is_lmi_up.is_set or
                            self.is_nni.is_set or
                            self.lmi_type.is_set or
                            self.lmidlci.is_set or
                            self.status_received.is_set or
                            self.status_sent.is_set or
                            self.update_status_received.is_set or
                            self.update_status_sent.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enquiries_received.yfilter != YFilter.not_set or
                            self.enquiries_sent.yfilter != YFilter.not_set or
                            self.fr_encapsulation_type.yfilter != YFilter.not_set or
                            self.is_dte.yfilter != YFilter.not_set or
                            self.is_lmi_enabled.yfilter != YFilter.not_set or
                            self.is_lmi_nni_dce_up.yfilter != YFilter.not_set or
                            self.is_lmi_up.yfilter != YFilter.not_set or
                            self.is_nni.yfilter != YFilter.not_set or
                            self.lmi_type.yfilter != YFilter.not_set or
                            self.lmidlci.yfilter != YFilter.not_set or
                            self.status_received.yfilter != YFilter.not_set or
                            self.status_sent.yfilter != YFilter.not_set or
                            self.update_status_received.yfilter != YFilter.not_set or
                            self.update_status_sent.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frame-relay-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enquiries_received.is_set or self.enquiries_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enquiries_received.get_name_leafdata())
                        if (self.enquiries_sent.is_set or self.enquiries_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enquiries_sent.get_name_leafdata())
                        if (self.fr_encapsulation_type.is_set or self.fr_encapsulation_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.fr_encapsulation_type.get_name_leafdata())
                        if (self.is_dte.is_set or self.is_dte.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_dte.get_name_leafdata())
                        if (self.is_lmi_enabled.is_set or self.is_lmi_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_lmi_enabled.get_name_leafdata())
                        if (self.is_lmi_nni_dce_up.is_set or self.is_lmi_nni_dce_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_lmi_nni_dce_up.get_name_leafdata())
                        if (self.is_lmi_up.is_set or self.is_lmi_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_lmi_up.get_name_leafdata())
                        if (self.is_nni.is_set or self.is_nni.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_nni.get_name_leafdata())
                        if (self.lmi_type.is_set or self.lmi_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lmi_type.get_name_leafdata())
                        if (self.lmidlci.is_set or self.lmidlci.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lmidlci.get_name_leafdata())
                        if (self.status_received.is_set or self.status_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.status_received.get_name_leafdata())
                        if (self.status_sent.is_set or self.status_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.status_sent.get_name_leafdata())
                        if (self.update_status_received.is_set or self.update_status_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.update_status_received.get_name_leafdata())
                        if (self.update_status_sent.is_set or self.update_status_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.update_status_sent.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enquiries-received" or name == "enquiries-sent" or name == "fr-encapsulation-type" or name == "is-dte" or name == "is-lmi-enabled" or name == "is-lmi-nni-dce-up" or name == "is-lmi-up" or name == "is-nni" or name == "lmi-type" or name == "lmidlci" or name == "status-received" or name == "status-sent" or name == "update-status-received" or name == "update-status-sent"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enquiries-received"):
                            self.enquiries_received = value
                            self.enquiries_received.value_namespace = name_space
                            self.enquiries_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "enquiries-sent"):
                            self.enquiries_sent = value
                            self.enquiries_sent.value_namespace = name_space
                            self.enquiries_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "fr-encapsulation-type"):
                            self.fr_encapsulation_type = value
                            self.fr_encapsulation_type.value_namespace = name_space
                            self.fr_encapsulation_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-dte"):
                            self.is_dte = value
                            self.is_dte.value_namespace = name_space
                            self.is_dte.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-lmi-enabled"):
                            self.is_lmi_enabled = value
                            self.is_lmi_enabled.value_namespace = name_space
                            self.is_lmi_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-lmi-nni-dce-up"):
                            self.is_lmi_nni_dce_up = value
                            self.is_lmi_nni_dce_up.value_namespace = name_space
                            self.is_lmi_nni_dce_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-lmi-up"):
                            self.is_lmi_up = value
                            self.is_lmi_up.value_namespace = name_space
                            self.is_lmi_up.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-nni"):
                            self.is_nni = value
                            self.is_nni.value_namespace = name_space
                            self.is_nni.value_namespace_prefix = name_space_prefix
                        if(value_path == "lmi-type"):
                            self.lmi_type = value
                            self.lmi_type.value_namespace = name_space
                            self.lmi_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "lmidlci"):
                            self.lmidlci = value
                            self.lmidlci.value_namespace = name_space
                            self.lmidlci.value_namespace_prefix = name_space_prefix
                        if(value_path == "status-received"):
                            self.status_received = value
                            self.status_received.value_namespace = name_space
                            self.status_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "status-sent"):
                            self.status_sent = value
                            self.status_sent.value_namespace = name_space
                            self.status_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "update-status-received"):
                            self.update_status_received = value
                            self.update_status_received.value_namespace = name_space
                            self.update_status_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "update-status-sent"):
                            self.update_status_sent = value
                            self.update_status_sent.value_namespace = name_space
                            self.update_status_sent.value_namespace_prefix = name_space_prefix


                class Dot1QInformation(Entity):
                    """
                    VLAN 802.1q information
                    
                    .. attribute:: encapsulation_details
                    
                    	Encapsulation type and tag stack
                    	**type**\:   :py:class:`EncapsulationDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails>`
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation, self).__init__()

                        self.yang_name = "dot1q-information"
                        self.yang_parent_name = "encapsulation-information"

                        self.encapsulation_details = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails()
                        self.encapsulation_details.parent = self
                        self._children_name_map["encapsulation_details"] = "encapsulation-details"
                        self._children_yang_names.add("encapsulation-details")


                    class EncapsulationDetails(Entity):
                        """
                        Encapsulation type and tag stack
                        
                        .. attribute:: dot1ad_dot1q_stack
                        
                        	802.1ad 802.1Q stack value
                        	**type**\:   :py:class:`Dot1AdDot1QStack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Dot1AdDot1QStack>`
                        
                        .. attribute:: dot1ad_native_tag
                        
                        	802.1ad native tag value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: dot1ad_outer_tag
                        
                        	802.1ad Outer tag value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: dot1ad_tag
                        
                        	802.1ad tag value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: native_tag
                        
                        	Native tag value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: outer_tag
                        
                        	Outer tag value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: service_instance_details
                        
                        	Service Instance encapsulation
                        	**type**\:   :py:class:`ServiceInstanceDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails>`
                        
                        .. attribute:: stack
                        
                        	Stack value
                        	**type**\:   :py:class:`Stack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Stack>`
                        
                        .. attribute:: tag
                        
                        	Tag value
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: vlan_encapsulation
                        
                        	VLANEncapsulation
                        	**type**\:   :py:class:`VlanEncaps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.VlanEncaps>`
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails, self).__init__()

                            self.yang_name = "encapsulation-details"
                            self.yang_parent_name = "dot1q-information"

                            self.dot1ad_native_tag = YLeaf(YType.uint16, "dot1ad-native-tag")

                            self.dot1ad_outer_tag = YLeaf(YType.uint16, "dot1ad-outer-tag")

                            self.dot1ad_tag = YLeaf(YType.uint16, "dot1ad-tag")

                            self.native_tag = YLeaf(YType.uint16, "native-tag")

                            self.outer_tag = YLeaf(YType.uint16, "outer-tag")

                            self.tag = YLeaf(YType.uint16, "tag")

                            self.vlan_encapsulation = YLeaf(YType.enumeration, "vlan-encapsulation")

                            self.dot1ad_dot1q_stack = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Dot1AdDot1QStack()
                            self.dot1ad_dot1q_stack.parent = self
                            self._children_name_map["dot1ad_dot1q_stack"] = "dot1ad-dot1q-stack"
                            self._children_yang_names.add("dot1ad-dot1q-stack")

                            self.service_instance_details = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails()
                            self.service_instance_details.parent = self
                            self._children_name_map["service_instance_details"] = "service-instance-details"
                            self._children_yang_names.add("service-instance-details")

                            self.stack = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Stack()
                            self.stack.parent = self
                            self._children_name_map["stack"] = "stack"
                            self._children_yang_names.add("stack")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("dot1ad_native_tag",
                                            "dot1ad_outer_tag",
                                            "dot1ad_tag",
                                            "native_tag",
                                            "outer_tag",
                                            "tag",
                                            "vlan_encapsulation") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails, self).__setattr__(name, value)


                        class Stack(Entity):
                            """
                            Stack value
                            
                            .. attribute:: outer_tag
                            
                            	Outer tag value
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: second_tag
                            
                            	Second tag value
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Stack, self).__init__()

                                self.yang_name = "stack"
                                self.yang_parent_name = "encapsulation-details"

                                self.outer_tag = YLeaf(YType.uint16, "outer-tag")

                                self.second_tag = YLeaf(YType.uint16, "second-tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("outer_tag",
                                                "second_tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Stack, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Stack, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.outer_tag.is_set or
                                    self.second_tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.outer_tag.yfilter != YFilter.not_set or
                                    self.second_tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "stack" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.outer_tag.is_set or self.outer_tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outer_tag.get_name_leafdata())
                                if (self.second_tag.is_set or self.second_tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.second_tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "outer-tag" or name == "second-tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "outer-tag"):
                                    self.outer_tag = value
                                    self.outer_tag.value_namespace = name_space
                                    self.outer_tag.value_namespace_prefix = name_space_prefix
                                if(value_path == "second-tag"):
                                    self.second_tag = value
                                    self.second_tag.value_namespace = name_space
                                    self.second_tag.value_namespace_prefix = name_space_prefix


                        class ServiceInstanceDetails(Entity):
                            """
                            Service Instance encapsulation
                            
                            .. attribute:: destination_mac_match
                            
                            	The destination MAC address to match on ingress
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: is_exact_match
                            
                            	Whether the packet must match the encapsulation exactly, with no further inner tags
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: is_native_preserving
                            
                            	Whether the native VLAN is customer\-tag preserving
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: is_native_vlan
                            
                            	Whether this represents the native VLAN on the port
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: local_traffic_stack
                            
                            	VLAN tags for locally\-sourced traffic
                            	**type**\:   :py:class:`LocalTrafficStack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack>`
                            
                            .. attribute:: payload_ethertype
                            
                            	Payload Ethertype to match
                            	**type**\:   :py:class:`EfpPayloadEtype <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.EfpPayloadEtype>`
                            
                            .. attribute:: pushe
                            
                            	VLAN tags pushed on egress
                            	**type**\: list of    :py:class:`Pushe <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.Pushe>`
                            
                            .. attribute:: source_mac_match
                            
                            	The source MAC address to match on ingress
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: tags_popped
                            
                            	Number of tags popped on ingress
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: tags_to_match
                            
                            	Tags to match on ingress packets
                            	**type**\: list of    :py:class:`TagsToMatch <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch>`
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails, self).__init__()

                                self.yang_name = "service-instance-details"
                                self.yang_parent_name = "encapsulation-details"

                                self.destination_mac_match = YLeaf(YType.str, "destination-mac-match")

                                self.is_exact_match = YLeaf(YType.int32, "is-exact-match")

                                self.is_native_preserving = YLeaf(YType.int32, "is-native-preserving")

                                self.is_native_vlan = YLeaf(YType.int32, "is-native-vlan")

                                self.payload_ethertype = YLeaf(YType.enumeration, "payload-ethertype")

                                self.source_mac_match = YLeaf(YType.str, "source-mac-match")

                                self.tags_popped = YLeaf(YType.uint16, "tags-popped")

                                self.local_traffic_stack = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack()
                                self.local_traffic_stack.parent = self
                                self._children_name_map["local_traffic_stack"] = "local-traffic-stack"
                                self._children_yang_names.add("local-traffic-stack")

                                self.pushe = YList(self)
                                self.tags_to_match = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("destination_mac_match",
                                                "is_exact_match",
                                                "is_native_preserving",
                                                "is_native_vlan",
                                                "payload_ethertype",
                                                "source_mac_match",
                                                "tags_popped") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails, self).__setattr__(name, value)


                            class LocalTrafficStack(Entity):
                                """
                                VLAN tags for locally\-sourced traffic
                                
                                .. attribute:: local_traffic_tag
                                
                                	VLAN tags for locally\-sourced traffic
                                	**type**\: list of    :py:class:`LocalTrafficTag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack.LocalTrafficTag>`
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack, self).__init__()

                                    self.yang_name = "local-traffic-stack"
                                    self.yang_parent_name = "service-instance-details"

                                    self.local_traffic_tag = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack, self).__setattr__(name, value)


                                class LocalTrafficTag(Entity):
                                    """
                                    VLAN tags for locally\-sourced traffic
                                    
                                    .. attribute:: ethertype
                                    
                                    	Ethertype of tag
                                    	**type**\:   :py:class:`EfpTagEtype <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.EfpTagEtype>`
                                    
                                    .. attribute:: vlan_id
                                    
                                    	VLAN Id
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    

                                    """

                                    _prefix = 'pfi-im-cmd-oper'
                                    _revision = '2016-12-18'

                                    def __init__(self):
                                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack.LocalTrafficTag, self).__init__()

                                        self.yang_name = "local-traffic-tag"
                                        self.yang_parent_name = "local-traffic-stack"

                                        self.ethertype = YLeaf(YType.enumeration, "ethertype")

                                        self.vlan_id = YLeaf(YType.uint16, "vlan-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("ethertype",
                                                        "vlan_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack.LocalTrafficTag, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack.LocalTrafficTag, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.ethertype.is_set or
                                            self.vlan_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.ethertype.yfilter != YFilter.not_set or
                                            self.vlan_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "local-traffic-tag" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.ethertype.is_set or self.ethertype.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ethertype.get_name_leafdata())
                                        if (self.vlan_id.is_set or self.vlan_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.vlan_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "ethertype" or name == "vlan-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "ethertype"):
                                            self.ethertype = value
                                            self.ethertype.value_namespace = name_space
                                            self.ethertype.value_namespace_prefix = name_space_prefix
                                        if(value_path == "vlan-id"):
                                            self.vlan_id = value
                                            self.vlan_id.value_namespace = name_space
                                            self.vlan_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.local_traffic_tag:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.local_traffic_tag:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "local-traffic-stack" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "local-traffic-tag"):
                                        for c in self.local_traffic_tag:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack.LocalTrafficTag()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.local_traffic_tag.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "local-traffic-tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class TagsToMatch(Entity):
                                """
                                Tags to match on ingress packets
                                
                                .. attribute:: ethertype
                                
                                	Ethertype of tag to match
                                	**type**\:   :py:class:`EfpTagEtype <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.EfpTagEtype>`
                                
                                .. attribute:: priority
                                
                                	Priority to match
                                	**type**\:   :py:class:`EfpTagPriority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.EfpTagPriority>`
                                
                                .. attribute:: vlan_range
                                
                                	VLAN Ids to match
                                	**type**\: list of    :py:class:`VlanRange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch.VlanRange>`
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch, self).__init__()

                                    self.yang_name = "tags-to-match"
                                    self.yang_parent_name = "service-instance-details"

                                    self.ethertype = YLeaf(YType.enumeration, "ethertype")

                                    self.priority = YLeaf(YType.enumeration, "priority")

                                    self.vlan_range = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ethertype",
                                                    "priority") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch, self).__setattr__(name, value)


                                class VlanRange(Entity):
                                    """
                                    VLAN Ids to match
                                    
                                    .. attribute:: vlan_id_high
                                    
                                    	VLAN ID High
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: vlan_id_low
                                    
                                    	VLAN ID Low
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    

                                    """

                                    _prefix = 'pfi-im-cmd-oper'
                                    _revision = '2016-12-18'

                                    def __init__(self):
                                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch.VlanRange, self).__init__()

                                        self.yang_name = "vlan-range"
                                        self.yang_parent_name = "tags-to-match"

                                        self.vlan_id_high = YLeaf(YType.uint16, "vlan-id-high")

                                        self.vlan_id_low = YLeaf(YType.uint16, "vlan-id-low")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("vlan_id_high",
                                                        "vlan_id_low") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch.VlanRange, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch.VlanRange, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.vlan_id_high.is_set or
                                            self.vlan_id_low.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.vlan_id_high.yfilter != YFilter.not_set or
                                            self.vlan_id_low.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "vlan-range" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.vlan_id_high.is_set or self.vlan_id_high.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.vlan_id_high.get_name_leafdata())
                                        if (self.vlan_id_low.is_set or self.vlan_id_low.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.vlan_id_low.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "vlan-id-high" or name == "vlan-id-low"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "vlan-id-high"):
                                            self.vlan_id_high = value
                                            self.vlan_id_high.value_namespace = name_space
                                            self.vlan_id_high.value_namespace_prefix = name_space_prefix
                                        if(value_path == "vlan-id-low"):
                                            self.vlan_id_low = value
                                            self.vlan_id_low.value_namespace = name_space
                                            self.vlan_id_low.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.vlan_range:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.ethertype.is_set or
                                        self.priority.is_set)

                                def has_operation(self):
                                    for c in self.vlan_range:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ethertype.yfilter != YFilter.not_set or
                                        self.priority.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "tags-to-match" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ethertype.is_set or self.ethertype.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ethertype.get_name_leafdata())
                                    if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.priority.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "vlan-range"):
                                        for c in self.vlan_range:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch.VlanRange()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.vlan_range.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "vlan-range" or name == "ethertype" or name == "priority"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ethertype"):
                                        self.ethertype = value
                                        self.ethertype.value_namespace = name_space
                                        self.ethertype.value_namespace_prefix = name_space_prefix
                                    if(value_path == "priority"):
                                        self.priority = value
                                        self.priority.value_namespace = name_space
                                        self.priority.value_namespace_prefix = name_space_prefix


                            class Pushe(Entity):
                                """
                                VLAN tags pushed on egress
                                
                                .. attribute:: ethertype
                                
                                	Ethertype of tag
                                	**type**\:   :py:class:`EfpTagEtype <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.EfpTagEtype>`
                                
                                .. attribute:: vlan_id
                                
                                	VLAN Id
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.Pushe, self).__init__()

                                    self.yang_name = "pushe"
                                    self.yang_parent_name = "service-instance-details"

                                    self.ethertype = YLeaf(YType.enumeration, "ethertype")

                                    self.vlan_id = YLeaf(YType.uint16, "vlan-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ethertype",
                                                    "vlan_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.Pushe, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.Pushe, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ethertype.is_set or
                                        self.vlan_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ethertype.yfilter != YFilter.not_set or
                                        self.vlan_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "pushe" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ethertype.is_set or self.ethertype.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ethertype.get_name_leafdata())
                                    if (self.vlan_id.is_set or self.vlan_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.vlan_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ethertype" or name == "vlan-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ethertype"):
                                        self.ethertype = value
                                        self.ethertype.value_namespace = name_space
                                        self.ethertype.value_namespace_prefix = name_space_prefix
                                    if(value_path == "vlan-id"):
                                        self.vlan_id = value
                                        self.vlan_id.value_namespace = name_space
                                        self.vlan_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.pushe:
                                    if (c.has_data()):
                                        return True
                                for c in self.tags_to_match:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.destination_mac_match.is_set or
                                    self.is_exact_match.is_set or
                                    self.is_native_preserving.is_set or
                                    self.is_native_vlan.is_set or
                                    self.payload_ethertype.is_set or
                                    self.source_mac_match.is_set or
                                    self.tags_popped.is_set or
                                    (self.local_traffic_stack is not None and self.local_traffic_stack.has_data()))

                            def has_operation(self):
                                for c in self.pushe:
                                    if (c.has_operation()):
                                        return True
                                for c in self.tags_to_match:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.destination_mac_match.yfilter != YFilter.not_set or
                                    self.is_exact_match.yfilter != YFilter.not_set or
                                    self.is_native_preserving.yfilter != YFilter.not_set or
                                    self.is_native_vlan.yfilter != YFilter.not_set or
                                    self.payload_ethertype.yfilter != YFilter.not_set or
                                    self.source_mac_match.yfilter != YFilter.not_set or
                                    self.tags_popped.yfilter != YFilter.not_set or
                                    (self.local_traffic_stack is not None and self.local_traffic_stack.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "service-instance-details" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.destination_mac_match.is_set or self.destination_mac_match.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.destination_mac_match.get_name_leafdata())
                                if (self.is_exact_match.is_set or self.is_exact_match.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_exact_match.get_name_leafdata())
                                if (self.is_native_preserving.is_set or self.is_native_preserving.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_native_preserving.get_name_leafdata())
                                if (self.is_native_vlan.is_set or self.is_native_vlan.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_native_vlan.get_name_leafdata())
                                if (self.payload_ethertype.is_set or self.payload_ethertype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.payload_ethertype.get_name_leafdata())
                                if (self.source_mac_match.is_set or self.source_mac_match.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.source_mac_match.get_name_leafdata())
                                if (self.tags_popped.is_set or self.tags_popped.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tags_popped.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "local-traffic-stack"):
                                    if (self.local_traffic_stack is None):
                                        self.local_traffic_stack = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.LocalTrafficStack()
                                        self.local_traffic_stack.parent = self
                                        self._children_name_map["local_traffic_stack"] = "local-traffic-stack"
                                    return self.local_traffic_stack

                                if (child_yang_name == "pushe"):
                                    for c in self.pushe:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.Pushe()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.pushe.append(c)
                                    return c

                                if (child_yang_name == "tags-to-match"):
                                    for c in self.tags_to_match:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails.TagsToMatch()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.tags_to_match.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "local-traffic-stack" or name == "pushe" or name == "tags-to-match" or name == "destination-mac-match" or name == "is-exact-match" or name == "is-native-preserving" or name == "is-native-vlan" or name == "payload-ethertype" or name == "source-mac-match" or name == "tags-popped"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "destination-mac-match"):
                                    self.destination_mac_match = value
                                    self.destination_mac_match.value_namespace = name_space
                                    self.destination_mac_match.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-exact-match"):
                                    self.is_exact_match = value
                                    self.is_exact_match.value_namespace = name_space
                                    self.is_exact_match.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-native-preserving"):
                                    self.is_native_preserving = value
                                    self.is_native_preserving.value_namespace = name_space
                                    self.is_native_preserving.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-native-vlan"):
                                    self.is_native_vlan = value
                                    self.is_native_vlan.value_namespace = name_space
                                    self.is_native_vlan.value_namespace_prefix = name_space_prefix
                                if(value_path == "payload-ethertype"):
                                    self.payload_ethertype = value
                                    self.payload_ethertype.value_namespace = name_space
                                    self.payload_ethertype.value_namespace_prefix = name_space_prefix
                                if(value_path == "source-mac-match"):
                                    self.source_mac_match = value
                                    self.source_mac_match.value_namespace = name_space
                                    self.source_mac_match.value_namespace_prefix = name_space_prefix
                                if(value_path == "tags-popped"):
                                    self.tags_popped = value
                                    self.tags_popped.value_namespace = name_space
                                    self.tags_popped.value_namespace_prefix = name_space_prefix


                        class Dot1AdDot1QStack(Entity):
                            """
                            802.1ad 802.1Q stack value
                            
                            .. attribute:: outer_tag
                            
                            	Outer tag value
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: second_tag
                            
                            	Second tag value
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Dot1AdDot1QStack, self).__init__()

                                self.yang_name = "dot1ad-dot1q-stack"
                                self.yang_parent_name = "encapsulation-details"

                                self.outer_tag = YLeaf(YType.uint16, "outer-tag")

                                self.second_tag = YLeaf(YType.uint16, "second-tag")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("outer_tag",
                                                "second_tag") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Dot1AdDot1QStack, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Dot1AdDot1QStack, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.outer_tag.is_set or
                                    self.second_tag.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.outer_tag.yfilter != YFilter.not_set or
                                    self.second_tag.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dot1ad-dot1q-stack" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.outer_tag.is_set or self.outer_tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outer_tag.get_name_leafdata())
                                if (self.second_tag.is_set or self.second_tag.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.second_tag.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "outer-tag" or name == "second-tag"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "outer-tag"):
                                    self.outer_tag = value
                                    self.outer_tag.value_namespace = name_space
                                    self.outer_tag.value_namespace_prefix = name_space_prefix
                                if(value_path == "second-tag"):
                                    self.second_tag = value
                                    self.second_tag.value_namespace = name_space
                                    self.second_tag.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.dot1ad_native_tag.is_set or
                                self.dot1ad_outer_tag.is_set or
                                self.dot1ad_tag.is_set or
                                self.native_tag.is_set or
                                self.outer_tag.is_set or
                                self.tag.is_set or
                                self.vlan_encapsulation.is_set or
                                (self.dot1ad_dot1q_stack is not None and self.dot1ad_dot1q_stack.has_data()) or
                                (self.service_instance_details is not None and self.service_instance_details.has_data()) or
                                (self.stack is not None and self.stack.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.dot1ad_native_tag.yfilter != YFilter.not_set or
                                self.dot1ad_outer_tag.yfilter != YFilter.not_set or
                                self.dot1ad_tag.yfilter != YFilter.not_set or
                                self.native_tag.yfilter != YFilter.not_set or
                                self.outer_tag.yfilter != YFilter.not_set or
                                self.tag.yfilter != YFilter.not_set or
                                self.vlan_encapsulation.yfilter != YFilter.not_set or
                                (self.dot1ad_dot1q_stack is not None and self.dot1ad_dot1q_stack.has_operation()) or
                                (self.service_instance_details is not None and self.service_instance_details.has_operation()) or
                                (self.stack is not None and self.stack.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "encapsulation-details" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.dot1ad_native_tag.is_set or self.dot1ad_native_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dot1ad_native_tag.get_name_leafdata())
                            if (self.dot1ad_outer_tag.is_set or self.dot1ad_outer_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dot1ad_outer_tag.get_name_leafdata())
                            if (self.dot1ad_tag.is_set or self.dot1ad_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dot1ad_tag.get_name_leafdata())
                            if (self.native_tag.is_set or self.native_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.native_tag.get_name_leafdata())
                            if (self.outer_tag.is_set or self.outer_tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outer_tag.get_name_leafdata())
                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tag.get_name_leafdata())
                            if (self.vlan_encapsulation.is_set or self.vlan_encapsulation.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.vlan_encapsulation.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dot1ad-dot1q-stack"):
                                if (self.dot1ad_dot1q_stack is None):
                                    self.dot1ad_dot1q_stack = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Dot1AdDot1QStack()
                                    self.dot1ad_dot1q_stack.parent = self
                                    self._children_name_map["dot1ad_dot1q_stack"] = "dot1ad-dot1q-stack"
                                return self.dot1ad_dot1q_stack

                            if (child_yang_name == "service-instance-details"):
                                if (self.service_instance_details is None):
                                    self.service_instance_details = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.ServiceInstanceDetails()
                                    self.service_instance_details.parent = self
                                    self._children_name_map["service_instance_details"] = "service-instance-details"
                                return self.service_instance_details

                            if (child_yang_name == "stack"):
                                if (self.stack is None):
                                    self.stack = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails.Stack()
                                    self.stack.parent = self
                                    self._children_name_map["stack"] = "stack"
                                return self.stack

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dot1ad-dot1q-stack" or name == "service-instance-details" or name == "stack" or name == "dot1ad-native-tag" or name == "dot1ad-outer-tag" or name == "dot1ad-tag" or name == "native-tag" or name == "outer-tag" or name == "tag" or name == "vlan-encapsulation"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "dot1ad-native-tag"):
                                self.dot1ad_native_tag = value
                                self.dot1ad_native_tag.value_namespace = name_space
                                self.dot1ad_native_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "dot1ad-outer-tag"):
                                self.dot1ad_outer_tag = value
                                self.dot1ad_outer_tag.value_namespace = name_space
                                self.dot1ad_outer_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "dot1ad-tag"):
                                self.dot1ad_tag = value
                                self.dot1ad_tag.value_namespace = name_space
                                self.dot1ad_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "native-tag"):
                                self.native_tag = value
                                self.native_tag.value_namespace = name_space
                                self.native_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "outer-tag"):
                                self.outer_tag = value
                                self.outer_tag.value_namespace = name_space
                                self.outer_tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "tag"):
                                self.tag = value
                                self.tag.value_namespace = name_space
                                self.tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "vlan-encapsulation"):
                                self.vlan_encapsulation = value
                                self.vlan_encapsulation.value_namespace = name_space
                                self.vlan_encapsulation.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.encapsulation_details is not None and self.encapsulation_details.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.encapsulation_details is not None and self.encapsulation_details.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "dot1q-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "encapsulation-details"):
                            if (self.encapsulation_details is None):
                                self.encapsulation_details = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation.EncapsulationDetails()
                                self.encapsulation_details.parent = self
                                self._children_name_map["encapsulation_details"] = "encapsulation-details"
                            return self.encapsulation_details

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "encapsulation-details"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class PppInformation(Entity):
                    """
                    PPP information
                    
                    .. attribute:: is_loopback_detected
                    
                    	Loopback detected
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: is_mp_bundle_member
                    
                    	MP Bundle Member
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: is_multilink_open
                    
                    	Is Multilink Open
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: keepalive_period
                    
                    	Keepalive value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: lcp_state
                    
                    	LCP State
                    	**type**\:   :py:class:`PppFsmState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.PppFsmState>`
                    
                    .. attribute:: ncp_info_array
                    
                    	Array of per\-NCP data
                    	**type**\: list of    :py:class:`NcpInfoArray <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation.NcpInfoArray>`
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation, self).__init__()

                        self.yang_name = "ppp-information"
                        self.yang_parent_name = "encapsulation-information"

                        self.is_loopback_detected = YLeaf(YType.int32, "is-loopback-detected")

                        self.is_mp_bundle_member = YLeaf(YType.int32, "is-mp-bundle-member")

                        self.is_multilink_open = YLeaf(YType.int32, "is-multilink-open")

                        self.keepalive_period = YLeaf(YType.uint32, "keepalive-period")

                        self.lcp_state = YLeaf(YType.enumeration, "lcp-state")

                        self.ncp_info_array = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("is_loopback_detected",
                                        "is_mp_bundle_member",
                                        "is_multilink_open",
                                        "keepalive_period",
                                        "lcp_state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation, self).__setattr__(name, value)


                    class NcpInfoArray(Entity):
                        """
                        Array of per\-NCP data
                        
                        .. attribute:: ncp_identifier
                        
                        	NCP state identifier
                        	**type**\:   :py:class:`NcpIdent <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.NcpIdent>`
                        
                        .. attribute:: ncp_state
                        
                        	NCP state value
                        	**type**\:   :py:class:`PppFsmState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.PppFsmState>`
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation.NcpInfoArray, self).__init__()

                            self.yang_name = "ncp-info-array"
                            self.yang_parent_name = "ppp-information"

                            self.ncp_identifier = YLeaf(YType.enumeration, "ncp-identifier")

                            self.ncp_state = YLeaf(YType.enumeration, "ncp-state")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ncp_identifier",
                                            "ncp_state") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation.NcpInfoArray, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation.NcpInfoArray, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.ncp_identifier.is_set or
                                self.ncp_state.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ncp_identifier.yfilter != YFilter.not_set or
                                self.ncp_state.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ncp-info-array" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ncp_identifier.is_set or self.ncp_identifier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ncp_identifier.get_name_leafdata())
                            if (self.ncp_state.is_set or self.ncp_state.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ncp_state.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ncp-identifier" or name == "ncp-state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ncp-identifier"):
                                self.ncp_identifier = value
                                self.ncp_identifier.value_namespace = name_space
                                self.ncp_identifier.value_namespace_prefix = name_space_prefix
                            if(value_path == "ncp-state"):
                                self.ncp_state = value
                                self.ncp_state.value_namespace = name_space
                                self.ncp_state.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.ncp_info_array:
                            if (c.has_data()):
                                return True
                        return (
                            self.is_loopback_detected.is_set or
                            self.is_mp_bundle_member.is_set or
                            self.is_multilink_open.is_set or
                            self.keepalive_period.is_set or
                            self.lcp_state.is_set)

                    def has_operation(self):
                        for c in self.ncp_info_array:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.is_loopback_detected.yfilter != YFilter.not_set or
                            self.is_mp_bundle_member.yfilter != YFilter.not_set or
                            self.is_multilink_open.yfilter != YFilter.not_set or
                            self.keepalive_period.yfilter != YFilter.not_set or
                            self.lcp_state.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ppp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.is_loopback_detected.is_set or self.is_loopback_detected.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_loopback_detected.get_name_leafdata())
                        if (self.is_mp_bundle_member.is_set or self.is_mp_bundle_member.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_mp_bundle_member.get_name_leafdata())
                        if (self.is_multilink_open.is_set or self.is_multilink_open.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_multilink_open.get_name_leafdata())
                        if (self.keepalive_period.is_set or self.keepalive_period.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_period.get_name_leafdata())
                        if (self.lcp_state.is_set or self.lcp_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lcp_state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ncp-info-array"):
                            for c in self.ncp_info_array:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation.NcpInfoArray()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.ncp_info_array.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ncp-info-array" or name == "is-loopback-detected" or name == "is-mp-bundle-member" or name == "is-multilink-open" or name == "keepalive-period" or name == "lcp-state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "is-loopback-detected"):
                            self.is_loopback_detected = value
                            self.is_loopback_detected.value_namespace = name_space
                            self.is_loopback_detected.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-mp-bundle-member"):
                            self.is_mp_bundle_member = value
                            self.is_mp_bundle_member.value_namespace = name_space
                            self.is_mp_bundle_member.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-multilink-open"):
                            self.is_multilink_open = value
                            self.is_multilink_open.value_namespace = name_space
                            self.is_multilink_open.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-period"):
                            self.keepalive_period = value
                            self.keepalive_period.value_namespace = name_space
                            self.keepalive_period.value_namespace_prefix = name_space_prefix
                        if(value_path == "lcp-state"):
                            self.lcp_state = value
                            self.lcp_state.value_namespace = name_space
                            self.lcp_state.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.encapsulation_type.is_set or
                        (self.dot1q_information is not None and self.dot1q_information.has_data()) or
                        (self.frame_relay_information is not None and self.frame_relay_information.has_data()) or
                        (self.ppp_information is not None and self.ppp_information.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.encapsulation_type.yfilter != YFilter.not_set or
                        (self.dot1q_information is not None and self.dot1q_information.has_operation()) or
                        (self.frame_relay_information is not None and self.frame_relay_information.has_operation()) or
                        (self.ppp_information is not None and self.ppp_information.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "encapsulation-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.encapsulation_type.is_set or self.encapsulation_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.encapsulation_type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "dot1q-information"):
                        if (self.dot1q_information is None):
                            self.dot1q_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation.Dot1QInformation()
                            self.dot1q_information.parent = self
                            self._children_name_map["dot1q_information"] = "dot1q-information"
                        return self.dot1q_information

                    if (child_yang_name == "frame-relay-information"):
                        if (self.frame_relay_information is None):
                            self.frame_relay_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation.FrameRelayInformation()
                            self.frame_relay_information.parent = self
                            self._children_name_map["frame_relay_information"] = "frame-relay-information"
                        return self.frame_relay_information

                    if (child_yang_name == "ppp-information"):
                        if (self.ppp_information is None):
                            self.ppp_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation.PppInformation()
                            self.ppp_information.parent = self
                            self._children_name_map["ppp_information"] = "ppp-information"
                        return self.ppp_information

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "dot1q-information" or name == "frame-relay-information" or name == "ppp-information" or name == "encapsulation-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "encapsulation-type"):
                        self.encapsulation_type = value
                        self.encapsulation_type.value_namespace = name_space
                        self.encapsulation_type.value_namespace_prefix = name_space_prefix


            class InterfaceTypeInformation(Entity):
                """
                Information specific to the interface type
                
                .. attribute:: bundle_information
                
                	Bundle interface information
                	**type**\:   :py:class:`BundleInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation>`
                
                .. attribute:: cem_information
                
                	Cem interface information
                	**type**\:   :py:class:`CemInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.CemInformation>`
                
                .. attribute:: gcc_information
                
                	GCC interface information
                	**type**\:   :py:class:`GccInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.GccInformation>`
                
                .. attribute:: interface_type_info
                
                	InterfaceTypeInfo
                	**type**\:   :py:class:`ImCmdIntfTypeEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImCmdIntfTypeEnum>`
                
                .. attribute:: pseudowire_head_end_information
                
                	PseudowireHeadEnd interface information
                	**type**\:   :py:class:`PseudowireHeadEndInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.PseudowireHeadEndInformation>`
                
                .. attribute:: serial_information
                
                	Serial interface information
                	**type**\:   :py:class:`SerialInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SerialInformation>`
                
                .. attribute:: sonet_pos_information
                
                	SONET POS interface information
                	**type**\:   :py:class:`SonetPosInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SonetPosInformation>`
                
                .. attribute:: srp_information
                
                	SRP interface information
                	**type**\:   :py:class:`SrpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation>`
                
                .. attribute:: tunnel_gre_information
                
                	Tunnel GRE interface information
                	**type**\:   :py:class:`TunnelGreInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation>`
                
                .. attribute:: tunnel_information
                
                	Tunnel interface information
                	**type**\:   :py:class:`TunnelInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelInformation>`
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation, self).__init__()

                    self.yang_name = "interface-type-information"
                    self.yang_parent_name = "interface"

                    self.interface_type_info = YLeaf(YType.enumeration, "interface-type-info")

                    self.bundle_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation()
                    self.bundle_information.parent = self
                    self._children_name_map["bundle_information"] = "bundle-information"
                    self._children_yang_names.add("bundle-information")

                    self.cem_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.CemInformation()
                    self.cem_information.parent = self
                    self._children_name_map["cem_information"] = "cem-information"
                    self._children_yang_names.add("cem-information")

                    self.gcc_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.GccInformation()
                    self.gcc_information.parent = self
                    self._children_name_map["gcc_information"] = "gcc-information"
                    self._children_yang_names.add("gcc-information")

                    self.pseudowire_head_end_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.PseudowireHeadEndInformation()
                    self.pseudowire_head_end_information.parent = self
                    self._children_name_map["pseudowire_head_end_information"] = "pseudowire-head-end-information"
                    self._children_yang_names.add("pseudowire-head-end-information")

                    self.serial_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SerialInformation()
                    self.serial_information.parent = self
                    self._children_name_map["serial_information"] = "serial-information"
                    self._children_yang_names.add("serial-information")

                    self.sonet_pos_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SonetPosInformation()
                    self.sonet_pos_information.parent = self
                    self._children_name_map["sonet_pos_information"] = "sonet-pos-information"
                    self._children_yang_names.add("sonet-pos-information")

                    self.srp_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation()
                    self.srp_information.parent = self
                    self._children_name_map["srp_information"] = "srp-information"
                    self._children_yang_names.add("srp-information")

                    self.tunnel_gre_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation()
                    self.tunnel_gre_information.parent = self
                    self._children_name_map["tunnel_gre_information"] = "tunnel-gre-information"
                    self._children_yang_names.add("tunnel-gre-information")

                    self.tunnel_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelInformation()
                    self.tunnel_information.parent = self
                    self._children_name_map["tunnel_information"] = "tunnel-information"
                    self._children_yang_names.add("tunnel-information")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_type_info") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation, self).__setattr__(name, value)


                class SrpInformation(Entity):
                    """
                    SRP interface information
                    
                    .. attribute:: srp_information
                    
                    	SRP\-specific data
                    	**type**\:   :py:class:`SrpInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation>`
                    
                    .. attribute:: srp_statistics
                    
                    	SRP\-specific packet and byte counters
                    	**type**\:   :py:class:`SrpStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics>`
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation, self).__init__()

                        self.yang_name = "srp-information"
                        self.yang_parent_name = "interface-type-information"

                        self.srp_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation()
                        self.srp_information.parent = self
                        self._children_name_map["srp_information"] = "srp-information"
                        self._children_yang_names.add("srp-information")

                        self.srp_statistics = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics()
                        self.srp_statistics.parent = self
                        self._children_name_map["srp_statistics"] = "srp-statistics"
                        self._children_yang_names.add("srp-statistics")


                    class SrpInformation(Entity):
                        """
                        SRP\-specific data
                        
                        .. attribute:: ips_info
                        
                        	SRP IPS information
                        	**type**\:   :py:class:`IpsInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo>`
                        
                        .. attribute:: rate_limit_info
                        
                        	SRP rate limit information
                        	**type**\:   :py:class:`RateLimitInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo>`
                        
                        .. attribute:: srr_info
                        
                        	SRP SRR information
                        	**type**\:   :py:class:`SrrInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo>`
                        
                        .. attribute:: topology_info
                        
                        	SRP topology information
                        	**type**\:   :py:class:`TopologyInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo>`
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation, self).__init__()

                            self.yang_name = "srp-information"
                            self.yang_parent_name = "srp-information"

                            self.ips_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo()
                            self.ips_info.parent = self
                            self._children_name_map["ips_info"] = "ips-info"
                            self._children_yang_names.add("ips-info")

                            self.rate_limit_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo()
                            self.rate_limit_info.parent = self
                            self._children_name_map["rate_limit_info"] = "rate-limit-info"
                            self._children_yang_names.add("rate-limit-info")

                            self.srr_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo()
                            self.srr_info.parent = self
                            self._children_name_map["srr_info"] = "srr-info"
                            self._children_yang_names.add("srr-info")

                            self.topology_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo()
                            self.topology_info.parent = self
                            self._children_name_map["topology_info"] = "topology-info"
                            self._children_yang_names.add("topology-info")


                        class IpsInfo(Entity):
                            """
                            SRP IPS information
                            
                            .. attribute:: is_admin_down
                            
                            	Is the interfaceadministratively down
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: local_information
                            
                            	IPS information
                            	**type**\: list of    :py:class:`LocalInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation>`
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo, self).__init__()

                                self.yang_name = "ips-info"
                                self.yang_parent_name = "srp-information"

                                self.is_admin_down = YLeaf(YType.int32, "is-admin-down")

                                self.local_information = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("is_admin_down") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo, self).__setattr__(name, value)


                            class LocalInformation(Entity):
                                """
                                IPS information
                                
                                .. attribute:: is_inter_card_bus_enabled
                                
                                	Inter card bus enabled
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: mac_address
                                
                                	MAC address for node
                                	**type**\:  str
                                
                                .. attribute:: side_a
                                
                                	Side A IPS details
                                	**type**\:   :py:class:`SideA <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA>`
                                
                                .. attribute:: side_b
                                
                                	Side B IPS details
                                	**type**\:   :py:class:`SideB <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB>`
                                
                                .. attribute:: wtr_timer_period
                                
                                	IPS Wait To Restore period in seconds
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation, self).__init__()

                                    self.yang_name = "local-information"
                                    self.yang_parent_name = "ips-info"

                                    self.is_inter_card_bus_enabled = YLeaf(YType.int32, "is-inter-card-bus-enabled")

                                    self.mac_address = YLeaf(YType.str, "mac-address")

                                    self.wtr_timer_period = YLeaf(YType.uint32, "wtr-timer-period")

                                    self.side_a = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA()
                                    self.side_a.parent = self
                                    self._children_name_map["side_a"] = "side-a"
                                    self._children_yang_names.add("side-a")

                                    self.side_b = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB()
                                    self.side_b.parent = self
                                    self._children_name_map["side_b"] = "side-b"
                                    self._children_yang_names.add("side-b")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("is_inter_card_bus_enabled",
                                                    "mac_address",
                                                    "wtr_timer_period") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation, self).__setattr__(name, value)


                                class SideA(Entity):
                                    """
                                    Side A IPS details
                                    
                                    .. attribute:: asserted_failure
                                    
                                    	Failures presently asserted
                                    	**type**\: list of    :py:class:`AssertedFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA.AssertedFailure>`
                                    
                                    .. attribute:: delay_keep_alive_trigger
                                    
                                    	Number of milliseconds to wait after an L1 failure is detected before triggering an L2 wrap
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: mac_address
                                    
                                    	MAC address
                                    	**type**\:  str
                                    
                                    .. attribute:: packet_sent_timer
                                    
                                    	SRP IPS packet send interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: remote_request
                                    
                                    	Remote Requests
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: rx_message_type
                                    
                                    	Type of message received
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: rx_neighbor_mac_address
                                    
                                    	Neighbour mac address for received message
                                    	**type**\:  str
                                    
                                    .. attribute:: rx_packet_test
                                    
                                    	Test for existence of an RX packet
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: rx_path_type
                                    
                                    	Short/long path for received message
                                    	**type**\:   :py:class:`SrpMgmtIpsPathInd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsPathInd>`
                                    
                                    .. attribute:: rx_ttl
                                    
                                    	Time to live for received message
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: self_detected_request
                                    
                                    	Self Detected Requests
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: send_timer_time_remaining
                                    
                                    	Time in seconds remaining until next send of an IPS request
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: tx_message_type
                                    
                                    	Type of message transmitted
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: tx_neighbor_mac_address
                                    
                                    	Mac address of node receiving TXed messages
                                    	**type**\:  str
                                    
                                    .. attribute:: tx_packet_test
                                    
                                    	Test for existence of a TX packet
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: tx_path_type
                                    
                                    	Short/long path of transmitted message
                                    	**type**\:   :py:class:`SrpMgmtIpsPathInd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsPathInd>`
                                    
                                    .. attribute:: tx_ttl
                                    
                                    	Time to live for transmitted message
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: wrap_state
                                    
                                    	Wrap state
                                    	**type**\:   :py:class:`SrpMgmtIpsWrapState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsWrapState>`
                                    
                                    .. attribute:: wtr_timer_remaining
                                    
                                    	Time in seconds until wrap removal
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'pfi-im-cmd-oper'
                                    _revision = '2016-12-18'

                                    def __init__(self):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA, self).__init__()

                                        self.yang_name = "side-a"
                                        self.yang_parent_name = "local-information"

                                        self.delay_keep_alive_trigger = YLeaf(YType.uint32, "delay-keep-alive-trigger")

                                        self.mac_address = YLeaf(YType.str, "mac-address")

                                        self.packet_sent_timer = YLeaf(YType.uint32, "packet-sent-timer")

                                        self.remote_request = YLeaf(YType.enumeration, "remote-request")

                                        self.rx_message_type = YLeaf(YType.enumeration, "rx-message-type")

                                        self.rx_neighbor_mac_address = YLeaf(YType.str, "rx-neighbor-mac-address")

                                        self.rx_packet_test = YLeaf(YType.int32, "rx-packet-test")

                                        self.rx_path_type = YLeaf(YType.enumeration, "rx-path-type")

                                        self.rx_ttl = YLeaf(YType.uint32, "rx-ttl")

                                        self.self_detected_request = YLeaf(YType.enumeration, "self-detected-request")

                                        self.send_timer_time_remaining = YLeaf(YType.uint32, "send-timer-time-remaining")

                                        self.tx_message_type = YLeaf(YType.enumeration, "tx-message-type")

                                        self.tx_neighbor_mac_address = YLeaf(YType.str, "tx-neighbor-mac-address")

                                        self.tx_packet_test = YLeaf(YType.int32, "tx-packet-test")

                                        self.tx_path_type = YLeaf(YType.enumeration, "tx-path-type")

                                        self.tx_ttl = YLeaf(YType.uint32, "tx-ttl")

                                        self.wrap_state = YLeaf(YType.enumeration, "wrap-state")

                                        self.wtr_timer_remaining = YLeaf(YType.uint32, "wtr-timer-remaining")

                                        self.asserted_failure = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("delay_keep_alive_trigger",
                                                        "mac_address",
                                                        "packet_sent_timer",
                                                        "remote_request",
                                                        "rx_message_type",
                                                        "rx_neighbor_mac_address",
                                                        "rx_packet_test",
                                                        "rx_path_type",
                                                        "rx_ttl",
                                                        "self_detected_request",
                                                        "send_timer_time_remaining",
                                                        "tx_message_type",
                                                        "tx_neighbor_mac_address",
                                                        "tx_packet_test",
                                                        "tx_path_type",
                                                        "tx_ttl",
                                                        "wrap_state",
                                                        "wtr_timer_remaining") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA, self).__setattr__(name, value)


                                    class AssertedFailure(Entity):
                                        """
                                        Failures presently asserted
                                        
                                        .. attribute:: current_state
                                        
                                        	Current state
                                        	**type**\:   :py:class:`SrpMgmtFailureStateEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureStateEt>`
                                        
                                        .. attribute:: debounced_delay
                                        
                                        	Debounce delay
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: debounced_state
                                        
                                        	Debounced state
                                        	**type**\:   :py:class:`SrpMgmtFailureStateEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureStateEt>`
                                        
                                        .. attribute:: reported_state
                                        
                                        	Reported state
                                        	**type**\:   :py:class:`SrpMgmtFailureStateEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureStateEt>`
                                        
                                        .. attribute:: stable_time
                                        
                                        	Stable time
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: type
                                        
                                        	Failure type
                                        	**type**\:   :py:class:`SrpMgmtFailureEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureEt>`
                                        
                                        

                                        """

                                        _prefix = 'pfi-im-cmd-oper'
                                        _revision = '2016-12-18'

                                        def __init__(self):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA.AssertedFailure, self).__init__()

                                            self.yang_name = "asserted-failure"
                                            self.yang_parent_name = "side-a"

                                            self.current_state = YLeaf(YType.enumeration, "current-state")

                                            self.debounced_delay = YLeaf(YType.uint32, "debounced-delay")

                                            self.debounced_state = YLeaf(YType.enumeration, "debounced-state")

                                            self.reported_state = YLeaf(YType.enumeration, "reported-state")

                                            self.stable_time = YLeaf(YType.uint64, "stable-time")

                                            self.type = YLeaf(YType.enumeration, "type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("current_state",
                                                            "debounced_delay",
                                                            "debounced_state",
                                                            "reported_state",
                                                            "stable_time",
                                                            "type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA.AssertedFailure, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA.AssertedFailure, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.current_state.is_set or
                                                self.debounced_delay.is_set or
                                                self.debounced_state.is_set or
                                                self.reported_state.is_set or
                                                self.stable_time.is_set or
                                                self.type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.current_state.yfilter != YFilter.not_set or
                                                self.debounced_delay.yfilter != YFilter.not_set or
                                                self.debounced_state.yfilter != YFilter.not_set or
                                                self.reported_state.yfilter != YFilter.not_set or
                                                self.stable_time.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "asserted-failure" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.current_state.is_set or self.current_state.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.current_state.get_name_leafdata())
                                            if (self.debounced_delay.is_set or self.debounced_delay.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.debounced_delay.get_name_leafdata())
                                            if (self.debounced_state.is_set or self.debounced_state.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.debounced_state.get_name_leafdata())
                                            if (self.reported_state.is_set or self.reported_state.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.reported_state.get_name_leafdata())
                                            if (self.stable_time.is_set or self.stable_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.stable_time.get_name_leafdata())
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "current-state" or name == "debounced-delay" or name == "debounced-state" or name == "reported-state" or name == "stable-time" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "current-state"):
                                                self.current_state = value
                                                self.current_state.value_namespace = name_space
                                                self.current_state.value_namespace_prefix = name_space_prefix
                                            if(value_path == "debounced-delay"):
                                                self.debounced_delay = value
                                                self.debounced_delay.value_namespace = name_space
                                                self.debounced_delay.value_namespace_prefix = name_space_prefix
                                            if(value_path == "debounced-state"):
                                                self.debounced_state = value
                                                self.debounced_state.value_namespace = name_space
                                                self.debounced_state.value_namespace_prefix = name_space_prefix
                                            if(value_path == "reported-state"):
                                                self.reported_state = value
                                                self.reported_state.value_namespace = name_space
                                                self.reported_state.value_namespace_prefix = name_space_prefix
                                            if(value_path == "stable-time"):
                                                self.stable_time = value
                                                self.stable_time.value_namespace = name_space
                                                self.stable_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.asserted_failure:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.delay_keep_alive_trigger.is_set or
                                            self.mac_address.is_set or
                                            self.packet_sent_timer.is_set or
                                            self.remote_request.is_set or
                                            self.rx_message_type.is_set or
                                            self.rx_neighbor_mac_address.is_set or
                                            self.rx_packet_test.is_set or
                                            self.rx_path_type.is_set or
                                            self.rx_ttl.is_set or
                                            self.self_detected_request.is_set or
                                            self.send_timer_time_remaining.is_set or
                                            self.tx_message_type.is_set or
                                            self.tx_neighbor_mac_address.is_set or
                                            self.tx_packet_test.is_set or
                                            self.tx_path_type.is_set or
                                            self.tx_ttl.is_set or
                                            self.wrap_state.is_set or
                                            self.wtr_timer_remaining.is_set)

                                    def has_operation(self):
                                        for c in self.asserted_failure:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.delay_keep_alive_trigger.yfilter != YFilter.not_set or
                                            self.mac_address.yfilter != YFilter.not_set or
                                            self.packet_sent_timer.yfilter != YFilter.not_set or
                                            self.remote_request.yfilter != YFilter.not_set or
                                            self.rx_message_type.yfilter != YFilter.not_set or
                                            self.rx_neighbor_mac_address.yfilter != YFilter.not_set or
                                            self.rx_packet_test.yfilter != YFilter.not_set or
                                            self.rx_path_type.yfilter != YFilter.not_set or
                                            self.rx_ttl.yfilter != YFilter.not_set or
                                            self.self_detected_request.yfilter != YFilter.not_set or
                                            self.send_timer_time_remaining.yfilter != YFilter.not_set or
                                            self.tx_message_type.yfilter != YFilter.not_set or
                                            self.tx_neighbor_mac_address.yfilter != YFilter.not_set or
                                            self.tx_packet_test.yfilter != YFilter.not_set or
                                            self.tx_path_type.yfilter != YFilter.not_set or
                                            self.tx_ttl.yfilter != YFilter.not_set or
                                            self.wrap_state.yfilter != YFilter.not_set or
                                            self.wtr_timer_remaining.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "side-a" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.delay_keep_alive_trigger.is_set or self.delay_keep_alive_trigger.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.delay_keep_alive_trigger.get_name_leafdata())
                                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mac_address.get_name_leafdata())
                                        if (self.packet_sent_timer.is_set or self.packet_sent_timer.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.packet_sent_timer.get_name_leafdata())
                                        if (self.remote_request.is_set or self.remote_request.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.remote_request.get_name_leafdata())
                                        if (self.rx_message_type.is_set or self.rx_message_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_message_type.get_name_leafdata())
                                        if (self.rx_neighbor_mac_address.is_set or self.rx_neighbor_mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_neighbor_mac_address.get_name_leafdata())
                                        if (self.rx_packet_test.is_set or self.rx_packet_test.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_packet_test.get_name_leafdata())
                                        if (self.rx_path_type.is_set or self.rx_path_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_path_type.get_name_leafdata())
                                        if (self.rx_ttl.is_set or self.rx_ttl.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_ttl.get_name_leafdata())
                                        if (self.self_detected_request.is_set or self.self_detected_request.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.self_detected_request.get_name_leafdata())
                                        if (self.send_timer_time_remaining.is_set or self.send_timer_time_remaining.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.send_timer_time_remaining.get_name_leafdata())
                                        if (self.tx_message_type.is_set or self.tx_message_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_message_type.get_name_leafdata())
                                        if (self.tx_neighbor_mac_address.is_set or self.tx_neighbor_mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_neighbor_mac_address.get_name_leafdata())
                                        if (self.tx_packet_test.is_set or self.tx_packet_test.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_packet_test.get_name_leafdata())
                                        if (self.tx_path_type.is_set or self.tx_path_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_path_type.get_name_leafdata())
                                        if (self.tx_ttl.is_set or self.tx_ttl.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_ttl.get_name_leafdata())
                                        if (self.wrap_state.is_set or self.wrap_state.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wrap_state.get_name_leafdata())
                                        if (self.wtr_timer_remaining.is_set or self.wtr_timer_remaining.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wtr_timer_remaining.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "asserted-failure"):
                                            for c in self.asserted_failure:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA.AssertedFailure()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.asserted_failure.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "asserted-failure" or name == "delay-keep-alive-trigger" or name == "mac-address" or name == "packet-sent-timer" or name == "remote-request" or name == "rx-message-type" or name == "rx-neighbor-mac-address" or name == "rx-packet-test" or name == "rx-path-type" or name == "rx-ttl" or name == "self-detected-request" or name == "send-timer-time-remaining" or name == "tx-message-type" or name == "tx-neighbor-mac-address" or name == "tx-packet-test" or name == "tx-path-type" or name == "tx-ttl" or name == "wrap-state" or name == "wtr-timer-remaining"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "delay-keep-alive-trigger"):
                                            self.delay_keep_alive_trigger = value
                                            self.delay_keep_alive_trigger.value_namespace = name_space
                                            self.delay_keep_alive_trigger.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mac-address"):
                                            self.mac_address = value
                                            self.mac_address.value_namespace = name_space
                                            self.mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "packet-sent-timer"):
                                            self.packet_sent_timer = value
                                            self.packet_sent_timer.value_namespace = name_space
                                            self.packet_sent_timer.value_namespace_prefix = name_space_prefix
                                        if(value_path == "remote-request"):
                                            self.remote_request = value
                                            self.remote_request.value_namespace = name_space
                                            self.remote_request.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-message-type"):
                                            self.rx_message_type = value
                                            self.rx_message_type.value_namespace = name_space
                                            self.rx_message_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-neighbor-mac-address"):
                                            self.rx_neighbor_mac_address = value
                                            self.rx_neighbor_mac_address.value_namespace = name_space
                                            self.rx_neighbor_mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-packet-test"):
                                            self.rx_packet_test = value
                                            self.rx_packet_test.value_namespace = name_space
                                            self.rx_packet_test.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-path-type"):
                                            self.rx_path_type = value
                                            self.rx_path_type.value_namespace = name_space
                                            self.rx_path_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-ttl"):
                                            self.rx_ttl = value
                                            self.rx_ttl.value_namespace = name_space
                                            self.rx_ttl.value_namespace_prefix = name_space_prefix
                                        if(value_path == "self-detected-request"):
                                            self.self_detected_request = value
                                            self.self_detected_request.value_namespace = name_space
                                            self.self_detected_request.value_namespace_prefix = name_space_prefix
                                        if(value_path == "send-timer-time-remaining"):
                                            self.send_timer_time_remaining = value
                                            self.send_timer_time_remaining.value_namespace = name_space
                                            self.send_timer_time_remaining.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-message-type"):
                                            self.tx_message_type = value
                                            self.tx_message_type.value_namespace = name_space
                                            self.tx_message_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-neighbor-mac-address"):
                                            self.tx_neighbor_mac_address = value
                                            self.tx_neighbor_mac_address.value_namespace = name_space
                                            self.tx_neighbor_mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-packet-test"):
                                            self.tx_packet_test = value
                                            self.tx_packet_test.value_namespace = name_space
                                            self.tx_packet_test.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-path-type"):
                                            self.tx_path_type = value
                                            self.tx_path_type.value_namespace = name_space
                                            self.tx_path_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-ttl"):
                                            self.tx_ttl = value
                                            self.tx_ttl.value_namespace = name_space
                                            self.tx_ttl.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wrap-state"):
                                            self.wrap_state = value
                                            self.wrap_state.value_namespace = name_space
                                            self.wrap_state.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wtr-timer-remaining"):
                                            self.wtr_timer_remaining = value
                                            self.wtr_timer_remaining.value_namespace = name_space
                                            self.wtr_timer_remaining.value_namespace_prefix = name_space_prefix


                                class SideB(Entity):
                                    """
                                    Side B IPS details
                                    
                                    .. attribute:: asserted_failure
                                    
                                    	Failures presently asserted
                                    	**type**\: list of    :py:class:`AssertedFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB.AssertedFailure>`
                                    
                                    .. attribute:: delay_keep_alive_trigger
                                    
                                    	Number of milliseconds to wait after an L1 failure is detected before triggering an L2 wrap
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: mac_address
                                    
                                    	MAC address
                                    	**type**\:  str
                                    
                                    .. attribute:: packet_sent_timer
                                    
                                    	SRP IPS packet send interval in seconds
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: remote_request
                                    
                                    	Remote Requests
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: rx_message_type
                                    
                                    	Type of message received
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: rx_neighbor_mac_address
                                    
                                    	Neighbour mac address for received message
                                    	**type**\:  str
                                    
                                    .. attribute:: rx_packet_test
                                    
                                    	Test for existence of an RX packet
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: rx_path_type
                                    
                                    	Short/long path for received message
                                    	**type**\:   :py:class:`SrpMgmtIpsPathInd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsPathInd>`
                                    
                                    .. attribute:: rx_ttl
                                    
                                    	Time to live for received message
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: self_detected_request
                                    
                                    	Self Detected Requests
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: send_timer_time_remaining
                                    
                                    	Time in seconds remaining until next send of an IPS request
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: tx_message_type
                                    
                                    	Type of message transmitted
                                    	**type**\:   :py:class:`SrpMgmtIpsReq <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsReq>`
                                    
                                    .. attribute:: tx_neighbor_mac_address
                                    
                                    	Mac address of node receiving TXed messages
                                    	**type**\:  str
                                    
                                    .. attribute:: tx_packet_test
                                    
                                    	Test for existence of a TX packet
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: tx_path_type
                                    
                                    	Short/long path of transmitted message
                                    	**type**\:   :py:class:`SrpMgmtIpsPathInd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsPathInd>`
                                    
                                    .. attribute:: tx_ttl
                                    
                                    	Time to live for transmitted message
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: wrap_state
                                    
                                    	Wrap state
                                    	**type**\:   :py:class:`SrpMgmtIpsWrapState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtIpsWrapState>`
                                    
                                    .. attribute:: wtr_timer_remaining
                                    
                                    	Time in seconds until wrap removal
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: second
                                    
                                    

                                    """

                                    _prefix = 'pfi-im-cmd-oper'
                                    _revision = '2016-12-18'

                                    def __init__(self):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB, self).__init__()

                                        self.yang_name = "side-b"
                                        self.yang_parent_name = "local-information"

                                        self.delay_keep_alive_trigger = YLeaf(YType.uint32, "delay-keep-alive-trigger")

                                        self.mac_address = YLeaf(YType.str, "mac-address")

                                        self.packet_sent_timer = YLeaf(YType.uint32, "packet-sent-timer")

                                        self.remote_request = YLeaf(YType.enumeration, "remote-request")

                                        self.rx_message_type = YLeaf(YType.enumeration, "rx-message-type")

                                        self.rx_neighbor_mac_address = YLeaf(YType.str, "rx-neighbor-mac-address")

                                        self.rx_packet_test = YLeaf(YType.int32, "rx-packet-test")

                                        self.rx_path_type = YLeaf(YType.enumeration, "rx-path-type")

                                        self.rx_ttl = YLeaf(YType.uint32, "rx-ttl")

                                        self.self_detected_request = YLeaf(YType.enumeration, "self-detected-request")

                                        self.send_timer_time_remaining = YLeaf(YType.uint32, "send-timer-time-remaining")

                                        self.tx_message_type = YLeaf(YType.enumeration, "tx-message-type")

                                        self.tx_neighbor_mac_address = YLeaf(YType.str, "tx-neighbor-mac-address")

                                        self.tx_packet_test = YLeaf(YType.int32, "tx-packet-test")

                                        self.tx_path_type = YLeaf(YType.enumeration, "tx-path-type")

                                        self.tx_ttl = YLeaf(YType.uint32, "tx-ttl")

                                        self.wrap_state = YLeaf(YType.enumeration, "wrap-state")

                                        self.wtr_timer_remaining = YLeaf(YType.uint32, "wtr-timer-remaining")

                                        self.asserted_failure = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("delay_keep_alive_trigger",
                                                        "mac_address",
                                                        "packet_sent_timer",
                                                        "remote_request",
                                                        "rx_message_type",
                                                        "rx_neighbor_mac_address",
                                                        "rx_packet_test",
                                                        "rx_path_type",
                                                        "rx_ttl",
                                                        "self_detected_request",
                                                        "send_timer_time_remaining",
                                                        "tx_message_type",
                                                        "tx_neighbor_mac_address",
                                                        "tx_packet_test",
                                                        "tx_path_type",
                                                        "tx_ttl",
                                                        "wrap_state",
                                                        "wtr_timer_remaining") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB, self).__setattr__(name, value)


                                    class AssertedFailure(Entity):
                                        """
                                        Failures presently asserted
                                        
                                        .. attribute:: current_state
                                        
                                        	Current state
                                        	**type**\:   :py:class:`SrpMgmtFailureStateEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureStateEt>`
                                        
                                        .. attribute:: debounced_delay
                                        
                                        	Debounce delay
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: debounced_state
                                        
                                        	Debounced state
                                        	**type**\:   :py:class:`SrpMgmtFailureStateEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureStateEt>`
                                        
                                        .. attribute:: reported_state
                                        
                                        	Reported state
                                        	**type**\:   :py:class:`SrpMgmtFailureStateEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureStateEt>`
                                        
                                        .. attribute:: stable_time
                                        
                                        	Stable time
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: type
                                        
                                        	Failure type
                                        	**type**\:   :py:class:`SrpMgmtFailureEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtFailureEt>`
                                        
                                        

                                        """

                                        _prefix = 'pfi-im-cmd-oper'
                                        _revision = '2016-12-18'

                                        def __init__(self):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB.AssertedFailure, self).__init__()

                                            self.yang_name = "asserted-failure"
                                            self.yang_parent_name = "side-b"

                                            self.current_state = YLeaf(YType.enumeration, "current-state")

                                            self.debounced_delay = YLeaf(YType.uint32, "debounced-delay")

                                            self.debounced_state = YLeaf(YType.enumeration, "debounced-state")

                                            self.reported_state = YLeaf(YType.enumeration, "reported-state")

                                            self.stable_time = YLeaf(YType.uint64, "stable-time")

                                            self.type = YLeaf(YType.enumeration, "type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("current_state",
                                                            "debounced_delay",
                                                            "debounced_state",
                                                            "reported_state",
                                                            "stable_time",
                                                            "type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB.AssertedFailure, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB.AssertedFailure, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.current_state.is_set or
                                                self.debounced_delay.is_set or
                                                self.debounced_state.is_set or
                                                self.reported_state.is_set or
                                                self.stable_time.is_set or
                                                self.type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.current_state.yfilter != YFilter.not_set or
                                                self.debounced_delay.yfilter != YFilter.not_set or
                                                self.debounced_state.yfilter != YFilter.not_set or
                                                self.reported_state.yfilter != YFilter.not_set or
                                                self.stable_time.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "asserted-failure" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.current_state.is_set or self.current_state.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.current_state.get_name_leafdata())
                                            if (self.debounced_delay.is_set or self.debounced_delay.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.debounced_delay.get_name_leafdata())
                                            if (self.debounced_state.is_set or self.debounced_state.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.debounced_state.get_name_leafdata())
                                            if (self.reported_state.is_set or self.reported_state.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.reported_state.get_name_leafdata())
                                            if (self.stable_time.is_set or self.stable_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.stable_time.get_name_leafdata())
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "current-state" or name == "debounced-delay" or name == "debounced-state" or name == "reported-state" or name == "stable-time" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "current-state"):
                                                self.current_state = value
                                                self.current_state.value_namespace = name_space
                                                self.current_state.value_namespace_prefix = name_space_prefix
                                            if(value_path == "debounced-delay"):
                                                self.debounced_delay = value
                                                self.debounced_delay.value_namespace = name_space
                                                self.debounced_delay.value_namespace_prefix = name_space_prefix
                                            if(value_path == "debounced-state"):
                                                self.debounced_state = value
                                                self.debounced_state.value_namespace = name_space
                                                self.debounced_state.value_namespace_prefix = name_space_prefix
                                            if(value_path == "reported-state"):
                                                self.reported_state = value
                                                self.reported_state.value_namespace = name_space
                                                self.reported_state.value_namespace_prefix = name_space_prefix
                                            if(value_path == "stable-time"):
                                                self.stable_time = value
                                                self.stable_time.value_namespace = name_space
                                                self.stable_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.asserted_failure:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.delay_keep_alive_trigger.is_set or
                                            self.mac_address.is_set or
                                            self.packet_sent_timer.is_set or
                                            self.remote_request.is_set or
                                            self.rx_message_type.is_set or
                                            self.rx_neighbor_mac_address.is_set or
                                            self.rx_packet_test.is_set or
                                            self.rx_path_type.is_set or
                                            self.rx_ttl.is_set or
                                            self.self_detected_request.is_set or
                                            self.send_timer_time_remaining.is_set or
                                            self.tx_message_type.is_set or
                                            self.tx_neighbor_mac_address.is_set or
                                            self.tx_packet_test.is_set or
                                            self.tx_path_type.is_set or
                                            self.tx_ttl.is_set or
                                            self.wrap_state.is_set or
                                            self.wtr_timer_remaining.is_set)

                                    def has_operation(self):
                                        for c in self.asserted_failure:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.delay_keep_alive_trigger.yfilter != YFilter.not_set or
                                            self.mac_address.yfilter != YFilter.not_set or
                                            self.packet_sent_timer.yfilter != YFilter.not_set or
                                            self.remote_request.yfilter != YFilter.not_set or
                                            self.rx_message_type.yfilter != YFilter.not_set or
                                            self.rx_neighbor_mac_address.yfilter != YFilter.not_set or
                                            self.rx_packet_test.yfilter != YFilter.not_set or
                                            self.rx_path_type.yfilter != YFilter.not_set or
                                            self.rx_ttl.yfilter != YFilter.not_set or
                                            self.self_detected_request.yfilter != YFilter.not_set or
                                            self.send_timer_time_remaining.yfilter != YFilter.not_set or
                                            self.tx_message_type.yfilter != YFilter.not_set or
                                            self.tx_neighbor_mac_address.yfilter != YFilter.not_set or
                                            self.tx_packet_test.yfilter != YFilter.not_set or
                                            self.tx_path_type.yfilter != YFilter.not_set or
                                            self.tx_ttl.yfilter != YFilter.not_set or
                                            self.wrap_state.yfilter != YFilter.not_set or
                                            self.wtr_timer_remaining.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "side-b" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.delay_keep_alive_trigger.is_set or self.delay_keep_alive_trigger.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.delay_keep_alive_trigger.get_name_leafdata())
                                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mac_address.get_name_leafdata())
                                        if (self.packet_sent_timer.is_set or self.packet_sent_timer.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.packet_sent_timer.get_name_leafdata())
                                        if (self.remote_request.is_set or self.remote_request.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.remote_request.get_name_leafdata())
                                        if (self.rx_message_type.is_set or self.rx_message_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_message_type.get_name_leafdata())
                                        if (self.rx_neighbor_mac_address.is_set or self.rx_neighbor_mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_neighbor_mac_address.get_name_leafdata())
                                        if (self.rx_packet_test.is_set or self.rx_packet_test.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_packet_test.get_name_leafdata())
                                        if (self.rx_path_type.is_set or self.rx_path_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_path_type.get_name_leafdata())
                                        if (self.rx_ttl.is_set or self.rx_ttl.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.rx_ttl.get_name_leafdata())
                                        if (self.self_detected_request.is_set or self.self_detected_request.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.self_detected_request.get_name_leafdata())
                                        if (self.send_timer_time_remaining.is_set or self.send_timer_time_remaining.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.send_timer_time_remaining.get_name_leafdata())
                                        if (self.tx_message_type.is_set or self.tx_message_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_message_type.get_name_leafdata())
                                        if (self.tx_neighbor_mac_address.is_set or self.tx_neighbor_mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_neighbor_mac_address.get_name_leafdata())
                                        if (self.tx_packet_test.is_set or self.tx_packet_test.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_packet_test.get_name_leafdata())
                                        if (self.tx_path_type.is_set or self.tx_path_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_path_type.get_name_leafdata())
                                        if (self.tx_ttl.is_set or self.tx_ttl.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tx_ttl.get_name_leafdata())
                                        if (self.wrap_state.is_set or self.wrap_state.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wrap_state.get_name_leafdata())
                                        if (self.wtr_timer_remaining.is_set or self.wtr_timer_remaining.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wtr_timer_remaining.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "asserted-failure"):
                                            for c in self.asserted_failure:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB.AssertedFailure()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.asserted_failure.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "asserted-failure" or name == "delay-keep-alive-trigger" or name == "mac-address" or name == "packet-sent-timer" or name == "remote-request" or name == "rx-message-type" or name == "rx-neighbor-mac-address" or name == "rx-packet-test" or name == "rx-path-type" or name == "rx-ttl" or name == "self-detected-request" or name == "send-timer-time-remaining" or name == "tx-message-type" or name == "tx-neighbor-mac-address" or name == "tx-packet-test" or name == "tx-path-type" or name == "tx-ttl" or name == "wrap-state" or name == "wtr-timer-remaining"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "delay-keep-alive-trigger"):
                                            self.delay_keep_alive_trigger = value
                                            self.delay_keep_alive_trigger.value_namespace = name_space
                                            self.delay_keep_alive_trigger.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mac-address"):
                                            self.mac_address = value
                                            self.mac_address.value_namespace = name_space
                                            self.mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "packet-sent-timer"):
                                            self.packet_sent_timer = value
                                            self.packet_sent_timer.value_namespace = name_space
                                            self.packet_sent_timer.value_namespace_prefix = name_space_prefix
                                        if(value_path == "remote-request"):
                                            self.remote_request = value
                                            self.remote_request.value_namespace = name_space
                                            self.remote_request.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-message-type"):
                                            self.rx_message_type = value
                                            self.rx_message_type.value_namespace = name_space
                                            self.rx_message_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-neighbor-mac-address"):
                                            self.rx_neighbor_mac_address = value
                                            self.rx_neighbor_mac_address.value_namespace = name_space
                                            self.rx_neighbor_mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-packet-test"):
                                            self.rx_packet_test = value
                                            self.rx_packet_test.value_namespace = name_space
                                            self.rx_packet_test.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-path-type"):
                                            self.rx_path_type = value
                                            self.rx_path_type.value_namespace = name_space
                                            self.rx_path_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "rx-ttl"):
                                            self.rx_ttl = value
                                            self.rx_ttl.value_namespace = name_space
                                            self.rx_ttl.value_namespace_prefix = name_space_prefix
                                        if(value_path == "self-detected-request"):
                                            self.self_detected_request = value
                                            self.self_detected_request.value_namespace = name_space
                                            self.self_detected_request.value_namespace_prefix = name_space_prefix
                                        if(value_path == "send-timer-time-remaining"):
                                            self.send_timer_time_remaining = value
                                            self.send_timer_time_remaining.value_namespace = name_space
                                            self.send_timer_time_remaining.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-message-type"):
                                            self.tx_message_type = value
                                            self.tx_message_type.value_namespace = name_space
                                            self.tx_message_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-neighbor-mac-address"):
                                            self.tx_neighbor_mac_address = value
                                            self.tx_neighbor_mac_address.value_namespace = name_space
                                            self.tx_neighbor_mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-packet-test"):
                                            self.tx_packet_test = value
                                            self.tx_packet_test.value_namespace = name_space
                                            self.tx_packet_test.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-path-type"):
                                            self.tx_path_type = value
                                            self.tx_path_type.value_namespace = name_space
                                            self.tx_path_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tx-ttl"):
                                            self.tx_ttl = value
                                            self.tx_ttl.value_namespace = name_space
                                            self.tx_ttl.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wrap-state"):
                                            self.wrap_state = value
                                            self.wrap_state.value_namespace = name_space
                                            self.wrap_state.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wtr-timer-remaining"):
                                            self.wtr_timer_remaining = value
                                            self.wtr_timer_remaining.value_namespace = name_space
                                            self.wtr_timer_remaining.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.is_inter_card_bus_enabled.is_set or
                                        self.mac_address.is_set or
                                        self.wtr_timer_period.is_set or
                                        (self.side_a is not None and self.side_a.has_data()) or
                                        (self.side_b is not None and self.side_b.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.is_inter_card_bus_enabled.yfilter != YFilter.not_set or
                                        self.mac_address.yfilter != YFilter.not_set or
                                        self.wtr_timer_period.yfilter != YFilter.not_set or
                                        (self.side_a is not None and self.side_a.has_operation()) or
                                        (self.side_b is not None and self.side_b.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "local-information" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.is_inter_card_bus_enabled.is_set or self.is_inter_card_bus_enabled.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_inter_card_bus_enabled.get_name_leafdata())
                                    if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mac_address.get_name_leafdata())
                                    if (self.wtr_timer_period.is_set or self.wtr_timer_period.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wtr_timer_period.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "side-a"):
                                        if (self.side_a is None):
                                            self.side_a = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideA()
                                            self.side_a.parent = self
                                            self._children_name_map["side_a"] = "side-a"
                                        return self.side_a

                                    if (child_yang_name == "side-b"):
                                        if (self.side_b is None):
                                            self.side_b = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation.SideB()
                                            self.side_b.parent = self
                                            self._children_name_map["side_b"] = "side-b"
                                        return self.side_b

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "side-a" or name == "side-b" or name == "is-inter-card-bus-enabled" or name == "mac-address" or name == "wtr-timer-period"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "is-inter-card-bus-enabled"):
                                        self.is_inter_card_bus_enabled = value
                                        self.is_inter_card_bus_enabled.value_namespace = name_space
                                        self.is_inter_card_bus_enabled.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mac-address"):
                                        self.mac_address = value
                                        self.mac_address.value_namespace = name_space
                                        self.mac_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wtr-timer-period"):
                                        self.wtr_timer_period = value
                                        self.wtr_timer_period.value_namespace = name_space
                                        self.wtr_timer_period.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.local_information:
                                    if (c.has_data()):
                                        return True
                                return self.is_admin_down.is_set

                            def has_operation(self):
                                for c in self.local_information:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.is_admin_down.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ips-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.is_admin_down.is_set or self.is_admin_down.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_admin_down.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "local-information"):
                                    for c in self.local_information:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo.LocalInformation()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.local_information.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "local-information" or name == "is-admin-down"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "is-admin-down"):
                                    self.is_admin_down = value
                                    self.is_admin_down.value_namespace = name_space
                                    self.is_admin_down.value_namespace_prefix = name_space_prefix


                        class TopologyInfo(Entity):
                            """
                            SRP topology information
                            
                            .. attribute:: is_admin_down
                            
                            	Is the interfaceadministratively down
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: local_information
                            
                            	Detailed SRP topology information
                            	**type**\: list of    :py:class:`LocalInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation>`
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo, self).__init__()

                                self.yang_name = "topology-info"
                                self.yang_parent_name = "srp-information"

                                self.is_admin_down = YLeaf(YType.int32, "is-admin-down")

                                self.local_information = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("is_admin_down") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo, self).__setattr__(name, value)


                            class LocalInformation(Entity):
                                """
                                Detailed SRP topology information
                                
                                .. attribute:: next_topology_packet_delay
                                
                                	Time remaining until next topo pkt sent
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: number_of_nodes_on_ring
                                
                                	Number of nodes on ring
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: ring_node
                                
                                	List of nodes on the ring info
                                	**type**\: list of    :py:class:`RingNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation.RingNode>`
                                
                                .. attribute:: time_since_last_topology_change
                                
                                	Time since last topology change
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: time_since_last_topology_packet_received
                                
                                	Time since last topo pkt was received
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: topology_timer
                                
                                	How often a topology pkt is sent
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation, self).__init__()

                                    self.yang_name = "local-information"
                                    self.yang_parent_name = "topology-info"

                                    self.next_topology_packet_delay = YLeaf(YType.uint32, "next-topology-packet-delay")

                                    self.number_of_nodes_on_ring = YLeaf(YType.uint16, "number-of-nodes-on-ring")

                                    self.time_since_last_topology_change = YLeaf(YType.uint32, "time-since-last-topology-change")

                                    self.time_since_last_topology_packet_received = YLeaf(YType.uint32, "time-since-last-topology-packet-received")

                                    self.topology_timer = YLeaf(YType.uint32, "topology-timer")

                                    self.ring_node = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("next_topology_packet_delay",
                                                    "number_of_nodes_on_ring",
                                                    "time_since_last_topology_change",
                                                    "time_since_last_topology_packet_received",
                                                    "topology_timer") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation, self).__setattr__(name, value)


                                class RingNode(Entity):
                                    """
                                    List of nodes on the ring info
                                    
                                    .. attribute:: hop_count
                                    
                                    	Outer\-ring hops to reach this node
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: ipv4_address
                                    
                                    	IPv4 address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: is_srr_supported
                                    
                                    	SRR protocol supported
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: is_wrapped
                                    
                                    	Wrap state
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: mac_address
                                    
                                    	MAC address
                                    	**type**\:  str
                                    
                                    .. attribute:: node_name
                                    
                                    	Node name
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'pfi-im-cmd-oper'
                                    _revision = '2016-12-18'

                                    def __init__(self):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation.RingNode, self).__init__()

                                        self.yang_name = "ring-node"
                                        self.yang_parent_name = "local-information"

                                        self.hop_count = YLeaf(YType.uint16, "hop-count")

                                        self.ipv4_address = YLeaf(YType.str, "ipv4-address")

                                        self.is_srr_supported = YLeaf(YType.int32, "is-srr-supported")

                                        self.is_wrapped = YLeaf(YType.int32, "is-wrapped")

                                        self.mac_address = YLeaf(YType.str, "mac-address")

                                        self.node_name = YLeaf(YType.str, "node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("hop_count",
                                                        "ipv4_address",
                                                        "is_srr_supported",
                                                        "is_wrapped",
                                                        "mac_address",
                                                        "node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation.RingNode, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation.RingNode, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.hop_count.is_set or
                                            self.ipv4_address.is_set or
                                            self.is_srr_supported.is_set or
                                            self.is_wrapped.is_set or
                                            self.mac_address.is_set or
                                            self.node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.hop_count.yfilter != YFilter.not_set or
                                            self.ipv4_address.yfilter != YFilter.not_set or
                                            self.is_srr_supported.yfilter != YFilter.not_set or
                                            self.is_wrapped.yfilter != YFilter.not_set or
                                            self.mac_address.yfilter != YFilter.not_set or
                                            self.node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ring-node" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.hop_count.is_set or self.hop_count.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hop_count.get_name_leafdata())
                                        if (self.ipv4_address.is_set or self.ipv4_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ipv4_address.get_name_leafdata())
                                        if (self.is_srr_supported.is_set or self.is_srr_supported.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.is_srr_supported.get_name_leafdata())
                                        if (self.is_wrapped.is_set or self.is_wrapped.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.is_wrapped.get_name_leafdata())
                                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mac_address.get_name_leafdata())
                                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "hop-count" or name == "ipv4-address" or name == "is-srr-supported" or name == "is-wrapped" or name == "mac-address" or name == "node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "hop-count"):
                                            self.hop_count = value
                                            self.hop_count.value_namespace = name_space
                                            self.hop_count.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ipv4-address"):
                                            self.ipv4_address = value
                                            self.ipv4_address.value_namespace = name_space
                                            self.ipv4_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "is-srr-supported"):
                                            self.is_srr_supported = value
                                            self.is_srr_supported.value_namespace = name_space
                                            self.is_srr_supported.value_namespace_prefix = name_space_prefix
                                        if(value_path == "is-wrapped"):
                                            self.is_wrapped = value
                                            self.is_wrapped.value_namespace = name_space
                                            self.is_wrapped.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mac-address"):
                                            self.mac_address = value
                                            self.mac_address.value_namespace = name_space
                                            self.mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "node-name"):
                                            self.node_name = value
                                            self.node_name.value_namespace = name_space
                                            self.node_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.ring_node:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.next_topology_packet_delay.is_set or
                                        self.number_of_nodes_on_ring.is_set or
                                        self.time_since_last_topology_change.is_set or
                                        self.time_since_last_topology_packet_received.is_set or
                                        self.topology_timer.is_set)

                                def has_operation(self):
                                    for c in self.ring_node:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.next_topology_packet_delay.yfilter != YFilter.not_set or
                                        self.number_of_nodes_on_ring.yfilter != YFilter.not_set or
                                        self.time_since_last_topology_change.yfilter != YFilter.not_set or
                                        self.time_since_last_topology_packet_received.yfilter != YFilter.not_set or
                                        self.topology_timer.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "local-information" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.next_topology_packet_delay.is_set or self.next_topology_packet_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_topology_packet_delay.get_name_leafdata())
                                    if (self.number_of_nodes_on_ring.is_set or self.number_of_nodes_on_ring.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.number_of_nodes_on_ring.get_name_leafdata())
                                    if (self.time_since_last_topology_change.is_set or self.time_since_last_topology_change.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.time_since_last_topology_change.get_name_leafdata())
                                    if (self.time_since_last_topology_packet_received.is_set or self.time_since_last_topology_packet_received.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.time_since_last_topology_packet_received.get_name_leafdata())
                                    if (self.topology_timer.is_set or self.topology_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.topology_timer.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "ring-node"):
                                        for c in self.ring_node:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation.RingNode()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.ring_node.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ring-node" or name == "next-topology-packet-delay" or name == "number-of-nodes-on-ring" or name == "time-since-last-topology-change" or name == "time-since-last-topology-packet-received" or name == "topology-timer"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "next-topology-packet-delay"):
                                        self.next_topology_packet_delay = value
                                        self.next_topology_packet_delay.value_namespace = name_space
                                        self.next_topology_packet_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "number-of-nodes-on-ring"):
                                        self.number_of_nodes_on_ring = value
                                        self.number_of_nodes_on_ring.value_namespace = name_space
                                        self.number_of_nodes_on_ring.value_namespace_prefix = name_space_prefix
                                    if(value_path == "time-since-last-topology-change"):
                                        self.time_since_last_topology_change = value
                                        self.time_since_last_topology_change.value_namespace = name_space
                                        self.time_since_last_topology_change.value_namespace_prefix = name_space_prefix
                                    if(value_path == "time-since-last-topology-packet-received"):
                                        self.time_since_last_topology_packet_received = value
                                        self.time_since_last_topology_packet_received.value_namespace = name_space
                                        self.time_since_last_topology_packet_received.value_namespace_prefix = name_space_prefix
                                    if(value_path == "topology-timer"):
                                        self.topology_timer = value
                                        self.topology_timer.value_namespace = name_space
                                        self.topology_timer.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.local_information:
                                    if (c.has_data()):
                                        return True
                                return self.is_admin_down.is_set

                            def has_operation(self):
                                for c in self.local_information:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.is_admin_down.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "topology-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.is_admin_down.is_set or self.is_admin_down.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_admin_down.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "local-information"):
                                    for c in self.local_information:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo.LocalInformation()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.local_information.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "local-information" or name == "is-admin-down"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "is-admin-down"):
                                    self.is_admin_down = value
                                    self.is_admin_down.value_namespace = name_space
                                    self.is_admin_down.value_namespace_prefix = name_space_prefix


                        class SrrInfo(Entity):
                            """
                            SRP SRR information
                            
                            .. attribute:: is_admin_down
                            
                            	Is the interfaceadministratively down
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: is_srr_enabled
                            
                            	SRR enabled
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: srr_detailed_info
                            
                            	SRP information
                            	**type**\: list of    :py:class:`SrrDetailedInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo>`
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo, self).__init__()

                                self.yang_name = "srr-info"
                                self.yang_parent_name = "srp-information"

                                self.is_admin_down = YLeaf(YType.int32, "is-admin-down")

                                self.is_srr_enabled = YLeaf(YType.int32, "is-srr-enabled")

                                self.srr_detailed_info = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("is_admin_down",
                                                "is_srr_enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo, self).__setattr__(name, value)


                            class SrrDetailedInfo(Entity):
                                """
                                SRP information
                                
                                .. attribute:: inner_fail_type
                                
                                	Inner fail type
                                	**type**\:   :py:class:`SrpMgmtSrrFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtSrrFailure>`
                                
                                .. attribute:: is_announce
                                
                                	Is announcing enabled
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: is_inner_ring_in_use
                                
                                	 Is the inner ring in use
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: is_outer_ring_in_use
                                
                                	Is the outer ring in use
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: is_wrong_version_received
                                
                                	Wrong version recieved
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: last_wrong_version_receive_time
                                
                                	Time that last wrong version message recieved
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: mac_address
                                
                                	SRR node mac address
                                	**type**\:  str
                                
                                .. attribute:: next_srr_packet_send_time
                                
                                	Time remaining in seconds to next SRR packet send
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                .. attribute:: node_state
                                
                                	SRR node state
                                	**type**\:   :py:class:`SrpMgmtSrrNodeState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtSrrNodeState>`
                                
                                .. attribute:: nodes_not_on_ring
                                
                                	nodes not in topology map
                                	**type**\: list of    :py:class:`NodesNotOnRing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesNotOnRing>`
                                
                                .. attribute:: nodes_on_ring
                                
                                	List of nodes on the ring info
                                	**type**\: list of    :py:class:`NodesOnRing <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesOnRing>`
                                
                                .. attribute:: outer_fail_type
                                
                                	Outer fail type
                                	**type**\:   :py:class:`SrpMgmtSrrFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtSrrFailure>`
                                
                                .. attribute:: packet_send_timer
                                
                                	SRR packet send timer interval in seconds
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                .. attribute:: single_ring_bw
                                
                                	Single ring bandwidth Mbps
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: Mbit/s
                                
                                .. attribute:: version_number
                                
                                	Version number
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: wtr_time
                                
                                	SRR Wait To Restore interval delay in seconds
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                .. attribute:: wtr_timer_remaining_inner_ring
                                
                                	Time remaining in seconds until next inner ring wrap removal
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                .. attribute:: wtr_timer_remaining_outer_ring
                                
                                	Time remaining in seconds until next outer ring wrap removal
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo, self).__init__()

                                    self.yang_name = "srr-detailed-info"
                                    self.yang_parent_name = "srr-info"

                                    self.inner_fail_type = YLeaf(YType.enumeration, "inner-fail-type")

                                    self.is_announce = YLeaf(YType.int32, "is-announce")

                                    self.is_inner_ring_in_use = YLeaf(YType.int32, "is-inner-ring-in-use")

                                    self.is_outer_ring_in_use = YLeaf(YType.int32, "is-outer-ring-in-use")

                                    self.is_wrong_version_received = YLeaf(YType.int32, "is-wrong-version-received")

                                    self.last_wrong_version_receive_time = YLeaf(YType.uint32, "last-wrong-version-receive-time")

                                    self.mac_address = YLeaf(YType.str, "mac-address")

                                    self.next_srr_packet_send_time = YLeaf(YType.uint32, "next-srr-packet-send-time")

                                    self.node_state = YLeaf(YType.enumeration, "node-state")

                                    self.outer_fail_type = YLeaf(YType.enumeration, "outer-fail-type")

                                    self.packet_send_timer = YLeaf(YType.uint32, "packet-send-timer")

                                    self.single_ring_bw = YLeaf(YType.uint32, "single-ring-bw")

                                    self.version_number = YLeaf(YType.uint32, "version-number")

                                    self.wtr_time = YLeaf(YType.uint32, "wtr-time")

                                    self.wtr_timer_remaining_inner_ring = YLeaf(YType.uint32, "wtr-timer-remaining-inner-ring")

                                    self.wtr_timer_remaining_outer_ring = YLeaf(YType.uint32, "wtr-timer-remaining-outer-ring")

                                    self.nodes_not_on_ring = YList(self)
                                    self.nodes_on_ring = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("inner_fail_type",
                                                    "is_announce",
                                                    "is_inner_ring_in_use",
                                                    "is_outer_ring_in_use",
                                                    "is_wrong_version_received",
                                                    "last_wrong_version_receive_time",
                                                    "mac_address",
                                                    "next_srr_packet_send_time",
                                                    "node_state",
                                                    "outer_fail_type",
                                                    "packet_send_timer",
                                                    "single_ring_bw",
                                                    "version_number",
                                                    "wtr_time",
                                                    "wtr_timer_remaining_inner_ring",
                                                    "wtr_timer_remaining_outer_ring") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo, self).__setattr__(name, value)


                                class NodesOnRing(Entity):
                                    """
                                    List of nodes on the ring info
                                    
                                    .. attribute:: inner_failure
                                    
                                    	Inner failure
                                    	**type**\:   :py:class:`SrpMgmtSrrFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtSrrFailure>`
                                    
                                    .. attribute:: is_last_announce_received
                                    
                                    	Announce last received ?
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: last_announce_received_time
                                    
                                    	Announce last received
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: mac_address
                                    
                                    	node mac address
                                    	**type**\:  str
                                    
                                    .. attribute:: node_name
                                    
                                    	Node name
                                    	**type**\:  str
                                    
                                    .. attribute:: outer_failure
                                    
                                    	Outer failure
                                    	**type**\:   :py:class:`SrpMgmtSrrFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtSrrFailure>`
                                    
                                    .. attribute:: srr_entry_exits
                                    
                                    	Does the SRR information exist for this node
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    

                                    """

                                    _prefix = 'pfi-im-cmd-oper'
                                    _revision = '2016-12-18'

                                    def __init__(self):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesOnRing, self).__init__()

                                        self.yang_name = "nodes-on-ring"
                                        self.yang_parent_name = "srr-detailed-info"

                                        self.inner_failure = YLeaf(YType.enumeration, "inner-failure")

                                        self.is_last_announce_received = YLeaf(YType.int32, "is-last-announce-received")

                                        self.last_announce_received_time = YLeaf(YType.uint32, "last-announce-received-time")

                                        self.mac_address = YLeaf(YType.str, "mac-address")

                                        self.node_name = YLeaf(YType.str, "node-name")

                                        self.outer_failure = YLeaf(YType.enumeration, "outer-failure")

                                        self.srr_entry_exits = YLeaf(YType.int32, "srr-entry-exits")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("inner_failure",
                                                        "is_last_announce_received",
                                                        "last_announce_received_time",
                                                        "mac_address",
                                                        "node_name",
                                                        "outer_failure",
                                                        "srr_entry_exits") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesOnRing, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesOnRing, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.inner_failure.is_set or
                                            self.is_last_announce_received.is_set or
                                            self.last_announce_received_time.is_set or
                                            self.mac_address.is_set or
                                            self.node_name.is_set or
                                            self.outer_failure.is_set or
                                            self.srr_entry_exits.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.inner_failure.yfilter != YFilter.not_set or
                                            self.is_last_announce_received.yfilter != YFilter.not_set or
                                            self.last_announce_received_time.yfilter != YFilter.not_set or
                                            self.mac_address.yfilter != YFilter.not_set or
                                            self.node_name.yfilter != YFilter.not_set or
                                            self.outer_failure.yfilter != YFilter.not_set or
                                            self.srr_entry_exits.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "nodes-on-ring" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.inner_failure.is_set or self.inner_failure.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.inner_failure.get_name_leafdata())
                                        if (self.is_last_announce_received.is_set or self.is_last_announce_received.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.is_last_announce_received.get_name_leafdata())
                                        if (self.last_announce_received_time.is_set or self.last_announce_received_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.last_announce_received_time.get_name_leafdata())
                                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mac_address.get_name_leafdata())
                                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.node_name.get_name_leafdata())
                                        if (self.outer_failure.is_set or self.outer_failure.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.outer_failure.get_name_leafdata())
                                        if (self.srr_entry_exits.is_set or self.srr_entry_exits.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.srr_entry_exits.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "inner-failure" or name == "is-last-announce-received" or name == "last-announce-received-time" or name == "mac-address" or name == "node-name" or name == "outer-failure" or name == "srr-entry-exits"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "inner-failure"):
                                            self.inner_failure = value
                                            self.inner_failure.value_namespace = name_space
                                            self.inner_failure.value_namespace_prefix = name_space_prefix
                                        if(value_path == "is-last-announce-received"):
                                            self.is_last_announce_received = value
                                            self.is_last_announce_received.value_namespace = name_space
                                            self.is_last_announce_received.value_namespace_prefix = name_space_prefix
                                        if(value_path == "last-announce-received-time"):
                                            self.last_announce_received_time = value
                                            self.last_announce_received_time.value_namespace = name_space
                                            self.last_announce_received_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mac-address"):
                                            self.mac_address = value
                                            self.mac_address.value_namespace = name_space
                                            self.mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "node-name"):
                                            self.node_name = value
                                            self.node_name.value_namespace = name_space
                                            self.node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "outer-failure"):
                                            self.outer_failure = value
                                            self.outer_failure.value_namespace = name_space
                                            self.outer_failure.value_namespace_prefix = name_space_prefix
                                        if(value_path == "srr-entry-exits"):
                                            self.srr_entry_exits = value
                                            self.srr_entry_exits.value_namespace = name_space
                                            self.srr_entry_exits.value_namespace_prefix = name_space_prefix


                                class NodesNotOnRing(Entity):
                                    """
                                    nodes not in topology map
                                    
                                    .. attribute:: inner_failure
                                    
                                    	Inner failure
                                    	**type**\:   :py:class:`SrpMgmtSrrFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtSrrFailure>`
                                    
                                    .. attribute:: is_last_announce_received
                                    
                                    	Announce last received ?
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: last_announce_received_time
                                    
                                    	Announce last received
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: mac_address
                                    
                                    	node mac address
                                    	**type**\:  str
                                    
                                    .. attribute:: node_name
                                    
                                    	Node name
                                    	**type**\:  str
                                    
                                    .. attribute:: outer_failure
                                    
                                    	Outer failure
                                    	**type**\:   :py:class:`SrpMgmtSrrFailure <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SrpMgmtSrrFailure>`
                                    
                                    .. attribute:: srr_entry_exits
                                    
                                    	Does the SRR information exist for this node
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    

                                    """

                                    _prefix = 'pfi-im-cmd-oper'
                                    _revision = '2016-12-18'

                                    def __init__(self):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesNotOnRing, self).__init__()

                                        self.yang_name = "nodes-not-on-ring"
                                        self.yang_parent_name = "srr-detailed-info"

                                        self.inner_failure = YLeaf(YType.enumeration, "inner-failure")

                                        self.is_last_announce_received = YLeaf(YType.int32, "is-last-announce-received")

                                        self.last_announce_received_time = YLeaf(YType.uint32, "last-announce-received-time")

                                        self.mac_address = YLeaf(YType.str, "mac-address")

                                        self.node_name = YLeaf(YType.str, "node-name")

                                        self.outer_failure = YLeaf(YType.enumeration, "outer-failure")

                                        self.srr_entry_exits = YLeaf(YType.int32, "srr-entry-exits")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("inner_failure",
                                                        "is_last_announce_received",
                                                        "last_announce_received_time",
                                                        "mac_address",
                                                        "node_name",
                                                        "outer_failure",
                                                        "srr_entry_exits") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesNotOnRing, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesNotOnRing, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.inner_failure.is_set or
                                            self.is_last_announce_received.is_set or
                                            self.last_announce_received_time.is_set or
                                            self.mac_address.is_set or
                                            self.node_name.is_set or
                                            self.outer_failure.is_set or
                                            self.srr_entry_exits.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.inner_failure.yfilter != YFilter.not_set or
                                            self.is_last_announce_received.yfilter != YFilter.not_set or
                                            self.last_announce_received_time.yfilter != YFilter.not_set or
                                            self.mac_address.yfilter != YFilter.not_set or
                                            self.node_name.yfilter != YFilter.not_set or
                                            self.outer_failure.yfilter != YFilter.not_set or
                                            self.srr_entry_exits.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "nodes-not-on-ring" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.inner_failure.is_set or self.inner_failure.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.inner_failure.get_name_leafdata())
                                        if (self.is_last_announce_received.is_set or self.is_last_announce_received.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.is_last_announce_received.get_name_leafdata())
                                        if (self.last_announce_received_time.is_set or self.last_announce_received_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.last_announce_received_time.get_name_leafdata())
                                        if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mac_address.get_name_leafdata())
                                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.node_name.get_name_leafdata())
                                        if (self.outer_failure.is_set or self.outer_failure.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.outer_failure.get_name_leafdata())
                                        if (self.srr_entry_exits.is_set or self.srr_entry_exits.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.srr_entry_exits.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "inner-failure" or name == "is-last-announce-received" or name == "last-announce-received-time" or name == "mac-address" or name == "node-name" or name == "outer-failure" or name == "srr-entry-exits"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "inner-failure"):
                                            self.inner_failure = value
                                            self.inner_failure.value_namespace = name_space
                                            self.inner_failure.value_namespace_prefix = name_space_prefix
                                        if(value_path == "is-last-announce-received"):
                                            self.is_last_announce_received = value
                                            self.is_last_announce_received.value_namespace = name_space
                                            self.is_last_announce_received.value_namespace_prefix = name_space_prefix
                                        if(value_path == "last-announce-received-time"):
                                            self.last_announce_received_time = value
                                            self.last_announce_received_time.value_namespace = name_space
                                            self.last_announce_received_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mac-address"):
                                            self.mac_address = value
                                            self.mac_address.value_namespace = name_space
                                            self.mac_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "node-name"):
                                            self.node_name = value
                                            self.node_name.value_namespace = name_space
                                            self.node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "outer-failure"):
                                            self.outer_failure = value
                                            self.outer_failure.value_namespace = name_space
                                            self.outer_failure.value_namespace_prefix = name_space_prefix
                                        if(value_path == "srr-entry-exits"):
                                            self.srr_entry_exits = value
                                            self.srr_entry_exits.value_namespace = name_space
                                            self.srr_entry_exits.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.nodes_not_on_ring:
                                        if (c.has_data()):
                                            return True
                                    for c in self.nodes_on_ring:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.inner_fail_type.is_set or
                                        self.is_announce.is_set or
                                        self.is_inner_ring_in_use.is_set or
                                        self.is_outer_ring_in_use.is_set or
                                        self.is_wrong_version_received.is_set or
                                        self.last_wrong_version_receive_time.is_set or
                                        self.mac_address.is_set or
                                        self.next_srr_packet_send_time.is_set or
                                        self.node_state.is_set or
                                        self.outer_fail_type.is_set or
                                        self.packet_send_timer.is_set or
                                        self.single_ring_bw.is_set or
                                        self.version_number.is_set or
                                        self.wtr_time.is_set or
                                        self.wtr_timer_remaining_inner_ring.is_set or
                                        self.wtr_timer_remaining_outer_ring.is_set)

                                def has_operation(self):
                                    for c in self.nodes_not_on_ring:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.nodes_on_ring:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.inner_fail_type.yfilter != YFilter.not_set or
                                        self.is_announce.yfilter != YFilter.not_set or
                                        self.is_inner_ring_in_use.yfilter != YFilter.not_set or
                                        self.is_outer_ring_in_use.yfilter != YFilter.not_set or
                                        self.is_wrong_version_received.yfilter != YFilter.not_set or
                                        self.last_wrong_version_receive_time.yfilter != YFilter.not_set or
                                        self.mac_address.yfilter != YFilter.not_set or
                                        self.next_srr_packet_send_time.yfilter != YFilter.not_set or
                                        self.node_state.yfilter != YFilter.not_set or
                                        self.outer_fail_type.yfilter != YFilter.not_set or
                                        self.packet_send_timer.yfilter != YFilter.not_set or
                                        self.single_ring_bw.yfilter != YFilter.not_set or
                                        self.version_number.yfilter != YFilter.not_set or
                                        self.wtr_time.yfilter != YFilter.not_set or
                                        self.wtr_timer_remaining_inner_ring.yfilter != YFilter.not_set or
                                        self.wtr_timer_remaining_outer_ring.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "srr-detailed-info" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.inner_fail_type.is_set or self.inner_fail_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.inner_fail_type.get_name_leafdata())
                                    if (self.is_announce.is_set or self.is_announce.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_announce.get_name_leafdata())
                                    if (self.is_inner_ring_in_use.is_set or self.is_inner_ring_in_use.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_inner_ring_in_use.get_name_leafdata())
                                    if (self.is_outer_ring_in_use.is_set or self.is_outer_ring_in_use.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_outer_ring_in_use.get_name_leafdata())
                                    if (self.is_wrong_version_received.is_set or self.is_wrong_version_received.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_wrong_version_received.get_name_leafdata())
                                    if (self.last_wrong_version_receive_time.is_set or self.last_wrong_version_receive_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.last_wrong_version_receive_time.get_name_leafdata())
                                    if (self.mac_address.is_set or self.mac_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mac_address.get_name_leafdata())
                                    if (self.next_srr_packet_send_time.is_set or self.next_srr_packet_send_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_srr_packet_send_time.get_name_leafdata())
                                    if (self.node_state.is_set or self.node_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_state.get_name_leafdata())
                                    if (self.outer_fail_type.is_set or self.outer_fail_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outer_fail_type.get_name_leafdata())
                                    if (self.packet_send_timer.is_set or self.packet_send_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.packet_send_timer.get_name_leafdata())
                                    if (self.single_ring_bw.is_set or self.single_ring_bw.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.single_ring_bw.get_name_leafdata())
                                    if (self.version_number.is_set or self.version_number.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.version_number.get_name_leafdata())
                                    if (self.wtr_time.is_set or self.wtr_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wtr_time.get_name_leafdata())
                                    if (self.wtr_timer_remaining_inner_ring.is_set or self.wtr_timer_remaining_inner_ring.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wtr_timer_remaining_inner_ring.get_name_leafdata())
                                    if (self.wtr_timer_remaining_outer_ring.is_set or self.wtr_timer_remaining_outer_ring.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wtr_timer_remaining_outer_ring.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "nodes-not-on-ring"):
                                        for c in self.nodes_not_on_ring:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesNotOnRing()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.nodes_not_on_ring.append(c)
                                        return c

                                    if (child_yang_name == "nodes-on-ring"):
                                        for c in self.nodes_on_ring:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo.NodesOnRing()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.nodes_on_ring.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "nodes-not-on-ring" or name == "nodes-on-ring" or name == "inner-fail-type" or name == "is-announce" or name == "is-inner-ring-in-use" or name == "is-outer-ring-in-use" or name == "is-wrong-version-received" or name == "last-wrong-version-receive-time" or name == "mac-address" or name == "next-srr-packet-send-time" or name == "node-state" or name == "outer-fail-type" or name == "packet-send-timer" or name == "single-ring-bw" or name == "version-number" or name == "wtr-time" or name == "wtr-timer-remaining-inner-ring" or name == "wtr-timer-remaining-outer-ring"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "inner-fail-type"):
                                        self.inner_fail_type = value
                                        self.inner_fail_type.value_namespace = name_space
                                        self.inner_fail_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-announce"):
                                        self.is_announce = value
                                        self.is_announce.value_namespace = name_space
                                        self.is_announce.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-inner-ring-in-use"):
                                        self.is_inner_ring_in_use = value
                                        self.is_inner_ring_in_use.value_namespace = name_space
                                        self.is_inner_ring_in_use.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-outer-ring-in-use"):
                                        self.is_outer_ring_in_use = value
                                        self.is_outer_ring_in_use.value_namespace = name_space
                                        self.is_outer_ring_in_use.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-wrong-version-received"):
                                        self.is_wrong_version_received = value
                                        self.is_wrong_version_received.value_namespace = name_space
                                        self.is_wrong_version_received.value_namespace_prefix = name_space_prefix
                                    if(value_path == "last-wrong-version-receive-time"):
                                        self.last_wrong_version_receive_time = value
                                        self.last_wrong_version_receive_time.value_namespace = name_space
                                        self.last_wrong_version_receive_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mac-address"):
                                        self.mac_address = value
                                        self.mac_address.value_namespace = name_space
                                        self.mac_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-srr-packet-send-time"):
                                        self.next_srr_packet_send_time = value
                                        self.next_srr_packet_send_time.value_namespace = name_space
                                        self.next_srr_packet_send_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-state"):
                                        self.node_state = value
                                        self.node_state.value_namespace = name_space
                                        self.node_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outer-fail-type"):
                                        self.outer_fail_type = value
                                        self.outer_fail_type.value_namespace = name_space
                                        self.outer_fail_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "packet-send-timer"):
                                        self.packet_send_timer = value
                                        self.packet_send_timer.value_namespace = name_space
                                        self.packet_send_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "single-ring-bw"):
                                        self.single_ring_bw = value
                                        self.single_ring_bw.value_namespace = name_space
                                        self.single_ring_bw.value_namespace_prefix = name_space_prefix
                                    if(value_path == "version-number"):
                                        self.version_number = value
                                        self.version_number.value_namespace = name_space
                                        self.version_number.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wtr-time"):
                                        self.wtr_time = value
                                        self.wtr_time.value_namespace = name_space
                                        self.wtr_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wtr-timer-remaining-inner-ring"):
                                        self.wtr_timer_remaining_inner_ring = value
                                        self.wtr_timer_remaining_inner_ring.value_namespace = name_space
                                        self.wtr_timer_remaining_inner_ring.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wtr-timer-remaining-outer-ring"):
                                        self.wtr_timer_remaining_outer_ring = value
                                        self.wtr_timer_remaining_outer_ring.value_namespace = name_space
                                        self.wtr_timer_remaining_outer_ring.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.srr_detailed_info:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.is_admin_down.is_set or
                                    self.is_srr_enabled.is_set)

                            def has_operation(self):
                                for c in self.srr_detailed_info:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.is_admin_down.yfilter != YFilter.not_set or
                                    self.is_srr_enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "srr-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.is_admin_down.is_set or self.is_admin_down.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_admin_down.get_name_leafdata())
                                if (self.is_srr_enabled.is_set or self.is_srr_enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_srr_enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "srr-detailed-info"):
                                    for c in self.srr_detailed_info:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo.SrrDetailedInfo()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.srr_detailed_info.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "srr-detailed-info" or name == "is-admin-down" or name == "is-srr-enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "is-admin-down"):
                                    self.is_admin_down = value
                                    self.is_admin_down.value_namespace = name_space
                                    self.is_admin_down.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-srr-enabled"):
                                    self.is_srr_enabled = value
                                    self.is_srr_enabled.value_namespace = name_space
                                    self.is_srr_enabled.value_namespace_prefix = name_space_prefix


                        class RateLimitInfo(Entity):
                            """
                            SRP rate limit information
                            
                            .. attribute:: is_admin_down
                            
                            	Is the interfaceadministratively down
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: rate_limit_detailed_info
                            
                            	SRP rate limit information
                            	**type**\: list of    :py:class:`RateLimitDetailedInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo.RateLimitDetailedInfo>`
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo, self).__init__()

                                self.yang_name = "rate-limit-info"
                                self.yang_parent_name = "srp-information"

                                self.is_admin_down = YLeaf(YType.int32, "is-admin-down")

                                self.rate_limit_detailed_info = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("is_admin_down") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo, self).__setattr__(name, value)


                            class RateLimitDetailedInfo(Entity):
                                """
                                SRP rate limit information
                                
                                .. attribute:: min_priority_value
                                
                                	Minimum SRP priority for high\-priority transmit queue
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo.RateLimitDetailedInfo, self).__init__()

                                    self.yang_name = "rate-limit-detailed-info"
                                    self.yang_parent_name = "rate-limit-info"

                                    self.min_priority_value = YLeaf(YType.uint16, "min-priority-value")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("min_priority_value") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo.RateLimitDetailedInfo, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo.RateLimitDetailedInfo, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.min_priority_value.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.min_priority_value.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "rate-limit-detailed-info" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.min_priority_value.is_set or self.min_priority_value.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.min_priority_value.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "min-priority-value"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "min-priority-value"):
                                        self.min_priority_value = value
                                        self.min_priority_value.value_namespace = name_space
                                        self.min_priority_value.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.rate_limit_detailed_info:
                                    if (c.has_data()):
                                        return True
                                return self.is_admin_down.is_set

                            def has_operation(self):
                                for c in self.rate_limit_detailed_info:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.is_admin_down.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "rate-limit-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.is_admin_down.is_set or self.is_admin_down.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_admin_down.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "rate-limit-detailed-info"):
                                    for c in self.rate_limit_detailed_info:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo.RateLimitDetailedInfo()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.rate_limit_detailed_info.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "rate-limit-detailed-info" or name == "is-admin-down"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "is-admin-down"):
                                    self.is_admin_down = value
                                    self.is_admin_down.value_namespace = name_space
                                    self.is_admin_down.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.ips_info is not None and self.ips_info.has_data()) or
                                (self.rate_limit_info is not None and self.rate_limit_info.has_data()) or
                                (self.srr_info is not None and self.srr_info.has_data()) or
                                (self.topology_info is not None and self.topology_info.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.ips_info is not None and self.ips_info.has_operation()) or
                                (self.rate_limit_info is not None and self.rate_limit_info.has_operation()) or
                                (self.srr_info is not None and self.srr_info.has_operation()) or
                                (self.topology_info is not None and self.topology_info.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "srp-information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ips-info"):
                                if (self.ips_info is None):
                                    self.ips_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.IpsInfo()
                                    self.ips_info.parent = self
                                    self._children_name_map["ips_info"] = "ips-info"
                                return self.ips_info

                            if (child_yang_name == "rate-limit-info"):
                                if (self.rate_limit_info is None):
                                    self.rate_limit_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.RateLimitInfo()
                                    self.rate_limit_info.parent = self
                                    self._children_name_map["rate_limit_info"] = "rate-limit-info"
                                return self.rate_limit_info

                            if (child_yang_name == "srr-info"):
                                if (self.srr_info is None):
                                    self.srr_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.SrrInfo()
                                    self.srr_info.parent = self
                                    self._children_name_map["srr_info"] = "srr-info"
                                return self.srr_info

                            if (child_yang_name == "topology-info"):
                                if (self.topology_info is None):
                                    self.topology_info = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation.TopologyInfo()
                                    self.topology_info.parent = self
                                    self._children_name_map["topology_info"] = "topology-info"
                                return self.topology_info

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ips-info" or name == "rate-limit-info" or name == "srr-info" or name == "topology-info"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class SrpStatistics(Entity):
                        """
                        SRP\-specific packet and byte counters
                        
                        .. attribute:: data_rate_interval
                        
                        	Data rate interval (5 mins or 30 seconds)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: second
                        
                        .. attribute:: side_a_data_rate
                        
                        	Data rates for side A interface
                        	**type**\:   :py:class:`SideADataRate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideADataRate>`
                        
                        .. attribute:: side_a_errors
                        
                        	Errors for side A interface
                        	**type**\:   :py:class:`SideAErrors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideAErrors>`
                        
                        .. attribute:: side_b_data_rate
                        
                        	Data rates for side B interface
                        	**type**\:   :py:class:`SideBDataRate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBDataRate>`
                        
                        .. attribute:: side_b_errors
                        
                        	Errors for side B interface
                        	**type**\:   :py:class:`SideBErrors <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBErrors>`
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics, self).__init__()

                            self.yang_name = "srp-statistics"
                            self.yang_parent_name = "srp-information"

                            self.data_rate_interval = YLeaf(YType.uint32, "data-rate-interval")

                            self.side_a_data_rate = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideADataRate()
                            self.side_a_data_rate.parent = self
                            self._children_name_map["side_a_data_rate"] = "side-a-data-rate"
                            self._children_yang_names.add("side-a-data-rate")

                            self.side_a_errors = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideAErrors()
                            self.side_a_errors.parent = self
                            self._children_name_map["side_a_errors"] = "side-a-errors"
                            self._children_yang_names.add("side-a-errors")

                            self.side_b_data_rate = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBDataRate()
                            self.side_b_data_rate.parent = self
                            self._children_name_map["side_b_data_rate"] = "side-b-data-rate"
                            self._children_yang_names.add("side-b-data-rate")

                            self.side_b_errors = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBErrors()
                            self.side_b_errors.parent = self
                            self._children_name_map["side_b_errors"] = "side-b-errors"
                            self._children_yang_names.add("side-b-errors")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("data_rate_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics, self).__setattr__(name, value)


                        class SideADataRate(Entity):
                            """
                            Data rates for side A interface
                            
                            .. attribute:: bit_rate_received
                            
                            	Received bit rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: bit_rate_sent
                            
                            	Sent bit rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: packet_rate_received
                            
                            	Received packet rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: packet_rate_sent
                            
                            	Sent packet rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideADataRate, self).__init__()

                                self.yang_name = "side-a-data-rate"
                                self.yang_parent_name = "srp-statistics"

                                self.bit_rate_received = YLeaf(YType.uint32, "bit-rate-received")

                                self.bit_rate_sent = YLeaf(YType.uint32, "bit-rate-sent")

                                self.packet_rate_received = YLeaf(YType.uint32, "packet-rate-received")

                                self.packet_rate_sent = YLeaf(YType.uint32, "packet-rate-sent")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bit_rate_received",
                                                "bit_rate_sent",
                                                "packet_rate_received",
                                                "packet_rate_sent") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideADataRate, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideADataRate, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.bit_rate_received.is_set or
                                    self.bit_rate_sent.is_set or
                                    self.packet_rate_received.is_set or
                                    self.packet_rate_sent.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bit_rate_received.yfilter != YFilter.not_set or
                                    self.bit_rate_sent.yfilter != YFilter.not_set or
                                    self.packet_rate_received.yfilter != YFilter.not_set or
                                    self.packet_rate_sent.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "side-a-data-rate" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bit_rate_received.is_set or self.bit_rate_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bit_rate_received.get_name_leafdata())
                                if (self.bit_rate_sent.is_set or self.bit_rate_sent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bit_rate_sent.get_name_leafdata())
                                if (self.packet_rate_received.is_set or self.packet_rate_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.packet_rate_received.get_name_leafdata())
                                if (self.packet_rate_sent.is_set or self.packet_rate_sent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.packet_rate_sent.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bit-rate-received" or name == "bit-rate-sent" or name == "packet-rate-received" or name == "packet-rate-sent"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bit-rate-received"):
                                    self.bit_rate_received = value
                                    self.bit_rate_received.value_namespace = name_space
                                    self.bit_rate_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "bit-rate-sent"):
                                    self.bit_rate_sent = value
                                    self.bit_rate_sent.value_namespace = name_space
                                    self.bit_rate_sent.value_namespace_prefix = name_space_prefix
                                if(value_path == "packet-rate-received"):
                                    self.packet_rate_received = value
                                    self.packet_rate_received.value_namespace = name_space
                                    self.packet_rate_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "packet-rate-sent"):
                                    self.packet_rate_sent = value
                                    self.packet_rate_sent.value_namespace = name_space
                                    self.packet_rate_sent.value_namespace_prefix = name_space_prefix


                        class SideBDataRate(Entity):
                            """
                            Data rates for side B interface
                            
                            .. attribute:: bit_rate_received
                            
                            	Received bit rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: bit_rate_sent
                            
                            	Sent bit rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: packet_rate_received
                            
                            	Received packet rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: packet_rate_sent
                            
                            	Sent packet rate
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBDataRate, self).__init__()

                                self.yang_name = "side-b-data-rate"
                                self.yang_parent_name = "srp-statistics"

                                self.bit_rate_received = YLeaf(YType.uint32, "bit-rate-received")

                                self.bit_rate_sent = YLeaf(YType.uint32, "bit-rate-sent")

                                self.packet_rate_received = YLeaf(YType.uint32, "packet-rate-received")

                                self.packet_rate_sent = YLeaf(YType.uint32, "packet-rate-sent")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bit_rate_received",
                                                "bit_rate_sent",
                                                "packet_rate_received",
                                                "packet_rate_sent") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBDataRate, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBDataRate, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.bit_rate_received.is_set or
                                    self.bit_rate_sent.is_set or
                                    self.packet_rate_received.is_set or
                                    self.packet_rate_sent.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bit_rate_received.yfilter != YFilter.not_set or
                                    self.bit_rate_sent.yfilter != YFilter.not_set or
                                    self.packet_rate_received.yfilter != YFilter.not_set or
                                    self.packet_rate_sent.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "side-b-data-rate" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bit_rate_received.is_set or self.bit_rate_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bit_rate_received.get_name_leafdata())
                                if (self.bit_rate_sent.is_set or self.bit_rate_sent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bit_rate_sent.get_name_leafdata())
                                if (self.packet_rate_received.is_set or self.packet_rate_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.packet_rate_received.get_name_leafdata())
                                if (self.packet_rate_sent.is_set or self.packet_rate_sent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.packet_rate_sent.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bit-rate-received" or name == "bit-rate-sent" or name == "packet-rate-received" or name == "packet-rate-sent"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bit-rate-received"):
                                    self.bit_rate_received = value
                                    self.bit_rate_received.value_namespace = name_space
                                    self.bit_rate_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "bit-rate-sent"):
                                    self.bit_rate_sent = value
                                    self.bit_rate_sent.value_namespace = name_space
                                    self.bit_rate_sent.value_namespace_prefix = name_space_prefix
                                if(value_path == "packet-rate-received"):
                                    self.packet_rate_received = value
                                    self.packet_rate_received.value_namespace = name_space
                                    self.packet_rate_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "packet-rate-sent"):
                                    self.packet_rate_sent = value
                                    self.packet_rate_sent.value_namespace = name_space
                                    self.packet_rate_sent.value_namespace_prefix = name_space_prefix


                        class SideAErrors(Entity):
                            """
                            Errors for side A interface
                            
                            .. attribute:: crc_errors
                            
                            	Input CRC errors
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: error_packets_received
                            
                            	Error packets received
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: framer_aborts_received
                            
                            	Aborts received at framer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: framer_giant_packets_received
                            
                            	Too large packets received at framer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: framer_runt_packets_received
                            
                            	Too small packets received at framer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: input_insufficient_resource_events
                            
                            	Input insufficient resources events
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mac_aborts_received
                            
                            	Aborts received at MAC/RAC
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mac_giant_packets_received
                            
                            	Too large packets received at MAC/RAC
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mac_runt_packets_received
                            
                            	Too small packets received at MAC/RAC
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideAErrors, self).__init__()

                                self.yang_name = "side-a-errors"
                                self.yang_parent_name = "srp-statistics"

                                self.crc_errors = YLeaf(YType.uint32, "crc-errors")

                                self.error_packets_received = YLeaf(YType.uint32, "error-packets-received")

                                self.framer_aborts_received = YLeaf(YType.uint32, "framer-aborts-received")

                                self.framer_giant_packets_received = YLeaf(YType.uint32, "framer-giant-packets-received")

                                self.framer_runt_packets_received = YLeaf(YType.uint32, "framer-runt-packets-received")

                                self.input_insufficient_resource_events = YLeaf(YType.uint32, "input-insufficient-resource-events")

                                self.mac_aborts_received = YLeaf(YType.uint32, "mac-aborts-received")

                                self.mac_giant_packets_received = YLeaf(YType.uint32, "mac-giant-packets-received")

                                self.mac_runt_packets_received = YLeaf(YType.uint32, "mac-runt-packets-received")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("crc_errors",
                                                "error_packets_received",
                                                "framer_aborts_received",
                                                "framer_giant_packets_received",
                                                "framer_runt_packets_received",
                                                "input_insufficient_resource_events",
                                                "mac_aborts_received",
                                                "mac_giant_packets_received",
                                                "mac_runt_packets_received") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideAErrors, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideAErrors, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.crc_errors.is_set or
                                    self.error_packets_received.is_set or
                                    self.framer_aborts_received.is_set or
                                    self.framer_giant_packets_received.is_set or
                                    self.framer_runt_packets_received.is_set or
                                    self.input_insufficient_resource_events.is_set or
                                    self.mac_aborts_received.is_set or
                                    self.mac_giant_packets_received.is_set or
                                    self.mac_runt_packets_received.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.crc_errors.yfilter != YFilter.not_set or
                                    self.error_packets_received.yfilter != YFilter.not_set or
                                    self.framer_aborts_received.yfilter != YFilter.not_set or
                                    self.framer_giant_packets_received.yfilter != YFilter.not_set or
                                    self.framer_runt_packets_received.yfilter != YFilter.not_set or
                                    self.input_insufficient_resource_events.yfilter != YFilter.not_set or
                                    self.mac_aborts_received.yfilter != YFilter.not_set or
                                    self.mac_giant_packets_received.yfilter != YFilter.not_set or
                                    self.mac_runt_packets_received.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "side-a-errors" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.crc_errors.is_set or self.crc_errors.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.crc_errors.get_name_leafdata())
                                if (self.error_packets_received.is_set or self.error_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.error_packets_received.get_name_leafdata())
                                if (self.framer_aborts_received.is_set or self.framer_aborts_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.framer_aborts_received.get_name_leafdata())
                                if (self.framer_giant_packets_received.is_set or self.framer_giant_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.framer_giant_packets_received.get_name_leafdata())
                                if (self.framer_runt_packets_received.is_set or self.framer_runt_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.framer_runt_packets_received.get_name_leafdata())
                                if (self.input_insufficient_resource_events.is_set or self.input_insufficient_resource_events.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.input_insufficient_resource_events.get_name_leafdata())
                                if (self.mac_aborts_received.is_set or self.mac_aborts_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_aborts_received.get_name_leafdata())
                                if (self.mac_giant_packets_received.is_set or self.mac_giant_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_giant_packets_received.get_name_leafdata())
                                if (self.mac_runt_packets_received.is_set or self.mac_runt_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_runt_packets_received.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "crc-errors" or name == "error-packets-received" or name == "framer-aborts-received" or name == "framer-giant-packets-received" or name == "framer-runt-packets-received" or name == "input-insufficient-resource-events" or name == "mac-aborts-received" or name == "mac-giant-packets-received" or name == "mac-runt-packets-received"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "crc-errors"):
                                    self.crc_errors = value
                                    self.crc_errors.value_namespace = name_space
                                    self.crc_errors.value_namespace_prefix = name_space_prefix
                                if(value_path == "error-packets-received"):
                                    self.error_packets_received = value
                                    self.error_packets_received.value_namespace = name_space
                                    self.error_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "framer-aborts-received"):
                                    self.framer_aborts_received = value
                                    self.framer_aborts_received.value_namespace = name_space
                                    self.framer_aborts_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "framer-giant-packets-received"):
                                    self.framer_giant_packets_received = value
                                    self.framer_giant_packets_received.value_namespace = name_space
                                    self.framer_giant_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "framer-runt-packets-received"):
                                    self.framer_runt_packets_received = value
                                    self.framer_runt_packets_received.value_namespace = name_space
                                    self.framer_runt_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "input-insufficient-resource-events"):
                                    self.input_insufficient_resource_events = value
                                    self.input_insufficient_resource_events.value_namespace = name_space
                                    self.input_insufficient_resource_events.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-aborts-received"):
                                    self.mac_aborts_received = value
                                    self.mac_aborts_received.value_namespace = name_space
                                    self.mac_aborts_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-giant-packets-received"):
                                    self.mac_giant_packets_received = value
                                    self.mac_giant_packets_received.value_namespace = name_space
                                    self.mac_giant_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-runt-packets-received"):
                                    self.mac_runt_packets_received = value
                                    self.mac_runt_packets_received.value_namespace = name_space
                                    self.mac_runt_packets_received.value_namespace_prefix = name_space_prefix


                        class SideBErrors(Entity):
                            """
                            Errors for side B interface
                            
                            .. attribute:: crc_errors
                            
                            	Input CRC errors
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: error_packets_received
                            
                            	Error packets received
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: framer_aborts_received
                            
                            	Aborts received at framer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: framer_giant_packets_received
                            
                            	Too large packets received at framer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: framer_runt_packets_received
                            
                            	Too small packets received at framer
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: input_insufficient_resource_events
                            
                            	Input insufficient resources events
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mac_aborts_received
                            
                            	Aborts received at MAC/RAC
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mac_giant_packets_received
                            
                            	Too large packets received at MAC/RAC
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mac_runt_packets_received
                            
                            	Too small packets received at MAC/RAC
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBErrors, self).__init__()

                                self.yang_name = "side-b-errors"
                                self.yang_parent_name = "srp-statistics"

                                self.crc_errors = YLeaf(YType.uint32, "crc-errors")

                                self.error_packets_received = YLeaf(YType.uint32, "error-packets-received")

                                self.framer_aborts_received = YLeaf(YType.uint32, "framer-aborts-received")

                                self.framer_giant_packets_received = YLeaf(YType.uint32, "framer-giant-packets-received")

                                self.framer_runt_packets_received = YLeaf(YType.uint32, "framer-runt-packets-received")

                                self.input_insufficient_resource_events = YLeaf(YType.uint32, "input-insufficient-resource-events")

                                self.mac_aborts_received = YLeaf(YType.uint32, "mac-aborts-received")

                                self.mac_giant_packets_received = YLeaf(YType.uint32, "mac-giant-packets-received")

                                self.mac_runt_packets_received = YLeaf(YType.uint32, "mac-runt-packets-received")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("crc_errors",
                                                "error_packets_received",
                                                "framer_aborts_received",
                                                "framer_giant_packets_received",
                                                "framer_runt_packets_received",
                                                "input_insufficient_resource_events",
                                                "mac_aborts_received",
                                                "mac_giant_packets_received",
                                                "mac_runt_packets_received") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBErrors, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBErrors, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.crc_errors.is_set or
                                    self.error_packets_received.is_set or
                                    self.framer_aborts_received.is_set or
                                    self.framer_giant_packets_received.is_set or
                                    self.framer_runt_packets_received.is_set or
                                    self.input_insufficient_resource_events.is_set or
                                    self.mac_aborts_received.is_set or
                                    self.mac_giant_packets_received.is_set or
                                    self.mac_runt_packets_received.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.crc_errors.yfilter != YFilter.not_set or
                                    self.error_packets_received.yfilter != YFilter.not_set or
                                    self.framer_aborts_received.yfilter != YFilter.not_set or
                                    self.framer_giant_packets_received.yfilter != YFilter.not_set or
                                    self.framer_runt_packets_received.yfilter != YFilter.not_set or
                                    self.input_insufficient_resource_events.yfilter != YFilter.not_set or
                                    self.mac_aborts_received.yfilter != YFilter.not_set or
                                    self.mac_giant_packets_received.yfilter != YFilter.not_set or
                                    self.mac_runt_packets_received.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "side-b-errors" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.crc_errors.is_set or self.crc_errors.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.crc_errors.get_name_leafdata())
                                if (self.error_packets_received.is_set or self.error_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.error_packets_received.get_name_leafdata())
                                if (self.framer_aborts_received.is_set or self.framer_aborts_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.framer_aborts_received.get_name_leafdata())
                                if (self.framer_giant_packets_received.is_set or self.framer_giant_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.framer_giant_packets_received.get_name_leafdata())
                                if (self.framer_runt_packets_received.is_set or self.framer_runt_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.framer_runt_packets_received.get_name_leafdata())
                                if (self.input_insufficient_resource_events.is_set or self.input_insufficient_resource_events.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.input_insufficient_resource_events.get_name_leafdata())
                                if (self.mac_aborts_received.is_set or self.mac_aborts_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_aborts_received.get_name_leafdata())
                                if (self.mac_giant_packets_received.is_set or self.mac_giant_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_giant_packets_received.get_name_leafdata())
                                if (self.mac_runt_packets_received.is_set or self.mac_runt_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mac_runt_packets_received.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "crc-errors" or name == "error-packets-received" or name == "framer-aborts-received" or name == "framer-giant-packets-received" or name == "framer-runt-packets-received" or name == "input-insufficient-resource-events" or name == "mac-aborts-received" or name == "mac-giant-packets-received" or name == "mac-runt-packets-received"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "crc-errors"):
                                    self.crc_errors = value
                                    self.crc_errors.value_namespace = name_space
                                    self.crc_errors.value_namespace_prefix = name_space_prefix
                                if(value_path == "error-packets-received"):
                                    self.error_packets_received = value
                                    self.error_packets_received.value_namespace = name_space
                                    self.error_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "framer-aborts-received"):
                                    self.framer_aborts_received = value
                                    self.framer_aborts_received.value_namespace = name_space
                                    self.framer_aborts_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "framer-giant-packets-received"):
                                    self.framer_giant_packets_received = value
                                    self.framer_giant_packets_received.value_namespace = name_space
                                    self.framer_giant_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "framer-runt-packets-received"):
                                    self.framer_runt_packets_received = value
                                    self.framer_runt_packets_received.value_namespace = name_space
                                    self.framer_runt_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "input-insufficient-resource-events"):
                                    self.input_insufficient_resource_events = value
                                    self.input_insufficient_resource_events.value_namespace = name_space
                                    self.input_insufficient_resource_events.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-aborts-received"):
                                    self.mac_aborts_received = value
                                    self.mac_aborts_received.value_namespace = name_space
                                    self.mac_aborts_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-giant-packets-received"):
                                    self.mac_giant_packets_received = value
                                    self.mac_giant_packets_received.value_namespace = name_space
                                    self.mac_giant_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "mac-runt-packets-received"):
                                    self.mac_runt_packets_received = value
                                    self.mac_runt_packets_received.value_namespace = name_space
                                    self.mac_runt_packets_received.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.data_rate_interval.is_set or
                                (self.side_a_data_rate is not None and self.side_a_data_rate.has_data()) or
                                (self.side_a_errors is not None and self.side_a_errors.has_data()) or
                                (self.side_b_data_rate is not None and self.side_b_data_rate.has_data()) or
                                (self.side_b_errors is not None and self.side_b_errors.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.data_rate_interval.yfilter != YFilter.not_set or
                                (self.side_a_data_rate is not None and self.side_a_data_rate.has_operation()) or
                                (self.side_a_errors is not None and self.side_a_errors.has_operation()) or
                                (self.side_b_data_rate is not None and self.side_b_data_rate.has_operation()) or
                                (self.side_b_errors is not None and self.side_b_errors.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "srp-statistics" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.data_rate_interval.is_set or self.data_rate_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.data_rate_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "side-a-data-rate"):
                                if (self.side_a_data_rate is None):
                                    self.side_a_data_rate = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideADataRate()
                                    self.side_a_data_rate.parent = self
                                    self._children_name_map["side_a_data_rate"] = "side-a-data-rate"
                                return self.side_a_data_rate

                            if (child_yang_name == "side-a-errors"):
                                if (self.side_a_errors is None):
                                    self.side_a_errors = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideAErrors()
                                    self.side_a_errors.parent = self
                                    self._children_name_map["side_a_errors"] = "side-a-errors"
                                return self.side_a_errors

                            if (child_yang_name == "side-b-data-rate"):
                                if (self.side_b_data_rate is None):
                                    self.side_b_data_rate = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBDataRate()
                                    self.side_b_data_rate.parent = self
                                    self._children_name_map["side_b_data_rate"] = "side-b-data-rate"
                                return self.side_b_data_rate

                            if (child_yang_name == "side-b-errors"):
                                if (self.side_b_errors is None):
                                    self.side_b_errors = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics.SideBErrors()
                                    self.side_b_errors.parent = self
                                    self._children_name_map["side_b_errors"] = "side-b-errors"
                                return self.side_b_errors

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "side-a-data-rate" or name == "side-a-errors" or name == "side-b-data-rate" or name == "side-b-errors" or name == "data-rate-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "data-rate-interval"):
                                self.data_rate_interval = value
                                self.data_rate_interval.value_namespace = name_space
                                self.data_rate_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.srp_information is not None and self.srp_information.has_data()) or
                            (self.srp_statistics is not None and self.srp_statistics.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.srp_information is not None and self.srp_information.has_operation()) or
                            (self.srp_statistics is not None and self.srp_statistics.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "srp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "srp-information"):
                            if (self.srp_information is None):
                                self.srp_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpInformation()
                                self.srp_information.parent = self
                                self._children_name_map["srp_information"] = "srp-information"
                            return self.srp_information

                        if (child_yang_name == "srp-statistics"):
                            if (self.srp_statistics is None):
                                self.srp_statistics = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation.SrpStatistics()
                                self.srp_statistics.parent = self
                                self._children_name_map["srp_statistics"] = "srp-statistics"
                            return self.srp_statistics

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "srp-information" or name == "srp-statistics"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class TunnelInformation(Entity):
                    """
                    Tunnel interface information
                    
                    .. attribute:: destination_ipv4_address
                    
                    	Tunnel destination IP address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: key
                    
                    	GRE tunnel key
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: source_ipv4_address
                    
                    	Tunnel source IP address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: source_name
                    
                    	Tunnel source name
                    	**type**\:  str
                    
                    .. attribute:: ttl
                    
                    	GRE tunnel TTL
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tunnel_type
                    
                    	Tunnel protocol/transport
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelInformation, self).__init__()

                        self.yang_name = "tunnel-information"
                        self.yang_parent_name = "interface-type-information"

                        self.destination_ipv4_address = YLeaf(YType.str, "destination-ipv4-address")

                        self.key = YLeaf(YType.uint32, "key")

                        self.source_ipv4_address = YLeaf(YType.str, "source-ipv4-address")

                        self.source_name = YLeaf(YType.str, "source-name")

                        self.ttl = YLeaf(YType.uint32, "ttl")

                        self.tunnel_type = YLeaf(YType.str, "tunnel-type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("destination_ipv4_address",
                                        "key",
                                        "source_ipv4_address",
                                        "source_name",
                                        "ttl",
                                        "tunnel_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.destination_ipv4_address.is_set or
                            self.key.is_set or
                            self.source_ipv4_address.is_set or
                            self.source_name.is_set or
                            self.ttl.is_set or
                            self.tunnel_type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.destination_ipv4_address.yfilter != YFilter.not_set or
                            self.key.yfilter != YFilter.not_set or
                            self.source_ipv4_address.yfilter != YFilter.not_set or
                            self.source_name.yfilter != YFilter.not_set or
                            self.ttl.yfilter != YFilter.not_set or
                            self.tunnel_type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.destination_ipv4_address.is_set or self.destination_ipv4_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination_ipv4_address.get_name_leafdata())
                        if (self.key.is_set or self.key.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.key.get_name_leafdata())
                        if (self.source_ipv4_address.is_set or self.source_ipv4_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_ipv4_address.get_name_leafdata())
                        if (self.source_name.is_set or self.source_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_name.get_name_leafdata())
                        if (self.ttl.is_set or self.ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ttl.get_name_leafdata())
                        if (self.tunnel_type.is_set or self.tunnel_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "destination-ipv4-address" or name == "key" or name == "source-ipv4-address" or name == "source-name" or name == "ttl" or name == "tunnel-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "destination-ipv4-address"):
                            self.destination_ipv4_address = value
                            self.destination_ipv4_address.value_namespace = name_space
                            self.destination_ipv4_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "key"):
                            self.key = value
                            self.key.value_namespace = name_space
                            self.key.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-ipv4-address"):
                            self.source_ipv4_address = value
                            self.source_ipv4_address.value_namespace = name_space
                            self.source_ipv4_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-name"):
                            self.source_name = value
                            self.source_name.value_namespace = name_space
                            self.source_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ttl"):
                            self.ttl = value
                            self.ttl.value_namespace = name_space
                            self.ttl.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-type"):
                            self.tunnel_type = value
                            self.tunnel_type.value_namespace = name_space
                            self.tunnel_type.value_namespace_prefix = name_space_prefix


                class BundleInformation(Entity):
                    """
                    Bundle interface information
                    
                    .. attribute:: member
                    
                    	List of bundle members and their properties
                    	**type**\: list of    :py:class:`Member <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member>`
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation, self).__init__()

                        self.yang_name = "bundle-information"
                        self.yang_parent_name = "interface-type-information"

                        self.member = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation, self).__setattr__(name, value)


                    class Member(Entity):
                        """
                        List of bundle members and their properties
                        
                        .. attribute:: bandwidth
                        
                        	Bandwidth of this member (kbps)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: kbit/s
                        
                        .. attribute:: counters
                        
                        	Counters data about member link
                        	**type**\:   :py:class:`Counters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.Counters>`
                        
                        .. attribute:: iccp_node
                        
                        	Location of member
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: interface_name
                        
                        	Member's interface name
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: link_data
                        
                        	Lacp data about member link
                        	**type**\:   :py:class:`LinkData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.LinkData>`
                        
                        .. attribute:: link_order_number
                        
                        	Member's link order number
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: mac_address
                        
                        	MAC address of this member (deprecated)
                        	**type**\:   :py:class:`MacAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MacAddress>`
                        
                        .. attribute:: member_mux_data
                        
                        	Mux state machine data
                        	**type**\:   :py:class:`MemberMuxData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData>`
                        
                        .. attribute:: member_name
                        
                        	Member's (short form) name
                        	**type**\:  str
                        
                        .. attribute:: member_type
                        
                        	Member's type (local/foreign)
                        	**type**\:   :py:class:`BmdMemberTypeEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.BmdMemberTypeEnum>`
                        
                        .. attribute:: port_number
                        
                        	Member's link number
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: port_priority
                        
                        	The priority of this member
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: underlying_link_id
                        
                        	Member's underlying link ID
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member, self).__init__()

                            self.yang_name = "member"
                            self.yang_parent_name = "bundle-information"

                            self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                            self.iccp_node = YLeaf(YType.uint32, "iccp-node")

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.link_order_number = YLeaf(YType.uint16, "link-order-number")

                            self.member_name = YLeaf(YType.str, "member-name")

                            self.member_type = YLeaf(YType.enumeration, "member-type")

                            self.port_number = YLeaf(YType.uint16, "port-number")

                            self.port_priority = YLeaf(YType.uint16, "port-priority")

                            self.underlying_link_id = YLeaf(YType.uint16, "underlying-link-id")

                            self.counters = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.Counters()
                            self.counters.parent = self
                            self._children_name_map["counters"] = "counters"
                            self._children_yang_names.add("counters")

                            self.link_data = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.LinkData()
                            self.link_data.parent = self
                            self._children_name_map["link_data"] = "link-data"
                            self._children_yang_names.add("link-data")

                            self.mac_address = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MacAddress()
                            self.mac_address.parent = self
                            self._children_name_map["mac_address"] = "mac-address"
                            self._children_yang_names.add("mac-address")

                            self.member_mux_data = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData()
                            self.member_mux_data.parent = self
                            self._children_name_map["member_mux_data"] = "member-mux-data"
                            self._children_yang_names.add("member-mux-data")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth",
                                            "iccp_node",
                                            "interface_name",
                                            "link_order_number",
                                            "member_name",
                                            "member_type",
                                            "port_number",
                                            "port_priority",
                                            "underlying_link_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member, self).__setattr__(name, value)


                        class Counters(Entity):
                            """
                            Counters data about member link
                            
                            .. attribute:: defaulted
                            
                            	State flag set to Defaulted
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: excess_lacpd_us_received
                            
                            	LACPDUs received that exceed the rate limit
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: excess_marker_packets_received
                            
                            	Marker packets received that exceed the rate limit
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: expired
                            
                            	State flag set to Expired
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: illegal_packets_received
                            
                            	Illegal and unknown packets received
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lacpd_us_received
                            
                            	LACPDUs received
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lacpd_us_transmitted
                            
                            	LACPDUs transmitted
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: last_cleared_nsec
                            
                            	Last time counters cleared (nsec) (deprecated)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: last_cleared_sec
                            
                            	Last time counters cleared (s) (deprecated)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: marker_packets_received
                            
                            	Marker packets received
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: marker_responses_transmitted
                            
                            	Marker response packets transmitted
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.Counters, self).__init__()

                                self.yang_name = "counters"
                                self.yang_parent_name = "member"

                                self.defaulted = YLeaf(YType.uint32, "defaulted")

                                self.excess_lacpd_us_received = YLeaf(YType.uint32, "excess-lacpd-us-received")

                                self.excess_marker_packets_received = YLeaf(YType.uint32, "excess-marker-packets-received")

                                self.expired = YLeaf(YType.uint32, "expired")

                                self.illegal_packets_received = YLeaf(YType.uint32, "illegal-packets-received")

                                self.lacpd_us_received = YLeaf(YType.uint32, "lacpd-us-received")

                                self.lacpd_us_transmitted = YLeaf(YType.uint32, "lacpd-us-transmitted")

                                self.last_cleared_nsec = YLeaf(YType.uint32, "last-cleared-nsec")

                                self.last_cleared_sec = YLeaf(YType.uint32, "last-cleared-sec")

                                self.marker_packets_received = YLeaf(YType.uint32, "marker-packets-received")

                                self.marker_responses_transmitted = YLeaf(YType.uint32, "marker-responses-transmitted")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("defaulted",
                                                "excess_lacpd_us_received",
                                                "excess_marker_packets_received",
                                                "expired",
                                                "illegal_packets_received",
                                                "lacpd_us_received",
                                                "lacpd_us_transmitted",
                                                "last_cleared_nsec",
                                                "last_cleared_sec",
                                                "marker_packets_received",
                                                "marker_responses_transmitted") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.Counters, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.Counters, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.defaulted.is_set or
                                    self.excess_lacpd_us_received.is_set or
                                    self.excess_marker_packets_received.is_set or
                                    self.expired.is_set or
                                    self.illegal_packets_received.is_set or
                                    self.lacpd_us_received.is_set or
                                    self.lacpd_us_transmitted.is_set or
                                    self.last_cleared_nsec.is_set or
                                    self.last_cleared_sec.is_set or
                                    self.marker_packets_received.is_set or
                                    self.marker_responses_transmitted.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.defaulted.yfilter != YFilter.not_set or
                                    self.excess_lacpd_us_received.yfilter != YFilter.not_set or
                                    self.excess_marker_packets_received.yfilter != YFilter.not_set or
                                    self.expired.yfilter != YFilter.not_set or
                                    self.illegal_packets_received.yfilter != YFilter.not_set or
                                    self.lacpd_us_received.yfilter != YFilter.not_set or
                                    self.lacpd_us_transmitted.yfilter != YFilter.not_set or
                                    self.last_cleared_nsec.yfilter != YFilter.not_set or
                                    self.last_cleared_sec.yfilter != YFilter.not_set or
                                    self.marker_packets_received.yfilter != YFilter.not_set or
                                    self.marker_responses_transmitted.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "counters" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.defaulted.is_set or self.defaulted.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.defaulted.get_name_leafdata())
                                if (self.excess_lacpd_us_received.is_set or self.excess_lacpd_us_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.excess_lacpd_us_received.get_name_leafdata())
                                if (self.excess_marker_packets_received.is_set or self.excess_marker_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.excess_marker_packets_received.get_name_leafdata())
                                if (self.expired.is_set or self.expired.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.expired.get_name_leafdata())
                                if (self.illegal_packets_received.is_set or self.illegal_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.illegal_packets_received.get_name_leafdata())
                                if (self.lacpd_us_received.is_set or self.lacpd_us_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lacpd_us_received.get_name_leafdata())
                                if (self.lacpd_us_transmitted.is_set or self.lacpd_us_transmitted.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lacpd_us_transmitted.get_name_leafdata())
                                if (self.last_cleared_nsec.is_set or self.last_cleared_nsec.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.last_cleared_nsec.get_name_leafdata())
                                if (self.last_cleared_sec.is_set or self.last_cleared_sec.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.last_cleared_sec.get_name_leafdata())
                                if (self.marker_packets_received.is_set or self.marker_packets_received.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.marker_packets_received.get_name_leafdata())
                                if (self.marker_responses_transmitted.is_set or self.marker_responses_transmitted.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.marker_responses_transmitted.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "defaulted" or name == "excess-lacpd-us-received" or name == "excess-marker-packets-received" or name == "expired" or name == "illegal-packets-received" or name == "lacpd-us-received" or name == "lacpd-us-transmitted" or name == "last-cleared-nsec" or name == "last-cleared-sec" or name == "marker-packets-received" or name == "marker-responses-transmitted"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "defaulted"):
                                    self.defaulted = value
                                    self.defaulted.value_namespace = name_space
                                    self.defaulted.value_namespace_prefix = name_space_prefix
                                if(value_path == "excess-lacpd-us-received"):
                                    self.excess_lacpd_us_received = value
                                    self.excess_lacpd_us_received.value_namespace = name_space
                                    self.excess_lacpd_us_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "excess-marker-packets-received"):
                                    self.excess_marker_packets_received = value
                                    self.excess_marker_packets_received.value_namespace = name_space
                                    self.excess_marker_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "expired"):
                                    self.expired = value
                                    self.expired.value_namespace = name_space
                                    self.expired.value_namespace_prefix = name_space_prefix
                                if(value_path == "illegal-packets-received"):
                                    self.illegal_packets_received = value
                                    self.illegal_packets_received.value_namespace = name_space
                                    self.illegal_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "lacpd-us-received"):
                                    self.lacpd_us_received = value
                                    self.lacpd_us_received.value_namespace = name_space
                                    self.lacpd_us_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "lacpd-us-transmitted"):
                                    self.lacpd_us_transmitted = value
                                    self.lacpd_us_transmitted.value_namespace = name_space
                                    self.lacpd_us_transmitted.value_namespace_prefix = name_space_prefix
                                if(value_path == "last-cleared-nsec"):
                                    self.last_cleared_nsec = value
                                    self.last_cleared_nsec.value_namespace = name_space
                                    self.last_cleared_nsec.value_namespace_prefix = name_space_prefix
                                if(value_path == "last-cleared-sec"):
                                    self.last_cleared_sec = value
                                    self.last_cleared_sec.value_namespace = name_space
                                    self.last_cleared_sec.value_namespace_prefix = name_space_prefix
                                if(value_path == "marker-packets-received"):
                                    self.marker_packets_received = value
                                    self.marker_packets_received.value_namespace = name_space
                                    self.marker_packets_received.value_namespace_prefix = name_space_prefix
                                if(value_path == "marker-responses-transmitted"):
                                    self.marker_responses_transmitted = value
                                    self.marker_responses_transmitted.value_namespace = name_space
                                    self.marker_responses_transmitted.value_namespace_prefix = name_space_prefix


                        class LinkData(Entity):
                            """
                            Lacp data about member link
                            
                            .. attribute:: actor_operational_key
                            
                            	Operational key for this port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: actor_port_id
                            
                            	Port number of this port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: actor_port_priority
                            
                            	Priority of this port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: actor_port_state
                            
                            	LACP state of this port
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: actor_system_mac_address
                            
                            	MAC Address of the actor system
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: actor_system_priority
                            
                            	System priority of actor system
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: attached_aggregator_id
                            
                            	MIB ifindex of attached bundle
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: interface_handle
                            
                            	Member's interface handle
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: partner_operational_key
                            
                            	Operational key for partner port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: partner_port_id
                            
                            	Port number of the partner's port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: partner_port_priority
                            
                            	Priority of the partner's port
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: partner_port_state
                            
                            	LACP state of the partner's port
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: partner_system_mac_address
                            
                            	MAC Address used to identify the partner system
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            .. attribute:: partner_system_priority
                            
                            	System priority of partner system
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: selected_aggregator_id
                            
                            	MIB ifindex of selected bundle
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.LinkData, self).__init__()

                                self.yang_name = "link-data"
                                self.yang_parent_name = "member"

                                self.actor_operational_key = YLeaf(YType.uint16, "actor-operational-key")

                                self.actor_port_id = YLeaf(YType.uint16, "actor-port-id")

                                self.actor_port_priority = YLeaf(YType.uint16, "actor-port-priority")

                                self.actor_port_state = YLeaf(YType.uint8, "actor-port-state")

                                self.actor_system_mac_address = YLeaf(YType.str, "actor-system-mac-address")

                                self.actor_system_priority = YLeaf(YType.uint16, "actor-system-priority")

                                self.attached_aggregator_id = YLeaf(YType.uint32, "attached-aggregator-id")

                                self.interface_handle = YLeaf(YType.str, "interface-handle")

                                self.partner_operational_key = YLeaf(YType.uint16, "partner-operational-key")

                                self.partner_port_id = YLeaf(YType.uint16, "partner-port-id")

                                self.partner_port_priority = YLeaf(YType.uint16, "partner-port-priority")

                                self.partner_port_state = YLeaf(YType.uint8, "partner-port-state")

                                self.partner_system_mac_address = YLeaf(YType.str, "partner-system-mac-address")

                                self.partner_system_priority = YLeaf(YType.uint16, "partner-system-priority")

                                self.selected_aggregator_id = YLeaf(YType.uint32, "selected-aggregator-id")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("actor_operational_key",
                                                "actor_port_id",
                                                "actor_port_priority",
                                                "actor_port_state",
                                                "actor_system_mac_address",
                                                "actor_system_priority",
                                                "attached_aggregator_id",
                                                "interface_handle",
                                                "partner_operational_key",
                                                "partner_port_id",
                                                "partner_port_priority",
                                                "partner_port_state",
                                                "partner_system_mac_address",
                                                "partner_system_priority",
                                                "selected_aggregator_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.LinkData, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.LinkData, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.actor_operational_key.is_set or
                                    self.actor_port_id.is_set or
                                    self.actor_port_priority.is_set or
                                    self.actor_port_state.is_set or
                                    self.actor_system_mac_address.is_set or
                                    self.actor_system_priority.is_set or
                                    self.attached_aggregator_id.is_set or
                                    self.interface_handle.is_set or
                                    self.partner_operational_key.is_set or
                                    self.partner_port_id.is_set or
                                    self.partner_port_priority.is_set or
                                    self.partner_port_state.is_set or
                                    self.partner_system_mac_address.is_set or
                                    self.partner_system_priority.is_set or
                                    self.selected_aggregator_id.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.actor_operational_key.yfilter != YFilter.not_set or
                                    self.actor_port_id.yfilter != YFilter.not_set or
                                    self.actor_port_priority.yfilter != YFilter.not_set or
                                    self.actor_port_state.yfilter != YFilter.not_set or
                                    self.actor_system_mac_address.yfilter != YFilter.not_set or
                                    self.actor_system_priority.yfilter != YFilter.not_set or
                                    self.attached_aggregator_id.yfilter != YFilter.not_set or
                                    self.interface_handle.yfilter != YFilter.not_set or
                                    self.partner_operational_key.yfilter != YFilter.not_set or
                                    self.partner_port_id.yfilter != YFilter.not_set or
                                    self.partner_port_priority.yfilter != YFilter.not_set or
                                    self.partner_port_state.yfilter != YFilter.not_set or
                                    self.partner_system_mac_address.yfilter != YFilter.not_set or
                                    self.partner_system_priority.yfilter != YFilter.not_set or
                                    self.selected_aggregator_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "link-data" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.actor_operational_key.is_set or self.actor_operational_key.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.actor_operational_key.get_name_leafdata())
                                if (self.actor_port_id.is_set or self.actor_port_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.actor_port_id.get_name_leafdata())
                                if (self.actor_port_priority.is_set or self.actor_port_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.actor_port_priority.get_name_leafdata())
                                if (self.actor_port_state.is_set or self.actor_port_state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.actor_port_state.get_name_leafdata())
                                if (self.actor_system_mac_address.is_set or self.actor_system_mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.actor_system_mac_address.get_name_leafdata())
                                if (self.actor_system_priority.is_set or self.actor_system_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.actor_system_priority.get_name_leafdata())
                                if (self.attached_aggregator_id.is_set or self.attached_aggregator_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.attached_aggregator_id.get_name_leafdata())
                                if (self.interface_handle.is_set or self.interface_handle.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_handle.get_name_leafdata())
                                if (self.partner_operational_key.is_set or self.partner_operational_key.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partner_operational_key.get_name_leafdata())
                                if (self.partner_port_id.is_set or self.partner_port_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partner_port_id.get_name_leafdata())
                                if (self.partner_port_priority.is_set or self.partner_port_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partner_port_priority.get_name_leafdata())
                                if (self.partner_port_state.is_set or self.partner_port_state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partner_port_state.get_name_leafdata())
                                if (self.partner_system_mac_address.is_set or self.partner_system_mac_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partner_system_mac_address.get_name_leafdata())
                                if (self.partner_system_priority.is_set or self.partner_system_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partner_system_priority.get_name_leafdata())
                                if (self.selected_aggregator_id.is_set or self.selected_aggregator_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.selected_aggregator_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "actor-operational-key" or name == "actor-port-id" or name == "actor-port-priority" or name == "actor-port-state" or name == "actor-system-mac-address" or name == "actor-system-priority" or name == "attached-aggregator-id" or name == "interface-handle" or name == "partner-operational-key" or name == "partner-port-id" or name == "partner-port-priority" or name == "partner-port-state" or name == "partner-system-mac-address" or name == "partner-system-priority" or name == "selected-aggregator-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "actor-operational-key"):
                                    self.actor_operational_key = value
                                    self.actor_operational_key.value_namespace = name_space
                                    self.actor_operational_key.value_namespace_prefix = name_space_prefix
                                if(value_path == "actor-port-id"):
                                    self.actor_port_id = value
                                    self.actor_port_id.value_namespace = name_space
                                    self.actor_port_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "actor-port-priority"):
                                    self.actor_port_priority = value
                                    self.actor_port_priority.value_namespace = name_space
                                    self.actor_port_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "actor-port-state"):
                                    self.actor_port_state = value
                                    self.actor_port_state.value_namespace = name_space
                                    self.actor_port_state.value_namespace_prefix = name_space_prefix
                                if(value_path == "actor-system-mac-address"):
                                    self.actor_system_mac_address = value
                                    self.actor_system_mac_address.value_namespace = name_space
                                    self.actor_system_mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "actor-system-priority"):
                                    self.actor_system_priority = value
                                    self.actor_system_priority.value_namespace = name_space
                                    self.actor_system_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "attached-aggregator-id"):
                                    self.attached_aggregator_id = value
                                    self.attached_aggregator_id.value_namespace = name_space
                                    self.attached_aggregator_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-handle"):
                                    self.interface_handle = value
                                    self.interface_handle.value_namespace = name_space
                                    self.interface_handle.value_namespace_prefix = name_space_prefix
                                if(value_path == "partner-operational-key"):
                                    self.partner_operational_key = value
                                    self.partner_operational_key.value_namespace = name_space
                                    self.partner_operational_key.value_namespace_prefix = name_space_prefix
                                if(value_path == "partner-port-id"):
                                    self.partner_port_id = value
                                    self.partner_port_id.value_namespace = name_space
                                    self.partner_port_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "partner-port-priority"):
                                    self.partner_port_priority = value
                                    self.partner_port_priority.value_namespace = name_space
                                    self.partner_port_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "partner-port-state"):
                                    self.partner_port_state = value
                                    self.partner_port_state.value_namespace = name_space
                                    self.partner_port_state.value_namespace_prefix = name_space_prefix
                                if(value_path == "partner-system-mac-address"):
                                    self.partner_system_mac_address = value
                                    self.partner_system_mac_address.value_namespace = name_space
                                    self.partner_system_mac_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "partner-system-priority"):
                                    self.partner_system_priority = value
                                    self.partner_system_priority.value_namespace = name_space
                                    self.partner_system_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "selected-aggregator-id"):
                                    self.selected_aggregator_id = value
                                    self.selected_aggregator_id.value_namespace = name_space
                                    self.selected_aggregator_id.value_namespace_prefix = name_space_prefix


                        class MemberMuxData(Entity):
                            """
                            Mux state machine data
                            
                            .. attribute:: error
                            
                            	Internal value indicating if an error occurred trying to put a link into the desired state
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: member_mux_state_reason
                            
                            	Reason for last Mux state change
                            	**type**\:   :py:class:`BmMbrStateReason <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.BmMbrStateReason>`
                            
                            .. attribute:: member_mux_state_reason_data
                            
                            	Data regarding the reason for last Mux state change
                            	**type**\:   :py:class:`MemberMuxStateReasonData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData.MemberMuxStateReasonData>`
                            
                            .. attribute:: member_state
                            
                            	Current internal state of this bundle member
                            	**type**\:   :py:class:`BmdMemberState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.BmdMemberState>`
                            
                            .. attribute:: mux_state
                            
                            	Current state of this bundle member
                            	**type**\:   :py:class:`BmMuxstate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.BmMuxstate>`
                            
                            .. attribute:: mux_state_reason
                            
                            	Reason for last Mux state change (Deprecated)
                            	**type**\:   :py:class:`BmMuxreason <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.BmMuxreason>`
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData, self).__init__()

                                self.yang_name = "member-mux-data"
                                self.yang_parent_name = "member"

                                self.error = YLeaf(YType.uint32, "error")

                                self.member_mux_state_reason = YLeaf(YType.enumeration, "member-mux-state-reason")

                                self.member_state = YLeaf(YType.enumeration, "member-state")

                                self.mux_state = YLeaf(YType.enumeration, "mux-state")

                                self.mux_state_reason = YLeaf(YType.enumeration, "mux-state-reason")

                                self.member_mux_state_reason_data = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData.MemberMuxStateReasonData()
                                self.member_mux_state_reason_data.parent = self
                                self._children_name_map["member_mux_state_reason_data"] = "member-mux-state-reason-data"
                                self._children_yang_names.add("member-mux-state-reason-data")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("error",
                                                "member_mux_state_reason",
                                                "member_state",
                                                "mux_state",
                                                "mux_state_reason") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData, self).__setattr__(name, value)


                            class MemberMuxStateReasonData(Entity):
                                """
                                Data regarding the reason for last Mux state
                                change
                                
                                .. attribute:: reason_type
                                
                                	The item the reason applies to
                                	**type**\:   :py:class:`BmStateReasonTarget <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.BmStateReasonTarget>`
                                
                                .. attribute:: severity
                                
                                	The severity of the reason
                                	**type**\:   :py:class:`BmSeverity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.BmSeverity>`
                                
                                

                                """

                                _prefix = 'pfi-im-cmd-oper'
                                _revision = '2016-12-18'

                                def __init__(self):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData.MemberMuxStateReasonData, self).__init__()

                                    self.yang_name = "member-mux-state-reason-data"
                                    self.yang_parent_name = "member-mux-data"

                                    self.reason_type = YLeaf(YType.enumeration, "reason-type")

                                    self.severity = YLeaf(YType.enumeration, "severity")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("reason_type",
                                                    "severity") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData.MemberMuxStateReasonData, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData.MemberMuxStateReasonData, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.reason_type.is_set or
                                        self.severity.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.reason_type.yfilter != YFilter.not_set or
                                        self.severity.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "member-mux-state-reason-data" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.reason_type.is_set or self.reason_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.reason_type.get_name_leafdata())
                                    if (self.severity.is_set or self.severity.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.severity.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "reason-type" or name == "severity"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "reason-type"):
                                        self.reason_type = value
                                        self.reason_type.value_namespace = name_space
                                        self.reason_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "severity"):
                                        self.severity = value
                                        self.severity.value_namespace = name_space
                                        self.severity.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.error.is_set or
                                    self.member_mux_state_reason.is_set or
                                    self.member_state.is_set or
                                    self.mux_state.is_set or
                                    self.mux_state_reason.is_set or
                                    (self.member_mux_state_reason_data is not None and self.member_mux_state_reason_data.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.error.yfilter != YFilter.not_set or
                                    self.member_mux_state_reason.yfilter != YFilter.not_set or
                                    self.member_state.yfilter != YFilter.not_set or
                                    self.mux_state.yfilter != YFilter.not_set or
                                    self.mux_state_reason.yfilter != YFilter.not_set or
                                    (self.member_mux_state_reason_data is not None and self.member_mux_state_reason_data.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "member-mux-data" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.error.is_set or self.error.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.error.get_name_leafdata())
                                if (self.member_mux_state_reason.is_set or self.member_mux_state_reason.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.member_mux_state_reason.get_name_leafdata())
                                if (self.member_state.is_set or self.member_state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.member_state.get_name_leafdata())
                                if (self.mux_state.is_set or self.mux_state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mux_state.get_name_leafdata())
                                if (self.mux_state_reason.is_set or self.mux_state_reason.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mux_state_reason.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "member-mux-state-reason-data"):
                                    if (self.member_mux_state_reason_data is None):
                                        self.member_mux_state_reason_data = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData.MemberMuxStateReasonData()
                                        self.member_mux_state_reason_data.parent = self
                                        self._children_name_map["member_mux_state_reason_data"] = "member-mux-state-reason-data"
                                    return self.member_mux_state_reason_data

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "member-mux-state-reason-data" or name == "error" or name == "member-mux-state-reason" or name == "member-state" or name == "mux-state" or name == "mux-state-reason"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "error"):
                                    self.error = value
                                    self.error.value_namespace = name_space
                                    self.error.value_namespace_prefix = name_space_prefix
                                if(value_path == "member-mux-state-reason"):
                                    self.member_mux_state_reason = value
                                    self.member_mux_state_reason.value_namespace = name_space
                                    self.member_mux_state_reason.value_namespace_prefix = name_space_prefix
                                if(value_path == "member-state"):
                                    self.member_state = value
                                    self.member_state.value_namespace = name_space
                                    self.member_state.value_namespace_prefix = name_space_prefix
                                if(value_path == "mux-state"):
                                    self.mux_state = value
                                    self.mux_state.value_namespace = name_space
                                    self.mux_state.value_namespace_prefix = name_space_prefix
                                if(value_path == "mux-state-reason"):
                                    self.mux_state_reason = value
                                    self.mux_state_reason.value_namespace = name_space
                                    self.mux_state_reason.value_namespace_prefix = name_space_prefix


                        class MacAddress(Entity):
                            """
                            MAC address of this member (deprecated)
                            
                            .. attribute:: address
                            
                            	MAC address
                            	**type**\:  str
                            
                            	**pattern:** [0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2}){5}
                            
                            

                            """

                            _prefix = 'pfi-im-cmd-oper'
                            _revision = '2016-12-18'

                            def __init__(self):
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MacAddress, self).__init__()

                                self.yang_name = "mac-address"
                                self.yang_parent_name = "member"

                                self.address = YLeaf(YType.str, "address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MacAddress, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MacAddress, self).__setattr__(name, value)

                            def has_data(self):
                                return self.address.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mac-address" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "address"):
                                    self.address = value
                                    self.address.value_namespace = name_space
                                    self.address.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bandwidth.is_set or
                                self.iccp_node.is_set or
                                self.interface_name.is_set or
                                self.link_order_number.is_set or
                                self.member_name.is_set or
                                self.member_type.is_set or
                                self.port_number.is_set or
                                self.port_priority.is_set or
                                self.underlying_link_id.is_set or
                                (self.counters is not None and self.counters.has_data()) or
                                (self.link_data is not None and self.link_data.has_data()) or
                                (self.mac_address is not None and self.mac_address.has_data()) or
                                (self.member_mux_data is not None and self.member_mux_data.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth.yfilter != YFilter.not_set or
                                self.iccp_node.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                self.link_order_number.yfilter != YFilter.not_set or
                                self.member_name.yfilter != YFilter.not_set or
                                self.member_type.yfilter != YFilter.not_set or
                                self.port_number.yfilter != YFilter.not_set or
                                self.port_priority.yfilter != YFilter.not_set or
                                self.underlying_link_id.yfilter != YFilter.not_set or
                                (self.counters is not None and self.counters.has_operation()) or
                                (self.link_data is not None and self.link_data.has_operation()) or
                                (self.mac_address is not None and self.mac_address.has_operation()) or
                                (self.member_mux_data is not None and self.member_mux_data.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "member" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth.get_name_leafdata())
                            if (self.iccp_node.is_set or self.iccp_node.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.iccp_node.get_name_leafdata())
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                            if (self.link_order_number.is_set or self.link_order_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.link_order_number.get_name_leafdata())
                            if (self.member_name.is_set or self.member_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.member_name.get_name_leafdata())
                            if (self.member_type.is_set or self.member_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.member_type.get_name_leafdata())
                            if (self.port_number.is_set or self.port_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.port_number.get_name_leafdata())
                            if (self.port_priority.is_set or self.port_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.port_priority.get_name_leafdata())
                            if (self.underlying_link_id.is_set or self.underlying_link_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.underlying_link_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "counters"):
                                if (self.counters is None):
                                    self.counters = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.Counters()
                                    self.counters.parent = self
                                    self._children_name_map["counters"] = "counters"
                                return self.counters

                            if (child_yang_name == "link-data"):
                                if (self.link_data is None):
                                    self.link_data = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.LinkData()
                                    self.link_data.parent = self
                                    self._children_name_map["link_data"] = "link-data"
                                return self.link_data

                            if (child_yang_name == "mac-address"):
                                if (self.mac_address is None):
                                    self.mac_address = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MacAddress()
                                    self.mac_address.parent = self
                                    self._children_name_map["mac_address"] = "mac-address"
                                return self.mac_address

                            if (child_yang_name == "member-mux-data"):
                                if (self.member_mux_data is None):
                                    self.member_mux_data = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member.MemberMuxData()
                                    self.member_mux_data.parent = self
                                    self._children_name_map["member_mux_data"] = "member-mux-data"
                                return self.member_mux_data

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "counters" or name == "link-data" or name == "mac-address" or name == "member-mux-data" or name == "bandwidth" or name == "iccp-node" or name == "interface-name" or name == "link-order-number" or name == "member-name" or name == "member-type" or name == "port-number" or name == "port-priority" or name == "underlying-link-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth"):
                                self.bandwidth = value
                                self.bandwidth.value_namespace = name_space
                                self.bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "iccp-node"):
                                self.iccp_node = value
                                self.iccp_node.value_namespace = name_space
                                self.iccp_node.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "link-order-number"):
                                self.link_order_number = value
                                self.link_order_number.value_namespace = name_space
                                self.link_order_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "member-name"):
                                self.member_name = value
                                self.member_name.value_namespace = name_space
                                self.member_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "member-type"):
                                self.member_type = value
                                self.member_type.value_namespace = name_space
                                self.member_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "port-number"):
                                self.port_number = value
                                self.port_number.value_namespace = name_space
                                self.port_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "port-priority"):
                                self.port_priority = value
                                self.port_priority.value_namespace = name_space
                                self.port_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "underlying-link-id"):
                                self.underlying_link_id = value
                                self.underlying_link_id.value_namespace = name_space
                                self.underlying_link_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.member:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.member:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bundle-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "member"):
                            for c in self.member:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation.Member()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.member.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "member"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SerialInformation(Entity):
                    """
                    Serial interface information
                    
                    .. attribute:: timeslots
                    
                    	Timeslots separated by \: or \- from 1 to 31. \: indicates individual timeslot and \- represents a range. E.g. 1\-3\:5 represents timeslots 1, 2, 3, and 5
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SerialInformation, self).__init__()

                        self.yang_name = "serial-information"
                        self.yang_parent_name = "interface-type-information"

                        self.timeslots = YLeaf(YType.str, "timeslots")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("timeslots") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SerialInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SerialInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return self.timeslots.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.timeslots.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "serial-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.timeslots.is_set or self.timeslots.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.timeslots.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "timeslots"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "timeslots"):
                            self.timeslots = value
                            self.timeslots.value_namespace = name_space
                            self.timeslots.value_namespace_prefix = name_space_prefix


                class SonetPosInformation(Entity):
                    """
                    SONET POS interface information
                    
                    .. attribute:: aps_state
                    
                    	APS state
                    	**type**\:   :py:class:`SonetApsEt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.SonetApsEt>`
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SonetPosInformation, self).__init__()

                        self.yang_name = "sonet-pos-information"
                        self.yang_parent_name = "interface-type-information"

                        self.aps_state = YLeaf(YType.enumeration, "aps-state")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("aps_state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SonetPosInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SonetPosInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return self.aps_state.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.aps_state.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "sonet-pos-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.aps_state.is_set or self.aps_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.aps_state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "aps-state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "aps-state"):
                            self.aps_state = value
                            self.aps_state.value_namespace = name_space
                            self.aps_state.value_namespace_prefix = name_space_prefix


                class TunnelGreInformation(Entity):
                    """
                    Tunnel GRE interface information
                    
                    .. attribute:: destination_ip_address
                    
                    	Tunnel destination IP address
                    	**type**\:   :py:class:`DestinationIpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.DestinationIpAddress>`
                    
                    .. attribute:: destination_ip_address_length
                    
                    	Tunnel destination IP address length
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: df_bit_state
                    
                    	DF Bit State
                    	**type**\:   :py:class:`TunnelKaDfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.TunnelKaDfState>`
                    
                    .. attribute:: keepalive_maximum_retry
                    
                    	Keepalive retry
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: keepalive_period
                    
                    	Keepalive period in seconds
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: second
                    
                    .. attribute:: keepalive_state
                    
                    	Keepalive State
                    	**type**\:   :py:class:`TunnelKaDfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.TunnelKaDfState>`
                    
                    .. attribute:: key
                    
                    	Key value for GRE Packet
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: key_bit_state
                    
                    	Key Config State
                    	**type**\:   :py:class:`TunnelKeyState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.TunnelKeyState>`
                    
                    .. attribute:: source_ip_address
                    
                    	Tunnel source IP address
                    	**type**\:   :py:class:`SourceIpAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.SourceIpAddress>`
                    
                    .. attribute:: source_name
                    
                    	Tunnel source name
                    	**type**\:  str
                    
                    .. attribute:: tunnel_mode
                    
                    	Tunnel GRE Mode
                    	**type**\:   :py:class:`TunnelGreMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.TunnelGreMode>`
                    
                    .. attribute:: tunnel_mode_decap
                    
                    	Tunnel Mode Decap
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: tunnel_tos
                    
                    	GRE tunnel TOS
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: tunnel_ttl
                    
                    	GRE tunnel TTL
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation, self).__init__()

                        self.yang_name = "tunnel-gre-information"
                        self.yang_parent_name = "interface-type-information"

                        self.destination_ip_address_length = YLeaf(YType.uint8, "destination-ip-address-length")

                        self.df_bit_state = YLeaf(YType.enumeration, "df-bit-state")

                        self.keepalive_maximum_retry = YLeaf(YType.uint8, "keepalive-maximum-retry")

                        self.keepalive_period = YLeaf(YType.uint16, "keepalive-period")

                        self.keepalive_state = YLeaf(YType.enumeration, "keepalive-state")

                        self.key = YLeaf(YType.uint32, "key")

                        self.key_bit_state = YLeaf(YType.enumeration, "key-bit-state")

                        self.source_name = YLeaf(YType.str, "source-name")

                        self.tunnel_mode = YLeaf(YType.enumeration, "tunnel-mode")

                        self.tunnel_mode_decap = YLeaf(YType.int32, "tunnel-mode-decap")

                        self.tunnel_tos = YLeaf(YType.uint32, "tunnel-tos")

                        self.tunnel_ttl = YLeaf(YType.uint32, "tunnel-ttl")

                        self.destination_ip_address = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.DestinationIpAddress()
                        self.destination_ip_address.parent = self
                        self._children_name_map["destination_ip_address"] = "destination-ip-address"
                        self._children_yang_names.add("destination-ip-address")

                        self.source_ip_address = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.SourceIpAddress()
                        self.source_ip_address.parent = self
                        self._children_name_map["source_ip_address"] = "source-ip-address"
                        self._children_yang_names.add("source-ip-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("destination_ip_address_length",
                                        "df_bit_state",
                                        "keepalive_maximum_retry",
                                        "keepalive_period",
                                        "keepalive_state",
                                        "key",
                                        "key_bit_state",
                                        "source_name",
                                        "tunnel_mode",
                                        "tunnel_mode_decap",
                                        "tunnel_tos",
                                        "tunnel_ttl") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation, self).__setattr__(name, value)


                    class SourceIpAddress(Entity):
                        """
                        Tunnel source IP address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`TunlPfiAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.TunlPfiAfId>`
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.SourceIpAddress, self).__init__()

                            self.yang_name = "source-ip-address"
                            self.yang_parent_name = "tunnel-gre-information"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.SourceIpAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.SourceIpAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "source-ip-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class DestinationIpAddress(Entity):
                        """
                        Tunnel destination IP address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`TunlPfiAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.TunlPfiAfId>`
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.DestinationIpAddress, self).__init__()

                            self.yang_name = "destination-ip-address"
                            self.yang_parent_name = "tunnel-gre-information"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.DestinationIpAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.DestinationIpAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "destination-ip-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.destination_ip_address_length.is_set or
                            self.df_bit_state.is_set or
                            self.keepalive_maximum_retry.is_set or
                            self.keepalive_period.is_set or
                            self.keepalive_state.is_set or
                            self.key.is_set or
                            self.key_bit_state.is_set or
                            self.source_name.is_set or
                            self.tunnel_mode.is_set or
                            self.tunnel_mode_decap.is_set or
                            self.tunnel_tos.is_set or
                            self.tunnel_ttl.is_set or
                            (self.destination_ip_address is not None and self.destination_ip_address.has_data()) or
                            (self.source_ip_address is not None and self.source_ip_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.destination_ip_address_length.yfilter != YFilter.not_set or
                            self.df_bit_state.yfilter != YFilter.not_set or
                            self.keepalive_maximum_retry.yfilter != YFilter.not_set or
                            self.keepalive_period.yfilter != YFilter.not_set or
                            self.keepalive_state.yfilter != YFilter.not_set or
                            self.key.yfilter != YFilter.not_set or
                            self.key_bit_state.yfilter != YFilter.not_set or
                            self.source_name.yfilter != YFilter.not_set or
                            self.tunnel_mode.yfilter != YFilter.not_set or
                            self.tunnel_mode_decap.yfilter != YFilter.not_set or
                            self.tunnel_tos.yfilter != YFilter.not_set or
                            self.tunnel_ttl.yfilter != YFilter.not_set or
                            (self.destination_ip_address is not None and self.destination_ip_address.has_operation()) or
                            (self.source_ip_address is not None and self.source_ip_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-gre-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.destination_ip_address_length.is_set or self.destination_ip_address_length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination_ip_address_length.get_name_leafdata())
                        if (self.df_bit_state.is_set or self.df_bit_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.df_bit_state.get_name_leafdata())
                        if (self.keepalive_maximum_retry.is_set or self.keepalive_maximum_retry.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_maximum_retry.get_name_leafdata())
                        if (self.keepalive_period.is_set or self.keepalive_period.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_period.get_name_leafdata())
                        if (self.keepalive_state.is_set or self.keepalive_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keepalive_state.get_name_leafdata())
                        if (self.key.is_set or self.key.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.key.get_name_leafdata())
                        if (self.key_bit_state.is_set or self.key_bit_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.key_bit_state.get_name_leafdata())
                        if (self.source_name.is_set or self.source_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source_name.get_name_leafdata())
                        if (self.tunnel_mode.is_set or self.tunnel_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_mode.get_name_leafdata())
                        if (self.tunnel_mode_decap.is_set or self.tunnel_mode_decap.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_mode_decap.get_name_leafdata())
                        if (self.tunnel_tos.is_set or self.tunnel_tos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_tos.get_name_leafdata())
                        if (self.tunnel_ttl.is_set or self.tunnel_ttl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_ttl.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "destination-ip-address"):
                            if (self.destination_ip_address is None):
                                self.destination_ip_address = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.DestinationIpAddress()
                                self.destination_ip_address.parent = self
                                self._children_name_map["destination_ip_address"] = "destination-ip-address"
                            return self.destination_ip_address

                        if (child_yang_name == "source-ip-address"):
                            if (self.source_ip_address is None):
                                self.source_ip_address = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation.SourceIpAddress()
                                self.source_ip_address.parent = self
                                self._children_name_map["source_ip_address"] = "source-ip-address"
                            return self.source_ip_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "destination-ip-address" or name == "source-ip-address" or name == "destination-ip-address-length" or name == "df-bit-state" or name == "keepalive-maximum-retry" or name == "keepalive-period" or name == "keepalive-state" or name == "key" or name == "key-bit-state" or name == "source-name" or name == "tunnel-mode" or name == "tunnel-mode-decap" or name == "tunnel-tos" or name == "tunnel-ttl"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "destination-ip-address-length"):
                            self.destination_ip_address_length = value
                            self.destination_ip_address_length.value_namespace = name_space
                            self.destination_ip_address_length.value_namespace_prefix = name_space_prefix
                        if(value_path == "df-bit-state"):
                            self.df_bit_state = value
                            self.df_bit_state.value_namespace = name_space
                            self.df_bit_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-maximum-retry"):
                            self.keepalive_maximum_retry = value
                            self.keepalive_maximum_retry.value_namespace = name_space
                            self.keepalive_maximum_retry.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-period"):
                            self.keepalive_period = value
                            self.keepalive_period.value_namespace = name_space
                            self.keepalive_period.value_namespace_prefix = name_space_prefix
                        if(value_path == "keepalive-state"):
                            self.keepalive_state = value
                            self.keepalive_state.value_namespace = name_space
                            self.keepalive_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "key"):
                            self.key = value
                            self.key.value_namespace = name_space
                            self.key.value_namespace_prefix = name_space_prefix
                        if(value_path == "key-bit-state"):
                            self.key_bit_state = value
                            self.key_bit_state.value_namespace = name_space
                            self.key_bit_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "source-name"):
                            self.source_name = value
                            self.source_name.value_namespace = name_space
                            self.source_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-mode"):
                            self.tunnel_mode = value
                            self.tunnel_mode.value_namespace = name_space
                            self.tunnel_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-mode-decap"):
                            self.tunnel_mode_decap = value
                            self.tunnel_mode_decap.value_namespace = name_space
                            self.tunnel_mode_decap.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-tos"):
                            self.tunnel_tos = value
                            self.tunnel_tos.value_namespace = name_space
                            self.tunnel_tos.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-ttl"):
                            self.tunnel_ttl = value
                            self.tunnel_ttl.value_namespace = name_space
                            self.tunnel_ttl.value_namespace_prefix = name_space_prefix


                class PseudowireHeadEndInformation(Entity):
                    """
                    PseudowireHeadEnd interface information
                    
                    .. attribute:: interface_list_name
                    
                    	Interface list Name
                    	**type**\:  str
                    
                    .. attribute:: internal_label
                    
                    	Internal Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: l2_overhead
                    
                    	L2 Overhead
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.PseudowireHeadEndInformation, self).__init__()

                        self.yang_name = "pseudowire-head-end-information"
                        self.yang_parent_name = "interface-type-information"

                        self.interface_list_name = YLeaf(YType.str, "interface-list-name")

                        self.internal_label = YLeaf(YType.uint32, "internal-label")

                        self.l2_overhead = YLeaf(YType.uint32, "l2-overhead")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_list_name",
                                        "internal_label",
                                        "l2_overhead") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.PseudowireHeadEndInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.PseudowireHeadEndInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.interface_list_name.is_set or
                            self.internal_label.is_set or
                            self.l2_overhead.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_list_name.yfilter != YFilter.not_set or
                            self.internal_label.yfilter != YFilter.not_set or
                            self.l2_overhead.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "pseudowire-head-end-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_list_name.is_set or self.interface_list_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_list_name.get_name_leafdata())
                        if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.internal_label.get_name_leafdata())
                        if (self.l2_overhead.is_set or self.l2_overhead.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.l2_overhead.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface-list-name" or name == "internal-label" or name == "l2-overhead"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-list-name"):
                            self.interface_list_name = value
                            self.interface_list_name.value_namespace = name_space
                            self.interface_list_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "internal-label"):
                            self.internal_label = value
                            self.internal_label.value_namespace = name_space
                            self.internal_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "l2-overhead"):
                            self.l2_overhead = value
                            self.l2_overhead.value_namespace = name_space
                            self.l2_overhead.value_namespace_prefix = name_space_prefix


                class CemInformation(Entity):
                    """
                    Cem interface information
                    
                    .. attribute:: dejitter_buffer
                    
                    	Dejitter buffer length configuredin milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: millisecond
                    
                    .. attribute:: framing
                    
                    	 If framing is TRUE then the CEM  interface is structure aware ; otherwise it is structure agnostic
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: payload
                    
                    	Payload size in bytes configured on CEM interface
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: byte
                    
                    .. attribute:: timeslots
                    
                    	Timeslots separated by \: or \- from 1 to 32. \: indicates individual timeslot and \- represents a range. E.g. 1\-3\:5 represents timeslots 1, 2, 3, and 5
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.CemInformation, self).__init__()

                        self.yang_name = "cem-information"
                        self.yang_parent_name = "interface-type-information"

                        self.dejitter_buffer = YLeaf(YType.uint16, "dejitter-buffer")

                        self.framing = YLeaf(YType.int32, "framing")

                        self.payload = YLeaf(YType.uint16, "payload")

                        self.timeslots = YLeaf(YType.str, "timeslots")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("dejitter_buffer",
                                        "framing",
                                        "payload",
                                        "timeslots") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.CemInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.CemInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.dejitter_buffer.is_set or
                            self.framing.is_set or
                            self.payload.is_set or
                            self.timeslots.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.dejitter_buffer.yfilter != YFilter.not_set or
                            self.framing.yfilter != YFilter.not_set or
                            self.payload.yfilter != YFilter.not_set or
                            self.timeslots.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "cem-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.dejitter_buffer.is_set or self.dejitter_buffer.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dejitter_buffer.get_name_leafdata())
                        if (self.framing.is_set or self.framing.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.framing.get_name_leafdata())
                        if (self.payload.is_set or self.payload.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.payload.get_name_leafdata())
                        if (self.timeslots.is_set or self.timeslots.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.timeslots.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "dejitter-buffer" or name == "framing" or name == "payload" or name == "timeslots"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "dejitter-buffer"):
                            self.dejitter_buffer = value
                            self.dejitter_buffer.value_namespace = name_space
                            self.dejitter_buffer.value_namespace_prefix = name_space_prefix
                        if(value_path == "framing"):
                            self.framing = value
                            self.framing.value_namespace = name_space
                            self.framing.value_namespace_prefix = name_space_prefix
                        if(value_path == "payload"):
                            self.payload = value
                            self.payload.value_namespace = name_space
                            self.payload.value_namespace_prefix = name_space_prefix
                        if(value_path == "timeslots"):
                            self.timeslots = value
                            self.timeslots.value_namespace = name_space
                            self.timeslots.value_namespace_prefix = name_space_prefix


                class GccInformation(Entity):
                    """
                    GCC interface information
                    
                    .. attribute:: derived_mode
                    
                    	Derived State
                    	**type**\:   :py:class:`GccDerState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.GccDerState>`
                    
                    .. attribute:: sec_state
                    
                    	Sec State 
                    	**type**\:   :py:class:`GccSecState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.GccSecState>`
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.GccInformation, self).__init__()

                        self.yang_name = "gcc-information"
                        self.yang_parent_name = "interface-type-information"

                        self.derived_mode = YLeaf(YType.enumeration, "derived-mode")

                        self.sec_state = YLeaf(YType.enumeration, "sec-state")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("derived_mode",
                                        "sec_state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.GccInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.GccInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.derived_mode.is_set or
                            self.sec_state.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.derived_mode.yfilter != YFilter.not_set or
                            self.sec_state.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "gcc-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.derived_mode.is_set or self.derived_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.derived_mode.get_name_leafdata())
                        if (self.sec_state.is_set or self.sec_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sec_state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "derived-mode" or name == "sec-state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "derived-mode"):
                            self.derived_mode = value
                            self.derived_mode.value_namespace = name_space
                            self.derived_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "sec-state"):
                            self.sec_state = value
                            self.sec_state.value_namespace = name_space
                            self.sec_state.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.interface_type_info.is_set or
                        (self.bundle_information is not None and self.bundle_information.has_data()) or
                        (self.cem_information is not None and self.cem_information.has_data()) or
                        (self.gcc_information is not None and self.gcc_information.has_data()) or
                        (self.pseudowire_head_end_information is not None and self.pseudowire_head_end_information.has_data()) or
                        (self.serial_information is not None and self.serial_information.has_data()) or
                        (self.sonet_pos_information is not None and self.sonet_pos_information.has_data()) or
                        (self.srp_information is not None and self.srp_information.has_data()) or
                        (self.tunnel_gre_information is not None and self.tunnel_gre_information.has_data()) or
                        (self.tunnel_information is not None and self.tunnel_information.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_type_info.yfilter != YFilter.not_set or
                        (self.bundle_information is not None and self.bundle_information.has_operation()) or
                        (self.cem_information is not None and self.cem_information.has_operation()) or
                        (self.gcc_information is not None and self.gcc_information.has_operation()) or
                        (self.pseudowire_head_end_information is not None and self.pseudowire_head_end_information.has_operation()) or
                        (self.serial_information is not None and self.serial_information.has_operation()) or
                        (self.sonet_pos_information is not None and self.sonet_pos_information.has_operation()) or
                        (self.srp_information is not None and self.srp_information.has_operation()) or
                        (self.tunnel_gre_information is not None and self.tunnel_gre_information.has_operation()) or
                        (self.tunnel_information is not None and self.tunnel_information.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-type-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_type_info.is_set or self.interface_type_info.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_type_info.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bundle-information"):
                        if (self.bundle_information is None):
                            self.bundle_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.BundleInformation()
                            self.bundle_information.parent = self
                            self._children_name_map["bundle_information"] = "bundle-information"
                        return self.bundle_information

                    if (child_yang_name == "cem-information"):
                        if (self.cem_information is None):
                            self.cem_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.CemInformation()
                            self.cem_information.parent = self
                            self._children_name_map["cem_information"] = "cem-information"
                        return self.cem_information

                    if (child_yang_name == "gcc-information"):
                        if (self.gcc_information is None):
                            self.gcc_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.GccInformation()
                            self.gcc_information.parent = self
                            self._children_name_map["gcc_information"] = "gcc-information"
                        return self.gcc_information

                    if (child_yang_name == "pseudowire-head-end-information"):
                        if (self.pseudowire_head_end_information is None):
                            self.pseudowire_head_end_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.PseudowireHeadEndInformation()
                            self.pseudowire_head_end_information.parent = self
                            self._children_name_map["pseudowire_head_end_information"] = "pseudowire-head-end-information"
                        return self.pseudowire_head_end_information

                    if (child_yang_name == "serial-information"):
                        if (self.serial_information is None):
                            self.serial_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SerialInformation()
                            self.serial_information.parent = self
                            self._children_name_map["serial_information"] = "serial-information"
                        return self.serial_information

                    if (child_yang_name == "sonet-pos-information"):
                        if (self.sonet_pos_information is None):
                            self.sonet_pos_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SonetPosInformation()
                            self.sonet_pos_information.parent = self
                            self._children_name_map["sonet_pos_information"] = "sonet-pos-information"
                        return self.sonet_pos_information

                    if (child_yang_name == "srp-information"):
                        if (self.srp_information is None):
                            self.srp_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.SrpInformation()
                            self.srp_information.parent = self
                            self._children_name_map["srp_information"] = "srp-information"
                        return self.srp_information

                    if (child_yang_name == "tunnel-gre-information"):
                        if (self.tunnel_gre_information is None):
                            self.tunnel_gre_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelGreInformation()
                            self.tunnel_gre_information.parent = self
                            self._children_name_map["tunnel_gre_information"] = "tunnel-gre-information"
                        return self.tunnel_gre_information

                    if (child_yang_name == "tunnel-information"):
                        if (self.tunnel_information is None):
                            self.tunnel_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation.TunnelInformation()
                            self.tunnel_information.parent = self
                            self._children_name_map["tunnel_information"] = "tunnel-information"
                        return self.tunnel_information

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bundle-information" or name == "cem-information" or name == "gcc-information" or name == "pseudowire-head-end-information" or name == "serial-information" or name == "sonet-pos-information" or name == "srp-information" or name == "tunnel-gre-information" or name == "tunnel-information" or name == "interface-type-info"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-type-info"):
                        self.interface_type_info = value
                        self.interface_type_info.value_namespace = name_space
                        self.interface_type_info.value_namespace_prefix = name_space_prefix


            class DataRates(Entity):
                """
                Packet and byte rates
                
                .. attribute:: bandwidth
                
                	Bandwidth (in kbps)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: kbit/s
                
                .. attribute:: input_data_rate
                
                	Input data rate in 1000's of bps
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                	**units**\: bit/s
                
                .. attribute:: input_load
                
                	Input load as fraction of 255
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: input_packet_rate
                
                	Input packets per second
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                	**units**\: packet/s
                
                .. attribute:: load_interval
                
                	Number of 30\-sec intervals less one
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: output_data_rate
                
                	Output data rate in 1000's of bps
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                	**units**\: bit/s
                
                .. attribute:: output_load
                
                	Output load as fraction of 255
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: output_packet_rate
                
                	Output packets per second
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                	**units**\: packet/s
                
                .. attribute:: peak_input_data_rate
                
                	Peak input data rate
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: peak_input_packet_rate
                
                	Peak input packet rate
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: peak_output_data_rate
                
                	Peak output data rate
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: peak_output_packet_rate
                
                	Peak output packet rate
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: reliability
                
                	Reliability coefficient
                	**type**\:  int
                
                	**range:** 0..255
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.DataRates, self).__init__()

                    self.yang_name = "data-rates"
                    self.yang_parent_name = "interface"

                    self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                    self.input_data_rate = YLeaf(YType.uint64, "input-data-rate")

                    self.input_load = YLeaf(YType.uint8, "input-load")

                    self.input_packet_rate = YLeaf(YType.uint64, "input-packet-rate")

                    self.load_interval = YLeaf(YType.uint32, "load-interval")

                    self.output_data_rate = YLeaf(YType.uint64, "output-data-rate")

                    self.output_load = YLeaf(YType.uint8, "output-load")

                    self.output_packet_rate = YLeaf(YType.uint64, "output-packet-rate")

                    self.peak_input_data_rate = YLeaf(YType.uint64, "peak-input-data-rate")

                    self.peak_input_packet_rate = YLeaf(YType.uint64, "peak-input-packet-rate")

                    self.peak_output_data_rate = YLeaf(YType.uint64, "peak-output-data-rate")

                    self.peak_output_packet_rate = YLeaf(YType.uint64, "peak-output-packet-rate")

                    self.reliability = YLeaf(YType.uint8, "reliability")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("bandwidth",
                                    "input_data_rate",
                                    "input_load",
                                    "input_packet_rate",
                                    "load_interval",
                                    "output_data_rate",
                                    "output_load",
                                    "output_packet_rate",
                                    "peak_input_data_rate",
                                    "peak_input_packet_rate",
                                    "peak_output_data_rate",
                                    "peak_output_packet_rate",
                                    "reliability") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.DataRates, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.DataRates, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.bandwidth.is_set or
                        self.input_data_rate.is_set or
                        self.input_load.is_set or
                        self.input_packet_rate.is_set or
                        self.load_interval.is_set or
                        self.output_data_rate.is_set or
                        self.output_load.is_set or
                        self.output_packet_rate.is_set or
                        self.peak_input_data_rate.is_set or
                        self.peak_input_packet_rate.is_set or
                        self.peak_output_data_rate.is_set or
                        self.peak_output_packet_rate.is_set or
                        self.reliability.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.bandwidth.yfilter != YFilter.not_set or
                        self.input_data_rate.yfilter != YFilter.not_set or
                        self.input_load.yfilter != YFilter.not_set or
                        self.input_packet_rate.yfilter != YFilter.not_set or
                        self.load_interval.yfilter != YFilter.not_set or
                        self.output_data_rate.yfilter != YFilter.not_set or
                        self.output_load.yfilter != YFilter.not_set or
                        self.output_packet_rate.yfilter != YFilter.not_set or
                        self.peak_input_data_rate.yfilter != YFilter.not_set or
                        self.peak_input_packet_rate.yfilter != YFilter.not_set or
                        self.peak_output_data_rate.yfilter != YFilter.not_set or
                        self.peak_output_packet_rate.yfilter != YFilter.not_set or
                        self.reliability.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "data-rates" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bandwidth.get_name_leafdata())
                    if (self.input_data_rate.is_set or self.input_data_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.input_data_rate.get_name_leafdata())
                    if (self.input_load.is_set or self.input_load.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.input_load.get_name_leafdata())
                    if (self.input_packet_rate.is_set or self.input_packet_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.input_packet_rate.get_name_leafdata())
                    if (self.load_interval.is_set or self.load_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.load_interval.get_name_leafdata())
                    if (self.output_data_rate.is_set or self.output_data_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.output_data_rate.get_name_leafdata())
                    if (self.output_load.is_set or self.output_load.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.output_load.get_name_leafdata())
                    if (self.output_packet_rate.is_set or self.output_packet_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.output_packet_rate.get_name_leafdata())
                    if (self.peak_input_data_rate.is_set or self.peak_input_data_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peak_input_data_rate.get_name_leafdata())
                    if (self.peak_input_packet_rate.is_set or self.peak_input_packet_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peak_input_packet_rate.get_name_leafdata())
                    if (self.peak_output_data_rate.is_set or self.peak_output_data_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peak_output_data_rate.get_name_leafdata())
                    if (self.peak_output_packet_rate.is_set or self.peak_output_packet_rate.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peak_output_packet_rate.get_name_leafdata())
                    if (self.reliability.is_set or self.reliability.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reliability.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bandwidth" or name == "input-data-rate" or name == "input-load" or name == "input-packet-rate" or name == "load-interval" or name == "output-data-rate" or name == "output-load" or name == "output-packet-rate" or name == "peak-input-data-rate" or name == "peak-input-packet-rate" or name == "peak-output-data-rate" or name == "peak-output-packet-rate" or name == "reliability"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "bandwidth"):
                        self.bandwidth = value
                        self.bandwidth.value_namespace = name_space
                        self.bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "input-data-rate"):
                        self.input_data_rate = value
                        self.input_data_rate.value_namespace = name_space
                        self.input_data_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "input-load"):
                        self.input_load = value
                        self.input_load.value_namespace = name_space
                        self.input_load.value_namespace_prefix = name_space_prefix
                    if(value_path == "input-packet-rate"):
                        self.input_packet_rate = value
                        self.input_packet_rate.value_namespace = name_space
                        self.input_packet_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "load-interval"):
                        self.load_interval = value
                        self.load_interval.value_namespace = name_space
                        self.load_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "output-data-rate"):
                        self.output_data_rate = value
                        self.output_data_rate.value_namespace = name_space
                        self.output_data_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "output-load"):
                        self.output_load = value
                        self.output_load.value_namespace = name_space
                        self.output_load.value_namespace_prefix = name_space_prefix
                    if(value_path == "output-packet-rate"):
                        self.output_packet_rate = value
                        self.output_packet_rate.value_namespace = name_space
                        self.output_packet_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "peak-input-data-rate"):
                        self.peak_input_data_rate = value
                        self.peak_input_data_rate.value_namespace = name_space
                        self.peak_input_data_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "peak-input-packet-rate"):
                        self.peak_input_packet_rate = value
                        self.peak_input_packet_rate.value_namespace = name_space
                        self.peak_input_packet_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "peak-output-data-rate"):
                        self.peak_output_data_rate = value
                        self.peak_output_data_rate.value_namespace = name_space
                        self.peak_output_data_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "peak-output-packet-rate"):
                        self.peak_output_packet_rate = value
                        self.peak_output_packet_rate.value_namespace = name_space
                        self.peak_output_packet_rate.value_namespace_prefix = name_space_prefix
                    if(value_path == "reliability"):
                        self.reliability = value
                        self.reliability.value_namespace = name_space
                        self.reliability.value_namespace_prefix = name_space_prefix


            class InterfaceStatistics(Entity):
                """
                Packet, byte and error counters
                
                .. attribute:: basic_interface_stats
                
                	Packet, byte and selected error counters
                	**type**\:   :py:class:`BasicInterfaceStats <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceStatistics.BasicInterfaceStats>`
                
                .. attribute:: full_interface_stats
                
                	Packet, byte and all error counters
                	**type**\:   :py:class:`FullInterfaceStats <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.InterfaceStatistics.FullInterfaceStats>`
                
                .. attribute:: stats_type
                
                	StatsType
                	**type**\:   :py:class:`ImCmdStatsEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImCmdStatsEnum>`
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.InterfaceStatistics, self).__init__()

                    self.yang_name = "interface-statistics"
                    self.yang_parent_name = "interface"

                    self.stats_type = YLeaf(YType.enumeration, "stats-type")

                    self.basic_interface_stats = Interfaces.InterfaceXr.Interface.InterfaceStatistics.BasicInterfaceStats()
                    self.basic_interface_stats.parent = self
                    self._children_name_map["basic_interface_stats"] = "basic-interface-stats"
                    self._children_yang_names.add("basic-interface-stats")

                    self.full_interface_stats = Interfaces.InterfaceXr.Interface.InterfaceStatistics.FullInterfaceStats()
                    self.full_interface_stats.parent = self
                    self._children_name_map["full_interface_stats"] = "full-interface-stats"
                    self._children_yang_names.add("full-interface-stats")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("stats_type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.InterfaceStatistics, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.InterfaceStatistics, self).__setattr__(name, value)


                class FullInterfaceStats(Entity):
                    """
                    Packet, byte and all error counters
                    
                    .. attribute:: applique
                    
                    	Applique
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: availability_flag
                    
                    	Availability bit mask
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: broadcast_packets_received
                    
                    	Broadcast packets received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: broadcast_packets_sent
                    
                    	Broadcast packets sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: bytes_received
                    
                    	Bytes received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: byte
                    
                    .. attribute:: bytes_sent
                    
                    	Bytes sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: byte
                    
                    .. attribute:: carrier_transitions
                    
                    	Carrier transitions
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: crc_errors
                    
                    	Input CRC errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: framing_errors_received
                    
                    	Framing\-errors received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: giant_packets_received
                    
                    	Received giant packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_aborts
                    
                    	Input aborts
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_drops
                    
                    	Total input drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_errors
                    
                    	Total input errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_ignored_packets
                    
                    	Input ignored packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_overruns
                    
                    	Input overruns
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_queue_drops
                    
                    	Input queue drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: last_data_time
                    
                    	Time when counters were last written (in seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: last_discontinuity_time
                    
                    	SysUpTime when counters were last reset (in seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: multicast_packets_received
                    
                    	Multicast packets received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: multicast_packets_sent
                    
                    	Multicast packets sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: output_buffer_failures
                    
                    	Output buffer failures
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_buffers_swapped_out
                    
                    	Output buffers swapped out
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_drops
                    
                    	Total output drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_errors
                    
                    	Total output errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_queue_drops
                    
                    	Output queue drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_underruns
                    
                    	Output underruns
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: packets_received
                    
                    	Packets received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: packets_sent
                    
                    	Packets sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: parity_packets_received
                    
                    	Received parity packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: resets
                    
                    	Number of board resets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: runt_packets_received
                    
                    	Received runt packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: seconds_since_last_clear_counters
                    
                    	Number of seconds since last clear counters
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: seconds_since_packet_received
                    
                    	Seconds since packet received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: seconds_since_packet_sent
                    
                    	Seconds since packet sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: throttled_packets_received
                    
                    	Received throttled packets
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: unknown_protocol_packets_received
                    
                    	Unknown protocol packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceStatistics.FullInterfaceStats, self).__init__()

                        self.yang_name = "full-interface-stats"
                        self.yang_parent_name = "interface-statistics"

                        self.applique = YLeaf(YType.uint32, "applique")

                        self.availability_flag = YLeaf(YType.uint32, "availability-flag")

                        self.broadcast_packets_received = YLeaf(YType.uint64, "broadcast-packets-received")

                        self.broadcast_packets_sent = YLeaf(YType.uint64, "broadcast-packets-sent")

                        self.bytes_received = YLeaf(YType.uint64, "bytes-received")

                        self.bytes_sent = YLeaf(YType.uint64, "bytes-sent")

                        self.carrier_transitions = YLeaf(YType.uint32, "carrier-transitions")

                        self.crc_errors = YLeaf(YType.uint32, "crc-errors")

                        self.framing_errors_received = YLeaf(YType.uint32, "framing-errors-received")

                        self.giant_packets_received = YLeaf(YType.uint32, "giant-packets-received")

                        self.input_aborts = YLeaf(YType.uint32, "input-aborts")

                        self.input_drops = YLeaf(YType.uint32, "input-drops")

                        self.input_errors = YLeaf(YType.uint32, "input-errors")

                        self.input_ignored_packets = YLeaf(YType.uint32, "input-ignored-packets")

                        self.input_overruns = YLeaf(YType.uint32, "input-overruns")

                        self.input_queue_drops = YLeaf(YType.uint32, "input-queue-drops")

                        self.last_data_time = YLeaf(YType.uint32, "last-data-time")

                        self.last_discontinuity_time = YLeaf(YType.uint32, "last-discontinuity-time")

                        self.multicast_packets_received = YLeaf(YType.uint64, "multicast-packets-received")

                        self.multicast_packets_sent = YLeaf(YType.uint64, "multicast-packets-sent")

                        self.output_buffer_failures = YLeaf(YType.uint32, "output-buffer-failures")

                        self.output_buffers_swapped_out = YLeaf(YType.uint32, "output-buffers-swapped-out")

                        self.output_drops = YLeaf(YType.uint32, "output-drops")

                        self.output_errors = YLeaf(YType.uint32, "output-errors")

                        self.output_queue_drops = YLeaf(YType.uint32, "output-queue-drops")

                        self.output_underruns = YLeaf(YType.uint32, "output-underruns")

                        self.packets_received = YLeaf(YType.uint64, "packets-received")

                        self.packets_sent = YLeaf(YType.uint64, "packets-sent")

                        self.parity_packets_received = YLeaf(YType.uint32, "parity-packets-received")

                        self.resets = YLeaf(YType.uint32, "resets")

                        self.runt_packets_received = YLeaf(YType.uint32, "runt-packets-received")

                        self.seconds_since_last_clear_counters = YLeaf(YType.uint32, "seconds-since-last-clear-counters")

                        self.seconds_since_packet_received = YLeaf(YType.uint32, "seconds-since-packet-received")

                        self.seconds_since_packet_sent = YLeaf(YType.uint32, "seconds-since-packet-sent")

                        self.throttled_packets_received = YLeaf(YType.uint32, "throttled-packets-received")

                        self.unknown_protocol_packets_received = YLeaf(YType.uint32, "unknown-protocol-packets-received")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("applique",
                                        "availability_flag",
                                        "broadcast_packets_received",
                                        "broadcast_packets_sent",
                                        "bytes_received",
                                        "bytes_sent",
                                        "carrier_transitions",
                                        "crc_errors",
                                        "framing_errors_received",
                                        "giant_packets_received",
                                        "input_aborts",
                                        "input_drops",
                                        "input_errors",
                                        "input_ignored_packets",
                                        "input_overruns",
                                        "input_queue_drops",
                                        "last_data_time",
                                        "last_discontinuity_time",
                                        "multicast_packets_received",
                                        "multicast_packets_sent",
                                        "output_buffer_failures",
                                        "output_buffers_swapped_out",
                                        "output_drops",
                                        "output_errors",
                                        "output_queue_drops",
                                        "output_underruns",
                                        "packets_received",
                                        "packets_sent",
                                        "parity_packets_received",
                                        "resets",
                                        "runt_packets_received",
                                        "seconds_since_last_clear_counters",
                                        "seconds_since_packet_received",
                                        "seconds_since_packet_sent",
                                        "throttled_packets_received",
                                        "unknown_protocol_packets_received") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceStatistics.FullInterfaceStats, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceStatistics.FullInterfaceStats, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.applique.is_set or
                            self.availability_flag.is_set or
                            self.broadcast_packets_received.is_set or
                            self.broadcast_packets_sent.is_set or
                            self.bytes_received.is_set or
                            self.bytes_sent.is_set or
                            self.carrier_transitions.is_set or
                            self.crc_errors.is_set or
                            self.framing_errors_received.is_set or
                            self.giant_packets_received.is_set or
                            self.input_aborts.is_set or
                            self.input_drops.is_set or
                            self.input_errors.is_set or
                            self.input_ignored_packets.is_set or
                            self.input_overruns.is_set or
                            self.input_queue_drops.is_set or
                            self.last_data_time.is_set or
                            self.last_discontinuity_time.is_set or
                            self.multicast_packets_received.is_set or
                            self.multicast_packets_sent.is_set or
                            self.output_buffer_failures.is_set or
                            self.output_buffers_swapped_out.is_set or
                            self.output_drops.is_set or
                            self.output_errors.is_set or
                            self.output_queue_drops.is_set or
                            self.output_underruns.is_set or
                            self.packets_received.is_set or
                            self.packets_sent.is_set or
                            self.parity_packets_received.is_set or
                            self.resets.is_set or
                            self.runt_packets_received.is_set or
                            self.seconds_since_last_clear_counters.is_set or
                            self.seconds_since_packet_received.is_set or
                            self.seconds_since_packet_sent.is_set or
                            self.throttled_packets_received.is_set or
                            self.unknown_protocol_packets_received.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.applique.yfilter != YFilter.not_set or
                            self.availability_flag.yfilter != YFilter.not_set or
                            self.broadcast_packets_received.yfilter != YFilter.not_set or
                            self.broadcast_packets_sent.yfilter != YFilter.not_set or
                            self.bytes_received.yfilter != YFilter.not_set or
                            self.bytes_sent.yfilter != YFilter.not_set or
                            self.carrier_transitions.yfilter != YFilter.not_set or
                            self.crc_errors.yfilter != YFilter.not_set or
                            self.framing_errors_received.yfilter != YFilter.not_set or
                            self.giant_packets_received.yfilter != YFilter.not_set or
                            self.input_aborts.yfilter != YFilter.not_set or
                            self.input_drops.yfilter != YFilter.not_set or
                            self.input_errors.yfilter != YFilter.not_set or
                            self.input_ignored_packets.yfilter != YFilter.not_set or
                            self.input_overruns.yfilter != YFilter.not_set or
                            self.input_queue_drops.yfilter != YFilter.not_set or
                            self.last_data_time.yfilter != YFilter.not_set or
                            self.last_discontinuity_time.yfilter != YFilter.not_set or
                            self.multicast_packets_received.yfilter != YFilter.not_set or
                            self.multicast_packets_sent.yfilter != YFilter.not_set or
                            self.output_buffer_failures.yfilter != YFilter.not_set or
                            self.output_buffers_swapped_out.yfilter != YFilter.not_set or
                            self.output_drops.yfilter != YFilter.not_set or
                            self.output_errors.yfilter != YFilter.not_set or
                            self.output_queue_drops.yfilter != YFilter.not_set or
                            self.output_underruns.yfilter != YFilter.not_set or
                            self.packets_received.yfilter != YFilter.not_set or
                            self.packets_sent.yfilter != YFilter.not_set or
                            self.parity_packets_received.yfilter != YFilter.not_set or
                            self.resets.yfilter != YFilter.not_set or
                            self.runt_packets_received.yfilter != YFilter.not_set or
                            self.seconds_since_last_clear_counters.yfilter != YFilter.not_set or
                            self.seconds_since_packet_received.yfilter != YFilter.not_set or
                            self.seconds_since_packet_sent.yfilter != YFilter.not_set or
                            self.throttled_packets_received.yfilter != YFilter.not_set or
                            self.unknown_protocol_packets_received.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "full-interface-stats" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.applique.is_set or self.applique.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.applique.get_name_leafdata())
                        if (self.availability_flag.is_set or self.availability_flag.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.availability_flag.get_name_leafdata())
                        if (self.broadcast_packets_received.is_set or self.broadcast_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.broadcast_packets_received.get_name_leafdata())
                        if (self.broadcast_packets_sent.is_set or self.broadcast_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.broadcast_packets_sent.get_name_leafdata())
                        if (self.bytes_received.is_set or self.bytes_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bytes_received.get_name_leafdata())
                        if (self.bytes_sent.is_set or self.bytes_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bytes_sent.get_name_leafdata())
                        if (self.carrier_transitions.is_set or self.carrier_transitions.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.carrier_transitions.get_name_leafdata())
                        if (self.crc_errors.is_set or self.crc_errors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.crc_errors.get_name_leafdata())
                        if (self.framing_errors_received.is_set or self.framing_errors_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.framing_errors_received.get_name_leafdata())
                        if (self.giant_packets_received.is_set or self.giant_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.giant_packets_received.get_name_leafdata())
                        if (self.input_aborts.is_set or self.input_aborts.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_aborts.get_name_leafdata())
                        if (self.input_drops.is_set or self.input_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_drops.get_name_leafdata())
                        if (self.input_errors.is_set or self.input_errors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_errors.get_name_leafdata())
                        if (self.input_ignored_packets.is_set or self.input_ignored_packets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_ignored_packets.get_name_leafdata())
                        if (self.input_overruns.is_set or self.input_overruns.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_overruns.get_name_leafdata())
                        if (self.input_queue_drops.is_set or self.input_queue_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_queue_drops.get_name_leafdata())
                        if (self.last_data_time.is_set or self.last_data_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_data_time.get_name_leafdata())
                        if (self.last_discontinuity_time.is_set or self.last_discontinuity_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_discontinuity_time.get_name_leafdata())
                        if (self.multicast_packets_received.is_set or self.multicast_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multicast_packets_received.get_name_leafdata())
                        if (self.multicast_packets_sent.is_set or self.multicast_packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.multicast_packets_sent.get_name_leafdata())
                        if (self.output_buffer_failures.is_set or self.output_buffer_failures.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_buffer_failures.get_name_leafdata())
                        if (self.output_buffers_swapped_out.is_set or self.output_buffers_swapped_out.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_buffers_swapped_out.get_name_leafdata())
                        if (self.output_drops.is_set or self.output_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_drops.get_name_leafdata())
                        if (self.output_errors.is_set or self.output_errors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_errors.get_name_leafdata())
                        if (self.output_queue_drops.is_set or self.output_queue_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_queue_drops.get_name_leafdata())
                        if (self.output_underruns.is_set or self.output_underruns.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_underruns.get_name_leafdata())
                        if (self.packets_received.is_set or self.packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packets_received.get_name_leafdata())
                        if (self.packets_sent.is_set or self.packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packets_sent.get_name_leafdata())
                        if (self.parity_packets_received.is_set or self.parity_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.parity_packets_received.get_name_leafdata())
                        if (self.resets.is_set or self.resets.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.resets.get_name_leafdata())
                        if (self.runt_packets_received.is_set or self.runt_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.runt_packets_received.get_name_leafdata())
                        if (self.seconds_since_last_clear_counters.is_set or self.seconds_since_last_clear_counters.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds_since_last_clear_counters.get_name_leafdata())
                        if (self.seconds_since_packet_received.is_set or self.seconds_since_packet_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds_since_packet_received.get_name_leafdata())
                        if (self.seconds_since_packet_sent.is_set or self.seconds_since_packet_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds_since_packet_sent.get_name_leafdata())
                        if (self.throttled_packets_received.is_set or self.throttled_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.throttled_packets_received.get_name_leafdata())
                        if (self.unknown_protocol_packets_received.is_set or self.unknown_protocol_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unknown_protocol_packets_received.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "applique" or name == "availability-flag" or name == "broadcast-packets-received" or name == "broadcast-packets-sent" or name == "bytes-received" or name == "bytes-sent" or name == "carrier-transitions" or name == "crc-errors" or name == "framing-errors-received" or name == "giant-packets-received" or name == "input-aborts" or name == "input-drops" or name == "input-errors" or name == "input-ignored-packets" or name == "input-overruns" or name == "input-queue-drops" or name == "last-data-time" or name == "last-discontinuity-time" or name == "multicast-packets-received" or name == "multicast-packets-sent" or name == "output-buffer-failures" or name == "output-buffers-swapped-out" or name == "output-drops" or name == "output-errors" or name == "output-queue-drops" or name == "output-underruns" or name == "packets-received" or name == "packets-sent" or name == "parity-packets-received" or name == "resets" or name == "runt-packets-received" or name == "seconds-since-last-clear-counters" or name == "seconds-since-packet-received" or name == "seconds-since-packet-sent" or name == "throttled-packets-received" or name == "unknown-protocol-packets-received"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "applique"):
                            self.applique = value
                            self.applique.value_namespace = name_space
                            self.applique.value_namespace_prefix = name_space_prefix
                        if(value_path == "availability-flag"):
                            self.availability_flag = value
                            self.availability_flag.value_namespace = name_space
                            self.availability_flag.value_namespace_prefix = name_space_prefix
                        if(value_path == "broadcast-packets-received"):
                            self.broadcast_packets_received = value
                            self.broadcast_packets_received.value_namespace = name_space
                            self.broadcast_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "broadcast-packets-sent"):
                            self.broadcast_packets_sent = value
                            self.broadcast_packets_sent.value_namespace = name_space
                            self.broadcast_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "bytes-received"):
                            self.bytes_received = value
                            self.bytes_received.value_namespace = name_space
                            self.bytes_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "bytes-sent"):
                            self.bytes_sent = value
                            self.bytes_sent.value_namespace = name_space
                            self.bytes_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "carrier-transitions"):
                            self.carrier_transitions = value
                            self.carrier_transitions.value_namespace = name_space
                            self.carrier_transitions.value_namespace_prefix = name_space_prefix
                        if(value_path == "crc-errors"):
                            self.crc_errors = value
                            self.crc_errors.value_namespace = name_space
                            self.crc_errors.value_namespace_prefix = name_space_prefix
                        if(value_path == "framing-errors-received"):
                            self.framing_errors_received = value
                            self.framing_errors_received.value_namespace = name_space
                            self.framing_errors_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "giant-packets-received"):
                            self.giant_packets_received = value
                            self.giant_packets_received.value_namespace = name_space
                            self.giant_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-aborts"):
                            self.input_aborts = value
                            self.input_aborts.value_namespace = name_space
                            self.input_aborts.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-drops"):
                            self.input_drops = value
                            self.input_drops.value_namespace = name_space
                            self.input_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-errors"):
                            self.input_errors = value
                            self.input_errors.value_namespace = name_space
                            self.input_errors.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-ignored-packets"):
                            self.input_ignored_packets = value
                            self.input_ignored_packets.value_namespace = name_space
                            self.input_ignored_packets.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-overruns"):
                            self.input_overruns = value
                            self.input_overruns.value_namespace = name_space
                            self.input_overruns.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-queue-drops"):
                            self.input_queue_drops = value
                            self.input_queue_drops.value_namespace = name_space
                            self.input_queue_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-data-time"):
                            self.last_data_time = value
                            self.last_data_time.value_namespace = name_space
                            self.last_data_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-discontinuity-time"):
                            self.last_discontinuity_time = value
                            self.last_discontinuity_time.value_namespace = name_space
                            self.last_discontinuity_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "multicast-packets-received"):
                            self.multicast_packets_received = value
                            self.multicast_packets_received.value_namespace = name_space
                            self.multicast_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "multicast-packets-sent"):
                            self.multicast_packets_sent = value
                            self.multicast_packets_sent.value_namespace = name_space
                            self.multicast_packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-buffer-failures"):
                            self.output_buffer_failures = value
                            self.output_buffer_failures.value_namespace = name_space
                            self.output_buffer_failures.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-buffers-swapped-out"):
                            self.output_buffers_swapped_out = value
                            self.output_buffers_swapped_out.value_namespace = name_space
                            self.output_buffers_swapped_out.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-drops"):
                            self.output_drops = value
                            self.output_drops.value_namespace = name_space
                            self.output_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-errors"):
                            self.output_errors = value
                            self.output_errors.value_namespace = name_space
                            self.output_errors.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-queue-drops"):
                            self.output_queue_drops = value
                            self.output_queue_drops.value_namespace = name_space
                            self.output_queue_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-underruns"):
                            self.output_underruns = value
                            self.output_underruns.value_namespace = name_space
                            self.output_underruns.value_namespace_prefix = name_space_prefix
                        if(value_path == "packets-received"):
                            self.packets_received = value
                            self.packets_received.value_namespace = name_space
                            self.packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "packets-sent"):
                            self.packets_sent = value
                            self.packets_sent.value_namespace = name_space
                            self.packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "parity-packets-received"):
                            self.parity_packets_received = value
                            self.parity_packets_received.value_namespace = name_space
                            self.parity_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "resets"):
                            self.resets = value
                            self.resets.value_namespace = name_space
                            self.resets.value_namespace_prefix = name_space_prefix
                        if(value_path == "runt-packets-received"):
                            self.runt_packets_received = value
                            self.runt_packets_received.value_namespace = name_space
                            self.runt_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds-since-last-clear-counters"):
                            self.seconds_since_last_clear_counters = value
                            self.seconds_since_last_clear_counters.value_namespace = name_space
                            self.seconds_since_last_clear_counters.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds-since-packet-received"):
                            self.seconds_since_packet_received = value
                            self.seconds_since_packet_received.value_namespace = name_space
                            self.seconds_since_packet_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds-since-packet-sent"):
                            self.seconds_since_packet_sent = value
                            self.seconds_since_packet_sent.value_namespace = name_space
                            self.seconds_since_packet_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "throttled-packets-received"):
                            self.throttled_packets_received = value
                            self.throttled_packets_received.value_namespace = name_space
                            self.throttled_packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "unknown-protocol-packets-received"):
                            self.unknown_protocol_packets_received = value
                            self.unknown_protocol_packets_received.value_namespace = name_space
                            self.unknown_protocol_packets_received.value_namespace_prefix = name_space_prefix


                class BasicInterfaceStats(Entity):
                    """
                    Packet, byte and selected error counters
                    
                    .. attribute:: bytes_received
                    
                    	Bytes received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: byte
                    
                    .. attribute:: bytes_sent
                    
                    	Bytes sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: byte
                    
                    .. attribute:: input_drops
                    
                    	Total input drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_errors
                    
                    	Total input errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: input_queue_drops
                    
                    	Input queue drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: last_data_time
                    
                    	Time when counters were last written (in seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: last_discontinuity_time
                    
                    	SysUpTime when counters were last reset (in seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: output_drops
                    
                    	Total output drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_errors
                    
                    	Total output errors
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: output_queue_drops
                    
                    	Output queue drops
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: packets_received
                    
                    	Packets received
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: packets_sent
                    
                    	Packets sent
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    .. attribute:: seconds_since_last_clear_counters
                    
                    	Number of seconds since last clear counters
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: seconds_since_packet_received
                    
                    	Seconds since packet received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: seconds_since_packet_sent
                    
                    	Seconds since packet sent
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: second
                    
                    .. attribute:: unknown_protocol_packets_received
                    
                    	Unknown protocol packets received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.InterfaceStatistics.BasicInterfaceStats, self).__init__()

                        self.yang_name = "basic-interface-stats"
                        self.yang_parent_name = "interface-statistics"

                        self.bytes_received = YLeaf(YType.uint64, "bytes-received")

                        self.bytes_sent = YLeaf(YType.uint64, "bytes-sent")

                        self.input_drops = YLeaf(YType.uint32, "input-drops")

                        self.input_errors = YLeaf(YType.uint32, "input-errors")

                        self.input_queue_drops = YLeaf(YType.uint32, "input-queue-drops")

                        self.last_data_time = YLeaf(YType.uint32, "last-data-time")

                        self.last_discontinuity_time = YLeaf(YType.uint32, "last-discontinuity-time")

                        self.output_drops = YLeaf(YType.uint32, "output-drops")

                        self.output_errors = YLeaf(YType.uint32, "output-errors")

                        self.output_queue_drops = YLeaf(YType.uint32, "output-queue-drops")

                        self.packets_received = YLeaf(YType.uint64, "packets-received")

                        self.packets_sent = YLeaf(YType.uint64, "packets-sent")

                        self.seconds_since_last_clear_counters = YLeaf(YType.uint32, "seconds-since-last-clear-counters")

                        self.seconds_since_packet_received = YLeaf(YType.uint32, "seconds-since-packet-received")

                        self.seconds_since_packet_sent = YLeaf(YType.uint32, "seconds-since-packet-sent")

                        self.unknown_protocol_packets_received = YLeaf(YType.uint32, "unknown-protocol-packets-received")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bytes_received",
                                        "bytes_sent",
                                        "input_drops",
                                        "input_errors",
                                        "input_queue_drops",
                                        "last_data_time",
                                        "last_discontinuity_time",
                                        "output_drops",
                                        "output_errors",
                                        "output_queue_drops",
                                        "packets_received",
                                        "packets_sent",
                                        "seconds_since_last_clear_counters",
                                        "seconds_since_packet_received",
                                        "seconds_since_packet_sent",
                                        "unknown_protocol_packets_received") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.InterfaceStatistics.BasicInterfaceStats, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.InterfaceStatistics.BasicInterfaceStats, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bytes_received.is_set or
                            self.bytes_sent.is_set or
                            self.input_drops.is_set or
                            self.input_errors.is_set or
                            self.input_queue_drops.is_set or
                            self.last_data_time.is_set or
                            self.last_discontinuity_time.is_set or
                            self.output_drops.is_set or
                            self.output_errors.is_set or
                            self.output_queue_drops.is_set or
                            self.packets_received.is_set or
                            self.packets_sent.is_set or
                            self.seconds_since_last_clear_counters.is_set or
                            self.seconds_since_packet_received.is_set or
                            self.seconds_since_packet_sent.is_set or
                            self.unknown_protocol_packets_received.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bytes_received.yfilter != YFilter.not_set or
                            self.bytes_sent.yfilter != YFilter.not_set or
                            self.input_drops.yfilter != YFilter.not_set or
                            self.input_errors.yfilter != YFilter.not_set or
                            self.input_queue_drops.yfilter != YFilter.not_set or
                            self.last_data_time.yfilter != YFilter.not_set or
                            self.last_discontinuity_time.yfilter != YFilter.not_set or
                            self.output_drops.yfilter != YFilter.not_set or
                            self.output_errors.yfilter != YFilter.not_set or
                            self.output_queue_drops.yfilter != YFilter.not_set or
                            self.packets_received.yfilter != YFilter.not_set or
                            self.packets_sent.yfilter != YFilter.not_set or
                            self.seconds_since_last_clear_counters.yfilter != YFilter.not_set or
                            self.seconds_since_packet_received.yfilter != YFilter.not_set or
                            self.seconds_since_packet_sent.yfilter != YFilter.not_set or
                            self.unknown_protocol_packets_received.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "basic-interface-stats" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bytes_received.is_set or self.bytes_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bytes_received.get_name_leafdata())
                        if (self.bytes_sent.is_set or self.bytes_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bytes_sent.get_name_leafdata())
                        if (self.input_drops.is_set or self.input_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_drops.get_name_leafdata())
                        if (self.input_errors.is_set or self.input_errors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_errors.get_name_leafdata())
                        if (self.input_queue_drops.is_set or self.input_queue_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.input_queue_drops.get_name_leafdata())
                        if (self.last_data_time.is_set or self.last_data_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_data_time.get_name_leafdata())
                        if (self.last_discontinuity_time.is_set or self.last_discontinuity_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_discontinuity_time.get_name_leafdata())
                        if (self.output_drops.is_set or self.output_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_drops.get_name_leafdata())
                        if (self.output_errors.is_set or self.output_errors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_errors.get_name_leafdata())
                        if (self.output_queue_drops.is_set or self.output_queue_drops.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.output_queue_drops.get_name_leafdata())
                        if (self.packets_received.is_set or self.packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packets_received.get_name_leafdata())
                        if (self.packets_sent.is_set or self.packets_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.packets_sent.get_name_leafdata())
                        if (self.seconds_since_last_clear_counters.is_set or self.seconds_since_last_clear_counters.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds_since_last_clear_counters.get_name_leafdata())
                        if (self.seconds_since_packet_received.is_set or self.seconds_since_packet_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds_since_packet_received.get_name_leafdata())
                        if (self.seconds_since_packet_sent.is_set or self.seconds_since_packet_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds_since_packet_sent.get_name_leafdata())
                        if (self.unknown_protocol_packets_received.is_set or self.unknown_protocol_packets_received.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unknown_protocol_packets_received.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bytes-received" or name == "bytes-sent" or name == "input-drops" or name == "input-errors" or name == "input-queue-drops" or name == "last-data-time" or name == "last-discontinuity-time" or name == "output-drops" or name == "output-errors" or name == "output-queue-drops" or name == "packets-received" or name == "packets-sent" or name == "seconds-since-last-clear-counters" or name == "seconds-since-packet-received" or name == "seconds-since-packet-sent" or name == "unknown-protocol-packets-received"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bytes-received"):
                            self.bytes_received = value
                            self.bytes_received.value_namespace = name_space
                            self.bytes_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "bytes-sent"):
                            self.bytes_sent = value
                            self.bytes_sent.value_namespace = name_space
                            self.bytes_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-drops"):
                            self.input_drops = value
                            self.input_drops.value_namespace = name_space
                            self.input_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-errors"):
                            self.input_errors = value
                            self.input_errors.value_namespace = name_space
                            self.input_errors.value_namespace_prefix = name_space_prefix
                        if(value_path == "input-queue-drops"):
                            self.input_queue_drops = value
                            self.input_queue_drops.value_namespace = name_space
                            self.input_queue_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-data-time"):
                            self.last_data_time = value
                            self.last_data_time.value_namespace = name_space
                            self.last_data_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-discontinuity-time"):
                            self.last_discontinuity_time = value
                            self.last_discontinuity_time.value_namespace = name_space
                            self.last_discontinuity_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-drops"):
                            self.output_drops = value
                            self.output_drops.value_namespace = name_space
                            self.output_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-errors"):
                            self.output_errors = value
                            self.output_errors.value_namespace = name_space
                            self.output_errors.value_namespace_prefix = name_space_prefix
                        if(value_path == "output-queue-drops"):
                            self.output_queue_drops = value
                            self.output_queue_drops.value_namespace = name_space
                            self.output_queue_drops.value_namespace_prefix = name_space_prefix
                        if(value_path == "packets-received"):
                            self.packets_received = value
                            self.packets_received.value_namespace = name_space
                            self.packets_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "packets-sent"):
                            self.packets_sent = value
                            self.packets_sent.value_namespace = name_space
                            self.packets_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds-since-last-clear-counters"):
                            self.seconds_since_last_clear_counters = value
                            self.seconds_since_last_clear_counters.value_namespace = name_space
                            self.seconds_since_last_clear_counters.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds-since-packet-received"):
                            self.seconds_since_packet_received = value
                            self.seconds_since_packet_received.value_namespace = name_space
                            self.seconds_since_packet_received.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds-since-packet-sent"):
                            self.seconds_since_packet_sent = value
                            self.seconds_since_packet_sent.value_namespace = name_space
                            self.seconds_since_packet_sent.value_namespace_prefix = name_space_prefix
                        if(value_path == "unknown-protocol-packets-received"):
                            self.unknown_protocol_packets_received = value
                            self.unknown_protocol_packets_received.value_namespace = name_space
                            self.unknown_protocol_packets_received.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.stats_type.is_set or
                        (self.basic_interface_stats is not None and self.basic_interface_stats.has_data()) or
                        (self.full_interface_stats is not None and self.full_interface_stats.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.stats_type.yfilter != YFilter.not_set or
                        (self.basic_interface_stats is not None and self.basic_interface_stats.has_operation()) or
                        (self.full_interface_stats is not None and self.full_interface_stats.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-statistics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.stats_type.is_set or self.stats_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stats_type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "basic-interface-stats"):
                        if (self.basic_interface_stats is None):
                            self.basic_interface_stats = Interfaces.InterfaceXr.Interface.InterfaceStatistics.BasicInterfaceStats()
                            self.basic_interface_stats.parent = self
                            self._children_name_map["basic_interface_stats"] = "basic-interface-stats"
                        return self.basic_interface_stats

                    if (child_yang_name == "full-interface-stats"):
                        if (self.full_interface_stats is None):
                            self.full_interface_stats = Interfaces.InterfaceXr.Interface.InterfaceStatistics.FullInterfaceStats()
                            self.full_interface_stats.parent = self
                            self._children_name_map["full_interface_stats"] = "full-interface-stats"
                        return self.full_interface_stats

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "basic-interface-stats" or name == "full-interface-stats" or name == "stats-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "stats-type"):
                        self.stats_type = value
                        self.stats_type.value_namespace = name_space
                        self.stats_type.value_namespace_prefix = name_space_prefix


            class L2InterfaceStatistics(Entity):
                """
                L2 Protocol Statistics
                
                .. attribute:: block_array
                
                	Block Array
                	**type**\: list of    :py:class:`BlockArray <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.BlockArray>`
                
                .. attribute:: contents
                
                	Bag contents
                	**type**\:   :py:class:`StatsTypeContents <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.StatsTypeContents>`
                
                .. attribute:: element_array
                
                	Element Array
                	**type**\: list of    :py:class:`ElementArray <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray>`
                
                .. attribute:: stats_id
                
                	Identifier
                	**type**\:   :py:class:`StatsId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.StatsId>`
                
                .. attribute:: stats_type
                
                	Stats type value
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics, self).__init__()

                    self.yang_name = "l2-interface-statistics"
                    self.yang_parent_name = "interface"

                    self.contents = YLeaf(YType.enumeration, "contents")

                    self.stats_type = YLeaf(YType.uint32, "stats-type")

                    self.stats_id = Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.StatsId()
                    self.stats_id.parent = self
                    self._children_name_map["stats_id"] = "stats-id"
                    self._children_yang_names.add("stats-id")

                    self.block_array = YList(self)
                    self.element_array = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("contents",
                                    "stats_type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics, self).__setattr__(name, value)


                class StatsId(Entity):
                    """
                    Identifier
                    
                    .. attribute:: feature_id
                    
                    	Feature ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: id
                    
                    	ID
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: id_type
                    
                    	id type
                    	**type**\:   :py:class:`StatsId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.StatsId>`
                    
                    .. attribute:: interface_handle
                    
                    	Interface Handle
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: node_id
                    
                    	Node ID
                    	**type**\:  str
                    
                    	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                    
                    .. attribute:: unused
                    
                    	Unused
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.StatsId, self).__init__()

                        self.yang_name = "stats-id"
                        self.yang_parent_name = "l2-interface-statistics"

                        self.feature_id = YLeaf(YType.uint32, "feature-id")

                        self.id = YLeaf(YType.uint32, "id")

                        self.id_type = YLeaf(YType.enumeration, "id-type")

                        self.interface_handle = YLeaf(YType.str, "interface-handle")

                        self.node_id = YLeaf(YType.str, "node-id")

                        self.unused = YLeaf(YType.uint32, "unused")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("feature_id",
                                        "id",
                                        "id_type",
                                        "interface_handle",
                                        "node_id",
                                        "unused") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.StatsId, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.StatsId, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.feature_id.is_set or
                            self.id.is_set or
                            self.id_type.is_set or
                            self.interface_handle.is_set or
                            self.node_id.is_set or
                            self.unused.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.feature_id.yfilter != YFilter.not_set or
                            self.id.yfilter != YFilter.not_set or
                            self.id_type.yfilter != YFilter.not_set or
                            self.interface_handle.yfilter != YFilter.not_set or
                            self.node_id.yfilter != YFilter.not_set or
                            self.unused.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "stats-id" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.feature_id.is_set or self.feature_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.feature_id.get_name_leafdata())
                        if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.id.get_name_leafdata())
                        if (self.id_type.is_set or self.id_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.id_type.get_name_leafdata())
                        if (self.interface_handle.is_set or self.interface_handle.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_handle.get_name_leafdata())
                        if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.node_id.get_name_leafdata())
                        if (self.unused.is_set or self.unused.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unused.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "feature-id" or name == "id" or name == "id-type" or name == "interface-handle" or name == "node-id" or name == "unused"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "feature-id"):
                            self.feature_id = value
                            self.feature_id.value_namespace = name_space
                            self.feature_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "id"):
                            self.id = value
                            self.id.value_namespace = name_space
                            self.id.value_namespace_prefix = name_space_prefix
                        if(value_path == "id-type"):
                            self.id_type = value
                            self.id_type.value_namespace = name_space
                            self.id_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-handle"):
                            self.interface_handle = value
                            self.interface_handle.value_namespace = name_space
                            self.interface_handle.value_namespace_prefix = name_space_prefix
                        if(value_path == "node-id"):
                            self.node_id = value
                            self.node_id.value_namespace = name_space
                            self.node_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "unused"):
                            self.unused = value
                            self.unused.value_namespace = name_space
                            self.unused.value_namespace_prefix = name_space_prefix


                class BlockArray(Entity):
                    """
                    Block Array
                    
                    .. attribute:: count
                    
                    	count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: data
                    
                    	data
                    	**type**\:  str
                    
                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                    
                    .. attribute:: type
                    
                    	type
                    	**type**\:   :py:class:`StatsCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.StatsCounter>`
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.BlockArray, self).__init__()

                        self.yang_name = "block-array"
                        self.yang_parent_name = "l2-interface-statistics"

                        self.count = YLeaf(YType.uint32, "count")

                        self.data = YLeaf(YType.str, "data")

                        self.type = YLeaf(YType.enumeration, "type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("count",
                                        "data",
                                        "type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.BlockArray, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.BlockArray, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.count.is_set or
                            self.data.is_set or
                            self.type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.count.yfilter != YFilter.not_set or
                            self.data.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "block-array" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.count.is_set or self.count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.count.get_name_leafdata())
                        if (self.data.is_set or self.data.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.data.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "count" or name == "data" or name == "type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "count"):
                            self.count = value
                            self.count.value_namespace = name_space
                            self.count.value_namespace_prefix = name_space_prefix
                        if(value_path == "data"):
                            self.data = value
                            self.data.value_namespace = name_space
                            self.data.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix


                class ElementArray(Entity):
                    """
                    Element Array
                    
                    .. attribute:: block_array
                    
                    	block array
                    	**type**\: list of    :py:class:`BlockArray <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray.BlockArray>`
                    
                    .. attribute:: key
                    
                    	key
                    	**type**\:  str
                    
                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray, self).__init__()

                        self.yang_name = "element-array"
                        self.yang_parent_name = "l2-interface-statistics"

                        self.key = YLeaf(YType.str, "key")

                        self.block_array = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("key") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray, self).__setattr__(name, value)


                    class BlockArray(Entity):
                        """
                        block array
                        
                        .. attribute:: count
                        
                        	count
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: data
                        
                        	data
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: type
                        
                        	type
                        	**type**\:   :py:class:`StatsCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.StatsCounter>`
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray.BlockArray, self).__init__()

                            self.yang_name = "block-array"
                            self.yang_parent_name = "element-array"

                            self.count = YLeaf(YType.uint32, "count")

                            self.data = YLeaf(YType.str, "data")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("count",
                                            "data",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray.BlockArray, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray.BlockArray, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.count.is_set or
                                self.data.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.count.yfilter != YFilter.not_set or
                                self.data.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "block-array" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.count.is_set or self.count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.count.get_name_leafdata())
                            if (self.data.is_set or self.data.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.data.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "count" or name == "data" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "count"):
                                self.count = value
                                self.count.value_namespace = name_space
                                self.count.value_namespace_prefix = name_space_prefix
                            if(value_path == "data"):
                                self.data = value
                                self.data.value_namespace = name_space
                                self.data.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.block_array:
                            if (c.has_data()):
                                return True
                        return self.key.is_set

                    def has_operation(self):
                        for c in self.block_array:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.key.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "element-array" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.key.is_set or self.key.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.key.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "block-array"):
                            for c in self.block_array:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray.BlockArray()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.block_array.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "block-array" or name == "key"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "key"):
                            self.key = value
                            self.key.value_namespace = name_space
                            self.key.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.block_array:
                        if (c.has_data()):
                            return True
                    for c in self.element_array:
                        if (c.has_data()):
                            return True
                    return (
                        self.contents.is_set or
                        self.stats_type.is_set or
                        (self.stats_id is not None and self.stats_id.has_data()))

                def has_operation(self):
                    for c in self.block_array:
                        if (c.has_operation()):
                            return True
                    for c in self.element_array:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.contents.yfilter != YFilter.not_set or
                        self.stats_type.yfilter != YFilter.not_set or
                        (self.stats_id is not None and self.stats_id.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "l2-interface-statistics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.contents.is_set or self.contents.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.contents.get_name_leafdata())
                    if (self.stats_type.is_set or self.stats_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.stats_type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "block-array"):
                        for c in self.block_array:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.BlockArray()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.block_array.append(c)
                        return c

                    if (child_yang_name == "element-array"):
                        for c in self.element_array:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.ElementArray()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.element_array.append(c)
                        return c

                    if (child_yang_name == "stats-id"):
                        if (self.stats_id is None):
                            self.stats_id = Interfaces.InterfaceXr.Interface.L2InterfaceStatistics.StatsId()
                            self.stats_id.parent = self
                            self._children_name_map["stats_id"] = "stats-id"
                        return self.stats_id

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "block-array" or name == "element-array" or name == "stats-id" or name == "contents" or name == "stats-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "contents"):
                        self.contents = value
                        self.contents.value_namespace = name_space
                        self.contents.value_namespace_prefix = name_space_prefix
                    if(value_path == "stats-type"):
                        self.stats_type = value
                        self.stats_type.value_namespace = name_space
                        self.stats_type.value_namespace_prefix = name_space_prefix


            class NvOptical(Entity):
                """
                nV Optical Controller Information
                
                .. attribute:: controller
                
                	Controller that nV controller maps to
                	**type**\:  str
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceXr.Interface.NvOptical, self).__init__()

                    self.yang_name = "nv-optical"
                    self.yang_parent_name = "interface"

                    self.controller = YLeaf(YType.str, "controller")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("controller") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceXr.Interface.NvOptical, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceXr.Interface.NvOptical, self).__setattr__(name, value)

                def has_data(self):
                    return self.controller.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.controller.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nv-optical" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.controller.is_set or self.controller.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.controller.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "controller"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "controller"):
                        self.controller = value
                        self.controller.value_namespace = name_space
                        self.controller.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.interface_name.is_set or
                    self.bandwidth.is_set or
                    self.crc_length.is_set or
                    self.description.is_set or
                    self.duplexity.is_set or
                    self.encapsulation.is_set or
                    self.encapsulation_type_string.is_set or
                    self.hardware_type_string.is_set or
                    self.if_index.is_set or
                    self.in_flow_control.is_set or
                    self.interface_handle.is_set or
                    self.interface_type.is_set or
                    self.is_dampening_enabled.is_set or
                    self.is_data_inverted.is_set or
                    self.is_l2_looped.is_set or
                    self.is_l2_transport_enabled.is_set or
                    self.is_maintenance_enabled.is_set or
                    self.is_scramble_enabled.is_set or
                    self.keepalive.is_set or
                    self.last_state_transition_time.is_set or
                    self.line_state.is_set or
                    self.link_type.is_set or
                    self.loopback_configuration.is_set or
                    self.max_bandwidth.is_set or
                    self.media_type.is_set or
                    self.mtu.is_set or
                    self.out_flow_control.is_set or
                    self.parent_interface_name.is_set or
                    self.speed.is_set or
                    self.state.is_set or
                    self.state_transition_count.is_set or
                    self.transport_mode.is_set or
                    (self.arp_information is not None and self.arp_information.has_data()) or
                    (self.burned_in_address is not None and self.burned_in_address.has_data()) or
                    (self.carrier_delay is not None and self.carrier_delay.has_data()) or
                    (self.dampening_information is not None and self.dampening_information.has_data()) or
                    (self.data_rates is not None and self.data_rates.has_data()) or
                    (self.encapsulation_information is not None and self.encapsulation_information.has_data()) or
                    (self.interface_statistics is not None and self.interface_statistics.has_data()) or
                    (self.interface_type_information is not None and self.interface_type_information.has_data()) or
                    (self.ip_information is not None and self.ip_information.has_data()) or
                    (self.l2_interface_statistics is not None and self.l2_interface_statistics.has_data()) or
                    (self.mac_address is not None and self.mac_address.has_data()) or
                    (self.nv_optical is not None and self.nv_optical.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.bandwidth.yfilter != YFilter.not_set or
                    self.crc_length.yfilter != YFilter.not_set or
                    self.description.yfilter != YFilter.not_set or
                    self.duplexity.yfilter != YFilter.not_set or
                    self.encapsulation.yfilter != YFilter.not_set or
                    self.encapsulation_type_string.yfilter != YFilter.not_set or
                    self.hardware_type_string.yfilter != YFilter.not_set or
                    self.if_index.yfilter != YFilter.not_set or
                    self.in_flow_control.yfilter != YFilter.not_set or
                    self.interface_handle.yfilter != YFilter.not_set or
                    self.interface_type.yfilter != YFilter.not_set or
                    self.is_dampening_enabled.yfilter != YFilter.not_set or
                    self.is_data_inverted.yfilter != YFilter.not_set or
                    self.is_l2_looped.yfilter != YFilter.not_set or
                    self.is_l2_transport_enabled.yfilter != YFilter.not_set or
                    self.is_maintenance_enabled.yfilter != YFilter.not_set or
                    self.is_scramble_enabled.yfilter != YFilter.not_set or
                    self.keepalive.yfilter != YFilter.not_set or
                    self.last_state_transition_time.yfilter != YFilter.not_set or
                    self.line_state.yfilter != YFilter.not_set or
                    self.link_type.yfilter != YFilter.not_set or
                    self.loopback_configuration.yfilter != YFilter.not_set or
                    self.max_bandwidth.yfilter != YFilter.not_set or
                    self.media_type.yfilter != YFilter.not_set or
                    self.mtu.yfilter != YFilter.not_set or
                    self.out_flow_control.yfilter != YFilter.not_set or
                    self.parent_interface_name.yfilter != YFilter.not_set or
                    self.speed.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.state_transition_count.yfilter != YFilter.not_set or
                    self.transport_mode.yfilter != YFilter.not_set or
                    (self.arp_information is not None and self.arp_information.has_operation()) or
                    (self.burned_in_address is not None and self.burned_in_address.has_operation()) or
                    (self.carrier_delay is not None and self.carrier_delay.has_operation()) or
                    (self.dampening_information is not None and self.dampening_information.has_operation()) or
                    (self.data_rates is not None and self.data_rates.has_operation()) or
                    (self.encapsulation_information is not None and self.encapsulation_information.has_operation()) or
                    (self.interface_statistics is not None and self.interface_statistics.has_operation()) or
                    (self.interface_type_information is not None and self.interface_type_information.has_operation()) or
                    (self.ip_information is not None and self.ip_information.has_operation()) or
                    (self.l2_interface_statistics is not None and self.l2_interface_statistics.has_operation()) or
                    (self.mac_address is not None and self.mac_address.has_operation()) or
                    (self.nv_optical is not None and self.nv_optical.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/interface-xr/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.bandwidth.get_name_leafdata())
                if (self.crc_length.is_set or self.crc_length.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.crc_length.get_name_leafdata())
                if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.description.get_name_leafdata())
                if (self.duplexity.is_set or self.duplexity.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.duplexity.get_name_leafdata())
                if (self.encapsulation.is_set or self.encapsulation.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.encapsulation.get_name_leafdata())
                if (self.encapsulation_type_string.is_set or self.encapsulation_type_string.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.encapsulation_type_string.get_name_leafdata())
                if (self.hardware_type_string.is_set or self.hardware_type_string.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.hardware_type_string.get_name_leafdata())
                if (self.if_index.is_set or self.if_index.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.if_index.get_name_leafdata())
                if (self.in_flow_control.is_set or self.in_flow_control.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.in_flow_control.get_name_leafdata())
                if (self.interface_handle.is_set or self.interface_handle.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_handle.get_name_leafdata())
                if (self.interface_type.is_set or self.interface_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_type.get_name_leafdata())
                if (self.is_dampening_enabled.is_set or self.is_dampening_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_dampening_enabled.get_name_leafdata())
                if (self.is_data_inverted.is_set or self.is_data_inverted.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_data_inverted.get_name_leafdata())
                if (self.is_l2_looped.is_set or self.is_l2_looped.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_l2_looped.get_name_leafdata())
                if (self.is_l2_transport_enabled.is_set or self.is_l2_transport_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_l2_transport_enabled.get_name_leafdata())
                if (self.is_maintenance_enabled.is_set or self.is_maintenance_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_maintenance_enabled.get_name_leafdata())
                if (self.is_scramble_enabled.is_set or self.is_scramble_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_scramble_enabled.get_name_leafdata())
                if (self.keepalive.is_set or self.keepalive.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.keepalive.get_name_leafdata())
                if (self.last_state_transition_time.is_set or self.last_state_transition_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_state_transition_time.get_name_leafdata())
                if (self.line_state.is_set or self.line_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.line_state.get_name_leafdata())
                if (self.link_type.is_set or self.link_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.link_type.get_name_leafdata())
                if (self.loopback_configuration.is_set or self.loopback_configuration.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.loopback_configuration.get_name_leafdata())
                if (self.max_bandwidth.is_set or self.max_bandwidth.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_bandwidth.get_name_leafdata())
                if (self.media_type.is_set or self.media_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.media_type.get_name_leafdata())
                if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.mtu.get_name_leafdata())
                if (self.out_flow_control.is_set or self.out_flow_control.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.out_flow_control.get_name_leafdata())
                if (self.parent_interface_name.is_set or self.parent_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.parent_interface_name.get_name_leafdata())
                if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.speed.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.state_transition_count.is_set or self.state_transition_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state_transition_count.get_name_leafdata())
                if (self.transport_mode.is_set or self.transport_mode.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.transport_mode.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "arp-information"):
                    if (self.arp_information is None):
                        self.arp_information = Interfaces.InterfaceXr.Interface.ArpInformation()
                        self.arp_information.parent = self
                        self._children_name_map["arp_information"] = "arp-information"
                    return self.arp_information

                if (child_yang_name == "burned-in-address"):
                    if (self.burned_in_address is None):
                        self.burned_in_address = Interfaces.InterfaceXr.Interface.BurnedInAddress()
                        self.burned_in_address.parent = self
                        self._children_name_map["burned_in_address"] = "burned-in-address"
                    return self.burned_in_address

                if (child_yang_name == "carrier-delay"):
                    if (self.carrier_delay is None):
                        self.carrier_delay = Interfaces.InterfaceXr.Interface.CarrierDelay()
                        self.carrier_delay.parent = self
                        self._children_name_map["carrier_delay"] = "carrier-delay"
                    return self.carrier_delay

                if (child_yang_name == "dampening-information"):
                    if (self.dampening_information is None):
                        self.dampening_information = Interfaces.InterfaceXr.Interface.DampeningInformation()
                        self.dampening_information.parent = self
                        self._children_name_map["dampening_information"] = "dampening-information"
                    return self.dampening_information

                if (child_yang_name == "data-rates"):
                    if (self.data_rates is None):
                        self.data_rates = Interfaces.InterfaceXr.Interface.DataRates()
                        self.data_rates.parent = self
                        self._children_name_map["data_rates"] = "data-rates"
                    return self.data_rates

                if (child_yang_name == "encapsulation-information"):
                    if (self.encapsulation_information is None):
                        self.encapsulation_information = Interfaces.InterfaceXr.Interface.EncapsulationInformation()
                        self.encapsulation_information.parent = self
                        self._children_name_map["encapsulation_information"] = "encapsulation-information"
                    return self.encapsulation_information

                if (child_yang_name == "interface-statistics"):
                    if (self.interface_statistics is None):
                        self.interface_statistics = Interfaces.InterfaceXr.Interface.InterfaceStatistics()
                        self.interface_statistics.parent = self
                        self._children_name_map["interface_statistics"] = "interface-statistics"
                    return self.interface_statistics

                if (child_yang_name == "interface-type-information"):
                    if (self.interface_type_information is None):
                        self.interface_type_information = Interfaces.InterfaceXr.Interface.InterfaceTypeInformation()
                        self.interface_type_information.parent = self
                        self._children_name_map["interface_type_information"] = "interface-type-information"
                    return self.interface_type_information

                if (child_yang_name == "ip-information"):
                    if (self.ip_information is None):
                        self.ip_information = Interfaces.InterfaceXr.Interface.IpInformation()
                        self.ip_information.parent = self
                        self._children_name_map["ip_information"] = "ip-information"
                    return self.ip_information

                if (child_yang_name == "l2-interface-statistics"):
                    if (self.l2_interface_statistics is None):
                        self.l2_interface_statistics = Interfaces.InterfaceXr.Interface.L2InterfaceStatistics()
                        self.l2_interface_statistics.parent = self
                        self._children_name_map["l2_interface_statistics"] = "l2-interface-statistics"
                    return self.l2_interface_statistics

                if (child_yang_name == "mac-address"):
                    if (self.mac_address is None):
                        self.mac_address = Interfaces.InterfaceXr.Interface.MacAddress()
                        self.mac_address.parent = self
                        self._children_name_map["mac_address"] = "mac-address"
                    return self.mac_address

                if (child_yang_name == "nv-optical"):
                    if (self.nv_optical is None):
                        self.nv_optical = Interfaces.InterfaceXr.Interface.NvOptical()
                        self.nv_optical.parent = self
                        self._children_name_map["nv_optical"] = "nv-optical"
                    return self.nv_optical

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "arp-information" or name == "burned-in-address" or name == "carrier-delay" or name == "dampening-information" or name == "data-rates" or name == "encapsulation-information" or name == "interface-statistics" or name == "interface-type-information" or name == "ip-information" or name == "l2-interface-statistics" or name == "mac-address" or name == "nv-optical" or name == "interface-name" or name == "bandwidth" or name == "crc-length" or name == "description" or name == "duplexity" or name == "encapsulation" or name == "encapsulation-type-string" or name == "hardware-type-string" or name == "if-index" or name == "in-flow-control" or name == "interface-handle" or name == "interface-type" or name == "is-dampening-enabled" or name == "is-data-inverted" or name == "is-l2-looped" or name == "is-l2-transport-enabled" or name == "is-maintenance-enabled" or name == "is-scramble-enabled" or name == "keepalive" or name == "last-state-transition-time" or name == "line-state" or name == "link-type" or name == "loopback-configuration" or name == "max-bandwidth" or name == "media-type" or name == "mtu" or name == "out-flow-control" or name == "parent-interface-name" or name == "speed" or name == "state" or name == "state-transition-count" or name == "transport-mode"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "bandwidth"):
                    self.bandwidth = value
                    self.bandwidth.value_namespace = name_space
                    self.bandwidth.value_namespace_prefix = name_space_prefix
                if(value_path == "crc-length"):
                    self.crc_length = value
                    self.crc_length.value_namespace = name_space
                    self.crc_length.value_namespace_prefix = name_space_prefix
                if(value_path == "description"):
                    self.description = value
                    self.description.value_namespace = name_space
                    self.description.value_namespace_prefix = name_space_prefix
                if(value_path == "duplexity"):
                    self.duplexity = value
                    self.duplexity.value_namespace = name_space
                    self.duplexity.value_namespace_prefix = name_space_prefix
                if(value_path == "encapsulation"):
                    self.encapsulation = value
                    self.encapsulation.value_namespace = name_space
                    self.encapsulation.value_namespace_prefix = name_space_prefix
                if(value_path == "encapsulation-type-string"):
                    self.encapsulation_type_string = value
                    self.encapsulation_type_string.value_namespace = name_space
                    self.encapsulation_type_string.value_namespace_prefix = name_space_prefix
                if(value_path == "hardware-type-string"):
                    self.hardware_type_string = value
                    self.hardware_type_string.value_namespace = name_space
                    self.hardware_type_string.value_namespace_prefix = name_space_prefix
                if(value_path == "if-index"):
                    self.if_index = value
                    self.if_index.value_namespace = name_space
                    self.if_index.value_namespace_prefix = name_space_prefix
                if(value_path == "in-flow-control"):
                    self.in_flow_control = value
                    self.in_flow_control.value_namespace = name_space
                    self.in_flow_control.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-handle"):
                    self.interface_handle = value
                    self.interface_handle.value_namespace = name_space
                    self.interface_handle.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-type"):
                    self.interface_type = value
                    self.interface_type.value_namespace = name_space
                    self.interface_type.value_namespace_prefix = name_space_prefix
                if(value_path == "is-dampening-enabled"):
                    self.is_dampening_enabled = value
                    self.is_dampening_enabled.value_namespace = name_space
                    self.is_dampening_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-data-inverted"):
                    self.is_data_inverted = value
                    self.is_data_inverted.value_namespace = name_space
                    self.is_data_inverted.value_namespace_prefix = name_space_prefix
                if(value_path == "is-l2-looped"):
                    self.is_l2_looped = value
                    self.is_l2_looped.value_namespace = name_space
                    self.is_l2_looped.value_namespace_prefix = name_space_prefix
                if(value_path == "is-l2-transport-enabled"):
                    self.is_l2_transport_enabled = value
                    self.is_l2_transport_enabled.value_namespace = name_space
                    self.is_l2_transport_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-maintenance-enabled"):
                    self.is_maintenance_enabled = value
                    self.is_maintenance_enabled.value_namespace = name_space
                    self.is_maintenance_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "is-scramble-enabled"):
                    self.is_scramble_enabled = value
                    self.is_scramble_enabled.value_namespace = name_space
                    self.is_scramble_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "keepalive"):
                    self.keepalive = value
                    self.keepalive.value_namespace = name_space
                    self.keepalive.value_namespace_prefix = name_space_prefix
                if(value_path == "last-state-transition-time"):
                    self.last_state_transition_time = value
                    self.last_state_transition_time.value_namespace = name_space
                    self.last_state_transition_time.value_namespace_prefix = name_space_prefix
                if(value_path == "line-state"):
                    self.line_state = value
                    self.line_state.value_namespace = name_space
                    self.line_state.value_namespace_prefix = name_space_prefix
                if(value_path == "link-type"):
                    self.link_type = value
                    self.link_type.value_namespace = name_space
                    self.link_type.value_namespace_prefix = name_space_prefix
                if(value_path == "loopback-configuration"):
                    self.loopback_configuration = value
                    self.loopback_configuration.value_namespace = name_space
                    self.loopback_configuration.value_namespace_prefix = name_space_prefix
                if(value_path == "max-bandwidth"):
                    self.max_bandwidth = value
                    self.max_bandwidth.value_namespace = name_space
                    self.max_bandwidth.value_namespace_prefix = name_space_prefix
                if(value_path == "media-type"):
                    self.media_type = value
                    self.media_type.value_namespace = name_space
                    self.media_type.value_namespace_prefix = name_space_prefix
                if(value_path == "mtu"):
                    self.mtu = value
                    self.mtu.value_namespace = name_space
                    self.mtu.value_namespace_prefix = name_space_prefix
                if(value_path == "out-flow-control"):
                    self.out_flow_control = value
                    self.out_flow_control.value_namespace = name_space
                    self.out_flow_control.value_namespace_prefix = name_space_prefix
                if(value_path == "parent-interface-name"):
                    self.parent_interface_name = value
                    self.parent_interface_name.value_namespace = name_space
                    self.parent_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "speed"):
                    self.speed = value
                    self.speed.value_namespace = name_space
                    self.speed.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "state-transition-count"):
                    self.state_transition_count = value
                    self.state_transition_count.value_namespace = name_space
                    self.state_transition_count.value_namespace_prefix = name_space_prefix
                if(value_path == "transport-mode"):
                    self.transport_mode = value
                    self.transport_mode.value_namespace = name_space
                    self.transport_mode.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.interface:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.interface:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "interface-xr" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interface"):
                for c in self.interface:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Interfaces.InterfaceXr.Interface()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.interface.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interface"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class NodeTypeSets(Entity):
        """
        Node and/or interface type specific view of
        interface summary data
        
        .. attribute:: node_type_set
        
        	Summary data for all interfaces on a particular node
        	**type**\: list of    :py:class:`NodeTypeSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.NodeTypeSets.NodeTypeSet>`
        
        

        """

        _prefix = 'pfi-im-cmd-oper'
        _revision = '2016-12-18'

        def __init__(self):
            super(Interfaces.NodeTypeSets, self).__init__()

            self.yang_name = "node-type-sets"
            self.yang_parent_name = "interfaces"

            self.node_type_set = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Interfaces.NodeTypeSets, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Interfaces.NodeTypeSets, self).__setattr__(name, value)


        class NodeTypeSet(Entity):
            """
            Summary data for all interfaces on a particular
            node
            
            .. attribute:: interface_summary
            
            	Interface summary information
            	**type**\:   :py:class:`InterfaceSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary>`
            
            .. attribute:: node_name
            
            	The location to filter on
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: type_set_name
            
            	The interface type to filter on
            	**type**\:   :py:class:`InterfaceTypeSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.InterfaceTypeSet>`
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.NodeTypeSets.NodeTypeSet, self).__init__()

                self.yang_name = "node-type-set"
                self.yang_parent_name = "node-type-sets"

                self.node_name = YLeaf(YType.str, "node-name")

                self.type_set_name = YLeaf(YType.enumeration, "type-set-name")

                self.interface_summary = Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary()
                self.interface_summary.parent = self
                self._children_name_map["interface_summary"] = "interface-summary"
                self._children_yang_names.add("interface-summary")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_name",
                                "type_set_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.NodeTypeSets.NodeTypeSet, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.NodeTypeSets.NodeTypeSet, self).__setattr__(name, value)


            class InterfaceSummary(Entity):
                """
                Interface summary information
                
                .. attribute:: interface_counts
                
                	Counts for all interfaces
                	**type**\:   :py:class:`InterfaceCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceCounts>`
                
                .. attribute:: interface_type
                
                	List of per interface type summary information
                	**type**\: list of    :py:class:`InterfaceType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType>`
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary, self).__init__()

                    self.yang_name = "interface-summary"
                    self.yang_parent_name = "node-type-set"

                    self.interface_counts = Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceCounts()
                    self.interface_counts.parent = self
                    self._children_name_map["interface_counts"] = "interface-counts"
                    self._children_yang_names.add("interface-counts")

                    self.interface_type = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary, self).__setattr__(name, value)


                class InterfaceCounts(Entity):
                    """
                    Counts for all interfaces
                    
                    .. attribute:: admin_down_interface_count
                    
                    	Number of interfaces in an ADMINDOWN state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: down_interface_count
                    
                    	Number of interfaces in DOWN state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_count
                    
                    	Number of interfaces
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: up_interface_count
                    
                    	Number of interfaces in UP state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceCounts, self).__init__()

                        self.yang_name = "interface-counts"
                        self.yang_parent_name = "interface-summary"

                        self.admin_down_interface_count = YLeaf(YType.uint32, "admin-down-interface-count")

                        self.down_interface_count = YLeaf(YType.uint32, "down-interface-count")

                        self.interface_count = YLeaf(YType.uint32, "interface-count")

                        self.up_interface_count = YLeaf(YType.uint32, "up-interface-count")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("admin_down_interface_count",
                                        "down_interface_count",
                                        "interface_count",
                                        "up_interface_count") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceCounts, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceCounts, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.admin_down_interface_count.is_set or
                            self.down_interface_count.is_set or
                            self.interface_count.is_set or
                            self.up_interface_count.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.admin_down_interface_count.yfilter != YFilter.not_set or
                            self.down_interface_count.yfilter != YFilter.not_set or
                            self.interface_count.yfilter != YFilter.not_set or
                            self.up_interface_count.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface-counts" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/node-type-sets/node-type-set/interface-summary/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.admin_down_interface_count.is_set or self.admin_down_interface_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_down_interface_count.get_name_leafdata())
                        if (self.down_interface_count.is_set or self.down_interface_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.down_interface_count.get_name_leafdata())
                        if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_count.get_name_leafdata())
                        if (self.up_interface_count.is_set or self.up_interface_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.up_interface_count.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "admin-down-interface-count" or name == "down-interface-count" or name == "interface-count" or name == "up-interface-count"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "admin-down-interface-count"):
                            self.admin_down_interface_count = value
                            self.admin_down_interface_count.value_namespace = name_space
                            self.admin_down_interface_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "down-interface-count"):
                            self.down_interface_count = value
                            self.down_interface_count.value_namespace = name_space
                            self.down_interface_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-count"):
                            self.interface_count = value
                            self.interface_count.value_namespace = name_space
                            self.interface_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "up-interface-count"):
                            self.up_interface_count = value
                            self.up_interface_count.value_namespace = name_space
                            self.up_interface_count.value_namespace_prefix = name_space_prefix


                class InterfaceType(Entity):
                    """
                    List of per interface type summary information
                    
                    .. attribute:: interface_counts
                    
                    	Counts for interfaces of this type
                    	**type**\:   :py:class:`InterfaceCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType.InterfaceCounts>`
                    
                    .. attribute:: interface_type_description
                    
                    	Description of the interface type
                    	**type**\:  str
                    
                    .. attribute:: interface_type_name
                    
                    	Name of the interface type
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'pfi-im-cmd-oper'
                    _revision = '2016-12-18'

                    def __init__(self):
                        super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType, self).__init__()

                        self.yang_name = "interface-type"
                        self.yang_parent_name = "interface-summary"

                        self.interface_type_description = YLeaf(YType.str, "interface-type-description")

                        self.interface_type_name = YLeaf(YType.str, "interface-type-name")

                        self.interface_counts = Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType.InterfaceCounts()
                        self.interface_counts.parent = self
                        self._children_name_map["interface_counts"] = "interface-counts"
                        self._children_yang_names.add("interface-counts")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_type_description",
                                        "interface_type_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType, self).__setattr__(name, value)


                    class InterfaceCounts(Entity):
                        """
                        Counts for interfaces of this type
                        
                        .. attribute:: admin_down_interface_count
                        
                        	Number of interfaces in an ADMINDOWN state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: down_interface_count
                        
                        	Number of interfaces in DOWN state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: interface_count
                        
                        	Number of interfaces
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: up_interface_count
                        
                        	Number of interfaces in UP state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'pfi-im-cmd-oper'
                        _revision = '2016-12-18'

                        def __init__(self):
                            super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType.InterfaceCounts, self).__init__()

                            self.yang_name = "interface-counts"
                            self.yang_parent_name = "interface-type"

                            self.admin_down_interface_count = YLeaf(YType.uint32, "admin-down-interface-count")

                            self.down_interface_count = YLeaf(YType.uint32, "down-interface-count")

                            self.interface_count = YLeaf(YType.uint32, "interface-count")

                            self.up_interface_count = YLeaf(YType.uint32, "up-interface-count")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("admin_down_interface_count",
                                            "down_interface_count",
                                            "interface_count",
                                            "up_interface_count") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType.InterfaceCounts, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType.InterfaceCounts, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.admin_down_interface_count.is_set or
                                self.down_interface_count.is_set or
                                self.interface_count.is_set or
                                self.up_interface_count.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.admin_down_interface_count.yfilter != YFilter.not_set or
                                self.down_interface_count.yfilter != YFilter.not_set or
                                self.interface_count.yfilter != YFilter.not_set or
                                self.up_interface_count.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "interface-counts" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/node-type-sets/node-type-set/interface-summary/interface-type/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.admin_down_interface_count.is_set or self.admin_down_interface_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.admin_down_interface_count.get_name_leafdata())
                            if (self.down_interface_count.is_set or self.down_interface_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.down_interface_count.get_name_leafdata())
                            if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_count.get_name_leafdata())
                            if (self.up_interface_count.is_set or self.up_interface_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.up_interface_count.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "admin-down-interface-count" or name == "down-interface-count" or name == "interface-count" or name == "up-interface-count"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "admin-down-interface-count"):
                                self.admin_down_interface_count = value
                                self.admin_down_interface_count.value_namespace = name_space
                                self.admin_down_interface_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "down-interface-count"):
                                self.down_interface_count = value
                                self.down_interface_count.value_namespace = name_space
                                self.down_interface_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface-count"):
                                self.interface_count = value
                                self.interface_count.value_namespace = name_space
                                self.interface_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "up-interface-count"):
                                self.up_interface_count = value
                                self.up_interface_count.value_namespace = name_space
                                self.up_interface_count.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.interface_type_description.is_set or
                            self.interface_type_name.is_set or
                            (self.interface_counts is not None and self.interface_counts.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_type_description.yfilter != YFilter.not_set or
                            self.interface_type_name.yfilter != YFilter.not_set or
                            (self.interface_counts is not None and self.interface_counts.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface-type" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/node-type-sets/node-type-set/interface-summary/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_type_description.is_set or self.interface_type_description.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_type_description.get_name_leafdata())
                        if (self.interface_type_name.is_set or self.interface_type_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_type_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "interface-counts"):
                            if (self.interface_counts is None):
                                self.interface_counts = Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType.InterfaceCounts()
                                self.interface_counts.parent = self
                                self._children_name_map["interface_counts"] = "interface-counts"
                            return self.interface_counts

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface-counts" or name == "interface-type-description" or name == "interface-type-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-type-description"):
                            self.interface_type_description = value
                            self.interface_type_description.value_namespace = name_space
                            self.interface_type_description.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-type-name"):
                            self.interface_type_name = value
                            self.interface_type_name.value_namespace = name_space
                            self.interface_type_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.interface_type:
                        if (c.has_data()):
                            return True
                    return (self.interface_counts is not None and self.interface_counts.has_data())

                def has_operation(self):
                    for c in self.interface_type:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.interface_counts is not None and self.interface_counts.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-summary" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/node-type-sets/node-type-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface-counts"):
                        if (self.interface_counts is None):
                            self.interface_counts = Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceCounts()
                            self.interface_counts.parent = self
                            self._children_name_map["interface_counts"] = "interface-counts"
                        return self.interface_counts

                    if (child_yang_name == "interface-type"):
                        for c in self.interface_type:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary.InterfaceType()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.interface_type.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-counts" or name == "interface-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.node_name.is_set or
                    self.type_set_name.is_set or
                    (self.interface_summary is not None and self.interface_summary.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_name.yfilter != YFilter.not_set or
                    self.type_set_name.yfilter != YFilter.not_set or
                    (self.interface_summary is not None and self.interface_summary.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node-type-set" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/node-type-sets/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_name.get_name_leafdata())
                if (self.type_set_name.is_set or self.type_set_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.type_set_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interface-summary"):
                    if (self.interface_summary is None):
                        self.interface_summary = Interfaces.NodeTypeSets.NodeTypeSet.InterfaceSummary()
                        self.interface_summary.parent = self
                        self._children_name_map["interface_summary"] = "interface-summary"
                    return self.interface_summary

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface-summary" or name == "node-name" or name == "type-set-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-name"):
                    self.node_name = value
                    self.node_name.value_namespace = name_space
                    self.node_name.value_namespace_prefix = name_space_prefix
                if(value_path == "type-set-name"):
                    self.type_set_name = value
                    self.type_set_name.value_namespace = name_space
                    self.type_set_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node_type_set:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node_type_set:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "node-type-sets" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node-type-set"):
                for c in self.node_type_set:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Interfaces.NodeTypeSets.NodeTypeSet()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node_type_set.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node-type-set"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class InterfaceBriefs(Entity):
        """
        Brief operational data for interfaces
        
        .. attribute:: interface_brief
        
        	Brief operational attributes for a particular interface
        	**type**\: list of    :py:class:`InterfaceBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceBriefs.InterfaceBrief>`
        
        

        """

        _prefix = 'pfi-im-cmd-oper'
        _revision = '2016-12-18'

        def __init__(self):
            super(Interfaces.InterfaceBriefs, self).__init__()

            self.yang_name = "interface-briefs"
            self.yang_parent_name = "interfaces"

            self.interface_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Interfaces.InterfaceBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Interfaces.InterfaceBriefs, self).__setattr__(name, value)


        class InterfaceBrief(Entity):
            """
            Brief operational attributes for a particular
            interface
            
            .. attribute:: interface_name  <key>
            
            	The name of the interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: actual_line_state
            
            	Line protocol state with no translation of error disable or shutdown
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            .. attribute:: actual_state
            
            	Operational state with no translation of error disable or shutdown
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            .. attribute:: bandwidth
            
            	Interface bandwidth (Kb/s)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: encapsulation
            
            	Interface encapsulation
            	**type**\:  str
            
            .. attribute:: encapsulation_type_string
            
            	Interface encapsulation description string
            	**type**\:  str
            
            	**length:** 0..32
            
            .. attribute:: interface
            
            	Interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: l2_transport
            
            	L2 transport
            	**type**\:  bool
            
            .. attribute:: line_state
            
            	Line protocol state
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            .. attribute:: mtu
            
            	MTU in bytes
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: byte
            
            .. attribute:: parent_interface
            
            	Parent Interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: state
            
            	Operational state
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            .. attribute:: sub_interface_mtu_overhead
            
            	Subif MTU overhead
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: type
            
            	Interface type
            	**type**\:  str
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.InterfaceBriefs.InterfaceBrief, self).__init__()

                self.yang_name = "interface-brief"
                self.yang_parent_name = "interface-briefs"

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.actual_line_state = YLeaf(YType.enumeration, "actual-line-state")

                self.actual_state = YLeaf(YType.enumeration, "actual-state")

                self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                self.encapsulation = YLeaf(YType.str, "encapsulation")

                self.encapsulation_type_string = YLeaf(YType.str, "encapsulation-type-string")

                self.interface = YLeaf(YType.str, "interface")

                self.l2_transport = YLeaf(YType.boolean, "l2-transport")

                self.line_state = YLeaf(YType.enumeration, "line-state")

                self.mtu = YLeaf(YType.uint32, "mtu")

                self.parent_interface = YLeaf(YType.str, "parent-interface")

                self.state = YLeaf(YType.enumeration, "state")

                self.sub_interface_mtu_overhead = YLeaf(YType.uint32, "sub-interface-mtu-overhead")

                self.type = YLeaf(YType.str, "type")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface_name",
                                "actual_line_state",
                                "actual_state",
                                "bandwidth",
                                "encapsulation",
                                "encapsulation_type_string",
                                "interface",
                                "l2_transport",
                                "line_state",
                                "mtu",
                                "parent_interface",
                                "state",
                                "sub_interface_mtu_overhead",
                                "type") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.InterfaceBriefs.InterfaceBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.InterfaceBriefs.InterfaceBrief, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.interface_name.is_set or
                    self.actual_line_state.is_set or
                    self.actual_state.is_set or
                    self.bandwidth.is_set or
                    self.encapsulation.is_set or
                    self.encapsulation_type_string.is_set or
                    self.interface.is_set or
                    self.l2_transport.is_set or
                    self.line_state.is_set or
                    self.mtu.is_set or
                    self.parent_interface.is_set or
                    self.state.is_set or
                    self.sub_interface_mtu_overhead.is_set or
                    self.type.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.actual_line_state.yfilter != YFilter.not_set or
                    self.actual_state.yfilter != YFilter.not_set or
                    self.bandwidth.yfilter != YFilter.not_set or
                    self.encapsulation.yfilter != YFilter.not_set or
                    self.encapsulation_type_string.yfilter != YFilter.not_set or
                    self.interface.yfilter != YFilter.not_set or
                    self.l2_transport.yfilter != YFilter.not_set or
                    self.line_state.yfilter != YFilter.not_set or
                    self.mtu.yfilter != YFilter.not_set or
                    self.parent_interface.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.sub_interface_mtu_overhead.yfilter != YFilter.not_set or
                    self.type.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface-brief" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/interface-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.actual_line_state.is_set or self.actual_line_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.actual_line_state.get_name_leafdata())
                if (self.actual_state.is_set or self.actual_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.actual_state.get_name_leafdata())
                if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.bandwidth.get_name_leafdata())
                if (self.encapsulation.is_set or self.encapsulation.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.encapsulation.get_name_leafdata())
                if (self.encapsulation_type_string.is_set or self.encapsulation_type_string.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.encapsulation_type_string.get_name_leafdata())
                if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface.get_name_leafdata())
                if (self.l2_transport.is_set or self.l2_transport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.l2_transport.get_name_leafdata())
                if (self.line_state.is_set or self.line_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.line_state.get_name_leafdata())
                if (self.mtu.is_set or self.mtu.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.mtu.get_name_leafdata())
                if (self.parent_interface.is_set or self.parent_interface.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.parent_interface.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.sub_interface_mtu_overhead.is_set or self.sub_interface_mtu_overhead.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sub_interface_mtu_overhead.get_name_leafdata())
                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.type.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface-name" or name == "actual-line-state" or name == "actual-state" or name == "bandwidth" or name == "encapsulation" or name == "encapsulation-type-string" or name == "interface" or name == "l2-transport" or name == "line-state" or name == "mtu" or name == "parent-interface" or name == "state" or name == "sub-interface-mtu-overhead" or name == "type"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "actual-line-state"):
                    self.actual_line_state = value
                    self.actual_line_state.value_namespace = name_space
                    self.actual_line_state.value_namespace_prefix = name_space_prefix
                if(value_path == "actual-state"):
                    self.actual_state = value
                    self.actual_state.value_namespace = name_space
                    self.actual_state.value_namespace_prefix = name_space_prefix
                if(value_path == "bandwidth"):
                    self.bandwidth = value
                    self.bandwidth.value_namespace = name_space
                    self.bandwidth.value_namespace_prefix = name_space_prefix
                if(value_path == "encapsulation"):
                    self.encapsulation = value
                    self.encapsulation.value_namespace = name_space
                    self.encapsulation.value_namespace_prefix = name_space_prefix
                if(value_path == "encapsulation-type-string"):
                    self.encapsulation_type_string = value
                    self.encapsulation_type_string.value_namespace = name_space
                    self.encapsulation_type_string.value_namespace_prefix = name_space_prefix
                if(value_path == "interface"):
                    self.interface = value
                    self.interface.value_namespace = name_space
                    self.interface.value_namespace_prefix = name_space_prefix
                if(value_path == "l2-transport"):
                    self.l2_transport = value
                    self.l2_transport.value_namespace = name_space
                    self.l2_transport.value_namespace_prefix = name_space_prefix
                if(value_path == "line-state"):
                    self.line_state = value
                    self.line_state.value_namespace = name_space
                    self.line_state.value_namespace_prefix = name_space_prefix
                if(value_path == "mtu"):
                    self.mtu = value
                    self.mtu.value_namespace = name_space
                    self.mtu.value_namespace_prefix = name_space_prefix
                if(value_path == "parent-interface"):
                    self.parent_interface = value
                    self.parent_interface.value_namespace = name_space
                    self.parent_interface.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "sub-interface-mtu-overhead"):
                    self.sub_interface_mtu_overhead = value
                    self.sub_interface_mtu_overhead.value_namespace = name_space
                    self.sub_interface_mtu_overhead.value_namespace_prefix = name_space_prefix
                if(value_path == "type"):
                    self.type = value
                    self.type.value_namespace = name_space
                    self.type.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.interface_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.interface_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "interface-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interface-brief"):
                for c in self.interface_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Interfaces.InterfaceBriefs.InterfaceBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.interface_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interface-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class InventorySummary(Entity):
        """
        Inventory summary information
        
        .. attribute:: interface_counts
        
        	Counts for all interfaces
        	**type**\:   :py:class:`InterfaceCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InventorySummary.InterfaceCounts>`
        
        .. attribute:: interface_type
        
        	List of per interface type summary information
        	**type**\: list of    :py:class:`InterfaceType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InventorySummary.InterfaceType>`
        
        

        """

        _prefix = 'pfi-im-cmd-oper'
        _revision = '2016-12-18'

        def __init__(self):
            super(Interfaces.InventorySummary, self).__init__()

            self.yang_name = "inventory-summary"
            self.yang_parent_name = "interfaces"

            self.interface_counts = Interfaces.InventorySummary.InterfaceCounts()
            self.interface_counts.parent = self
            self._children_name_map["interface_counts"] = "interface-counts"
            self._children_yang_names.add("interface-counts")

            self.interface_type = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Interfaces.InventorySummary, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Interfaces.InventorySummary, self).__setattr__(name, value)


        class InterfaceCounts(Entity):
            """
            Counts for all interfaces
            
            .. attribute:: admin_down_interface_count
            
            	Number of interfaces in an ADMINDOWN state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: down_interface_count
            
            	Number of interfaces in DOWN state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_count
            
            	Number of interfaces
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_interface_count
            
            	Number of interfaces in UP state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.InventorySummary.InterfaceCounts, self).__init__()

                self.yang_name = "interface-counts"
                self.yang_parent_name = "inventory-summary"

                self.admin_down_interface_count = YLeaf(YType.uint32, "admin-down-interface-count")

                self.down_interface_count = YLeaf(YType.uint32, "down-interface-count")

                self.interface_count = YLeaf(YType.uint32, "interface-count")

                self.up_interface_count = YLeaf(YType.uint32, "up-interface-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("admin_down_interface_count",
                                "down_interface_count",
                                "interface_count",
                                "up_interface_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.InventorySummary.InterfaceCounts, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.InventorySummary.InterfaceCounts, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.admin_down_interface_count.is_set or
                    self.down_interface_count.is_set or
                    self.interface_count.is_set or
                    self.up_interface_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.admin_down_interface_count.yfilter != YFilter.not_set or
                    self.down_interface_count.yfilter != YFilter.not_set or
                    self.interface_count.yfilter != YFilter.not_set or
                    self.up_interface_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface-counts" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/inventory-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.admin_down_interface_count.is_set or self.admin_down_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.admin_down_interface_count.get_name_leafdata())
                if (self.down_interface_count.is_set or self.down_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_interface_count.get_name_leafdata())
                if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_count.get_name_leafdata())
                if (self.up_interface_count.is_set or self.up_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_interface_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "admin-down-interface-count" or name == "down-interface-count" or name == "interface-count" or name == "up-interface-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "admin-down-interface-count"):
                    self.admin_down_interface_count = value
                    self.admin_down_interface_count.value_namespace = name_space
                    self.admin_down_interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "down-interface-count"):
                    self.down_interface_count = value
                    self.down_interface_count.value_namespace = name_space
                    self.down_interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-count"):
                    self.interface_count = value
                    self.interface_count.value_namespace = name_space
                    self.interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-interface-count"):
                    self.up_interface_count = value
                    self.up_interface_count.value_namespace = name_space
                    self.up_interface_count.value_namespace_prefix = name_space_prefix


        class InterfaceType(Entity):
            """
            List of per interface type summary information
            
            .. attribute:: interface_counts
            
            	Counts for interfaces of this type
            	**type**\:   :py:class:`InterfaceCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InventorySummary.InterfaceType.InterfaceCounts>`
            
            .. attribute:: interface_type_description
            
            	Description of the interface type
            	**type**\:  str
            
            .. attribute:: interface_type_name
            
            	Name of the interface type
            	**type**\:  str
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.InventorySummary.InterfaceType, self).__init__()

                self.yang_name = "interface-type"
                self.yang_parent_name = "inventory-summary"

                self.interface_type_description = YLeaf(YType.str, "interface-type-description")

                self.interface_type_name = YLeaf(YType.str, "interface-type-name")

                self.interface_counts = Interfaces.InventorySummary.InterfaceType.InterfaceCounts()
                self.interface_counts.parent = self
                self._children_name_map["interface_counts"] = "interface-counts"
                self._children_yang_names.add("interface-counts")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface_type_description",
                                "interface_type_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.InventorySummary.InterfaceType, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.InventorySummary.InterfaceType, self).__setattr__(name, value)


            class InterfaceCounts(Entity):
                """
                Counts for interfaces of this type
                
                .. attribute:: admin_down_interface_count
                
                	Number of interfaces in an ADMINDOWN state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: down_interface_count
                
                	Number of interfaces in DOWN state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interface_count
                
                	Number of interfaces
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_interface_count
                
                	Number of interfaces in UP state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InventorySummary.InterfaceType.InterfaceCounts, self).__init__()

                    self.yang_name = "interface-counts"
                    self.yang_parent_name = "interface-type"

                    self.admin_down_interface_count = YLeaf(YType.uint32, "admin-down-interface-count")

                    self.down_interface_count = YLeaf(YType.uint32, "down-interface-count")

                    self.interface_count = YLeaf(YType.uint32, "interface-count")

                    self.up_interface_count = YLeaf(YType.uint32, "up-interface-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_down_interface_count",
                                    "down_interface_count",
                                    "interface_count",
                                    "up_interface_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InventorySummary.InterfaceType.InterfaceCounts, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InventorySummary.InterfaceType.InterfaceCounts, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.admin_down_interface_count.is_set or
                        self.down_interface_count.is_set or
                        self.interface_count.is_set or
                        self.up_interface_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_down_interface_count.yfilter != YFilter.not_set or
                        self.down_interface_count.yfilter != YFilter.not_set or
                        self.interface_count.yfilter != YFilter.not_set or
                        self.up_interface_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-counts" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/inventory-summary/interface-type/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.admin_down_interface_count.is_set or self.admin_down_interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.admin_down_interface_count.get_name_leafdata())
                    if (self.down_interface_count.is_set or self.down_interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_interface_count.get_name_leafdata())
                    if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_count.get_name_leafdata())
                    if (self.up_interface_count.is_set or self.up_interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_interface_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "admin-down-interface-count" or name == "down-interface-count" or name == "interface-count" or name == "up-interface-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-down-interface-count"):
                        self.admin_down_interface_count = value
                        self.admin_down_interface_count.value_namespace = name_space
                        self.admin_down_interface_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "down-interface-count"):
                        self.down_interface_count = value
                        self.down_interface_count.value_namespace = name_space
                        self.down_interface_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-count"):
                        self.interface_count = value
                        self.interface_count.value_namespace = name_space
                        self.interface_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-interface-count"):
                        self.up_interface_count = value
                        self.up_interface_count.value_namespace = name_space
                        self.up_interface_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.interface_type_description.is_set or
                    self.interface_type_name.is_set or
                    (self.interface_counts is not None and self.interface_counts.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface_type_description.yfilter != YFilter.not_set or
                    self.interface_type_name.yfilter != YFilter.not_set or
                    (self.interface_counts is not None and self.interface_counts.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface-type" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/inventory-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.interface_type_description.is_set or self.interface_type_description.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_type_description.get_name_leafdata())
                if (self.interface_type_name.is_set or self.interface_type_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_type_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interface-counts"):
                    if (self.interface_counts is None):
                        self.interface_counts = Interfaces.InventorySummary.InterfaceType.InterfaceCounts()
                        self.interface_counts.parent = self
                        self._children_name_map["interface_counts"] = "interface-counts"
                    return self.interface_counts

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface-counts" or name == "interface-type-description" or name == "interface-type-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface-type-description"):
                    self.interface_type_description = value
                    self.interface_type_description.value_namespace = name_space
                    self.interface_type_description.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-type-name"):
                    self.interface_type_name = value
                    self.interface_type_name.value_namespace = name_space
                    self.interface_type_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.interface_type:
                if (c.has_data()):
                    return True
            return (self.interface_counts is not None and self.interface_counts.has_data())

        def has_operation(self):
            for c in self.interface_type:
                if (c.has_operation()):
                    return True
            return (
                self.yfilter != YFilter.not_set or
                (self.interface_counts is not None and self.interface_counts.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "inventory-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interface-counts"):
                if (self.interface_counts is None):
                    self.interface_counts = Interfaces.InventorySummary.InterfaceCounts()
                    self.interface_counts.parent = self
                    self._children_name_map["interface_counts"] = "interface-counts"
                return self.interface_counts

            if (child_yang_name == "interface-type"):
                for c in self.interface_type:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Interfaces.InventorySummary.InterfaceType()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.interface_type.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interface-counts" or name == "interface-type"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Interfaces(Entity):
        """
        Descriptions for interfaces
        
        .. attribute:: interface
        
        	Description for a particular interface
        	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.Interfaces.Interface>`
        
        

        """

        _prefix = 'pfi-im-cmd-oper'
        _revision = '2016-12-18'

        def __init__(self):
            super(Interfaces.Interfaces, self).__init__()

            self.yang_name = "interfaces"
            self.yang_parent_name = "interfaces"

            self.interface = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Interfaces.Interfaces, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Interfaces.Interfaces, self).__setattr__(name, value)


        class Interface(Entity):
            """
            Description for a particular interface
            
            .. attribute:: interface_name  <key>
            
            	The name of the interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: description
            
            	Interface description string
            	**type**\:  str
            
            .. attribute:: interface
            
            	Interface
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: line_state
            
            	Line protocol state with no translation of error disable or shutdown
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            .. attribute:: state
            
            	Operational state with no translation of error disable or shutdown
            	**type**\:   :py:class:`ImStateEnum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.ImStateEnum>`
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.Interfaces.Interface, self).__init__()

                self.yang_name = "interface"
                self.yang_parent_name = "interfaces"

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.description = YLeaf(YType.str, "description")

                self.interface = YLeaf(YType.str, "interface")

                self.line_state = YLeaf(YType.enumeration, "line-state")

                self.state = YLeaf(YType.enumeration, "state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface_name",
                                "description",
                                "interface",
                                "line_state",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.Interfaces.Interface, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.Interfaces.Interface, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.interface_name.is_set or
                    self.description.is_set or
                    self.interface.is_set or
                    self.line_state.is_set or
                    self.state.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.description.yfilter != YFilter.not_set or
                    self.interface.yfilter != YFilter.not_set or
                    self.line_state.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/interfaces/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.description.get_name_leafdata())
                if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface.get_name_leafdata())
                if (self.line_state.is_set or self.line_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.line_state.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface-name" or name == "description" or name == "interface" or name == "line-state" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "description"):
                    self.description = value
                    self.description.value_namespace = name_space
                    self.description.value_namespace_prefix = name_space_prefix
                if(value_path == "interface"):
                    self.interface = value
                    self.interface.value_namespace = name_space
                    self.interface.value_namespace_prefix = name_space_prefix
                if(value_path == "line-state"):
                    self.line_state = value
                    self.line_state.value_namespace = name_space
                    self.line_state.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.interface:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.interface:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "interfaces" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interface"):
                for c in self.interface:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Interfaces.Interfaces.Interface()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.interface.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interface"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class InterfaceSummary(Entity):
        """
        Interface summary information
        
        .. attribute:: interface_counts
        
        	Counts for all interfaces
        	**type**\:   :py:class:`InterfaceCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceSummary.InterfaceCounts>`
        
        .. attribute:: interface_type
        
        	List of per interface type summary information
        	**type**\: list of    :py:class:`InterfaceType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceSummary.InterfaceType>`
        
        

        """

        _prefix = 'pfi-im-cmd-oper'
        _revision = '2016-12-18'

        def __init__(self):
            super(Interfaces.InterfaceSummary, self).__init__()

            self.yang_name = "interface-summary"
            self.yang_parent_name = "interfaces"

            self.interface_counts = Interfaces.InterfaceSummary.InterfaceCounts()
            self.interface_counts.parent = self
            self._children_name_map["interface_counts"] = "interface-counts"
            self._children_yang_names.add("interface-counts")

            self.interface_type = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Interfaces.InterfaceSummary, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Interfaces.InterfaceSummary, self).__setattr__(name, value)


        class InterfaceCounts(Entity):
            """
            Counts for all interfaces
            
            .. attribute:: admin_down_interface_count
            
            	Number of interfaces in an ADMINDOWN state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: down_interface_count
            
            	Number of interfaces in DOWN state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_count
            
            	Number of interfaces
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_interface_count
            
            	Number of interfaces in UP state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.InterfaceSummary.InterfaceCounts, self).__init__()

                self.yang_name = "interface-counts"
                self.yang_parent_name = "interface-summary"

                self.admin_down_interface_count = YLeaf(YType.uint32, "admin-down-interface-count")

                self.down_interface_count = YLeaf(YType.uint32, "down-interface-count")

                self.interface_count = YLeaf(YType.uint32, "interface-count")

                self.up_interface_count = YLeaf(YType.uint32, "up-interface-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("admin_down_interface_count",
                                "down_interface_count",
                                "interface_count",
                                "up_interface_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.InterfaceSummary.InterfaceCounts, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.InterfaceSummary.InterfaceCounts, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.admin_down_interface_count.is_set or
                    self.down_interface_count.is_set or
                    self.interface_count.is_set or
                    self.up_interface_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.admin_down_interface_count.yfilter != YFilter.not_set or
                    self.down_interface_count.yfilter != YFilter.not_set or
                    self.interface_count.yfilter != YFilter.not_set or
                    self.up_interface_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface-counts" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/interface-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.admin_down_interface_count.is_set or self.admin_down_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.admin_down_interface_count.get_name_leafdata())
                if (self.down_interface_count.is_set or self.down_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_interface_count.get_name_leafdata())
                if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_count.get_name_leafdata())
                if (self.up_interface_count.is_set or self.up_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_interface_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "admin-down-interface-count" or name == "down-interface-count" or name == "interface-count" or name == "up-interface-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "admin-down-interface-count"):
                    self.admin_down_interface_count = value
                    self.admin_down_interface_count.value_namespace = name_space
                    self.admin_down_interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "down-interface-count"):
                    self.down_interface_count = value
                    self.down_interface_count.value_namespace = name_space
                    self.down_interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-count"):
                    self.interface_count = value
                    self.interface_count.value_namespace = name_space
                    self.interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-interface-count"):
                    self.up_interface_count = value
                    self.up_interface_count.value_namespace = name_space
                    self.up_interface_count.value_namespace_prefix = name_space_prefix


        class InterfaceType(Entity):
            """
            List of per interface type summary information
            
            .. attribute:: interface_counts
            
            	Counts for interfaces of this type
            	**type**\:   :py:class:`InterfaceCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_pfi_im_cmd_oper.Interfaces.InterfaceSummary.InterfaceType.InterfaceCounts>`
            
            .. attribute:: interface_type_description
            
            	Description of the interface type
            	**type**\:  str
            
            .. attribute:: interface_type_name
            
            	Name of the interface type
            	**type**\:  str
            
            

            """

            _prefix = 'pfi-im-cmd-oper'
            _revision = '2016-12-18'

            def __init__(self):
                super(Interfaces.InterfaceSummary.InterfaceType, self).__init__()

                self.yang_name = "interface-type"
                self.yang_parent_name = "interface-summary"

                self.interface_type_description = YLeaf(YType.str, "interface-type-description")

                self.interface_type_name = YLeaf(YType.str, "interface-type-name")

                self.interface_counts = Interfaces.InterfaceSummary.InterfaceType.InterfaceCounts()
                self.interface_counts.parent = self
                self._children_name_map["interface_counts"] = "interface-counts"
                self._children_yang_names.add("interface-counts")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface_type_description",
                                "interface_type_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Interfaces.InterfaceSummary.InterfaceType, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Interfaces.InterfaceSummary.InterfaceType, self).__setattr__(name, value)


            class InterfaceCounts(Entity):
                """
                Counts for interfaces of this type
                
                .. attribute:: admin_down_interface_count
                
                	Number of interfaces in an ADMINDOWN state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: down_interface_count
                
                	Number of interfaces in DOWN state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interface_count
                
                	Number of interfaces
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_interface_count
                
                	Number of interfaces in UP state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'pfi-im-cmd-oper'
                _revision = '2016-12-18'

                def __init__(self):
                    super(Interfaces.InterfaceSummary.InterfaceType.InterfaceCounts, self).__init__()

                    self.yang_name = "interface-counts"
                    self.yang_parent_name = "interface-type"

                    self.admin_down_interface_count = YLeaf(YType.uint32, "admin-down-interface-count")

                    self.down_interface_count = YLeaf(YType.uint32, "down-interface-count")

                    self.interface_count = YLeaf(YType.uint32, "interface-count")

                    self.up_interface_count = YLeaf(YType.uint32, "up-interface-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_down_interface_count",
                                    "down_interface_count",
                                    "interface_count",
                                    "up_interface_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Interfaces.InterfaceSummary.InterfaceType.InterfaceCounts, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Interfaces.InterfaceSummary.InterfaceType.InterfaceCounts, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.admin_down_interface_count.is_set or
                        self.down_interface_count.is_set or
                        self.interface_count.is_set or
                        self.up_interface_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_down_interface_count.yfilter != YFilter.not_set or
                        self.down_interface_count.yfilter != YFilter.not_set or
                        self.interface_count.yfilter != YFilter.not_set or
                        self.up_interface_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-counts" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/interface-summary/interface-type/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.admin_down_interface_count.is_set or self.admin_down_interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.admin_down_interface_count.get_name_leafdata())
                    if (self.down_interface_count.is_set or self.down_interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_interface_count.get_name_leafdata())
                    if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_count.get_name_leafdata())
                    if (self.up_interface_count.is_set or self.up_interface_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_interface_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "admin-down-interface-count" or name == "down-interface-count" or name == "interface-count" or name == "up-interface-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-down-interface-count"):
                        self.admin_down_interface_count = value
                        self.admin_down_interface_count.value_namespace = name_space
                        self.admin_down_interface_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "down-interface-count"):
                        self.down_interface_count = value
                        self.down_interface_count.value_namespace = name_space
                        self.down_interface_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-count"):
                        self.interface_count = value
                        self.interface_count.value_namespace = name_space
                        self.interface_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-interface-count"):
                        self.up_interface_count = value
                        self.up_interface_count.value_namespace = name_space
                        self.up_interface_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.interface_type_description.is_set or
                    self.interface_type_name.is_set or
                    (self.interface_counts is not None and self.interface_counts.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface_type_description.yfilter != YFilter.not_set or
                    self.interface_type_name.yfilter != YFilter.not_set or
                    (self.interface_counts is not None and self.interface_counts.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface-type" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/interface-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.interface_type_description.is_set or self.interface_type_description.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_type_description.get_name_leafdata())
                if (self.interface_type_name.is_set or self.interface_type_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_type_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interface-counts"):
                    if (self.interface_counts is None):
                        self.interface_counts = Interfaces.InterfaceSummary.InterfaceType.InterfaceCounts()
                        self.interface_counts.parent = self
                        self._children_name_map["interface_counts"] = "interface-counts"
                    return self.interface_counts

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface-counts" or name == "interface-type-description" or name == "interface-type-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface-type-description"):
                    self.interface_type_description = value
                    self.interface_type_description.value_namespace = name_space
                    self.interface_type_description.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-type-name"):
                    self.interface_type_name = value
                    self.interface_type_name.value_namespace = name_space
                    self.interface_type_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.interface_type:
                if (c.has_data()):
                    return True
            return (self.interface_counts is not None and self.interface_counts.has_data())

        def has_operation(self):
            for c in self.interface_type:
                if (c.has_operation()):
                    return True
            return (
                self.yfilter != YFilter.not_set or
                (self.interface_counts is not None and self.interface_counts.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "interface-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interface-counts"):
                if (self.interface_counts is None):
                    self.interface_counts = Interfaces.InterfaceSummary.InterfaceCounts()
                    self.interface_counts.parent = self
                    self._children_name_map["interface_counts"] = "interface-counts"
                return self.interface_counts

            if (child_yang_name == "interface-type"):
                for c in self.interface_type:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Interfaces.InterfaceSummary.InterfaceType()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.interface_type.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interface-counts" or name == "interface-type"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.interface_briefs is not None and self.interface_briefs.has_data()) or
            (self.interface_summary is not None and self.interface_summary.has_data()) or
            (self.interface_xr is not None and self.interface_xr.has_data()) or
            (self.interfaces is not None and self.interfaces.has_data()) or
            (self.inventory_summary is not None and self.inventory_summary.has_data()) or
            (self.node_type_sets is not None and self.node_type_sets.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.interface_briefs is not None and self.interface_briefs.has_operation()) or
            (self.interface_summary is not None and self.interface_summary.has_operation()) or
            (self.interface_xr is not None and self.interface_xr.has_operation()) or
            (self.interfaces is not None and self.interfaces.has_operation()) or
            (self.inventory_summary is not None and self.inventory_summary.has_operation()) or
            (self.node_type_sets is not None and self.node_type_sets.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-pfi-im-cmd-oper:interfaces" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "interface-briefs"):
            if (self.interface_briefs is None):
                self.interface_briefs = Interfaces.InterfaceBriefs()
                self.interface_briefs.parent = self
                self._children_name_map["interface_briefs"] = "interface-briefs"
            return self.interface_briefs

        if (child_yang_name == "interface-summary"):
            if (self.interface_summary is None):
                self.interface_summary = Interfaces.InterfaceSummary()
                self.interface_summary.parent = self
                self._children_name_map["interface_summary"] = "interface-summary"
            return self.interface_summary

        if (child_yang_name == "interface-xr"):
            if (self.interface_xr is None):
                self.interface_xr = Interfaces.InterfaceXr()
                self.interface_xr.parent = self
                self._children_name_map["interface_xr"] = "interface-xr"
            return self.interface_xr

        if (child_yang_name == "interfaces"):
            if (self.interfaces is None):
                self.interfaces = Interfaces.Interfaces()
                self.interfaces.parent = self
                self._children_name_map["interfaces"] = "interfaces"
            return self.interfaces

        if (child_yang_name == "inventory-summary"):
            if (self.inventory_summary is None):
                self.inventory_summary = Interfaces.InventorySummary()
                self.inventory_summary.parent = self
                self._children_name_map["inventory_summary"] = "inventory-summary"
            return self.inventory_summary

        if (child_yang_name == "node-type-sets"):
            if (self.node_type_sets is None):
                self.node_type_sets = Interfaces.NodeTypeSets()
                self.node_type_sets.parent = self
                self._children_name_map["node_type_sets"] = "node-type-sets"
            return self.node_type_sets

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "interface-briefs" or name == "interface-summary" or name == "interface-xr" or name == "interfaces" or name == "inventory-summary" or name == "node-type-sets"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Interfaces()
        return self._top_entity

